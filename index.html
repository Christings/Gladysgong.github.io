<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"gongyanli.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Up in the wind!">
<meta property="og:type" content="website">
<meta property="og:title" content="茉莉Python">
<meta property="og:url" content="http://gongyanli.com/index.html">
<meta property="og:site_name" content="茉莉Python">
<meta property="og:description" content="Up in the wind!">
<meta property="og:locale">
<meta property="article:author" content="Lilly">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://gongyanli.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>茉莉Python</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">茉莉Python</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">voidqueens@hotmail.com</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/LeetCode-16-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/LeetCode-16-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">LeetCode-16-区间问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-26 18:27:11" itemprop="dateCreated datePublished" datetime="2020-11-26T18:27:11+08:00">2020-11-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-27 12:32:13" itemprop="dateModified" datetime="2020-11-27T12:32:13+08:00">2020-11-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p><a target="_blank" rel="noopener" href="https://labuladong.github.io/ebook/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98%E5%90%88%E9%9B%86.html">https://labuladong.github.io/ebook/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98%E5%90%88%E9%9B%86.html</a></p>
</blockquote>
<h3 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a>56. 合并区间</h3><pre><code>链接：https://leetcode-cn.com/problems/merge-intervals/

给出一个区间的集合，请合并所有重叠的区间。

示例 1:

输入: intervals = [[1,3],[2,6],[8,10],[15,18]]
输出: [[1,6],[8,10],[15,18]]
解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
示例 2:

输入: intervals = [[1,4],[4,5]]
输出: [[1,5]]
解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。
注意：输入类型已于2019年4月15日更改。 请重置默认代码定义以获取新方法签名。

提示：

intervals[i][0] &lt;= intervals[i][1]</code></pre>
<p>题解一：</p>
<p>时间复杂度：O(nlogn)，其中 n为区间的数量。除去排序的开销，我们只需要一次线性扫描，所以主要的时间开销是排序的 O(nlogn)。</p>
<p>空间复杂度：O(logn)，其中 n为区间的数量。这里计算的是存储答案之外，使用的额外空间。O(logn) 即为排序所需要的空间复杂度。</p>
<pre><code>class Solution(object):
    def merge(self, intervals):
        &quot;&quot;&quot;
        :type intervals: List[List[int]]
        :rtype: List[List[int]]
        &quot;&quot;&quot;
        if not intervals:
            return
        intervals.sort(key=lambda x:(x[0],-x[1]))
        res=[]
        res.append(intervals[0])
        for i in range(1,len(intervals)):
            tmp=intervals[i]
            last=res[-1]
            if last[1] &gt;= tmp[0]:
                last[1]=max(last[1],tmp[1])
            else:
                res.append(tmp)
        return res</code></pre>
<h3 id="57-插入区间"><a href="#57-插入区间" class="headerlink" title="57. 插入区间"></a>57. 插入区间</h3><pre><code>链接：https://leetcode-cn.com/problems/insert-interval/

给出一个无重叠的 ，按照区间起始端点排序的区间列表。

在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。

示例 1：

输入：intervals = [[1,3],[6,9]], newInterval = [2,5]
输出：[[1,5],[6,9]]
示例 2：

输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
输出：[[1,2],[3,10],[12,16]]
解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。

注意：输入类型已在 2019 年 4 月 15 日更改。请重置为默认代码定义以获取新的方法签名。</code></pre>
<p>题解一|分段考察：</p>
<p>1、不重叠，位于newInterval的左侧<br>2、重叠<br>2、不重叠，位于newInterval的右侧</p>
<pre><code>class Solution(object):
    def insert(self, intervals, newInterval):
        &quot;&quot;&quot;
        :type intervals: List[List[int]]
        :type newInterval: List[int]
        :rtype: List[List[int]]
        &quot;&quot;&quot;
        res=[]
        i,n=0,len(intervals)
        while i&lt;n and intervals[i][1]&lt;newInterval[0]:
            res.append(intervals[i])
            i+=1
        while i&lt;n and intervals[i][0]&lt;=newInterval[1]:
            newInterval[0]=min(newInterval[0],intervals[i][0])
            newInterval[1]=max(newInterval[1],intervals[i][1])
            i+=1
        res.append(newInterval)
        while i&lt;n:
            res.append(intervals[i])
            i+=1
        return res</code></pre>
<p>题解二|模拟：</p>
<pre><code>class Solution(object):
    def insert(self, intervals, newInterval):
        &quot;&quot;&quot;
        :type intervals: List[List[int]]
        :type newInterval: List[int]
        :rtype: List[List[int]]
        &quot;&quot;&quot;
        left,right=newInterval
        flag=False
        ans=[]
        for low,high in intervals:
            if low&gt;right: # 在插入区间右侧且无交集
                if not flag:
                    ans.append([left,right]) # 此处插入交集部分
                    flag=True
                ans.append([low,high])
            elif high&lt;left: # 在插入区间左侧且无交集
                ans.append([low,high])
            else: # 与插入区间有交集，计算它们的并集
                left=min(left,low)
                right=max(right,high)
        if not flag: # 如果intervals为空时，此处插入newInterval
            ans.append([left,right])
        return ans</code></pre>
<h3 id="228-汇总区间"><a href="#228-汇总区间" class="headerlink" title="228. 汇总区间"></a>228. 汇总区间</h3><pre><code>给定一个无重复元素的有序整数数组 nums 。

返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表。也就是说，nums 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 nums 的数字 x 。

列表中的每个区间范围 [a,b] 应该按如下格式输出：

&quot;a-&gt;b&quot; ，如果 a != b
&quot;a&quot; ，如果 a == b

示例 1：

输入：nums = [0,1,2,4,5,7]
输出：[&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;]
解释：区间范围是：
[0,2] --&gt; &quot;0-&gt;2&quot;
[4,5] --&gt; &quot;4-&gt;5&quot;
[7,7] --&gt; &quot;7&quot;
示例 2：

输入：nums = [0,2,3,4,6,8,9]
输出：[&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;]
解释：区间范围是：
[0,0] --&gt; &quot;0&quot;
[2,4] --&gt; &quot;2-&gt;4&quot;
[6,6] --&gt; &quot;6&quot;
[8,9] --&gt; &quot;8-&gt;9&quot;
示例 3：

输入：nums = []
输出：[]
示例 4：

输入：nums = [-1]
输出：[&quot;-1&quot;]
示例 5：

输入：nums = [0]
输出：[&quot;0&quot;]

提示：

0 &lt;= nums.length &lt;= 20
-231 &lt;= nums[i] &lt;= 231 - 1
nums 中的所有值都 互不相同</code></pre>
<p>题解一|双指针：</p>
<p>时间复杂度：O(N)<br>空间复杂度：O(1)</p>
<pre><code>class Solution(object):
    def summaryRanges(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: List[str]
        &quot;&quot;&quot;
        left,right=0,0
        nums.append(float(&#39;inf&#39;)) # 解决溢出问题
        res=[]
        for i in range(len(nums)-1):
            right=i
            if nums[i]+1 != nums[i+1]:
                if left==right:
                    res.append(str(nums[right])+&#39;&#39;)
                else:
                    res.append(str(nums[left])+&#39;-&gt;&#39;+str(nums[right]))

                left=i+1
                right=i+1
        return res</code></pre>
<pre><code>class Solution(object):
    def summaryRanges(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: List[str]
        &quot;&quot;&quot;
        if len(nums) == 0: 
            return []
        elif len(nums) == 1:
            return [str(nums[0])]
        result = []
        j = 0 
        for i in range(len(nums)):
            if i:
                if nums[i] - nums[i-1] != 1:
                    if j == i-1:
                        result.append(str(nums[j]))
                    else:
                        result.append(str(nums[j]) + &#39;-&gt;&#39; + str(nums[i-1]))
                    if i == len(nums)-1:
                        result.append(str(nums[i]))
                    j = i
            if i == len(nums)-1 and j &lt; len(nums)-1:
                result.append(str(nums[j]) + &#39;-&gt;&#39; + str(nums[i]))
        return result</code></pre>
<h3 id="986-区间列表的交集"><a href="#986-区间列表的交集" class="headerlink" title="986. 区间列表的交集"></a>986. 区间列表的交集</h3><pre><code>链接：https://leetcode-cn.com/problems/interval-list-intersections/

给定两个由一些 闭区间 组成的列表，每个区间列表都是成对不相交的，并且已经排序。

返回这两个区间列表的交集。

（形式上，闭区间 [a, b]（其中 a &lt;= b）表示实数 x 的集合，而 a &lt;= x &lt;= b。两个闭区间的交集是一组实数，要么为空集，要么为闭区间。例如，[1, 3] 和 [2, 4] 的交集为 [2, 3]。）

示例：

输入：A = [[0,2],[5,10],[13,23],[24,25]], B = [[1,5],[8,12],[15,24],[25,26]]
输出：[[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]


提示：

0 &lt;= A.length &lt; 1000
0 &lt;= B.length &lt; 1000
0 &lt;= A[i].start, A[i].end, B[i].start, B[i].end &lt; 10^9</code></pre>
<p>题解一|归并计算：</p>
<p>时间复杂度：O(M+N)，其中 M, N 分别是数组 A 和 B 的长度。</p>
<p>空间复杂度：O(M+N)，答案中区间数量的上限。</p>
<pre><code>class Solution(object):
    def intervalIntersection(self, A, B):
        &quot;&quot;&quot;
        :type A: List[List[int]]
        :type B: List[List[int]]
        :rtype: List[List[int]]
        &quot;&quot;&quot;
        i,j=0,0
        res=[]
        while i&lt;len(A) and j&lt;len(B):
            a1,a2=A[i][0],A[i][1]
            b1,b2=B[j][0],B[j][1]

            if b2&gt;=a1 and a2&gt;=b1:
                res.append([max(a1,b1),min(a2,b2)]) # 交集计算
            if b2&lt;a2:
                j+=1
            else:
                i+=1
        return res</code></pre>
<h3 id="1288-删除被覆盖区间"><a href="#1288-删除被覆盖区间" class="headerlink" title="1288. 删除被覆盖区间"></a>1288. 删除被覆盖区间</h3><pre><code>链接：https://leetcode-cn.com/problems/remove-covered-intervals/

给你一个区间列表，请你删除列表中被其他区间所覆盖的区间。

只有当 c &lt;= a 且 b &lt;= d 时，我们才认为区间 [a,b) 被区间 [c,d) 覆盖。

在完成所有删除操作后，请你返回列表中剩余区间的数目。

示例：

输入：intervals = [[1,4],[3,6],[2,8]]
输出：2
解释：区间 [3,6] 被区间 [2,8] 覆盖，所以它被删除了。

提示：​​​​​​

1 &lt;= intervals.length &lt;= 1000
0 &lt;= intervals[i][0] &lt; intervals[i][1] &lt;= 10^5
对于所有的 i != j：intervals[i] != intervals[j]</code></pre>
<p>题解一:</p>
<pre><code>1、区间被完全覆盖
2、两个区间相交，合并成一个大区间
3、两个区间完全不相交</code></pre>
<p>注意：对于这两个起点相同的区间，我们需要保证长的那个区间在上面（按照终点降序），这样才会被判定为覆盖，否则会被错误地判定为相交，少算一个覆盖区间。</p>
<pre><code>class Solution(object):
    def removeCoveredIntervals(self, intervals):
        &quot;&quot;&quot;
        :type intervals: List[List[int]]
        :rtype: int
        &quot;&quot;&quot;
        intervals.sort(key=lambda x: (x[0],-x[1])) # 起点升序排序，起点相同时降序排序
        left,right=intervals[0][0],intervals[0][1] # 合并区间的起点和终点
        count=0
        for i in range(1,len(intervals)):
            tmp=intervals[i]
            if left&lt;=tmp[0] and right&gt;=tmp[1]: # 覆盖区间
                count+=1
            if right&gt;=tmp[0] and right&lt;=tmp[1]: # 相交区间，合并
                right=tmp[1]
            if right&lt;tmp[0]: # 完全不相交区间，更新起点和终点
                left=tmp[0]
                right=tmp[1]
        return len(intervals)-count</code></pre>
<p>题解二|贪心|扫描线：</p>
<pre><code>class Solution(object):
    def removeCoveredIntervals(self, intervals):
        &quot;&quot;&quot;
        :type intervals: List[List[int]]
        :rtype: int
        &quot;&quot;&quot;
        intervals.sort(key=lambda x: (x[0],-x[1]))
        right=intervals[0][1]
        count=0
        for i in range(1,len(intervals)):
            if right&gt;=intervals[i][1]:
                count+=1
            else:
                right=intervals[i][1]
        return len(intervals)-count</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/LeetCode-2-%E6%A0%88-%E5%8D%95%E8%B0%83%E6%A0%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/LeetCode-2-%E6%A0%88-%E5%8D%95%E8%B0%83%E6%A0%88/" class="post-title-link" itemprop="url">LeetCode-2-栈-单调栈</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-13 15:41:07" itemprop="dateCreated datePublished" datetime="2020-11-13T15:41:07+08:00">2020-11-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-14 19:52:51" itemprop="dateModified" datetime="2020-11-14T19:52:51+08:00">2020-11-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496. 下一个更大元素 I"></a>496. 下一个更大元素 I</h3><pre><code>链接：https://leetcode-cn.com/problems/next-greater-element-i/

给定两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。

nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。

示例 1:

输入: nums1 = [4,1,2], nums2 = [1,3,4,2].
输出: [-1,3,-1]
解释:
    对于num1中的数字4，你无法在第二个数组中找到下一个更大的数字，因此输出 -1。
    对于num1中的数字1，第二个数组中数字1右边的下一个较大数字是 3。
    对于num1中的数字2，第二个数组中没有下一个更大的数字，因此输出 -1。
示例 2:

输入: nums1 = [2,4], nums2 = [1,2,3,4].
输出: [3,-1]
解释:
    对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。
    对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出 -1 。


提示：

nums1和nums2中所有元素是唯一的。
nums1和nums2 的数组大小都不超过1000。</code></pre>
<p>题解一|暴力：</p>
<p>时间复杂度：O(n^2)</p>
<p>从前向后遍历：</p>
<pre><code>class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:
        m=len(nums1)
        n=len(nums2)
        res=[-1]*m
        for i in range(m):
            flag=0
            for j in range(n):
                if nums1[i]==nums2[j]:
                    flag=1
                if flag==1 and nums1[i]&lt;nums2[j]:
                    res[i]=nums2[j]
                    break
        return res</code></pre>
<p>从后向前遍历：</p>
<pre><code>class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:
        m=len(nums1)
        n=len(nums2)
        res=[-1]*m
        for i in range(m):
            for j in range(n-1,-1,-1):
                if nums1[i]==nums2[j]:
                    break
                if nums1[i]&lt;nums2[j]:
                    res[i]=nums2[j]
        return res</code></pre>
<p>题解二|单调递减栈：</p>
<p>思路：</p>
<pre><code>遍历nums2，维护一个递减栈
当得到一个更大的数的时候，将栈里小于它的数都放到哈希表当中</code></pre>
<p>时间复杂度：O(M+N)<br>空间复杂度：O(M)</p>
<pre><code>class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:
        m=len(nums1)
        n=len(nums2)
        hash=&#123;&#125;
        stack=[]
        res=[]
        for i in range(n):
            while stack and stack[-1]&lt;nums2[i]:
                hash[stack.pop()]=nums2[i]
            stack.append(nums2[i])
        for i in nums1:
            res.append(hash.get(i,-1))
        return res </code></pre>
<h3 id="503-下一个更大元素-II"><a href="#503-下一个更大元素-II" class="headerlink" title="503. 下一个更大元素 II"></a>503. 下一个更大元素 II</h3><pre><code>链接：https://leetcode-cn.com/problems/next-greater-element-ii/

给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。

示例 1:

输入: [1,2,1]
输出: [2,-1,2]
解释: 第一个 1 的下一个更大的数是 2；
数字 2 找不到下一个更大的数； 
第二个 1 的下一个最大的数需要循环搜索，结果也是 2。
注意: 输入数组的长度不会超过 10000。</code></pre>
<p>题解一|暴力：</p>
<pre><code>class Solution:
    def nextGreaterElements(self, nums: List[int]) -&gt; List[int]:
        new=nums+nums
        res=[-1]*len(new)
        for i in range(len(new)):
            tmp=new[i]
            if i&gt;len(nums):
                break
            for j in range(i+1,len(new)):
                if new[i]&lt;new[j]:
                    res[i]=new[j]
                    break
        return res[:len(nums)]</code></pre>
<p>题解二|单调递减栈：</p>
<p>不同点：和上一题不相同的是，这个是循环数组，关于循环数组的一个技巧就是*2取余了</p>
<p>栈内存储的是什么，是下标还是值，都是可以的。</p>
<pre><code>class Solution:
    def nextGreaterElements(self, nums: List[int]) -&gt; List[int]:
        n=len(nums)
        stack=[]
        res=[-1]*n
        for i in range(2*n):
            while stack and nums[stack[-1]] &lt; nums[i%n]:
                index=stack.pop()
                res[index%n]=nums[i%n]
            stack.append(i%n)
        return res</code></pre>
<h3 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a>739. 每日温度</h3><pre><code>链接：https://leetcode-cn.com/problems/daily-temperatures/

请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。

例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。

提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</code></pre>
<p>题解一|暴力|超时：</p>
<p>关键：找出右边第 1 个严格大于自己的元素的索引。</p>
<p>问题：就像选择排序一样，上一轮的操作并没有为下一轮的操作留下什么有用的信息。</p>
<p>时间复杂度：O(n^2)<br>空间复杂度：O(n)</p>
<pre><code>class Solution:
    def dailyTemperatures(self, T: List[int]) -&gt; List[int]:
        n=len(T)
        res=[0]*n
        for i in range(n-1):
            tmp=T[i]
            for j in range(i+1,n):
                if tmp&lt;T[j]:
                    res[i]=j-i
                    break                
        return res    </code></pre>
<p>题解二|单调递减栈：</p>
<p>单调栈介绍视频：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/daily-temperatures/solution/leetcode-tu-jie-739mei-ri-wen-du-by-misterbooo/">https://leetcode-cn.com/problems/daily-temperatures/solution/leetcode-tu-jie-739mei-ri-wen-du-by-misterbooo/</a></p>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<pre><code>class Solution:
    def dailyTemperatures(self, T: List[int]) -&gt; List[int]:
        n=len(T)
        stack=[]
        res=[0]*n
        for i in range(n):
            while stack and T[stack[-1]]&lt;T[i]:
                index=stack.pop()
                res[index]=i-index
            stack.append(i)
        return res    </code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/LeetCode-19-%E5%85%B6%E4%BB%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/LeetCode-19-%E5%85%B6%E4%BB%96/" class="post-title-link" itemprop="url">LeetCode-19-其他</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-02 12:17:10" itemprop="dateCreated datePublished" datetime="2020-11-02T12:17:10+08:00">2020-11-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-15 00:08:21" itemprop="dateModified" datetime="2020-11-15T00:08:21+08:00">2020-11-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="190-颠倒二进制位"><a href="#190-颠倒二进制位" class="headerlink" title="190. 颠倒二进制位"></a>190. 颠倒二进制位</h3><pre><code>链接：https://leetcode-cn.com/problems/reverse-bits/

颠倒给定的 32 位无符号整数的二进制位。

示例 1：

输入: 00000010100101000001111010011100
输出: 00111001011110000010100101000000
解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
示例 2：

输入：11111111111111111111111111111101
输出：10111111111111111111111111111111
解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。


提示：

请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。


进阶:
如果多次调用这个函数，你将如何优化你的算法？</code></pre>
<p>题解一：</p>
<p>zfill():32位右对齐，不够的话，左边补0</p>
<pre><code>class Solution:
    def reverseBits(self, n: int) -&gt; int:
        return int(bin(n)[2:].zfill(32)[::-1],2)</code></pre>
<p>题解二|移位：</p>
<pre><code>class Solution:
    def reverseBits(self, n: int) -&gt; int:
        res=0
        count=32
        while count:
            res&lt;&lt;=1
            res+=n&amp;1
            n&gt;&gt;=1
            count-=1
        return int(bin(res),2)</code></pre>
<h3 id="191-位1的个数"><a href="#191-位1的个数" class="headerlink" title="191. 位1的个数"></a>191. 位1的个数</h3><pre><code>链接：https://leetcode-cn.com/problems/number-of-1-bits/

编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。

示例 1：

输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。
示例 2：

输入：00000000000000000000000010000000
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#39;1&#39;。
示例 3：

输入：11111111111111111111111111111101
输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#39;1&#39;。


提示：

请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。


进阶:
如果多次调用这个函数，你将如何优化你的算法？</code></pre>
<p>题解一|循环：</p>
<pre><code>class Solution:
    def hammingWeight(self, n: int) -&gt; int:
        tmp=bin(n)[2:]
        res=0
        for i in tmp:
            if int(i)==1:
                res+=1
        return res    </code></pre>
<p>题解二|循环和位移动：</p>
<pre><code>class Solution:
    def hammingWeight(self, n: int) -&gt; int:
        bits=0
        mask=1
        for i in range(32):
            if (n &amp; mask) != 0:
                bits+=1
            mask&lt;&lt;=1
        return bits</code></pre>
<p>题解三|位操作：</p>
<p>时间复杂度：O(1) 。运行时间与 n 中位为 1 的有关。在最坏情况下， n 中所有位都是 11 。对于 32 位整数，运行时间是 O(1) 的。</p>
<p>空间复杂度：O(1) ，没有使用额外空间。</p>
<pre><code>class Solution:
    def hammingWeight(self, n: int) -&gt; int:
        res=0
        while n != 0:
            res+=1
            n &amp;= (n-1)
        return res</code></pre>
<h3 id="268-丢失的数字"><a href="#268-丢失的数字" class="headerlink" title="268. 丢失的数字"></a>268. 丢失的数字</h3><pre><code>链接：https://leetcode-cn.com/problems/missing-number/

给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。

进阶：

你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?


示例 1：

输入：nums = [3,0,1]
输出：2
解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。
示例 2：

输入：nums = [0,1]
输出：2
解释：n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。
示例 3：

输入：nums = [9,6,4,2,3,5,7,0,1]
输出：8
解释：n = 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。
示例 4：

输入：nums = [0]
输出：1
解释：n = 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。

提示：

n == nums.length
1 &lt;= n &lt;= 104
0 &lt;= nums[i] &lt;= n
nums 中的所有数字都 独一无二</code></pre>
<p>题解一|数学：</p>
<pre><code>class Solution:
    def missingNumber(self, nums: List[int]) -&gt; int:
        n=len(nums)
        ans=((n+1)*n)//2
        for i in range(len(nums)):
            ans-=nums[i]
        return ans</code></pre>
<h3 id="371-两整数之和"><a href="#371-两整数之和" class="headerlink" title="371. 两整数之和"></a>371. 两整数之和</h3><pre><code>链接：https://leetcode-cn.com/problems/sum-of-two-integers/

不使用运算符 + 和 - ​​​​​​​，计算两整数 ​​​​​​​a 、b ​​​​​​​之和。

示例 1:

输入: a = 1, b = 2
输出: 3
示例 2:

输入: a = -2, b = 3
输出: 1</code></pre>
<p>题解一|位运算：</p>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-of-two-integers/solution/wei-yun-suan-xiang-jie-yi-ji-zai-python-zhong-xu-y/">https://leetcode-cn.com/problems/sum-of-two-integers/solution/wei-yun-suan-xiang-jie-yi-ji-zai-python-zhong-xu-y/</a></p>
<pre><code>class Solution:
    def getSum(self, a: int, b: int) -&gt; int:
        # 2^32
        MASK = 0x100000000
        # 整型最大值
        MAX_INT = 0x7FFFFFFF
        MIN_INT = MAX_INT + 1
        while b != 0:
            # 计算进位
            carry = (a &amp; b) &lt;&lt; 1 
            # 取余范围限制在 [0, 2^32-1] 范围内
            a = (a ^ b) % MASK
            b = carry % MASK
        return a if a &lt;= MAX_INT else ~((a % MIN_INT) ^ MAX_INT) 
</code></pre>
<h3 id="461-汉明距离"><a href="#461-汉明距离" class="headerlink" title="461. 汉明距离"></a>461. 汉明距离</h3><pre><code>链接：https://leetcode-cn.com/problems/hamming-distance/

两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。

给出两个整数 x 和 y，计算它们之间的汉明距离。

注意：
0 ≤ x, y &lt; 231.

示例:

输入: x = 1, y = 4

输出: 2

解释:
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑

上面的箭头指出了对应二进制位不同的位置。</code></pre>
<p>题解一|内置函数：</p>
<p>时间复杂度：O(1)<br>空间复杂度：O(1)</p>
<pre><code>class Solution:
    def hammingDistance(self, x: int, y: int) -&gt; int:
        return bin(x^y).count(&#39;1&#39;)</code></pre>
<p>题解二|移位：</p>
<p>时间复杂度：O(1)<br>空间复杂度：O(1)</p>
<pre><code>class Solution:
    def hammingDistance(self, x: int, y: int) -&gt; int:
        xor=x^y
        count=0
        while xor:
            if xor &amp; 1:
                count+=1
            xor=xor&gt;&gt;1
        return count</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/LeetCode-18-%E6%90%9C%E7%B4%A2%E5%92%8C%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/LeetCode-18-%E6%90%9C%E7%B4%A2%E5%92%8C%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">LeetCode-18-搜索和排序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-29 21:34:51" itemprop="dateCreated datePublished" datetime="2020-10-29T21:34:51+08:00">2020-10-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-27 15:23:43" itemprop="dateModified" datetime="2020-11-27T15:23:43+08:00">2020-11-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a>33. 搜索旋转排序数组</h3><pre><code>链接：https://leetcode-cn.com/problems/search-in-rotated-sorted-array/

给你一个整数数组 nums ，和一个整数 target 。

该整数数组原本是按升序排列，但输入时在预先未知的某个点上进行了旋转。（例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] ）。

请你在数组中搜索 target ，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。


示例 1：

输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
示例 2：

输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1
示例 3：

输入：nums = [1], target = 0
输出：-1

提示：

1 &lt;= nums.length &lt;= 5000
-10^4 &lt;= nums[i] &lt;= 10^4
nums 中的每个值都 独一无二
nums 肯定会在某个点上旋转
-10^4 &lt;= target &lt;= 10^4</code></pre>
<p>题解一|二分查找：</p>
<p>时间复杂度：O(logn)，其中 n 为 nums数组的大小。整个算法时间复杂度即为二分搜索的时间复杂度 O(logn)。</p>
<p>空间复杂度：O(1) 我们只需要常数级别的空间存放变量。</p>
<p>注意：if中很多等号的判断</p>
<pre><code>class Solution(object):
    def search(self, nums, target):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type target: int
        :rtype: int
        &quot;&quot;&quot;
        if not nums:
            return -1
        left,right=0,len(nums)-1
        while left&lt;=right:
            mid=left+(right-left)//2
            if nums[mid]==target:
                return mid
            elif nums[0]&lt;=nums[mid] : # 此处加=号，解决case[3,1]和1
                if nums[0]&lt;=target&lt;nums[mid]: # 此处加=号，解决case[1,3,5]和1
                    right=mid-1
                else:
                    left=mid+1
            else:
                if nums[mid]&lt;target&lt;=nums[len(nums)-1]: # 此处加=号，解决case[1,3]和3
                    left=mid+1
                else:
                    right=mid-1
        return -1</code></pre>
<h3 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a>34. 在排序数组中查找元素的第一个和最后一个位置</h3><pre><code>链接：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/

给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

你的算法时间复杂度必须是 O(log n) 级别。

如果数组中不存在目标值，返回 [-1, -1]。

示例 1:

输入: nums = [5,7,7,8,8,10], target = 8
输出: [3,4]
示例 2:

输入: nums = [5,7,7,8,8,10], target = 6
输出: [-1,-1]</code></pre>
<p>题解一：</p>
<p>时间复杂度： O(n)<br>空间复杂度： O(1)</p>
<pre><code>class Solution(object):
    def searchRange(self, nums, target):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        &quot;&quot;&quot;
        res=[-1,-1]
        for i in range(len(nums)):
            if nums[i]==target:
                res[0]=i
                break
        if res[0]==-1:
            return res
        for i in range(len(nums)-1,-1,-1):
            if nums[i]==target:
                res[1]=i
                break
        return res</code></pre>
<p>题解二|二分查找：</p>
<p>时间复杂度： O(logn)<br>空间复杂度： O(1)</p>
<pre class=" language-class"><code class="language-class">    def searchRange(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        if not nums:
            return [-1,-1]
        left,right=0,len(nums)-1
        while left<right:
            mid=left+(right-left)//2
            if nums[mid]>=target:
                right=mid
            else:
                left=mid+1
        if nums[left]!=target:
            return [-1,-1]
        start=left

        left,right=0,len(nums)-1
        while left<right:
            mid=(left+right+1)//2
            if nums[mid]<=target:
                left=mid
            else:
                right=mid-1
        if nums[left]!=target:
            return [-1,-1]
        end=right
        return [start,end]</code></pre>
<h3 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a>75. 颜色分类</h3><pre><code>链接：https://leetcode-cn.com/problems/sort-colors/

给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

注意:
不能使用代码库中的排序函数来解决这道题。

示例:

输入: [2,0,2,1,1,0]
输出: [0,0,1,1,2,2]
进阶：

一个直观的解决方案是使用计数排序的两趟扫描算法。
首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。
你能想出一个仅使用常数空间的一趟扫描算法吗？</code></pre>
<p>题解一|重写数组：</p>
<pre><code>class Solution:
    def sortColors(self, nums: List[int]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums in-place instead.
        &quot;&quot;&quot;
        c0,c1,c2=0,0,0
        for i in nums:
            if i==0:
                c0+=1
            elif i==1:
                c1+=1
            elif i==2:
                c2+=1
        for i in range(len(nums)):
            if c0:
                nums[i]=0
                c0-=1
            elif c1:
                nums[i]=1
                c1-=1
            elif c2:
                nums[i]=2
                c2-=1</code></pre>
<p>题解二|单指针：</p>
<p>时间复杂度：O(n)，其中 n 是数组 nums 的长度。<br>空间复杂度：O(1)。</p>
<pre><code>class Solution:
    def sortColors(self, nums: List[int]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums in-place instead.
        &quot;&quot;&quot;
        n=len(nums)
        ptr=0
        for i in range(n):
            if nums[i]==0:
                nums[i],nums[ptr]=nums[ptr],nums[i]
                ptr+=1
        for i in range(ptr,n):
            if nums[i]==1:
                nums[i],nums[ptr]=nums[ptr],nums[i]
                ptr+=1</code></pre>
<p>题解三|双指针：</p>
<p>时间复杂度：O(n)，其中 n 是数组 nums 的长度。<br>空间复杂度：O(1)。</p>
<pre><code>class Solution:
    def sortColors(self, nums: List[int]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums in-place instead.
        &quot;&quot;&quot;
        n=len(nums)
        p0=p1=0
        for i in range(n):
            if nums[i]==1:
                nums[i],nums[p1]=nums[p1],nums[i]
                p1+=1
            elif nums[i]==0:
                nums[i],nums[p0]=nums[p0],nums[i]
                if p0 &lt; p1:
                    nums[i],nums[p1]=nums[p1],nums[i]
                p0+=1
                p1+=1</code></pre>
<pre><code>class Solution:
    def sortColors(self, nums: List[int]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums in-place instead.
        &quot;&quot;&quot;
        n=len(nums)
        p0,p2=0,n-1
        i=0
        while i&lt;=p2:
            while i&lt;=p2 and nums[i]==2:
                nums[i],nums[p2]=nums[p2],nums[i]
                p2-=1
            if nums[i]==0:
                nums[i],nums[p0]=nums[p0],nums[i]
                p0+=1
            i+=1</code></pre>
<h3 id="162-寻找峰值"><a href="#162-寻找峰值" class="headerlink" title="162. 寻找峰值"></a>162. 寻找峰值</h3><pre><code>峰值元素是指其值大于左右相邻值的元素。

给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。

数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。

你可以假设 nums[-1] = nums[n] = -∞。

示例 1:

输入: nums = [1,2,3,1]
输出: 2
解释: 3 是峰值元素，你的函数应该返回其索引 2。
示例 2:

输入: nums = [1,2,1,3,5,6,4]
输出: 1 或 5 
解释: 你的函数可以返回索引 1，其峰值元素为 2；
     或者返回索引 5， 其峰值元素为 6。
说明:

你的解法应该是 O(logN) 时间复杂度的。</code></pre>
<p>题解一|线性扫描：</p>
<p>1、一直上坡<br>2、一直下坡<br>3、上坡和下坡</p>
<p>时间复杂度 : O(n)。 我们对长度为 n 的数组 nums 只进行一次遍历。<br>空间复杂度 : O(1)。 只使用了常数空间。</p>
<pre><code>class Solution(object):
    def findPeakElement(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: int
        &quot;&quot;&quot;
        for i in range(len(nums)-1):
            if nums[i]&gt;nums[i+1]:
                return i
        return len(nums)-1</code></pre>
<p>题解二|递归|二分查找：<br>时间复杂度 : O(logn)。每一步都将搜索空间减半。因此，总的搜索空间只需要 log(n) 步。其中 n 为 nums 数组的长度。<br>空间复杂度: O(logn)。每一步都将搜索空间减半。因此，总的搜索空间只需要 log(n) 步。于是，递归树的深度为 log(n)。</p>
<pre><code>class Solution(object):
    def findPeakElement(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: int
        &quot;&quot;&quot;
        return self.binarySearch(nums,0,len(nums)-1)
    def binarySearch(self,nums,left,right):
        if left==right:
            return left
        mid=left+(right-left)//2
        if nums[mid]&gt;nums[mid+1]:
            return self.binarySearch(nums,left,mid)
        return self.binarySearch(nums,mid+1,right)</code></pre>
<p>题解三|迭代|二分查找：</p>
<pre><code>class Solution(object):
    def findPeakElement(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: int
        &quot;&quot;&quot;
        left,right=0,len(nums)-1
        while left&lt;right:
            mid=left+(right-left)//2
            if nums[mid]&gt;nums[mid+1]:
                right=mid
            else:
                left=mid+1
        return left
</code></pre>
<h3 id="278-第一个错误的版本"><a href="#278-第一个错误的版本" class="headerlink" title="278. 第一个错误的版本"></a>278. 第一个错误的版本</h3><pre><code>链接：https://leetcode-cn.com/problems/first-bad-version/

你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。

假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。

你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。

示例:

给定 n = 5，并且 version = 4 是第一个错误的版本。

调用 isBadVersion(3) -&gt; false
调用 isBadVersion(5) -&gt; true
调用 isBadVersion(4) -&gt; true

所以，4 是第一个错误的版本。 </code></pre>
<p>题解一|二分查找：</p>
<pre><code># The isBadVersion API is already defined for you.
# @param version, an integer
# @return an integer
# def isBadVersion(version):

class Solution:
    def firstBadVersion(self, n):
        &quot;&quot;&quot;
        :type n: int
        :rtype: int
        &quot;&quot;&quot;
        left,right=1,n
        while left&lt;=right: # 注意是小于等于
            mid=left+(right-left)//2
            if isBadVersion(mid):
                right=mid-1
            else:
                left=mid+1
        return left</code></pre>
<h3 id="240-搜索二维矩阵-II"><a href="#240-搜索二维矩阵-II" class="headerlink" title="240. 搜索二维矩阵 II"></a>240. 搜索二维矩阵 II</h3><pre><code>链接：https://leetcode-cn.com/problems/search-a-2d-matrix-ii/

编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：

每行的元素从左到右升序排列。
每列的元素从上到下升序排列。

示例 1：

输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
输出：true
示例 2：

输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
输出：false

提示：

m == matrix.length
n == matrix[i].length
1 &lt;= n, m &lt;= 300
-109 &lt;= matix[i][j] &lt;= 109
每行的所有元素从左到右升序排列
每列的所有元素从上到下升序排列
-109 &lt;= target &lt;= 109</code></pre>
<p>题解一|暴力：</p>
<pre><code>class Solution:
    def searchMatrix(self, matrix, target):
        &quot;&quot;&quot;
        :type matrix: List[List[int]]
        :type target: int
        :rtype: bool
        &quot;&quot;&quot;
        for row in matrix:
            if target in row:
                return True
        return False</code></pre>
<p>题解二|二分查找：</p>
<p>时间复杂度：O(mlogn)<br>空间复杂度：O(1)</p>
<pre><code>class Solution(object):
    def searchMatrix(self, matrix, target):
        &quot;&quot;&quot;
        :type matrix: List[List[int]]
        :type target: int
        :rtype: bool
        &quot;&quot;&quot;
        for i in range(len(matrix)):
            if self.binarySearch(matrix,i,target):
                return True
        return False

    def binarySearch(self,matrix,i,target):
        left,right=0,len(matrix[0])-1
        while left&lt;=right:
            mid=left+(right-left)//2
            if target &gt; matrix[i][mid]:
                left=mid+1
            elif target &lt; matrix[i][mid]:
                right=mid-1
            elif target == matrix[i][mid]:
                return True
        return False</code></pre>
<p>题解三|规律:</p>
<p>时间复杂度：O(m+n)<br>空间复杂度：O(1)</p>
<pre><code>class Solution(object):
    def searchMatrix(self, matrix, target):
        &quot;&quot;&quot;
        :type matrix: List[List[int]]
        :type target: int
        :rtype: bool
        &quot;&quot;&quot;
        left,right=0,len(matrix[0])-1
        while left&lt;len(matrix) and right&gt;=0:
            if matrix[left][right]&gt;target:
                right-=1
            elif matrix[left][right]&lt;target:
                left+=1
            elif matrix[left][right]==target:
                return True
        return False</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/LeetCode-17-%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/LeetCode-17-%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">LeetCode-17-设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-29 21:24:44" itemprop="dateCreated datePublished" datetime="2020-10-29T21:24:44+08:00">2020-10-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-26 16:36:29" itemprop="dateModified" datetime="2020-11-26T16:36:29+08:00">2020-11-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a>155. 最小栈</h3><pre><code>链接：https://leetcode-cn.com/problems/min-stack/solution/

设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

push(x) —— 将元素 x 推入栈中。
pop() —— 删除栈顶的元素。
top() —— 获取栈顶元素。
getMin() —— 检索栈中的最小元素。

示例:

输入：
[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --&gt; 返回 -3.
minStack.pop();
minStack.top();      --&gt; 返回 0.
minStack.getMin();   --&gt; 返回 -2.

提示：

pop、top 和 getMin 操作总是在 非空栈 上调用。</code></pre>
<p>题解一|双栈：</p>
<pre><code>class MinStack:

    def __init__(self):
        &quot;&quot;&quot;
        initialize your data structure here.
        &quot;&quot;&quot;
        self.stack=[]
        self.minstack=[]

    def push(self, x: int) -&gt; None:
        self.stack.append(x)
        if not self.minstack or self.minstack[-1]&gt;=x:
            self.minstack.append(x)

    def pop(self) -&gt; None:
        if self.stack:
            if self.stack[-1] == self.minstack[-1]:
                self.minstack.pop()
            return self.stack.pop()

    def top(self) -&gt; int:
        if self.stack:
            return self.stack[-1]
        else:
            return 

    def getMin(self) -&gt; int:
        if self.minstack:
            return self.minstack[-1]
        else:
            return

# Your MinStack object will be instantiated and called as such:
# obj = MinStack()
# obj.push(x)
# obj.pop()
# param_3 = obj.top()
# param_4 = obj.getMin()</code></pre>
<h3 id="380-常数时间插入、删除和获取随机元素"><a href="#380-常数时间插入、删除和获取随机元素" class="headerlink" title="380. 常数时间插入、删除和获取随机元素"></a>380. 常数时间插入、删除和获取随机元素</h3><pre><code>链接：https://leetcode-cn.com/problems/insert-delete-getrandom-o1/

设计一个支持在平均 时间复杂度 O(1) 下，执行以下操作的数据结构。

insert(val)：当元素 val 不存在时，向集合中插入该项。
remove(val)：元素 val 存在时，从集合中移除该项。
getRandom：随机返回现有集合中的一项。每个元素应该有相同的概率被返回。
示例 :

// 初始化一个空的集合。
RandomizedSet randomSet = new RandomizedSet();

// 向集合中插入 1 。返回 true 表示 1 被成功地插入。
randomSet.insert(1);

// 返回 false ，表示集合中不存在 2 。
randomSet.remove(2);

// 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。
randomSet.insert(2);

// getRandom 应随机返回 1 或 2 。
randomSet.getRandom();

// 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。
randomSet.remove(1);

// 2 已在集合中，所以返回 false 。
randomSet.insert(2);

// 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。
randomSet.getRandom();</code></pre>
<p>题解一|hash|动态数组：</p>
<p>1、insert：</p>
<pre><code>平均插入时间为O(1) 的选择：
    哈希表：Java 中为 HashMap，Python 中为 dictionary。
    动态数组：Java 中为 ArrayList，Python 中为 list。</code></pre>
<p>2、getRandom：</p>
<pre><code>哈希表提供常数时间的插入和删除，但是实现 getRandom 时会出现问题。
getRandom 的思想是选择一个随机索引，然后使用该索引返回一个元素。而哈希表中没有索引，因此要获得真正的随机值，则要将哈希表中的键转换为列表，这需要线性时间。解决的方法是用一个列表存储值，并在该列表中实现常数时间的 getRandom。</code></pre>
<p>3、remove：</p>
<pre><code>列表有索引可以实现常数时间的 insert 和 getRandom，则接下来的问题是如何实现常数时间的 remove。

删除任意索引元素需要线性时间，这里的解决方案是总是删除最后一个元素。
    将要删除元素和最后一个元素交换。
    将最后一个元素删除。</code></pre>
<p>综上：</p>
<pre><code>动态数组存储元素值。
哈希表存储存储值到索引的映射。</code></pre>
<pre><code>import random
class RandomizedSet(object):

    def __init__(self):
        &quot;&quot;&quot;
        Initialize your data structure here.
        &quot;&quot;&quot;
        self.list=[]
        self.dict=&#123;&#125;


    def insert(self, val):
        &quot;&quot;&quot;
        Inserts a value to the set. Returns true if the set did not already contain the specified element.
        :type val: int
        :rtype: bool
        &quot;&quot;&quot;
        if val in self.dict:
            return False
        self.dict[val]=len(self.list)
        self.list.append(val)
        return True

    def remove(self, val):
        &quot;&quot;&quot;
        Removes a value from the set. Returns true if the set contained the specified element.
        :type val: int
        :rtype: bool
        &quot;&quot;&quot;
        if val in self.dict:
            last,index=self.list[-1],self.dict[val]
            self.list[index],self.dict[last]=last,index
            self.list.pop()
            del self.dict[val]
            return True
        return False


    def getRandom(self):
        &quot;&quot;&quot;
        Get a random element from the set.
        :rtype: int
        &quot;&quot;&quot;
        return random.choice(self.list)

# Your RandomizedSet object will be instantiated and called as such:
# obj = RandomizedSet()
# param_1 = obj.insert(val)
# param_2 = obj.remove(val)
# param_3 = obj.getRandom()</code></pre>
<h3 id="384-打乱数组"><a href="#384-打乱数组" class="headerlink" title="384. 打乱数组"></a>384. 打乱数组</h3><pre><code>链接：https://leetcode-cn.com/problems/shuffle-an-array/

打乱一个没有重复元素的数组。

示例:

// 以数字集合 1, 2 和 3 初始化数组。
int[] nums = &#123;1,2,3&#125;;
Solution solution = new Solution(nums);

// 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。
solution.shuffle();

// 重设数组到它的初始状态[1,2,3]。
solution.reset();

// 随机返回数组[1,2,3]打乱后的结果。
solution.shuffle();</code></pre>
<p>拷贝知识：</p>
<pre><code>直接赋值：其实就是对象的引用（别名）。

浅拷贝(copy)：拷贝父对象，不会拷贝对象的内部的子对象。

深拷贝(deepcopy)： copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象。</code></pre>
<p>题解一|暴力：</p>
<p>时间复杂度： O(n^2)，乘方时间复杂度来自于 list.remove（list.pop）。每次操作都是线性时间的，总共发生 n 次。</p>
<p>空间复杂度： O(n)，因为需要实现 重置 方法，需要额外的空间把原始数组另存一份，在重置的时候用来恢复原始状态。</p>
<pre><code>class Solution:
    from copy import copy
    from random import random
    def __init__(self, nums: List[int]):
        self.ori=copy.deepcopy(nums)
        self.nums=nums

    def reset(self) -&gt; List[int]:
        &quot;&quot;&quot;
        Resets the array to its original configuration and return it.
        &quot;&quot;&quot;
        return self.ori

    def shuffle(self) -&gt; List[int]:
        &quot;&quot;&quot;
        Returns a random shuffling of the array.
        &quot;&quot;&quot;
        self.aux=copy.deepcopy(self.nums)
        for i in range(len(self.nums)):
            index=random.randrange(len(self.aux))
            self.nums[i]=self.aux.pop(index)
        return self.nums

# Your Solution object will be instantiated and called as such:
# obj = Solution(nums)
# param_1 = obj.reset()
# param_2 = obj.shuffle()</code></pre>
<p>题解二| Fisher-Yates 洗牌算法：</p>
<p>时间复杂度 ： O(n)，Fisher-Yates 洗牌算法时间复杂度是线性的，因为算法中生成随机序列，交换两个元素这两种操作都是常数时间复杂度的。</p>
<p>空间复杂度： O(n)，因为要实现 重置 功能，原始数组必须得保存一份，因此空间复杂度并没有优化。</p>
<pre><code>class Solution:
    from copy import copy
    from random import random
    def __init__(self, nums: List[int]):
        self.ori=copy.deepcopy(nums)
        self.nums=nums

    def reset(self) -&gt; List[int]:
        &quot;&quot;&quot;
        Resets the array to its original configuration and return it.
        &quot;&quot;&quot;
        return self.ori

    def shuffle(self) -&gt; List[int]:
        &quot;&quot;&quot;
        Returns a random shuffling of the array.
        &quot;&quot;&quot;
        for i in range(len(self.nums)):
            index=random.randint(i,len(self.nums)-1)
            self.nums[i],self.nums[index]=self.nums[index],self.nums[i]
        return self.nums

# Your Solution object will be instantiated and called as such:
# obj = Solution(nums)
# param_1 = obj.reset()
# param_2 = obj.shuffle()</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-15-%E9%93%BE%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-15-%E9%93%BE%E8%A1%A8/" class="post-title-link" itemprop="url">数据结构与算法-15-链表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-24 12:17:57" itemprop="dateCreated datePublished" datetime="2020-09-24T12:17:57+08:00">2020-09-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-05 16:51:10" itemprop="dateModified" datetime="2020-11-05T16:51:10+08:00">2020-11-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>扩展：链表有环，如何判断相交？</p>
<p>分析：如果有环且两个链表相交，则两个链表都有共同一个环，即环上的任意一个节点都存在于两个链表上。因此，就可以判断一链表上俩指针相遇的那个节点，在不在另一条链表上。</p>
<pre><code>无环链表和有环链表是不可能相交的;

两个有环链表若相交，其“整个环上”的所有node一定都重合;

有环链表的相交，情况只有2种：相交于”环上”或相交于”不是环的部分”,即下图所示;</code></pre>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/link.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/link.png"></p>
<pre><code>https://cloud.tencent.com/developer/article/1045468</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/Django-1-%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Django-1-%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">Django-1-问题记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-09-18 12:43:19 / Modified: 13:41:32" itemprop="dateCreated datePublished" datetime="2020-09-18T12:43:19+08:00">2020-09-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/Django/" itemprop="url" rel="index"><span itemprop="name">Django</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一-问题-QuerySet-object-has-no-attribute-meta"><a href="#一-问题-QuerySet-object-has-no-attribute-meta" class="headerlink" title="一.问题:QuerySet object has no attribute _meta"></a>一.问题:QuerySet object has no attribute _meta</h2><pre><code>    filter() returns a QuerySet also if only one object if found. If you want to return just a model instance, use get()

    edit_content = models.Wikistore.objects.filter(id=edit_id)
    form = EditorTestForm(instance=edit_content)

    # 将filter改为get即可。</code></pre>
<h2 id="二-问题-django-db-utils-InternalError-1050-“Table-‘wiki’-already-exists”"><a href="#二-问题-django-db-utils-InternalError-1050-“Table-‘wiki’-already-exists”" class="headerlink" title="二.问题:django.db.utils.InternalError: (1050, “Table ‘wiki’ already exists”)"></a>二.问题:django.db.utils.InternalError: (1050, “Table ‘wiki’ already exists”)</h2><pre><code>    $ python manage.py migrate wiki --fake 
    # wiki是自己的应用名
    $ python manage.py migrate</code></pre>
<h2 id="三-问题-执行python-manage-py-migrate无反应"><a href="#三-问题-执行python-manage-py-migrate无反应" class="headerlink" title="三.问题:执行python manage.py migrate无反应"></a>三.问题:执行python manage.py migrate无反应</h2><pre><code>已有model，修改后重新建模，于是将migrations文件夹中除__init__.py之外其他文件都删掉，再次执行以下步骤python manage.py makemigrations确认成功，执行python manage.py migrate，提示No migrations to apply. 
再次修改，指定表名，再次尝试，问题依旧。</code></pre>
<h3 id="1-排查"><a href="#1-排查" class="headerlink" title="1.排查"></a>1.排查</h3><pre><code>python manage.py dbshell 进到数据库里面，查看是否表已存在 
结果：表不存在
检查migrations文件 
结果：文件没问题</code></pre>
<h3 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2.解决方案"></a>2.解决方案</h3><pre><code>$ python manage.py dbshell # 进入数据库
$ delete from django_migrations where app=&#39;your_appname&#39;;
$ python manage.py makemigrations(若migrations文件未删除，可不执行这一步)
$ python manage.py migrate # 成功</code></pre>
<h3 id="3-原因分析"><a href="#3-原因分析" class="headerlink" title="3.原因分析"></a>3.原因分析</h3><pre><code>(1)查看django_migrations表结构 
建表语句： 
CREATE TABLE &quot;django_migrations&quot; (&quot;id&quot; integer NOT NULL PRIMARY KEY AUTOINCREMENT, &quot;app&quot; varchar(255) NOT NULL, &quot;name&quot; varchar(255) NOT NULL, &quot;applied&quot; datetime NOT NULL); 

(2)原因 
造成多次应用migrations失败的原因是，当前model是修改过的，原来的migrations已经被我删除，但是，重新生成的migrations使用递增整数记名，所以，在django_migrations表中0001，0002等前面几个数字的文件都已被记录，在Django看来，被记录了就相当于已应用，所以，会出现刚开始的No migrations to apply.</code></pre>
<h3 id="4-避免方案"><a href="#4-避免方案" class="headerlink" title="4.避免方案"></a>4.避免方案</h3><pre><code>删除migrations文件，请同时到数据库中删除相应记录
可以继续生成新的migrations，旧的就不必理会了</code></pre>
<h3 id="5-其他"><a href="#5-其他" class="headerlink" title="5.其他"></a>5.其他</h3><pre><code>执行python manage.py migrate之后，可以使用python manage.py sqlmigrate appname migrations_num(例如python manage.py sqlmigrate user 0002)查看当前migrations文件对应的sql语句。 
另外，在使用上述命令查看0002文件的sql语句时发现，django会新建一个表user_new，然后插入user表中的数据，再把user表删掉，再把user_new重命名为user。所以，修改model的时候，不必担心原有数据会丢失。</code></pre>
<h2 id="四-问题-使用distinct的时候出现了以下问题，DISTINCT-ON-fields-is-not-supported-by-this-database-backend"><a href="#四-问题-使用distinct的时候出现了以下问题，DISTINCT-ON-fields-is-not-supported-by-this-database-backend" class="headerlink" title="四.问题:使用distinct的时候出现了以下问题，DISTINCT ON fields is not supported by this database backend"></a>四.问题:使用distinct的时候出现了以下问题，DISTINCT ON fields is not supported by this database backend</h2><pre><code>    文档中的用法：
    Author.objects.distinct()
    Entry.objects.order_by(&#39;pub_date&#39;).distinct(&#39;pub_date&#39;)
    Entry.objects.order_by(&#39;blog&#39;).distinct(&#39;blog&#39;)
    Entry.objects.order_by(&#39;author&#39;, &#39;pub_date&#39;).distinct(&#39;author&#39;, &#39;pub_date&#39;)
    Entry.objects.order_by(&#39;blog__name&#39;, &#39;mod_date&#39;).distinct(&#39;blog__name&#39;, &#39;mod_date&#39;)
    Entry.objects.order_by(&#39;author&#39;, &#39;pub_date&#39;).distinct(&#39;author&#39;)

    但是根据文档中的用法却出了上述问题

    后来找到原因，如果是使用mysql的话，distinct()中不能使用任何参数，参数应该在value()中使用
    正确使用方法：
    obj= Category.objects.values(&#39;parentcode&#39;,&#39;email&#39;).distinct()
    obj= Category.objects.values(&#39;parentcode&#39;).distinct()</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-14-%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-14-%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">数据结构与算法-14-排序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-27 13:04:49" itemprop="dateCreated datePublished" datetime="2020-08-27T13:04:49+08:00">2020-08-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-27 19:55:13" itemprop="dateModified" datetime="2020-11-27T19:55:13+08:00">2020-11-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/ge-chong-pai-xu-suan-fa-tu-xie-zong-jie-by-ke-ai-x/">https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/ge-chong-pai-xu-suan-fa-tu-xie-zong-jie-by-ke-ai-x/</a></p>
<h2 id="一、冒泡排序"><a href="#一、冒泡排序" class="headerlink" title="一、冒泡排序"></a>一、冒泡排序</h2><h3 id="一、思想"><a href="#一、思想" class="headerlink" title="一、思想"></a>一、思想</h3><pre><code>每次比较两个相邻的元素，如果他们之前的顺序不符就交换位置。
比如5个数从小到大排序，23，64，1，43，21
第一趟：
第一次比较：23，64，1，43，21
第二次比较：23，1，64，43，21
第三次比较：23，1，43，64，21
第四次比较：23，1，43，21，64
经过第一趟的比较后，最大的数字已经到最后面了，接下来只需要比较前四个数字，以此类推。
第二趟：1，23，21，43，64
第三趟：1，21，23，43，64
第四趟：1，21，23，43，64

冒泡排序每一趟只能对一个数进行归位，如果是n个数进行排序，则需要将n-1个数归位，即n-1趟操作
冒泡排序解决了桶排序浪费空间的问题，但是它效率很低。
时间复杂度：O(n^2)</code></pre>
<h3 id="二、用Python实现"><a href="#二、用Python实现" class="headerlink" title="二、用Python实现"></a>二、用Python实现</h3><pre><code>`
#!/usr/bin/env python
# coding:utf-8

def bubbleSort(nums):
    for i in range(len(nums) - 1):
        for j in range(len(nums) - i - 1):
            if nums[j] &gt; nums[j + 1]:
                nums[j], nums[j + 1] = nums[j + 1], nums[j]
    return nums

nums = [5, 6, 3, 1, 6, 2, 5, 33, 3]
print(bubbleSort(nums))
`</code></pre>
<h2 id="二、选择排序"><a href="#二、选择排序" class="headerlink" title="二、选择排序"></a>二、选择排序</h2><h3 id="一、思想-1"><a href="#一、思想-1" class="headerlink" title="一、思想"></a>一、思想</h3><pre><code>第1趟，在待排序记录r1 ~ r[n]中选出最小的记录，将它与r1交换；
第2趟，在待排序记录r2 ~ r[n]中选出最小的记录，将它与r2交换；
以此类推，第i趟在待排序记录r[i] ~ r[n]中选出最小的记录，将它与r[i]交换，使有序序列不断增长直到全部排序完毕。
原始数据：[3,1,0,8,4,2]
第一趟：[0,1,3,8,4,2]
第二趟：[0,1,3,8,4,2]
第三趟：[0,1,2,8,4,3]
第四趟：[0,1,2,3,4,8]
第五趟：[0,1,2,3,4,8]</code></pre>
<h3 id="二、用Python实现选择排序"><a href="#二、用Python实现选择排序" class="headerlink" title="二、用Python实现选择排序"></a>二、用Python实现选择排序</h3><pre><code>`
def selectSort(nums):
    for i in range(len(nums)-1):
        print(i)
        min = i
        for j in range(i + 1, len(nums)):
            if nums[min] &gt; nums[j]:
                min = j
        nums[i], nums[min] = nums[min], nums[i]
    return nums`</code></pre>
<h2 id="三、插入排序"><a href="#三、插入排序" class="headerlink" title="三、插入排序"></a>三、插入排序</h2><h3 id="一、思想-2"><a href="#一、思想-2" class="headerlink" title="一、思想"></a>一、思想</h3><pre><code>插入排序原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。
其基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，是稳定的排
序方法。
时间复杂度为O(n^2)。</code></pre>
<h3 id="二、步骤"><a href="#二、步骤" class="headerlink" title="二、步骤"></a>二、步骤</h3><pre><code>1. 从第一个元素开始，该元素可以认为已经被排序
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
5. 将新元素插入到该位置后
6. 重复步骤2~5</code></pre>
<h3 id="二、用Python实现插入排序"><a href="#二、用Python实现插入排序" class="headerlink" title="二、用Python实现插入排序"></a>二、用Python实现插入排序</h3><pre><code>`
#!/usr/bin/env python
# coding:utf-8

def insertSort(lists):
    for i in range(1, len(lists)):
        key = lists[i]
        j = i - 1
        while j &gt;= 0:
            if lists[j] &gt; key:
                lists[j + 1] = lists[j]
                lists[j] = key
            j -= 1
    return lists

lists = [4, 6, 2, 4, 7, 3, 9, 2, 1]
print(insertSort(lists))</code></pre>
<p>`</p>
<h2 id="四、快速排序"><a href="#四、快速排序" class="headerlink" title="四、快速排序"></a>四、快速排序</h2><h3 id="一、思想-3"><a href="#一、思想-3" class="headerlink" title="一、思想"></a>一、思想</h3><pre><code>快速排序是对冒泡排序的一种改进，其基本思想是通过一趟排序将待排序记录分割成独立的两部分，一种一部分记录的关键字均比另一部分记录的关键字小，最后再分别对这两部分记录继续进行排序，以达到整个序列有序。

一趟快读排序的具体做法是：附设两个指针low和high，初值分别为low和high，设枢轴记录关键字为pivotkey，则首先从high所指位置向前搜索找到第一个关键字小于pivotkey的记录和枢轴记录相互交换，然后从low所指位置起向后搜索，找到第一个关键字大于pivotkey的记录和枢轴记录相互交换，重复这两步直到low=high为止，过程如图：</code></pre>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/quickSort.jpg" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/quickSort.jpg"></p>
<h3 id="二、用Python实现快速排序"><a href="#二、用Python实现快速排序" class="headerlink" title="二、用Python实现快速排序"></a>二、用Python实现快速排序</h3><pre><code>`
#!/usr/bin/env python
# coding:utf-8

def quickSort(lists, left, right):
    if left &gt;= right:
        return lists
    key = lists[left]
    low = left
    high = right
    print(&quot;111&quot;)
    while left &lt; right:
        while (left &lt; right and lists[right] &gt;= key):
            right -= 1
        lists[left] = lists[right]
        while (left &lt; right and lists[left] &lt;= key):
            left += 1
        lists[right] = lists[left]
    lists[left] = key
    print(&quot;key&quot;)
    quickSort(lists, low, left - 1)
    quickSort(lists, left + 1, high)
    return lists


lists = [59, 3, 6, 3, 46]
print(quickSort(x, 0, 4))</code></pre>
<p>`</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-5-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%E7%B3%BB%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-5-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%E7%B3%BB%E5%88%97/" class="post-title-link" itemprop="url">数据结构与算法-5-动态规划-零钱兑换系列</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-26 11:51:34" itemprop="dateCreated datePublished" datetime="2020-08-26T11:51:34+08:00">2020-08-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-18 23:43:05" itemprop="dateModified" datetime="2020-11-18T23:43:05+08:00">2020-11-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322.零钱兑换"></a>322.零钱兑换</h3><pre><code>链接：https://leetcode-cn.com/problems/coin-change/

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

示例 1:

输入: coins = [1, 2, 5], amount = 11
输出: 3 
解释: 11 = 5 + 5 + 1
示例 2:

输入: coins = [2], amount = 3
输出: -1
说明:
你可以认为每种硬币的数量是无限的。</code></pre>
<p>题解一|递归|超时：</p>
<pre><code>递归遍历添加所有硬币的情况，每次添加某硬币，则递归遍历总金额-某硬币 的子问题。

    若 当前总金额为 0 则表明当前硬币情况有解，返回 0。

    若 当前总金额不为 0，则继续添加硬币

        若 当前总金额-硬币&lt;0 表明不能添加该硬币（无解），尝试添加其他硬币。

        若 当前总金额-硬币&gt;0 则递归遍历当前总金额-硬币的子问题，若子问题无解，尝试添加其他硬币；若子问题有解，则每次添加硬币时记录，硬币数 +1，最终比较取最小值。

    返回情况，若子问题有解，则返回子问题的最少硬币数，否则返回 -1。</code></pre>
<pre><code>class Solution:
    def coinChange(self, coins: List[int], amount: int) -&gt; int:
        self.res=float(&#39;inf&#39;)
        def helper(amount,count):
            if amount &lt; 0:
                return
            if amount == 0:
                self.res=min(self.res,count)
            for i in range(len(coins)):
                helper(amount-coins[i],count+1)

        if len(coins)==0:
            return -1
        helper(amount,0)
        if self.res == float(&#39;inf&#39;):
            return -1
        return self.res</code></pre>
<pre><code>class Solution:
    def coinChange(self, coins: List[int], amount: int) -&gt; int:
        if amount &lt; 0:
            return 0
        res=float(&#39;inf&#39;)
        for coin in coins:
            if amount-coin &lt; 0:
                continue
            sub=self.coinChange(coins,amount-coin)
            if sub == -1:
                continue
            res=min(res,sub+1)
        return res if res != float(&#39;inf&#39;) else -1</code></pre>
<p>题解二|记忆化搜索：</p>
<pre><code>class Solution:
    def coinChange(self, coins: List[int], amount: int) -&gt; int:
        def helper(coins,amount,memo):
            if amount == 0:
                return 0
            if amount in memo:
                return memo[amount]

            res=float(&#39;inf&#39;)

            for coin in coins:
                if amount-coin &lt; 0:
                    continue
                sub=helper(coins,amount-coin,memo)
                if sub == -1:
                    continue
                res=min(res,sub+1)
            if res != float(&#39;inf&#39;):
                memo[amount]=res
            else:
                memo[amount]=-1
            return memo[amount]
        memo=&#123;&#125;
        return helper(coins,amount,memo)</code></pre>
<pre><code>class Solution:
    def coinChange(self, coins: List[int], amount: int) -&gt; int:
        def helper(amount):
            if amount in memo:
                return memo[amount]
            if amount == 0:
                return 0
            if amount &lt; 0:
                return -1

            res=float(&#39;inf&#39;)
            for coin in coins:
                sub=helper(amount-coin)
                if sub == -1:
                    continue
                res=min(res,sub+1)
            if res != float(&#39;inf&#39;):
                memo[amount]=res
            else:
                memo[amount]=-1
            return memo[amount]
        memo=&#123;&#125;
        return helper(coins,amount,memo)</code></pre>
<p>题解三|动态规划|自上而下：</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&amp;mid=2247486360&amp;idx=2&amp;sn=bebf739b28f51a666af4cb9b30533b55&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&amp;mid=2247486360&amp;idx=2&amp;sn=bebf739b28f51a666af4cb9b30533b55&amp;scene=21#wechat_redirect</a></p>
<p>1、定义数组含义</p>
<pre><code>dp[i] 保存金额 i 的最小组成数。</code></pre>
<p>2、找出数组递推关系式</p>
<pre><code>遍历 dp 数组，i 遍历区间 [1,amount+1)：

    遍历每种硬币的面值 coin：
        必须满足条件 i&gt;=coin，表示金额必须比硬币面值大。
        dp[i]=min(dp[i],dp(i-coin)+1)，保存的是最小的组成数。

若 dp[amount]不为MAX，则返回，否则返回 −1。</code></pre>
<p>3、找到初始值</p>
<pre><code>初试化 dp=[MAX,⋯,MAX]，长度为 amount+1
dp[0]=0，表示 0 元的组成种类为 0</code></pre>
<p>时间复杂度：O(mn)<br>空间复杂度：O(n)</p>
<pre><code>class Solution:
    def coinChange(self, coins: List[int], amount: int) -&gt; int:
        dp=[float(&#39;inf&#39;)]*(amount+1)
        dp[0]=0
        for i in range(1,amount+1):
            for coin in coins:
                if i &gt;= coin:
                    dp[i]=min(dp[i],dp[i-coin]+1)
        return dp[-1] if dp[-1] != float(&#39;inf&#39;) else -1</code></pre>
<h3 id="518-零钱兑换-II"><a href="#518-零钱兑换-II" class="headerlink" title="518. 零钱兑换 II"></a>518. 零钱兑换 II</h3><pre><code>链接：https://leetcode-cn.com/problems/coin-change-2/

给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 

示例 1:

输入: amount = 5, coins = [1, 2, 5]
输出: 4
解释: 有四种方式可以凑成总金额:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1

示例 2:

输入: amount = 3, coins = [2]
输出: 0
解释: 只用面额2的硬币不能凑成总金额3。

示例 3:

输入: amount = 10, coins = [10] 
输出: 1

注意:

你可以假设：

0 &lt;= amount (总金额) &lt;= 5000
1 &lt;= coin (硬币面额) &lt;= 5000
硬币种类不超过 500 种
结果符合 32 位符号整数</code></pre>
<p>题解一|回溯|超时：</p>
<pre><code>class Solution:
    def change(self, amount: int, coins: List[int]) -&gt; int:
        n=len(coins)
        self.res=0
        def helper(first,amount):
            if amount == 0:
                self.res+=1
                return

            for i in range(first,len(coins)):
                if coins[i] &lt;= amount:
                    helper(i,amount-coins[i])
        coins.sort()
        helper(0,amount)
        return self.res</code></pre>
<pre><code>class Solution:
    def change(self, amount: int, coins: List[int]) -&gt; int:
        n=len(coins)
        self.res=0
        def helper(first,amount):
            if amount == 0:
                self.res+=1
                return 
            for i in range(first,len(coins)):
                if amount &gt;= coins[i]:
                    amount-=coins[i]
                    helper(i,amount)
                    amount+=coins[i]
        coins.sort()
        helper(0,amount)
        return self.res</code></pre>
<p>题解二|动态规划：</p>
<pre><code>参考背包系列</code></pre>
<pre><code>class Solution:
    def change(self, amount: int, coins: List[int]) -&gt; int:
        n=len(coins)
        dp=[[0]*(amount+1) for i in range(n+1)]
        for i in range(n+1):
            dp[i][0]=1
        for i in range(1,n+1):
            for j in range(1,amount+1):
                if j-coins[i-1]&gt;=0:
                    dp[i][j]=dp[i-1][j]+dp[i][j-coins[i-1]]
                else:
                    dp[i][j]=dp[i-1][j]
        return dp[n][amount]</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-13-%E7%BA%A2%E9%BB%91%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-13-%E7%BA%A2%E9%BB%91%E6%A0%91/" class="post-title-link" itemprop="url">数据结构与算法-13-红黑树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-14 10:47:10" itemprop="dateCreated datePublished" datetime="2020-07-14T10:47:10+08:00">2020-07-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-27 12:52:45" itemprop="dateModified" datetime="2020-08-27T12:52:45+08:00">2020-08-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>参考：<a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1641940303518144126&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1641940303518144126&amp;wfr=spider&amp;for=pc</a></p>
<h2 id="一、红黑树"><a href="#一、红黑树" class="headerlink" title="一、红黑树"></a>一、红黑树</h2><p>红黑树除了符合二叉查找树的特性之外，还具有以下特性：</p>
<pre><code>1. 节点是红色或者黑色

2. 根节点是黑色

3. 每个叶子的节点都是黑色的空节点（NULL）

4. 每个红色节点的两个子节点都是黑色的。

5. 从任意节点到其每个叶子的所有路径都包含相同的黑色节点。</code></pre>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/redblacktree.jpeg" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/redblacktree.jpeg"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Lilly</p>
  <div class="site-description" itemprop="description">Up in the wind!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">133</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lilly</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
