<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"gongyanli.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="常用函数： bin() # 十进制转二进制 oct() # 十进制转八进制 hex() # 十进制转十六进制  chr() # 数字转字符串(ascii) ord() # 字符串(ascii)转数字  65--&#39;A&#39; 97--&#39;a&#39; 十二、字符串?5.最长回文子串链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;longest-palindro">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode-12-字符串">
<meta property="og:url" content="http://gongyanli.com/LeetCode-12-%E5%AD%97%E7%AC%A6%E4%B8%B2/index.html">
<meta property="og:site_name" content="茉莉Python">
<meta property="og:description" content="常用函数： bin() # 十进制转二进制 oct() # 十进制转八进制 hex() # 十进制转十六进制  chr() # 数字转字符串(ascii) ord() # 字符串(ascii)转数字  65--&#39;A&#39; 97--&#39;a&#39; 十二、字符串?5.最长回文子串链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;longest-palindro">
<meta property="og:locale">
<meta property="og:image" content="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/dp.png">
<meta property="og:image" content="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/rome.png">
<meta property="og:image" content="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/lcp1.png">
<meta property="og:image" content="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/lcp2.png">
<meta property="og:image" content="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/lcp3.png">
<meta property="og:image" content="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/str1.png">
<meta property="og:image" content="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/str.png">
<meta property="og:image" content="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/bit.png">
<meta property="article:published_time" content="2020-03-28T15:45:50.000Z">
<meta property="article:modified_time" content="2020-09-01T04:01:03.187Z">
<meta property="article:author" content="Lilly">
<meta property="article:tag" content="LeetCode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/dp.png">

<link rel="canonical" href="http://gongyanli.com/LeetCode-12-%E5%AD%97%E7%AC%A6%E4%B8%B2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>LeetCode-12-字符串 | 茉莉Python</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">茉莉Python</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">voidqueens@hotmail.com</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/LeetCode-12-%E5%AD%97%E7%AC%A6%E4%B8%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          LeetCode-12-字符串
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-28 23:45:50" itemprop="dateCreated datePublished" datetime="2020-03-28T23:45:50+08:00">2020-03-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-01 12:01:03" itemprop="dateModified" datetime="2020-09-01T12:01:03+08:00">2020-09-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>常用函数：</p>
<pre><code>bin() # 十进制转二进制
oct() # 十进制转八进制
hex() # 十进制转十六进制

chr() # 数字转字符串(ascii)
ord() # 字符串(ascii)转数字

65--&#39;A&#39;
97--&#39;a&#39;</code></pre>
<h2 id="十二、字符串"><a href="#十二、字符串" class="headerlink" title="十二、字符串"></a>十二、字符串</h2><h3 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="?5.最长回文子串"></a>?5.最长回文子串</h3><pre><code>链接：https://leetcode-cn.com/problems/longest-palindromic-substring/

给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

示例 1：

输入: &quot;babad&quot;
输出: &quot;bab&quot;
注意: &quot;aba&quot; 也是一个有效答案。
示例 2：

输入: &quot;cbbd&quot;
输出: &quot;bb&quot;</code></pre>
<p>题解一|暴力破解：<br>    很明显，暴力法将选出所有子字符串可能的开始和结束位置，并检验它是不是回文。<br>    时间复杂度：O(n^2),往往利用python的切片可以很好的缩减复杂度<br>    如果不用切片，还需要遍历一次子字符串，时间复杂度就是O(n^3)<br>    空间复杂度：O(1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def longestPalindrome(self, s: str) -&gt; str:</span><br><span class="line">        if s&#x3D;&#x3D;s[::-1]:</span><br><span class="line">            return s</span><br><span class="line"></span><br><span class="line">        maxLen&#x3D;1</span><br><span class="line">        ans&#x3D;s[0]</span><br><span class="line">        for i in range(0,len(s)-1):</span><br><span class="line">            for j in range(i+1,len(s)):</span><br><span class="line">                if j-i+1 &gt; maxLen and self.isPalindrome(s[i:j+1]):</span><br><span class="line">                    maxLen&#x3D;j-i+1</span><br><span class="line">                    ans&#x3D;s[i:j+1]</span><br><span class="line">        return ans</span><br><span class="line"></span><br><span class="line">    def isPalindrome(self, s: str) -&gt; bool:</span><br><span class="line">        left,right&#x3D;0,len(s)-1</span><br><span class="line">        while left&lt;right:</span><br><span class="line">            while left&lt;len(s) and not s[left].isalnum():</span><br><span class="line">                left+&#x3D;1</span><br><span class="line">            while right &gt;-1 and not s[right].isalnum():</span><br><span class="line">                right-&#x3D;1</span><br><span class="line">            if left&gt;right:</span><br><span class="line">                return True</span><br><span class="line">            if s[left].upper() !&#x3D; s[right].upper():</span><br><span class="line">                return False</span><br><span class="line">            else:</span><br><span class="line">                left+&#x3D;1</span><br><span class="line">                right-&#x3D;1</span><br><span class="line">        return True</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def longestPalindrome(self, s: str) -&gt; str:</span><br><span class="line">        if s&#x3D;&#x3D;s[::-1]:</span><br><span class="line">            return s</span><br><span class="line"></span><br><span class="line">        maxLen&#x3D;1</span><br><span class="line">        ans&#x3D;s[0]</span><br><span class="line">        for i in range(0,len(s)-1):</span><br><span class="line">            for j in range(i+1,len(s)):</span><br><span class="line">                if j-i+1 &gt; maxLen and s[i:j+1]&#x3D;&#x3D;s[i:j+1][::-1]: # arr&#x3D;&#39;abb&#39;,arr[0:1]&#x3D;&#39;a&#39;,右边是开区间</span><br><span class="line">                    maxLen&#x3D;j-i+1</span><br><span class="line">                    ans&#x3D;s[i:j+1]</span><br><span class="line">        return ans</span><br></pre></td></tr></table></figure>

<p>题解二：</p>
<pre><code>每个字母当成回文串的中心
考虑两种情况:回文串的长度为奇数或者偶数情况。</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def longestPalindrome(self, s: str) -&gt; str:</span><br><span class="line">        n&#x3D;len(s)</span><br><span class="line">        self.res&#x3D;&#39;&#39;</span><br><span class="line">        def helper(i,j):</span><br><span class="line">            while i&gt;&#x3D; 0 and j&lt;n and s[i]&#x3D;&#x3D;s[j]:</span><br><span class="line">                i-&#x3D;1</span><br><span class="line">                j+&#x3D;1</span><br><span class="line">            if len(self.res) &lt; j-i-1:</span><br><span class="line">                self.res&#x3D;s[i+1:j]</span><br><span class="line">                # print(i,self.res)</span><br><span class="line">        </span><br><span class="line">        for i in range(n):</span><br><span class="line">            helper(i,i)</span><br><span class="line">            helper(i,i+1) # 解决case为&quot;cbbd&quot;,即解决回文串为偶数的情况</span><br><span class="line">        return self.res</span><br></pre></td></tr></table></figure>

<p>题解三：</p>
<pre><code>把每个字母当成回文串的结束</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def longestPalindrome(self, s: str) -&gt; str:</span><br><span class="line">        if not s:</span><br><span class="line">            return &quot;&quot;</span><br><span class="line">        max_len &#x3D; 1</span><br><span class="line">        n &#x3D; len(s)</span><br><span class="line">        start &#x3D; 0</span><br><span class="line">        for i in range(1,n):</span><br><span class="line">            even &#x3D; s[i-max_len:i+1]</span><br><span class="line">            odd &#x3D; s[i - max_len-1:i+1]</span><br><span class="line">            #print(even,odd)</span><br><span class="line">            if i - max_len - 1 &gt;&#x3D; 0 and odd &#x3D;&#x3D; odd[::-1]:</span><br><span class="line">                start &#x3D; i - max_len - 1</span><br><span class="line">                max_len +&#x3D; 2</span><br><span class="line">            elif i - max_len &gt;&#x3D;0 and even &#x3D;&#x3D; even[::-1]:</span><br><span class="line">                start &#x3D; i - max_len</span><br><span class="line">                max_len +&#x3D; 1</span><br><span class="line">                </span><br><span class="line">        #print(start,max_len)</span><br><span class="line">        return s[start: start+max_len]</span><br></pre></td></tr></table></figure>

<p>题解二（动态规划）：<br><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/dp.png"></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/">https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/</a></p>
<pre><code>1、定义数组的定义
    dp[i][j] 表示子串 s[i, j] 是否为回文子串。
2、找出数组的关系式
    dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1]
3、找到初始值</code></pre>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/gao-hao-dong-tai-gui-hua-he-zhong-xin-tuo-zhan-zhu/">https://leetcode-cn.com/problems/longest-palindromic-substring/solution/gao-hao-dong-tai-gui-hua-he-zhong-xin-tuo-zhan-zhu/</a></p>
<h3 id="12-整数转罗马数字"><a href="#12-整数转罗马数字" class="headerlink" title="12.整数转罗马数字"></a>12.整数转罗马数字</h3><pre><code>链接：https://leetcode-cn.com/problems/integer-to-roman/

罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。

字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。

示例 1:

输入: 3
输出: &quot;III&quot;
示例 2:

输入: 4
输出: &quot;IV&quot;
示例 3:

输入: 9
输出: &quot;IX&quot;
示例 4:

输入: 58
输出: &quot;LVIII&quot;
解释: L = 50, V = 5, III = 3.
示例 5:

输入: 1994
输出: &quot;MCMXCIV&quot;
解释: M = 1000, CM = 900, XC = 90, IV = 4.</code></pre>
<p>题解一(贪心算法)：<br><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/rome.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def intToRoman(self, num: int) -&gt; str:</span><br><span class="line">        # dicts&#x3D;&#123;&#39;I&#39;:1,&#39;V&#39;:5,&#39;X&#39;:10,&#39;L&#39;:50,&#39;C&#39;:100,&#39;D&#39;:500,&#39;M&#39;:1000&#125;</span><br><span class="line">        dicts&#x3D;&#123;1:&#39;I&#39;,4:&#39;IV&#39;,5:&#39;V&#39;,9:&#39;IX&#39;,10:&#39;X&#39;,40:&#39;XL&#39;,50:&#39;L&#39;,90:&#39;XC&#39;,100:&#39;C&#39;,400:&#39;CD&#39;,500:&#39;D&#39;,900:&#39;CM&#39;,1000:&#39;M&#39; &#125;</span><br><span class="line">        ans&#x3D;&#39;&#39;</span><br><span class="line">        for key in sorted(dicts.keys())[::-1]:</span><br><span class="line">            if num&#x3D;&#x3D;0:</span><br><span class="line">                break</span><br><span class="line">            tmp&#x3D;num&#x2F;&#x2F;key</span><br><span class="line">            if tmp&#x3D;&#x3D;0:</span><br><span class="line">                continue</span><br><span class="line">            ans+&#x3D;dicts[key]*tmp</span><br><span class="line">            num-&#x3D;key*tmp</span><br><span class="line">        return ans</span><br></pre></td></tr></table></figure>

<h3 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13.罗马数字转整数"></a>13.罗马数字转整数</h3><pre><code>链接：https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/rome.png

罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。

字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。

示例 1:

输入: &quot;III&quot;
输出: 3
示例 2:

输入: &quot;IV&quot;
输出: 4
示例 3:

输入: &quot;IX&quot;
输出: 9
示例 4:

输入: &quot;LVIII&quot;
输出: 58
解释: L = 50, V= 5, III = 3.
示例 5:

输入: &quot;MCMXCIV&quot;
输出: 1994
解释: M = 1000, CM = 900, XC = 90, IV = 4.</code></pre>
<p>题解一(hash)：<br>    首先建立一个HashMap来映射符号和值，然后对字符串从左到右来，如果当前字符代表的值小于其右边，就减去该值；否则就加上该值，以此类推到最右边的数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def romanToInt(self, s: str) -&gt; int:</span><br><span class="line">        arr&#x3D;&#123;&#39;I&#39;:1,&#39;V&#39;:5,&#39;X&#39;:10,&#39;L&#39;:50,&#39;C&#39;:100,&#39;D&#39;:500,&#39;M&#39;:1000&#125;</span><br><span class="line">        ans&#x3D;0</span><br><span class="line">        for i in range(len(s)):</span><br><span class="line">            if i&lt;len(s)-1 and arr[s[i]]&lt;arr[s[i+1]]:</span><br><span class="line">                ans-&#x3D;arr[s[i]]</span><br><span class="line">            else:</span><br><span class="line">                ans+&#x3D;arr[s[i]]</span><br><span class="line">        return ans</span><br></pre></td></tr></table></figure>
<p>题解二（hash）：<br>    # 构建一个字典记录所有罗马数字子串，注意长度为2的子串记录的值是（实际值 - 子串内左边罗马数字代表的数值）</p>
<pre><code># 然后，遍历整个 s 的时候判断当前位置和前一个位置的两个字符组成的字符串是否在字典内，如果在就记录值，不在就说明当前位置不存在小数字在前面的情况，直接记录当前位置字符对应值

# 举个例子，遍历经过 IV 的时候先记录 I 的对应值 1，再往前移动一步记录 IV 的值 3，加起来正好是 IV 的真实值 4。max 函数在这里是为了防止遍历第一个字符的时候出现 [-1:0] 的情况，因为s[-1:0]为空。</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def romanToInt(self, s: str) -&gt; int:</span><br><span class="line">        arr&#x3D;&#123;&#39;I&#39;:1,&#39;IV&#39;:3,&#39;V&#39;:5,&#39;IX&#39;:8,&#39;X&#39;:10,&#39;XL&#39;:30,&#39;L&#39;:50,&#39;XC&#39;:80,&#39;C&#39;:100,&#39;CD&#39;:300,&#39;D&#39;:500,&#39;CM&#39;:800,&#39;M&#39;:1000&#125;</span><br><span class="line">        return sum(arr.get(s[max(i-1,0):i+1],arr[v]) for i,v in enumerate(s))</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def romanToInt(self, s: str) -&gt; int:</span><br><span class="line">        arr&#x3D;&#123;&#39;I&#39;:1,&#39;IV&#39;:3,&#39;V&#39;:5,&#39;IX&#39;:8,&#39;X&#39;:10,&#39;XL&#39;:30,&#39;L&#39;:50,&#39;XC&#39;:80,&#39;C&#39;:100,&#39;CD&#39;:300,&#39;D&#39;:500,&#39;CM&#39;:800,&#39;M&#39;:1000&#125;</span><br><span class="line">        ans&#x3D;0</span><br><span class="line">        for i,v in enumerate(s):</span><br><span class="line">            ans+&#x3D;arr.get(s[i-1:i+1],arr[v])</span><br><span class="line">        return ans</span><br></pre></td></tr></table></figure>


<p>?### 14.最长公共前缀<br>    链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-common-prefix/">https://leetcode-cn.com/problems/longest-common-prefix/</a></p>
<pre><code>编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 &quot;&quot;。

示例 1:

输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]
输出: &quot;fl&quot;
示例 2:

输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]
输出: &quot;&quot;
解释: 输入不存在公共前缀。
说明:

所有输入只包含小写字母 a-z 。</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lz_901/article/details/89021210">https://blog.csdn.net/lz_901/article/details/89021210</a><br>题解一(水平扫描)：</p>
<pre><code>1、先找出 str1 和 str2（注：str1代表第一个字符串，str2代表第二个） 的公共字符串 s1。

2、然后再找出 s1 和 str3 的公共前缀 s2。

3、然后再找出 s2 和 str4 的公共前缀 s3。

4、一直这样遍历重复，用一个变量来保存两个两个字符串之间的公共前缀。</code></pre>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/lcp1.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/lcp1.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def longestCommonPrefix(self, strs: List[str]) -&gt; str:</span><br><span class="line">        # if not strs:</span><br><span class="line">        #     return &#39;&#39;</span><br><span class="line">        # res&#x3D;&#39;&#39;</span><br><span class="line">        # for i in range(0,len(strs[0])):</span><br><span class="line">        #     c&#x3D;strs[0][i]</span><br><span class="line">        #     for j in range(1,len(strs)):</span><br><span class="line">        #         if i &#x3D;&#x3D; len(str[j]) or c !&#x3D; strs[j][i] </span><br><span class="line">        #             return res</span><br><span class="line">        #     res+&#x3D;c</span><br><span class="line">        if not strs:</span><br><span class="line">            return &#39;&#39;</span><br><span class="line">        prefix&#x3D;strs[0]</span><br><span class="line">        for i in range(1,len(strs)):</span><br><span class="line">            while strs[i].find(prefix) !&#x3D; 0: # 此题是寻找最长公共前缀，所以需要找到开始索引是0.</span><br><span class="line">                prefix&#x3D;prefix[0:len(prefix)-1]</span><br><span class="line">                if prefix&#x3D;&#x3D;&#39;&#39;:</span><br><span class="line">                    return &#39;&#39;</span><br><span class="line">        return prefix</span><br></pre></td></tr></table></figure>

<p>find()语法：</p>
<pre><code>str.find(str, beg=0, end=len(string))

参数：
    str -- 指定检索的字符串
    beg -- 开始索引，默认为0。
    end -- 结束索引，默认为字符串的长度。

返回值：
    如果包含子字符串返回开始的索引值，否则返回-1。</code></pre>
<p>题解二(水平扫描优化)：</p>
<pre><code>想象数组的末尾有一个非常短的字符串，使用上述方法仍旧会进行S次比较。
优化这类情况的方法是水平扫描，从前往后枚举字符串的每一列，先比较每个字符串相同列上的字符（即不同字符串相同下标的字符），然后再进行下一列的比较。

我们不横向一个一个字符串遍历，而是采用纵向的方式。例如对于这个[&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]，我们把它看成一个二维字符数组。

然后纵向遍历，一列一列遍历，只要发现某一列出现不同的字符，就遍历结束，例如上面这个例子中，第三列就出现不同了，所以遍历结束，把前两列返回。</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def longestCommonPrefix(self, strs: List[str]) -&gt; str:</span><br><span class="line">        if(not strs):</span><br><span class="line">            return &quot;&quot;</span><br><span class="line">        for i in range(len(strs[0])):</span><br><span class="line">            c&#x3D;strs[0][i]</span><br><span class="line">            for j in range(len(strs)):</span><br><span class="line">                if i&#x3D;&#x3D;len(strs[j]) or strs[j][i] !&#x3D; c:</span><br><span class="line">                    return strs[0][0:i]</span><br><span class="line">        return strs[0]</span><br></pre></td></tr></table></figure>

<p>题解三（分治）：</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/lcp2.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/lcp2.png"></p>
<p>复杂度：<br><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/lcp3.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/lcp3.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def longestCommonPrefix(self, strs: List[str]) -&gt; str:</span><br><span class="line">        def commonPrefix(l, r):</span><br><span class="line">            &#39;&#39;&#39;</span><br><span class="line">            治：从首位开始对比</span><br><span class="line">            :param l:</span><br><span class="line">            :param r:</span><br><span class="line">            :return:</span><br><span class="line">            &#39;&#39;&#39;</span><br><span class="line">            minlen &#x3D; min(len(l), len(r))</span><br><span class="line">            for i in range(minlen):</span><br><span class="line">                if l[i] !&#x3D; r[i]:</span><br><span class="line">                    return l[0:i]</span><br><span class="line">            return l[0:minlen]</span><br><span class="line"></span><br><span class="line">        def lcp(strs, l, r):</span><br><span class="line">            &#39;&#39;&#39;</span><br><span class="line">            分：分为小问题</span><br><span class="line">            :param strs:</span><br><span class="line">            :param l:</span><br><span class="line">            :param r:</span><br><span class="line">            :return:</span><br><span class="line">            &#39;&#39;&#39;</span><br><span class="line"></span><br><span class="line">            # 递归弹出</span><br><span class="line">            if l &#x3D;&#x3D; r:</span><br><span class="line">                return strs[l]</span><br><span class="line">            # 继续分</span><br><span class="line">            else:</span><br><span class="line">                mid &#x3D; (l + r) &#x2F;&#x2F; 2</span><br><span class="line">                left &#x3D; lcp(strs, l, mid)</span><br><span class="line">                right &#x3D; lcp(strs, mid + 1, r)</span><br><span class="line">                return commonPrefix(left, right)</span><br><span class="line"></span><br><span class="line">        if not strs:</span><br><span class="line">            return &#39;&#39;</span><br><span class="line">        return lcp(strs, 0, len(strs) - 1)</span><br></pre></td></tr></table></figure>

<p>题解四（zip）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def longestCommonPrefix(self, strs: List[str]) -&gt; str:</span><br><span class="line">        # print(strs)</span><br><span class="line">        # print(*strs)</span><br><span class="line">        res&#x3D;&#39;&#39;</span><br><span class="line">        for i in zip(*strs):</span><br><span class="line">            # print(i)</span><br><span class="line">            if len(set(i))&#x3D;&#x3D;1:</span><br><span class="line">                res+&#x3D;i[0]</span><br><span class="line">            else:</span><br><span class="line">                break</span><br><span class="line">        return res</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[&#39;flower&#39;, &#39;flow&#39;, &#39;flight&#39;]</span><br><span class="line">flower flow flight</span><br><span class="line">(&#39;f&#39;, &#39;f&#39;, &#39;f&#39;)</span><br><span class="line">(&#39;l&#39;, &#39;l&#39;, &#39;l&#39;)</span><br><span class="line">(&#39;o&#39;, &#39;o&#39;, &#39;i&#39;)</span><br></pre></td></tr></table></figure>

<p>zip()语法：</p>
<pre><code>zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表(python2)/对象(python3)。

如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。

zip 方法在 Python 2 和 Python 3 中的不同：在 Python 3.x 中为了减少内存，zip() 返回的是一个对象。如需展示列表，需手动 list() 转换。在 Python 2.x zip() 返回的是一个列表。

zip([iterable, ...])

参数说明：
    iterabl -- 一个或多个迭代器;
返回值:
返回元组列表/一个对象。</code></pre>
<p>题解五（max和min）：</p>
<p>max()和min()在python字符串中是可以比较的，按照ascii值排序，比如abb，aba，abac，最大为abb，最小为aba。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def longestCommonPrefix(self, strs: List[str]) -&gt; str:</span><br><span class="line">        if not strs:</span><br><span class="line">            return &#39;&#39;</span><br><span class="line">        s1&#x3D;min(strs)</span><br><span class="line">        s2&#x3D;max(strs)</span><br><span class="line">        for i,v in enumerate(s1):</span><br><span class="line">            if v !&#x3D; s2[i]:</span><br><span class="line">                return s1[:i]</span><br><span class="line">        return s1</span><br></pre></td></tr></table></figure>

<h3 id="28-实现-strStr"><a href="#28-实现-strStr" class="headerlink" title="28. 实现 strStr()"></a>28. 实现 strStr()</h3><pre><code>链接：https://leetcode-cn.com/problems/implement-strstr/

实现 strStr() 函数。

给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。

示例 1:

输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;
输出: 2
示例 2:

输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;
输出: -1
说明:

当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</code></pre>
<p>题解一(子串逐一比较 - 线性时间复杂度)：</p>
<p>思路：沿着字符换逐步移动滑动窗口，将窗口内的子串与 needle 字符串比较。</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/str1.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/str1.png"></p>
<p>时间复杂度：O((N - L)L)，其中 N 为 haystack 字符串的长度，L 为 needle 字符串的长度。内循环中比较字符串的复杂度为 L，总共需要比较 (N - L) 次。<br>空间复杂度：O(1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def strStr(self, haystack: str, needle: str) -&gt; int:</span><br><span class="line">        n,length&#x3D;len(haystack),len(needle)</span><br><span class="line">        for i in range(n-length+1):</span><br><span class="line">            if haystack[i:i+length]&#x3D;&#x3D;needle:</span><br><span class="line">                return i</span><br><span class="line">        return -1</span><br></pre></td></tr></table></figure>

<p>？？题解二（双指针 - 线性时间复杂度）：</p>
<p>题解一的缺陷是会将 haystack 所有长度为 L 的子串都与 needle 字符串比较，实际上是不需要这么做的。</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/str.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/str.png"></p>
<pre><code>首先，只有子串的第一个字符跟 needle 字符串第一个字符相同的时候才需要比较。

其次，可以一个字符一个字符比较，一旦不匹配了就立刻终止。

比较到最后一位时发现不匹配，这时候开始回溯。需要注意的是，pn 指针是移动到 pn = pn - curr_len + 1 的位置，而 不是 pn = pn - curr_len 的位置。

这时候再比较一次，就找到了完整匹配的子串，直接返回子串的开始位置 pn - L。</code></pre>
<p>思路：</p>
<pre><code>移动 pn 指针，直到 pn 所指向位置的字符与 needle 字符串第一个字符相等。

通过 pn，pL，curr_len 计算匹配长度。

如果完全匹配（即 curr_len == L），返回匹配子串的起始坐标（即 pn - L）。

如果不完全匹配，回溯。使 pn = pn - curr_len + 1， pL = 0， curr_len = 0。</code></pre>
<p>时间复杂度：最坏时间复杂度为 O((N - L)L)，最优时间复杂度为 O(N)。<br>空间复杂度：O(1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def strStr(self, haystack: str, needle: str) -&gt; int:</span><br><span class="line">        L, n &#x3D; len(needle), len(haystack)</span><br><span class="line">        if L &#x3D;&#x3D; 0:</span><br><span class="line">            return 0</span><br><span class="line"></span><br><span class="line">        pn &#x3D; 0</span><br><span class="line">        while pn &lt; n - L + 1:</span><br><span class="line">            # find the position of the first needle character</span><br><span class="line">            # in the haystack string</span><br><span class="line">            while pn &lt; n - L + 1 and haystack[pn] !&#x3D; needle[0]:</span><br><span class="line">                pn +&#x3D; 1</span><br><span class="line">            </span><br><span class="line">            # compute the max match string</span><br><span class="line">            curr_len &#x3D; pL &#x3D; 0</span><br><span class="line">            while pL &lt; L and pn &lt; n and haystack[pn] &#x3D;&#x3D; needle[pL]:</span><br><span class="line">                pn +&#x3D; 1</span><br><span class="line">                pL +&#x3D; 1</span><br><span class="line">                curr_len +&#x3D; 1</span><br><span class="line">            </span><br><span class="line">            # if the whole needle string is found,</span><br><span class="line">            # return its start position</span><br><span class="line">            if curr_len &#x3D;&#x3D; L:</span><br><span class="line">                return pn - L</span><br><span class="line">            </span><br><span class="line">            # otherwise, backtrack</span><br><span class="line">            pn &#x3D; pn - curr_len + 1</span><br><span class="line">            </span><br><span class="line">        return -1</span><br></pre></td></tr></table></figure>

<p>？？？题解三（KMP）：<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-strstr/solution/kmphua-48xiao-shi-kan-dong-liao-kmpxiang-rang-ni-z/">https://leetcode-cn.com/problems/implement-strstr/solution/kmphua-48xiao-shi-kan-dong-liao-kmpxiang-rang-ni-z/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Px411z7Yo?from=search&amp;seid=13225444196686531503">https://www.bilibili.com/video/BV1Px411z7Yo?from=search&amp;seid=13225444196686531503</a><br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1hW411a7ys/?spm_id_from=333.788.videocard.0">https://www.bilibili.com/video/BV1hW411a7ys/?spm_id_from=333.788.videocard.0</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def strStr(self, haystack: str, needle: str) -&gt; int:</span><br><span class="line">        if not needle:</span><br><span class="line">            return 0</span><br><span class="line">        next&#x3D;self.getNext(needle)</span><br><span class="line">        i&#x3D;j&#x3D;0</span><br><span class="line">        while i&lt;len(haystack) and j&lt;len(needle):</span><br><span class="line">            if j&#x3D;&#x3D;-1 or haystack[i]&#x3D;&#x3D;needle[j]:</span><br><span class="line">                i+&#x3D;1</span><br><span class="line">                j+&#x3D;1</span><br><span class="line">            else:</span><br><span class="line">                j&#x3D;next[j]</span><br><span class="line">        if j&#x3D;&#x3D;len(needle):</span><br><span class="line">            return i-j</span><br><span class="line">        else:</span><br><span class="line">            return -1</span><br><span class="line">    def getNext(self,needle):</span><br><span class="line">        next&#x3D;[0]*len(needle)</span><br><span class="line">        next[0]&#x3D;-1</span><br><span class="line">        print(next)</span><br><span class="line">        i&#x3D;0</span><br><span class="line">        j&#x3D;-1</span><br><span class="line">        while i&lt;len(needle)-1:</span><br><span class="line">            if j&#x3D;&#x3D;-1 or needle[i]&#x3D;&#x3D;needle[j]:</span><br><span class="line">                i+&#x3D;1</span><br><span class="line">                j+&#x3D;1</span><br><span class="line">                next[i]&#x3D;j</span><br><span class="line">            else:</span><br><span class="line">                j&#x3D;next[j]</span><br><span class="line">        return next</span><br></pre></td></tr></table></figure>

<p>题解四：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def strStr(self, haystack: str, needle: str) -&gt; int:</span><br><span class="line">        i&#x3D;haystack.find(needle)</span><br><span class="line">        return i</span><br></pre></td></tr></table></figure>

<h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h3><pre><code>链接：https://leetcode-cn.com/problems/valid-parentheses/

给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;&#123;&#39;，&#39;&#125;&#39;，&#39;[&#39;，&#39;]&#39; 的字符串，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
注意空字符串可被认为是有效字符串。

示例 1:

输入: &quot;()&quot;
输出: true
示例 2:

输入: &quot;()[]&#123;&#125;&quot;
输出: true
示例 3:

输入: &quot;(]&quot;
输出: false
示例 4:

输入: &quot;([)]&quot;
输出: false
示例 5:

输入: &quot;&#123;[]&#125;&quot;
输出: true</code></pre>
<p>题解一：</p>
<p>时间复杂度：O(N)。遍历了一遍字符串。<br>空间复杂度：O(N)。最坏情况下，假如输入是 (((((((，栈的大小将是输入字符串的长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isValid(self, s: str) -&gt; bool:</span><br><span class="line">        dict &#x3D; &#123;&#39;)&#39;:&#39;(&#39;,&#39;]&#39;:&#39;[&#39;,&#39;&#125;&#39;:&#39;&#123;&#39;&#125;</span><br><span class="line">        stack&#x3D;[]</span><br><span class="line">        for i in s:</span><br><span class="line">            if stack and i in dict:</span><br><span class="line">                if stack[-1] &#x3D;&#x3D; dict[i]:</span><br><span class="line">                    stack.pop()</span><br><span class="line">                else:</span><br><span class="line">                    return False</span><br><span class="line">            else:</span><br><span class="line">                stack.append(i)</span><br><span class="line">        return not stack</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isValid(self, s: str) -&gt; bool:</span><br><span class="line">        dicts&#x3D;&#123;&#39;(&#39;:1,&#39;)&#39;:-1,&#39;&#123;&#39;:2,&#39;&#125;&#39;:-2,&#39;[&#39;:3,&#39;]&#39;:-3&#125;</span><br><span class="line">        list&#x3D;[]</span><br><span class="line">        for i in s:</span><br><span class="line">            if len(list)&#x3D;&#x3D;0:</span><br><span class="line">                list.append(i)</span><br><span class="line">            elif dicts[i]+dicts[list[-1]]&#x3D;&#x3D;0:</span><br><span class="line">                del list[-1]</span><br><span class="line">            else:</span><br><span class="line">                list.append(i)</span><br><span class="line">        return len(list)&#x3D;&#x3D;0</span><br></pre></td></tr></table></figure>

<h3 id="38-外观数列"><a href="#38-外观数列" class="headerlink" title="38. 外观数列"></a>38. 外观数列</h3><pre><code>链接：https://leetcode-cn.com/problems/count-and-say/

「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：

1.     1
2.     11
3.     21
4.     1211
5.     111221
1 被读作  &quot;one 1&quot;  (&quot;一个一&quot;) , 即 11。
11 被读作 &quot;two 1s&quot; (&quot;两个一&quot;）, 即 21。
21 被读作 &quot;one 2&quot;,  &quot;one 1&quot; （&quot;一个二&quot; ,  &quot;一个一&quot;) , 即 1211。

给定一个正整数 n（1 ≤ n ≤ 30），输出外观数列的第 n 项。

注意：整数序列中的每一项将表示为一个字符串。

示例 1:

输入: 1
输出: &quot;1&quot;
解释：这是一个基本样例。
示例 2:

输入: 4
输出: &quot;1211&quot;
解释：当 n = 3 时，序列是 &quot;21&quot;，其中我们有 &quot;2&quot; 和 &quot;1&quot; 两组，&quot;2&quot; 可以读作 &quot;12&quot;，也就是出现频次 = 1 而 值 = 2；类似 &quot;1&quot; 可以读作 &quot;11&quot;。所以答案是 &quot;12&quot; 和 &quot;11&quot; 组合在一起，也就是 &quot;1211&quot;。</code></pre>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/106149461">https://zhuanlan.zhihu.com/p/106149461</a></p>
<p>题解一（递归）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def countAndSay(self, n: int) -&gt; str:</span><br><span class="line">        # 初始条件</span><br><span class="line">        if n&#x3D;&#x3D;1:</span><br><span class="line">            return &#39;1&#39;</span><br><span class="line">        print(&#39;调用前：&#39;,n)</span><br><span class="line">        pre&#x3D;self.countAndSay(n-1) # 得到上一行的字符串</span><br><span class="line">        print(&#39;调用后：&#39;,n,pre)</span><br><span class="line">        res&#x3D;&#39;&#39;</span><br><span class="line">        count&#x3D;1</span><br><span class="line">        length&#x3D;len(pre)</span><br><span class="line">        for i in range(1,length):</span><br><span class="line">            if pre[i] !&#x3D; pre[i-1]:</span><br><span class="line">                res+&#x3D;str(count)+pre[i-1]</span><br><span class="line">                count&#x3D;1</span><br><span class="line">            else:</span><br><span class="line">                count+&#x3D;1</span><br><span class="line">        print(pre[length-1])</span><br><span class="line">        res+&#x3D;str(count)+pre[length-1]</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<pre><code>调用前： 5
调用前： 4
调用前： 3
调用前： 2
调用后： 2 1
1
调用后： 3 11
1
调用后： 4 21
1
调用后： 5 1211
1</code></pre>
<p>题解二（迭代）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def countAndSay(self, n: int) -&gt; str:</span><br><span class="line">        res&#x3D;&#39;1&#39;</span><br><span class="line">        while n-1&gt;0:</span><br><span class="line">            tmp&#x3D;&#39;&#39;</span><br><span class="line">            pre&#x3D;res[0]</span><br><span class="line">            count&#x3D;0 # count&#x3D;0</span><br><span class="line">            for i in range(len(res)): # 从0开始</span><br><span class="line">                if pre&#x3D;&#x3D;res[i]:</span><br><span class="line">                    count+&#x3D;1</span><br><span class="line">                else:</span><br><span class="line">                    tmp+&#x3D;str(count)+pre</span><br><span class="line">                    pre&#x3D;res[i]</span><br><span class="line">                    count&#x3D;1</span><br><span class="line">            tmp+&#x3D;str(count)+pre</span><br><span class="line">            res&#x3D;tmp</span><br><span class="line">            n-&#x3D;1</span><br><span class="line">        return res</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def countAndSay(self, n: int) -&gt; str:</span><br><span class="line">        res&#x3D;&#39;1&#39;</span><br><span class="line">        for i in range(n-1,0,-1):</span><br><span class="line">            tmp&#x3D;&#39;&#39;</span><br><span class="line">            pre&#x3D;res[0]</span><br><span class="line">            count&#x3D;1 # count&#x3D;1</span><br><span class="line">            for j in range(1,len(res)): # 从1开始</span><br><span class="line">                if pre&#x3D;&#x3D;res[j]:</span><br><span class="line">                    count+&#x3D;1</span><br><span class="line">                else:</span><br><span class="line">                    tmp+&#x3D;str(count)+pre</span><br><span class="line">                    pre&#x3D;res[j]</span><br><span class="line">                    count&#x3D;1</span><br><span class="line">            tmp+&#x3D;str(count)+pre</span><br><span class="line">            res&#x3D;tmp</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>


<h3 id="58-最后一个单词的长度"><a href="#58-最后一个单词的长度" class="headerlink" title="58. 最后一个单词的长度"></a>58. 最后一个单词的长度</h3><pre><code>链接：https://leetcode-cn.com/problems/length-of-last-word/

给定一个仅包含大小写字母和空格 &#39; &#39; 的字符串 s，返回其最后一个单词的长度。如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。

如果不存在最后一个单词，请返回 0 。

说明：一个单词是指仅由字母组成、不包含任何空格字符的 最大子字符串。

示例:

输入: &quot;Hello World&quot;
输出: 5</code></pre>
<p>题解一（内置函数）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def lengthOfLastWord(self, s: str) -&gt; int:</span><br><span class="line">        return len(s.rstrip().split(&#39; &#39;)[-1])</span><br></pre></td></tr></table></figure>

<p>题解二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def lengthOfLastWord(self, s: str) -&gt; int:</span><br><span class="line">        end&#x3D;len(s)-1</span><br><span class="line">        while end&gt;&#x3D;0 and s[end]&#x3D;&#x3D;&#39; &#39;:</span><br><span class="line">            end-&#x3D;1</span><br><span class="line">        if end &lt; 0: return 0</span><br><span class="line">        start&#x3D;end</span><br><span class="line">        while start &gt;&#x3D;0 and s[start] !&#x3D;&#39; &#39;:</span><br><span class="line">            start-&#x3D;1</span><br><span class="line">        return end-start</span><br></pre></td></tr></table></figure>

<h3 id="67-二进制求和"><a href="#67-二进制求和" class="headerlink" title="67. 二进制求和"></a>67. 二进制求和</h3><pre><code>给你两个二进制字符串，返回它们的和（用二进制表示）。

输入为 非空 字符串且只包含数字 1 和 0。

示例 1:

输入: a = &quot;11&quot;, b = &quot;1&quot;
输出: &quot;100&quot;
示例 2:

输入: a = &quot;1010&quot;, b = &quot;1011&quot;
输出: &quot;10101&quot;


提示：

每个字符串仅由字符 &#39;0&#39; 或 &#39;1&#39; 组成。
1 &lt;= a.length, b.length &lt;= 10^4
字符串如果不是 &quot;0&quot; ，就都不含前导零。</code></pre>
<p>题解一（内置函数）:</p>
<p>时间复杂度为 O(N+M)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def addBinary(self, a: str, b: str) -&gt; str:</span><br><span class="line">        return bin(int(a,2)+int(b,2))[2:]</span><br></pre></td></tr></table></figure>

<p>题解二(逐位运算)：</p>
<p>时间复杂度：O(max(N,M))，其中 N 和 M 是输入字符串 a 和 b 的长度。</p>
<p>空间复杂度：O(max(N,M))，存储求和结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def addBinary(self, a: str, b: str) -&gt; str:</span><br><span class="line">        n&#x3D;max(len(a),len(b))</span><br><span class="line">        a,b&#x3D;a.zfill(n),b.zfill(n)</span><br><span class="line">        carry&#x3D;0</span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        for i in range(n-1,-1,-1):</span><br><span class="line">            if a[i]&#x3D;&#x3D;&#39;1&#39;:</span><br><span class="line">                carry+&#x3D;1</span><br><span class="line">            if b[i]&#x3D;&#x3D;&#39;1&#39;:</span><br><span class="line">                carry+&#x3D;1</span><br><span class="line">            if carry%2&#x3D;&#x3D;1:</span><br><span class="line">                res.append(&#39;1&#39;)</span><br><span class="line">            else:</span><br><span class="line">                res.append(&#39;0&#39;)</span><br><span class="line"></span><br><span class="line">            carry&#x2F;&#x2F;&#x3D;2</span><br><span class="line"></span><br><span class="line">        if carry&#x3D;&#x3D;1:</span><br><span class="line">            res.append(&#39;1&#39;)</span><br><span class="line">        res.reverse()</span><br><span class="line">        return &#39;&#39;.join(res)</span><br></pre></td></tr></table></figure>

<p>zfill()方法语法：<br>    str.zfill(width)<br>    参数:<br>        width – 指定字符串的长度。原字符串右对齐，前面填充0。<br>    返回值:<br>        返回指定长度的字符串。</p>
<p>题解三（位操作）：</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/bit.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/bit.png"></p>
<p>算法:</p>
<pre><code>把 a 和 b 转换成整型数字 x 和 y，x 保存结果，y 保存进位。

当进位不为 0：y != 0：

    计算当前 x 和 y 的无进位相加结果：answer = x^y。

    计算当前 x 和 y 的进位：carry = (x &amp; y) &lt;&lt; 1。

    完成本次循环，更新 x = answer，y = carry。

返回 xx 的二进制形式。</code></pre>
<p>时间复杂度：O(N+M)，其中 N 和 M 是输入字符串 a 和 b 的长度。</p>
<p>空间复杂度：O(max(N,M))，存储计算结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def addBinary(self, a: str, b: str) -&gt; str:</span><br><span class="line">        x,y&#x3D;int(a,2),int(b,2)</span><br><span class="line">        while y:</span><br><span class="line">            res&#x3D;x^y</span><br><span class="line">            carry&#x3D;(x &amp; y) &lt;&lt; 1</span><br><span class="line">            x,y&#x3D;res,carry</span><br><span class="line">        return bin(x)[2:]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def addBinary(self, a, b) -&gt; str:</span><br><span class="line">        x, y &#x3D; int(a, 2), int(b, 2)</span><br><span class="line">        while y:</span><br><span class="line">            x, y &#x3D; x ^ y, (x &amp; y) &lt;&lt; 1</span><br><span class="line">        return bin(x)[2:]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125.验证回文串"></a>125.验证回文串</h3><pre><code>链接：https://leetcode-cn.com/problems/valid-palindrome/

给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

说明：本题中，我们将空字符串定义为有效的回文串。

示例 1:

输入: &quot;A man, a plan, a canal: Panama&quot;
输出: true
示例 2:

输入: &quot;race a car&quot;
输出: false</code></pre>
<p>题解一（双指针）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isPalindrome(self, s: str) -&gt; bool:</span><br><span class="line">        left,right&#x3D;0,len(s)-1</span><br><span class="line">        while left&lt;right:</span><br><span class="line">            while left&lt;len(s) and not s[left].isalnum():</span><br><span class="line">                left+&#x3D;1</span><br><span class="line">            while right &gt;-1 and not s[right].isalnum():</span><br><span class="line">                right-&#x3D;1</span><br><span class="line">            if left&gt;right:</span><br><span class="line">                return True</span><br><span class="line">            if s[left].upper() !&#x3D; s[right].upper():</span><br><span class="line">                return False</span><br><span class="line">            else:</span><br><span class="line">                left+&#x3D;1</span><br><span class="line">                right-&#x3D;1</span><br><span class="line">        return True</span><br></pre></td></tr></table></figure>

<p>isalnum():检测字符串是否由字母和数字组成。</p>
<p>题解二（正则）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isPalindrome(self, s: str) -&gt; bool:</span><br><span class="line">        import re</span><br><span class="line">        p&#x3D;&#39;&#39;.join(re.findall(r&#39;[a-zA-Z0-9+]&#39;,s))</span><br><span class="line">        p&#x3D;p.lower()</span><br><span class="line">        return True if p&#x3D;&#x3D;p[::-1] else False</span><br></pre></td></tr></table></figure>

<p>题解三（内置函数）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isPalindrome(self, s: str) -&gt; bool:</span><br><span class="line">        s &#x3D; [*filter(str.isalnum, s.lower())]</span><br><span class="line">        return s &#x3D;&#x3D; s[::-1]</span><br></pre></td></tr></table></figure>

<h3 id="168-Excel表列名称"><a href="#168-Excel表列名称" class="headerlink" title="168.Excel表列名称"></a>168.Excel表列名称</h3><pre><code>链接：https://leetcode-cn.com/problems/excel-sheet-column-title/

给定一个正整数，返回它在 Excel 表中相对应的列名称。

例如，

    1 -&gt; A
    2 -&gt; B
    3 -&gt; C
    ...
    26 -&gt; Z
    27 -&gt; AA
    28 -&gt; AB 
    ...
示例 1:

输入: 1
输出: &quot;A&quot;
示例 2:

输入: 28
输出: &quot;AB&quot;
示例 3:

输入: 701
输出: &quot;ZY&quot;</code></pre>
<p>题解一（转26进制）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def convertToTitle(self, n: int) -&gt; str:</span><br><span class="line">        res&#x3D;&#39;&#39;</span><br><span class="line">        while n:</span><br><span class="line">            n,y&#x3D;divmod(n,26)</span><br><span class="line">            if y&#x3D;&#x3D;0:</span><br><span class="line">                n-&#x3D;1</span><br><span class="line">                y&#x3D;26</span><br><span class="line">            res&#x3D;chr(y+64)+res</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def convertToTitle(self, n: int) -&gt; str:</span><br><span class="line">        res&#x3D;&#39;&#39;</span><br><span class="line">        while n:</span><br><span class="line">            n-&#x3D;1</span><br><span class="line">            n,y&#x3D;divmod(n,26)</span><br><span class="line">            res&#x3D;chr(y+65)+res</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<p>题解二（递归）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def convertToTitle(self, n: int) -&gt; str:</span><br><span class="line">        if n&#x3D;&#x3D;0:</span><br><span class="line">            return &#39;&#39;</span><br><span class="line">        else:</span><br><span class="line">            return self.convertToTitle((n-1)&#x2F;&#x2F;26) + chr((n-1) % 26 + 65)</span><br></pre></td></tr></table></figure>

<h3 id="171-Excel表列序号"><a href="#171-Excel表列序号" class="headerlink" title="171.Excel表列序号"></a>171.Excel表列序号</h3><pre><code>链接：https://leetcode-cn.com/problems/excel-sheet-column-number/

给定一个Excel表格中的列名称，返回其相应的列序号。

例如，

    A -&gt; 1
    B -&gt; 2
    C -&gt; 3
    ...
    Z -&gt; 26
    AA -&gt; 27
    AB -&gt; 28 
    ...
示例 1:

输入: &quot;A&quot;
输出: 1
示例 2:

输入: &quot;AB&quot;
输出: 28
示例 3:

输入: &quot;ZY&quot;
输出: 701</code></pre>
<p>题解一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def titleToNumber(self, s: str) -&gt; int: </span><br><span class="line">        res&#x3D;0</span><br><span class="line">        for each in s:</span><br><span class="line">            num&#x3D;(ord(each)-65)+1</span><br><span class="line">            res&#x3D;res*26+num</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344.反转字符串"></a>344.反转字符串</h3><pre><code>链接：https://leetcode-cn.com/problems/reverse-string/

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。

示例 1：

输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]
输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]
示例 2：

输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]
输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</code></pre>
<p>字符串逆序：</p>
<p>方法一：利用字符串的切片来实现逆序</p>
<pre><code>def reverse1(str):
    return str[::-1]</code></pre>
<p>方法二：将字符串转换为列表后再使用reverse()</p>
<pre><code>def reverse2(str):
    str_list=list(str)
    str_list.reverse()  # 列表翻转
    return &#39;&#39;.join(str_list) # 将列表转换为字符串

def reverse2(str):
    str_list=[]
    for each in str:
        str_list.append(each)
    str_list.reverse()
    return &#39;&#39;.join(str_list)</code></pre>
<p>方法三：新建列表，从后往前添加元素</p>
<pre><code>def reverse3(str):
    str_list=[]
    for i in range(len(str)-1,-1,-1):
        str_list.append(str[i])
    return &#39;&#39;.join(str_list)    </code></pre>
<p>方法四：递归</p>
<pre><code>def reverse4(str):
    if len(str)&lt;=1:
        return str
    return str[-1]+reverse4(str[:-1])</code></pre>
<p>方法五：借助collections模块extendleft()</p>
<pre><code>import collections

def reverse5(str):
    deque1 = collections.deque(str)
    deque2=collections.deque()
    for char in deque1:
        deque2.extendleft(char)
    return &#39;&#39;.join(deque2)</code></pre>
<p>方法六：swap交换操作，以中间为基准，交换对称位置的字符</p>
<pre><code>def reverse5(str):
str_list = list(str)
if len(str_list) == 0 or len(str_list) == 1:
    return str
i = 0
length = len(str_list)
while i &lt; length / 2:
    str_list[i], str_list[length - i - 1] = str_list[length - i - 1], str_list[i]
    i += 1
return &#39;&#39;.join(str_list)</code></pre>
<p>题解一（内置函数）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reverseString(self, s):</span><br><span class="line">        s.reverse()</span><br></pre></td></tr></table></figure>

<p>题解二（递归）：</p>
<p>时间复杂度：O(N)。执行了 N/2 次的交换。<br>空间复杂度：O(N)，递归过程中使用的堆栈空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reverseString(self, s: List[str]) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Do not return anything, modify s in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        def helper(left,right):</span><br><span class="line">            if left&lt;right:</span><br><span class="line">                s[left],s[right]&#x3D;s[right],s[left]</span><br><span class="line">                helper(left+1,right-1)</span><br><span class="line">        helper(0,len(s)-1)</span><br></pre></td></tr></table></figure>

<p>题解二（双指针）:</p>
<p>时间复杂度：O(N)。执行了 N/2 次的交换。<br>空间复杂度：O(1)，只使用了常数级空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reverseString(self, s: List[str]) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Do not return anything, modify s in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        left,right&#x3D;0,len(s)-1</span><br><span class="line">        while left&lt;right:</span><br><span class="line">            s[left],s[right]&#x3D;s[right],s[left]</span><br><span class="line">            left+&#x3D;1</span><br><span class="line">            right-&#x3D;1</span><br><span class="line">        return s</span><br></pre></td></tr></table></figure>

<h3 id="345-反转字符串中的元音字母"><a href="#345-反转字符串中的元音字母" class="headerlink" title="345. 反转字符串中的元音字母"></a>345. 反转字符串中的元音字母</h3><pre><code>链接：https://leetcode-cn.com/problems/reverse-vowels-of-a-string/

编写一个函数，以字符串作为输入，反转该字符串中的元音字母。

示例 1:

输入: &quot;hello&quot;
输出: &quot;holle&quot;
示例 2:

输入: &quot;leetcode&quot;
输出: &quot;leotcede&quot;</code></pre>
<p>题解一（栈）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reverseVowels(self, s: str) -&gt; str:</span><br><span class="line">        stack&#x3D;[&#39;a&#39;,&#39;e&#39;,&#39;i&#39;,&#39;o&#39;,&#39;u&#39;,&#39;A&#39;,&#39;E&#39;,&#39;I&#39;,&#39;O&#39;,&#39;U&#39;]</span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        tmp&#x3D;[i for i in s if i in stack]</span><br><span class="line">        for i in s:</span><br><span class="line">            if i not in stack:</span><br><span class="line">                res.append(i)</span><br><span class="line">            else:</span><br><span class="line">                res.append(tmp.pop())</span><br><span class="line">        return &#39;&#39;.join(res)</span><br></pre></td></tr></table></figure>

<p>题解二（双指针）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reverseVowels(self, s: str) -&gt; str:</span><br><span class="line">        if not s or len(s)&#x3D;&#x3D;1:</span><br><span class="line">            return s</span><br><span class="line">        stack&#x3D;[&#39;a&#39;,&#39;e&#39;,&#39;i&#39;,&#39;o&#39;,&#39;u&#39;,&#39;A&#39;,&#39;E&#39;,&#39;I&#39;,&#39;O&#39;,&#39;U&#39;]</span><br><span class="line">        s&#x3D;list(s)</span><br><span class="line">        left,right&#x3D;0,len(s)-1</span><br><span class="line">        while left&lt;right:</span><br><span class="line">            if s[left] not in stack:</span><br><span class="line">                left+&#x3D;1</span><br><span class="line">            if s[right] not in stack:</span><br><span class="line">                right-&#x3D;1</span><br><span class="line">            if s[left] in stack and s[right] in stack:</span><br><span class="line">                s[left],s[right]&#x3D;s[right],s[left]</span><br><span class="line">                left+&#x3D;1</span><br><span class="line">                right-&#x3D;1</span><br><span class="line">        return &#39;&#39;.join(s)</span><br></pre></td></tr></table></figure>

<h3 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a>383. 赎金信</h3><pre><code>链接：https://leetcode-cn.com/problems/ransom-note/

给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。

(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。) 

注意：

你可以假设两个字符串均只含有小写字母。

canConstruct(&quot;a&quot;, &quot;b&quot;) -&gt; false
canConstruct(&quot;aa&quot;, &quot;ab&quot;) -&gt; false
canConstruct(&quot;aa&quot;, &quot;aab&quot;) -&gt; true</code></pre>
<p>题解一（Counter）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def canConstruct(self, ransomNote: str, magazine: str) -&gt; bool:</span><br><span class="line">        from collections import Counter</span><br><span class="line">        r&#x3D;Counter(ransomNote)</span><br><span class="line">        m&#x3D;Counter(magazine)</span><br><span class="line">        if not r-m:</span><br><span class="line">            return True</span><br><span class="line">        else:</span><br><span class="line">            return False</span><br></pre></td></tr></table></figure>

<p>题解二(双指针)：</p>
<p>时间复杂度为O(nlog(n)+mlog(m))<br>空间复杂度为O(m + n)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def canConstruct(self, ransomNote: str, magazine: str) -&gt; bool:</span><br><span class="line">        sorted(ransomNote)</span><br><span class="line">        sorted(magazine)</span><br><span class="line">        i,j&#x3D;0,0</span><br><span class="line">        while i&lt;len(ransomNote) and j&lt;len(magazine):</span><br><span class="line">            if ransomNote[i]&gt;magazine[j]:</span><br><span class="line">                j+&#x3D;1</span><br><span class="line">            elif ransomNote[i] &lt; magazine[j]:</span><br><span class="line">                return False</span><br><span class="line">            else:</span><br><span class="line">                i+&#x3D;1</span><br><span class="line">                j+&#x3D;1</span><br><span class="line">        return i&#x3D;&#x3D;len(ransomNote)</span><br></pre></td></tr></table></figure>

<p>题解三（hash）：</p>
<p>时间复杂度: O(N) - N（遍历magazine） + 1（字典检索为O(1)）<br>空间复杂度: O(N)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def canConstruct(self, ransomNote: str, magazine: str) -&gt; bool:</span><br><span class="line">        hash&#x3D;&#123;&#125;</span><br><span class="line">        for i in magazine:</span><br><span class="line">            if i in hash:</span><br><span class="line">                hash[i]+&#x3D;1</span><br><span class="line">            else:</span><br><span class="line">                hash[i]&#x3D;1</span><br><span class="line">        for i in ransomNote:</span><br><span class="line">            if i in hash and hash[i]&gt;0:</span><br><span class="line">                hash[i]-&#x3D;1</span><br><span class="line">            else:</span><br><span class="line">                return False</span><br><span class="line">        return True</span><br></pre></td></tr></table></figure>

<p>题解四（暴力）：</p>
<p>时间复杂度: O(N^2) - N（遍历ransomNote） * N（replace最糟糕的情况是遍历整个magazine）<br>空间复杂度: O(1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def canConstruct(self, ransomNote: str, magazine: str) -&gt; bool:</span><br><span class="line">        for i in ransomNote:</span><br><span class="line">            if i in magazine:</span><br><span class="line">                magazine&#x3D;magazine.replace(i,&#39;&#39;,1) # 可选字符串, 替换不超过 max 次</span><br><span class="line">            else:</span><br><span class="line">                return False</span><br><span class="line">        return True</span><br></pre></td></tr></table></figure>

<h3 id="387-字符串中的第一个唯一字符"><a href="#387-字符串中的第一个唯一字符" class="headerlink" title="387. 字符串中的第一个唯一字符"></a>387. 字符串中的第一个唯一字符</h3><pre><code>链接：https://leetcode-cn.com/problems/first-unique-character-in-a-string/

给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。

案例:

s = &quot;leetcode&quot;
返回 0.

s = &quot;loveleetcode&quot;,
返回 2.


注意事项：您可以假定该字符串只包含小写字母。</code></pre>
<p>题解一（切片）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def firstUniqChar(self, s: str) -&gt; int:</span><br><span class="line">        if len(s)&#x3D;&#x3D;1:</span><br><span class="line">            return 0</span><br><span class="line">        for k in range(len(s)):</span><br><span class="line">            if (s[k] not in s[k+1:]) and (s[k] not in s[:k]):</span><br><span class="line">                return k</span><br><span class="line">        return -1</span><br></pre></td></tr></table></figure>

<p>题解二(内置函数)：</p>
<p>时间复杂度： O(N)，只遍历了两遍字符串，同时散列表中查找操作是常数时间复杂度的。<br>空间复杂度： O(N)，用到了散列表来存储字符串中每个元素出现的次数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def firstUniqChar(self, s: str) -&gt; int:</span><br><span class="line">        from collections import Counter</span><br><span class="line">        count&#x3D;Counter(s)</span><br><span class="line">        for k,v in enumerate(s):</span><br><span class="line">            if count[v]&#x3D;&#x3D;1:</span><br><span class="line">                return k</span><br><span class="line">        return -1</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import collections</span><br><span class="line">class Solution:</span><br><span class="line">    def firstUniqChar(self, s: str) -&gt; int:</span><br><span class="line">        for i,j in collections.Counter(s).items():</span><br><span class="line">            if j&#x3D;&#x3D;1:return s.index(i)</span><br><span class="line">        return -1</span><br></pre></td></tr></table></figure>

<p>题解三（find）:</p>
<p>1.证明字母只出现了一次<br>如果一个字符串中的字符在字符串中从左边搜索和从右边搜索得到的index一样，那就证明只有一个了<br>2.循环每次是从第一个开始的，保证了执行的顺序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def firstUniqChar(self, s):</span><br><span class="line">        for i in s:</span><br><span class="line">            if s.find(i)&#x3D;&#x3D; s.rfind(i):</span><br><span class="line">                return s.find(i)</span><br><span class="line">        return -1</span><br></pre></td></tr></table></figure>

<h3 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415. 字符串相加"></a>415. 字符串相加</h3><pre><code>链接：https://leetcode-cn.com/problems/add-strings/

给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。

注意：

num1 和num2 的长度都小于 5100.
num1 和num2 都只包含数字 0-9.
num1 和num2 都不包含任何前导零。
你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。</code></pre>
<p>题解一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def addStrings(self, num1: str, num2: str) -&gt; str:</span><br><span class="line">        n&#x3D;max(len(num1),len(num2))</span><br><span class="line">        n1&#x3D;num1.zfill(n)</span><br><span class="line">        n2&#x3D;num2.zfill(n)</span><br><span class="line">        print(n1,n2)</span><br><span class="line">        carry&#x3D;0</span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        for i in range(n-1,-1,-1):</span><br><span class="line">            tmp&#x3D;int(n1[i])+int(n2[i])</span><br><span class="line">            carry+&#x3D;tmp</span><br><span class="line">            res.append(carry%10)</span><br><span class="line">            carry&#x2F;&#x2F;&#x3D;10</span><br><span class="line">        if carry&#x3D;&#x3D;1:</span><br><span class="line">            res.append(1)</span><br><span class="line">        res.reverse()</span><br><span class="line">        return &#39;&#39;.join([str(i) for i in res])</span><br></pre></td></tr></table></figure>

<p>题解二（双指针）:</p>
<p>时间复杂度:O(max(M,N))：其中 M，N 为 2 数字长度，按位遍历一遍数字（以较长的数字为准）；<br>空间复杂度:O(1),指针与变量使用常数大小空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def addStrings(self, num1: str, num2: str) -&gt; str:</span><br><span class="line">        res &#x3D; &quot;&quot;</span><br><span class="line">        i, j, carry &#x3D; len(num1) - 1, len(num2) - 1, 0</span><br><span class="line">        while i &gt;&#x3D; 0 or j &gt;&#x3D; 0:</span><br><span class="line">            n1 &#x3D; int(num1[i]) if i &gt;&#x3D; 0 else 0</span><br><span class="line">            n2 &#x3D; int(num2[j]) if j &gt;&#x3D; 0 else 0</span><br><span class="line">            tmp &#x3D; n1 + n2 + carry</span><br><span class="line">            carry &#x3D; tmp &#x2F;&#x2F; 10</span><br><span class="line">            res &#x3D; str(tmp % 10) + res</span><br><span class="line">            i, j &#x3D; i - 1, j - 1</span><br><span class="line">        return &quot;1&quot; + res if carry else res</span><br></pre></td></tr></table></figure>

<h3 id="434-字符串中的单词数"><a href="#434-字符串中的单词数" class="headerlink" title="434. 字符串中的单词数"></a>434. 字符串中的单词数</h3><pre><code>链接：https://leetcode-cn.com/problems/number-of-segments-in-a-string/

统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。

请注意，你可以假定字符串里不包括任何不可打印的字符。

示例:

输入: &quot;Hello, my name is John&quot;
输出: 5
解释: 这里的单词是指连续的不是空格的字符，所以 &quot;Hello,&quot; 算作 1 个单词。</code></pre>
<p>题解一（split）:</p>
<p>时间复杂度 : O(n)。<br>这里用到的内置函数（无论是 Java 还是 Python）的时间复杂度或为 O(n)，或为 O(1) ，故整个算法可以在线性复杂度内完成。</p>
<p>空间复杂度 : O(n)。<br>split 函数 (不管哪种语言) 返回长度为 O(n) 的数组/列表，故算法使用线性的额外空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def countSegments(self, s: str) -&gt; int:</span><br><span class="line">        if not s:</span><br><span class="line">            return 0</span><br><span class="line">        return len(s.split(&#39; &#39;)) # 这段代码是错误的，并不能解决连续过个空格的case</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def countSegments(self, s: str) -&gt; int:</span><br><span class="line">        return len(s.split())</span><br></pre></td></tr></table></figure>

<p>区别：</p>
<pre><code>split()的时候，多个空格当成一个空格；
split(&#39; &#39;)的时候，多个空格也要分割，会分割出来空。</code></pre>
<p>题解二：</p>
<p>时间复杂度 : O(n)，对每个下标进行常数时间的检测。</p>
<p>空间复杂度 : O(1)，只使用了额外的几个整数，因此使用的空间为常数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def countSegments(self, s: str) -&gt; int:</span><br><span class="line">        count&#x3D;0</span><br><span class="line">        for i in range(len(s)):</span><br><span class="line">            if s[i] !&#x3D; &#39; &#39; and (s[i-1] &#x3D;&#x3D;&#39; &#39; or i&#x3D;&#x3D;0 ):</span><br><span class="line">                print(s[i])</span><br><span class="line">                count+&#x3D;1</span><br><span class="line">        return count </span><br></pre></td></tr></table></figure>

<pre><code>### 520. 检测大写字母
链接：https://leetcode-cn.com/problems/detect-capital/

给定一个单词，你需要判断单词的大写使用是否正确。

我们定义，在以下情况时，单词的大写用法是正确的：

全部字母都是大写，比如&quot;USA&quot;。
单词中所有字母都不是大写，比如&quot;leetcode&quot;。
如果单词不只含有一个字母，只有首字母大写， 比如 &quot;Google&quot;。
否则，我们定义这个单词没有正确使用大写字母。

示例 1:

输入: &quot;USA&quot;
输出: True
示例 2:

输入: &quot;FlaG&quot;
输出: False
注意: 输入是由大写和小写拉丁字母组成的非空单词。</code></pre>
<p>题解一（内置函数）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def detectCapitalUse(self, word: str) -&gt; bool:</span><br><span class="line">        if word.isupper() or word.islower() or word.istitle():</span><br><span class="line">            return True</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def detectCapitalUse(self, word: str) -&gt; bool:</span><br><span class="line">        return word.isupper() or word.islower() or word.istitle()</span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<p>题解二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def detectCapitalUse(self, word: str) -&gt; bool:</span><br><span class="line">        c1&#x3D;0</span><br><span class="line">        c2&#x3D;0</span><br><span class="line">        for i in word:</span><br><span class="line">            if (i&gt;&#x3D;&#39;a&#39;):</span><br><span class="line">                c1+&#x3D;1</span><br><span class="line">            else:</span><br><span class="line">                c2+&#x3D;1</span><br><span class="line">        if (c1&#x3D;&#x3D;len(word)) | (c2&#x3D;&#x3D;len(word)):</span><br><span class="line">            return True</span><br><span class="line">                              </span><br><span class="line">        return ((c2&#x3D;&#x3D;1) &amp; (word[0] &lt; &#39;a&#39; ))</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/LeetCode/" rel="tag"># LeetCode</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/LeetCode-2-%E6%A0%88/" rel="prev" title="LeetCode-2-栈">
      <i class="fa fa-chevron-left"></i> LeetCode-2-栈
    </a></div>
      <div class="post-nav-item">
    <a href="/LeetCode-13-%E6%95%B0%E5%AD%A6/" rel="next" title="LeetCode-13-数学">
      LeetCode-13-数学 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.</span> <span class="nav-text">十二、字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="nav-number">1.1.</span> <span class="nav-text">?5.最长回文子串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97"><span class="nav-number">1.2.</span> <span class="nav-text">12.整数转罗马数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0"><span class="nav-number">1.3.</span> <span class="nav-text">13.罗马数字转整数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#28-%E5%AE%9E%E7%8E%B0-strStr"><span class="nav-number">1.4.</span> <span class="nav-text">28. 实现 strStr()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="nav-number">1.5.</span> <span class="nav-text">20. 有效的括号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#38-%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97"><span class="nav-number">1.6.</span> <span class="nav-text">38. 外观数列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#58-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="nav-number">1.7.</span> <span class="nav-text">58. 最后一个单词的长度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#67-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C"><span class="nav-number">1.8.</span> <span class="nav-text">67. 二进制求和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#125-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="nav-number">1.9.</span> <span class="nav-text">125.验证回文串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#168-Excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0"><span class="nav-number">1.10.</span> <span class="nav-text">168.Excel表列名称</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#171-Excel%E8%A1%A8%E5%88%97%E5%BA%8F%E5%8F%B7"><span class="nav-number">1.11.</span> <span class="nav-text">171.Excel表列序号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.12.</span> <span class="nav-text">344.反转字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#345-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D"><span class="nav-number">1.13.</span> <span class="nav-text">345. 反转字符串中的元音字母</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#383-%E8%B5%8E%E9%87%91%E4%BF%A1"><span class="nav-number">1.14.</span> <span class="nav-text">383. 赎金信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#387-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6"><span class="nav-number">1.15.</span> <span class="nav-text">387. 字符串中的第一个唯一字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#415-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0"><span class="nav-number">1.16.</span> <span class="nav-text">415. 字符串相加</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#434-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0"><span class="nav-number">1.17.</span> <span class="nav-text">434. 字符串中的单词数</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Lilly</p>
  <div class="site-description" itemprop="description">Up in the wind!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">129</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lilly</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
