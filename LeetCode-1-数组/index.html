<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"gongyanli.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="一、数组1.两数之和链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;two-sum&#x2F;  给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。  你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。  示例:  给定 nums &#x3D; [2, 7, 11, 15], target &#x3D;">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode-1-数组">
<meta property="og:url" content="http://gongyanli.com/LeetCode-1-%E6%95%B0%E7%BB%84/index.html">
<meta property="og:site_name" content="茉莉Python">
<meta property="og:description" content="一、数组1.两数之和链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;two-sum&#x2F;  给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。  你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。  示例:  给定 nums &#x3D; [2, 7, 11, 15], target &#x3D;">
<meta property="og:locale">
<meta property="og:image" content="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/z-word.png">
<meta property="og:image" content="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/z-word1.png">
<meta property="og:image" content="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/youdao/water3.jpg">
<meta property="og:image" content="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/newton.png">
<meta property="og:image" content="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/duijiaoxian.png">
<meta property="article:published_time" content="2019-09-26T04:13:05.000Z">
<meta property="article:modified_time" content="2020-09-18T04:41:31.327Z">
<meta property="article:author" content="Lilly">
<meta property="article:tag" content="LeetCode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/z-word.png">

<link rel="canonical" href="http://gongyanli.com/LeetCode-1-%E6%95%B0%E7%BB%84/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>LeetCode-1-数组 | 茉莉Python</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">茉莉Python</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">voidqueens@hotmail.com</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/LeetCode-1-%E6%95%B0%E7%BB%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          LeetCode-1-数组
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-09-26 12:13:05" itemprop="dateCreated datePublished" datetime="2019-09-26T12:13:05+08:00">2019-09-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-18 12:41:31" itemprop="dateModified" datetime="2020-09-18T12:41:31+08:00">2020-09-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="一、数组"><a href="#一、数组" class="headerlink" title="一、数组"></a>一、数组</h2><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h3><pre><code>链接：https://leetcode-cn.com/problems/two-sum/

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

示例:

给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]</code></pre>
<p>题解一|暴力：</p>
<p>最简单的思路就是通过两遍循环直接进行暴力破解，时间复杂度O(n^2)，空间复杂度O(1)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">   def twoSum(self,nums,target):</span><br><span class="line">       for i in range(0,len(nums)):</span><br><span class="line">           for j in range(i+1,len(nums)):</span><br><span class="line">               if nums[j]&#x3D;&#x3D;target-nums[i]:</span><br><span class="line">                   return i,j</span><br></pre></td></tr></table></figure>

<p>题解二|hash：</p>
<p>接着思考如何进行优化，采用hash记录需要的key，遍历的时候找到需要的值。时间复杂度O(n)，空间复杂度O(n)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">   def twoSum(self,nums,target):</span><br><span class="line">       dicts&#x3D;&#123;&#125;</span><br><span class="line">       for i in range(len(nums)):</span><br><span class="line">           tmp&#x3D;nums[i]</span><br><span class="line">           if target-tmp in dicts:</span><br><span class="line">               return (dicts[target-tmp],i)</span><br><span class="line">           dicts[tmp]&#x3D;i</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">   def twoSum(self,nums,target):</span><br><span class="line">       dicts&#x3D;&#123;&#125;</span><br><span class="line">       for i,num in enumerate(nums):</span><br><span class="line">           if num in dicts:</span><br><span class="line">               return [dicts[num],i]</span><br><span class="line">           else:</span><br><span class="line">               dicts[target-num]&#x3D;i</span><br></pre></td></tr></table></figure>

<p>题解三|切片：</p>
<p>判断target-nums[i]是否在nums[i+1:]中，时间复杂度O(n)，空间复杂度O(1)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">   def twoSum(self,nums,target):</span><br><span class="line">       for i in range(len(nums)):</span><br><span class="line">           if target-nums[i] in nums[i+1:]:</span><br><span class="line">               return [i,nums.index(target-nums[i],i+1)]</span><br></pre></td></tr></table></figure>

<p>index()方法语法：list.index(x[, start[, end]])<br>参数:<br>    x– 查找的对象。<br>    start– 可选，查找的起始位置。<br>    end– 可选，查找的结束位置。<br>返回值:该方法返回查找对象的索引位置，如果没有找到对象则抛出异常。</p>
<h3 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h3><pre><code>链接：
https://leetcode-cn.com/problems/add-two-numbers/

给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。

如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

您可以假设除了数字 0 之外，这两个数都不会以 0 开头。

示例：

输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
输出：7 -&gt; 0 -&gt; 8
原因：342 + 465 = 807</code></pre>
<p>题解一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class ListNode:</span><br><span class="line">    def __init__(self,x):</span><br><span class="line">        self.val&#x3D;x</span><br><span class="line">        self.next&#x3D;None</span><br><span class="line">class Solution:</span><br><span class="line">    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:</span><br><span class="line">        if l1 is None:</span><br><span class="line">            return l2</span><br><span class="line">        if l2 is None:</span><br><span class="line">            return l1</span><br><span class="line"></span><br><span class="line">        tmp&#x3D;ListNode(0)</span><br><span class="line">        res&#x3D;tmp</span><br><span class="line">        flag&#x3D;0</span><br><span class="line"></span><br><span class="line">        while l1 or l2:</span><br><span class="line">            tmpSum&#x3D;0</span><br><span class="line">            if l1:</span><br><span class="line">                tmpSum&#x3D;l1.val</span><br><span class="line">                l1&#x3D;l1.next</span><br><span class="line">            if l2:</span><br><span class="line">                tmpSum+&#x3D;l2.val</span><br><span class="line">                l2&#x3D;l2.next</span><br><span class="line">            tmpRes&#x3D;(tmpSum+falg)%10</span><br><span class="line">            flag&#x3D;(tmpSum+flag)&#x2F;&#x2F;10</span><br><span class="line"></span><br><span class="line">            res.next&#x3D;ListNode(tmpRes)</span><br><span class="line">            res&#x3D;res.next # res后移</span><br><span class="line"></span><br><span class="line">            # 这个判断是拿来解决此种情况的：</span><br><span class="line">            # 输入：【5】和【5】</span><br><span class="line">            # 输出：【0,1】</span><br><span class="line">            if flag:</span><br><span class="line">                res.next&#x3D;ListNode(1) # 这里创建了节点，但是没有后移</span><br><span class="line"></span><br><span class="line">        res&#x3D;tmp.next # 把链表初始化的0后移</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:</span><br><span class="line">        res&#x3D;dummy&#x3D;ListNode(-1)</span><br><span class="line">        flag&#x3D;0</span><br><span class="line">        while l1 and l2:</span><br><span class="line">            res.next&#x3D;ListNode(l1.val+l2.val+flag)</span><br><span class="line">            flag&#x3D;res.next.val &#x2F;&#x2F; 10</span><br><span class="line">            res.next.val %&#x3D; 10</span><br><span class="line">            res&#x3D;res.next</span><br><span class="line">            l1&#x3D;l1.next</span><br><span class="line">            l2&#x3D;l2.next</span><br><span class="line">        </span><br><span class="line">        p&#x3D; l1 or l2</span><br><span class="line">        while p:</span><br><span class="line">            res.next&#x3D;ListNode(p.val+flag)</span><br><span class="line">            flag&#x3D;res.next.val &#x2F;&#x2F; 10</span><br><span class="line">            res.next.val %&#x3D; 10</span><br><span class="line">            p&#x3D;p.next</span><br><span class="line">            res&#x3D;res.next</span><br><span class="line">        if flag:</span><br><span class="line">            res.next&#x3D;ListNode(1)</span><br><span class="line">        return dummy.next</span><br></pre></td></tr></table></figure>

<h3 id="？？4-寻找两个有序数组的中位数"><a href="#？？4-寻找两个有序数组的中位数" class="headerlink" title="？？4.寻找两个有序数组的中位数"></a>？？4.寻找两个有序数组的中位数</h3><pre><code>链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays/

给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。

请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。

你可以假设 nums1 和 nums2 不会同时为空。

示例 1:

nums1 = [1, 3]
nums2 = [2]

则中位数是 2.0
示例 2:

nums1 = [1, 2]
nums2 = [3, 4]

则中位数是 (2 + 3)/2 = 2.5</code></pre>
<p>题解一（暴力）：</p>
<h3 id="6-Z字形变换"><a href="#6-Z字形变换" class="headerlink" title="6.Z字形变换"></a>6.Z字形变换</h3><pre><code>链接：https://leetcode-cn.com/problems/zigzag-conversion/

将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。

比如输入字符串为 &quot;LEETCODEISHIRING&quot; 行数为 3 时，排列如下：

L   C   I   R
E T O E S I I G
E   D   H   N
之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&quot;LCIRETOESIIGEDHN&quot;。

请你实现这个将字符串进行指定行数变换的函数：

string convert(string s, int numRows);
示例 1:

输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 3
输出: &quot;LCIRETOESIIGEDHN&quot;
示例 2:

输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 4
输出: &quot;LDREOEIIECIHNTSG&quot;
解释:

L     D     R
E   O E   I I
E C   I H   N
T     S     G</code></pre>
<p>题解一：<br><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/z-word.png"><br><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/z-word1.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def convert(self, s: str, numRows: int) -&gt; str:</span><br><span class="line">        if numRows&lt;2:</span><br><span class="line">            return s</span><br><span class="line">        ans&#x3D;[&#39;&#39; for _ in range(numRows)]</span><br><span class="line">        i,flag&#x3D;0,-1</span><br><span class="line">        for c in s:</span><br><span class="line">            ans[i] +&#x3D; c</span><br><span class="line">            if i&#x3D;&#x3D;0 or i&#x3D;&#x3D;numRows-1:</span><br><span class="line">                flag&#x3D;-flag</span><br><span class="line">            i+&#x3D;flag</span><br><span class="line">        return &#39;&#39;.join(ans)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7.整数反转"></a>7.整数反转</h3><pre><code>链接：https://leetcode-cn.com/problems/reverse-integer/

给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。

示例 1:

输入: 123
输出: 321
示例 2:

输入: -123
输出: -321
示例 3:

输入: 120
输出: 21
注意:

假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31,  2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</code></pre>
<p>题解一：<br>int型的数值范围是 -2147483648～2147483647， 那么如果我们要翻转 1000000009 这个在范围内的数得到 9000000001，而翻转后的数就超过了范围。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reverse(self, x: int) -&gt; int:</span><br><span class="line">        x&#x3D;int(str(x)[::-1]) if x&gt;&#x3D;0 else -int(str((-x)[::-1])) # python3没有数字范围，如果其他语言之间int会造成精度缺失。</span><br><span class="line">        # return x if x&lt;2**31-1 and x&gt;-2**31 else 0</span><br><span class="line">        return x if x&lt;pow(2,31)-1 and x&gt;-pow(2,31) else 0</span><br></pre></td></tr></table></figure>
<p>题解二：<br>    # /:除法<br>    # //:整除<br>    # %：取模</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reverse(self, x):</span><br><span class="line">        flag &#x3D; 1 if x &gt;&#x3D; 0 else -1</span><br><span class="line">        new_x, x &#x3D; 0, abs(x)</span><br><span class="line">        while x:</span><br><span class="line">            new_x &#x3D; 10 * new_x + x % 10</span><br><span class="line">            x &#x2F;&#x2F;&#x3D; 10</span><br><span class="line">        new_x &#x3D; flag * new_x</span><br><span class="line">        return new_x if new_x &lt; 2147483648 and new_x &gt;&#x3D; -2147483648 else 0</span><br></pre></td></tr></table></figure>
<h3 id="8-字符串转换整数-atoi"><a href="#8-字符串转换整数-atoi" class="headerlink" title="8.字符串转换整数(atoi)"></a>8.字符串转换整数(atoi)</h3><pre><code>链接：https://leetcode-cn.com/problems/string-to-integer-atoi/

请你来实现一个 atoi 函数，使其能将字符串转换成整数。

首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。

当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。

该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。

注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。

在任何情况下，若函数不能进行有效的转换时，请返回 0。

说明：

假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。

示例 1:

输入: &quot;42&quot;
输出: 42
示例 2:

输入: &quot;   -42&quot;
输出: -42
解释: 第一个非空白字符为 &#39;-&#39;, 它是一个负号。
     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。
示例 3:

输入: &quot;4193 with words&quot;
输出: 4193
解释: 转换截止于数字 &#39;3&#39; ，因为它的下一个字符不为数字。
示例 4:

输入: &quot;words and 987&quot;
输出: 0
解释: 第一个非空字符是 &#39;w&#39;, 但它不是数字或正、负号。
     因此无法执行有效的转换。
示例 5:

输入: &quot;-91283472332&quot;
输出: -2147483648
解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 </code></pre>
<p>          因此返回 INT_MIN (−231) 。<br>题解一|正则表达式：</p>
<pre><code>^：匹配字符串开头
[\+\-]：代表一个+字符或-字符
?：前面一个字符可有可无
\d：一个数字
+：前面一个字符的一个或多个
\D：一个非数字字符
*：前面一个字符的0个或多个</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def myAtoi(self, str: str) -&gt; int:</span><br><span class="line">        return max(min(int(*re.findall(&#39;^[\+\-]?\d+&#39;,str.lstrip())),2**31-1),-2**31)</span><br><span class="line">        #由于返回的是个列表，解包并且转换成整数</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def myAtoi(self, str: str) -&gt; int:</span><br><span class="line">        # return max(min(int(*re.findall(&#39;^[\+\-]?\d+&#39;,str.lstrip())),2**31-1),-2**31)</span><br><span class="line">        # print(re.findall(&#39;\d&#39;,str.lstrip())) # [&#39;4&#39;, &#39;2&#39;, &#39;4&#39;, &#39;4&#39;]</span><br><span class="line">        # print(re.findall(&#39;\d*&#39;,str.lstrip())) # [&#39;4244&#39;, &#39;&#39;]</span><br><span class="line">        # print(re.findall(&#39;\d+&#39;,str.lstrip())) # [&#39;4244&#39;]</span><br><span class="line">        # print(re.findall(&#39;^[+-]\d+&#39;,str.lstrip())) # [&#39;-4244&#39;]</span><br><span class="line">        # print(re.findall(&#39;^[+-]?\d+&#39;,str.lstrip())) # ?代表前面的+-可有可无。</span><br><span class="line">        # #  re.findall返回的是一个字符串列表，int()数据类型转换不支持列表，用*对列表解包得到字符串。比如[7,8,8]→7,8,8</span><br><span class="line">        # print(int(*re.findall(&#39;^[+-]\d+&#39;,str.lstrip()))) # -4244</span><br><span class="line"></span><br><span class="line">        x&#x3D;int(*re.findall(&#39;^[-+]?\d+&#39;,str.lstrip()))</span><br><span class="line">        if x &gt; pow(2,31)-1:</span><br><span class="line">            return pow(2,31)-1</span><br><span class="line">        elif x &lt; pow(-2,31):</span><br><span class="line">            return pow(-2,31)</span><br><span class="line">        else:</span><br><span class="line">            return x</span><br></pre></td></tr></table></figure>

<p>题解二|逐个强行转int：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def myAtoi(self, str: str) -&gt; int:</span><br><span class="line">        str&#x3D;str.lstrip()</span><br><span class="line"></span><br><span class="line">        if len(str)&#x3D;&#x3D;0:</span><br><span class="line">            return 0</span><br><span class="line">        last&#x3D;0</span><br><span class="line">        i&#x3D;1 if str[0]&#x3D;&#x3D;&#39;+&#39; or str[0]&#x3D;&#x3D;&#39;-&#39; else 0</span><br><span class="line">        #循环，直到无法强转成int，跳出循环</span><br><span class="line">        while i&lt;&#x3D;len(str):</span><br><span class="line">            try:</span><br><span class="line">                last&#x3D;int(str[:i+1]) # int[&#39;aa&#39;]会报错，所以走break</span><br><span class="line">                i+&#x3D;1</span><br><span class="line">            except:</span><br><span class="line">                break</span><br><span class="line">        # 判断数字是否超出范围</span><br><span class="line">        if last&lt;-2**31:</span><br><span class="line">            return -2**31</span><br><span class="line">        if last&gt;2**31-1:</span><br><span class="line">            return 2**31-1</span><br><span class="line">        return last</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<h3 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9.回文数"></a>9.回文数</h3><pre><code>链接：https://leetcode-cn.com/problems/palindrome-number/

判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

示例 1:

输入: 121
输出: true
示例 2:

输入: -121
输出: false
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
示例 3:

输入: 10
输出: false
解释: 从右向左读, 为 01 。因此它不是一个回文数。</code></pre>
<p>题解一|整数转换为字符串:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isPalindrome(self, x: int) -&gt; bool:</span><br><span class="line">        x&#x3D;str(x)</span><br><span class="line">        if x &#x3D;&#x3D; x[::-1]:</span><br><span class="line">            return True</span><br><span class="line">        else:</span><br><span class="line">            return False</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def isPalindrome(self, x) :</span><br><span class="line">        x&#x3D;str(x)</span><br><span class="line">        return x&#x3D;&#x3D;x[::-1]</span><br><span class="line"></span><br><span class="line"># 整数转字符串，通过下标对比确定该整数是否为回文数</span><br><span class="line">class Solution:</span><br><span class="line">    def isPalindrome(self, x) :</span><br><span class="line">        x&#x3D;str(x)</span><br><span class="line">        for i in range(0,int(len(x)&#x2F;2)):</span><br><span class="line">            if x[i] !&#x3D; x[-i-1]:</span><br><span class="line">                return False</span><br><span class="line">        return True</span><br></pre></td></tr></table></figure>
<p>题解二（数字反转）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isPalindrome(self, x) :</span><br><span class="line">        if x&lt;0:</span><br><span class="line">            return False</span><br><span class="line">        m,n&#x3D;x,0</span><br><span class="line"></span><br><span class="line">        while m:</span><br><span class="line">            n&#x3D;n*10+m%10</span><br><span class="line">            m&#x3D;m&#x2F;&#x2F;10</span><br><span class="line">        if x&#x3D;&#x3D;n:</span><br><span class="line">            return True</span><br><span class="line">        else:</span><br><span class="line">            return False</span><br></pre></td></tr></table></figure>
<h3 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11.盛最多水的容器"></a>11.盛最多水的容器</h3><pre><code>链接：https://leetcode-cn.com/problems/container-with-most-water/

给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

说明：你不能倾斜容器，且 n 的值至少为 2。</code></pre>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/youdao/water3.jpg"></p>
<pre><code>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。

示例:

输入: [1,8,6,2,5,4,8,3,7]
输出: 49</code></pre>
<p>思路：<br>    矩阵的面积=矩阵长度 * 矩阵宽度<br>    矩阵长度：两条垂直线的距离<br>    矩阵宽度：两条垂直线中较短一条的长度<br>    面积最大化：两条垂直线的距离越远越好，两条垂直线的最短长度也要越长越好。</p>
<p>解法一|暴力|超时：<br>    在这种情况下，我们将简单地考虑每对可能出现的线段组合并找出这些情况之下的最大面积。<br>    时间复杂度O(n^2)，计算n(n-1)/2种高度组合的面积，空间复杂度O(1)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">不能通过case:[1,1],结果应该为1.</span><br><span class="line">class Solution:</span><br><span class="line">    def maxArea(self, height: List[int]) -&gt; int:</span><br><span class="line">        area&#x3D;0</span><br><span class="line">        for i in range(len(height)):</span><br><span class="line">            for j in range(i+1,len(height)):</span><br><span class="line">                # print(&#39;i&#39;,i,height[i])</span><br><span class="line">                # print(&#39;j&#39;,j,height[j])</span><br><span class="line">                area&#x3D;max(area,min(height[i],height[j])*(j-1)) # j-1为矩阵的长度</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxArea(self, height: List[int]) -&gt; int:</span><br><span class="line">        area&#x3D;0</span><br><span class="line">        for i in range(len(height)-1):</span><br><span class="line">            for j in range(i+1,len(height)):</span><br><span class="line">                # print(&#39;i&#39;,i,height[i])</span><br><span class="line">                # print(&#39;j&#39;,j,height[j])</span><br><span class="line">                area&#x3D;max(area,min(height[i],height[j])*(j-i)) # j-i为矩阵的长度</span><br><span class="line">        return area</span><br></pre></td></tr></table></figure>

<p>解法二|双指针：</p>
<pre><code>设置两个指针 left 和 right，分别指向数组的最左端和最右端。此时，两条垂直线的距离是最远的，若要下一个矩阵面积比当前面积来得大，必须要把 height[left] 和 height[right] 中较短的垂直线往中间移动，看看是否可以找到更长的垂直线。
时间复杂度O(n)，空间复杂度O(1)。</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxArea(self, height: List[int]) -&gt; int:</span><br><span class="line">        left&#x3D;0</span><br><span class="line">        right&#x3D;len(height)-1</span><br><span class="line">        area&#x3D;0</span><br><span class="line"></span><br><span class="line">        while left &lt; right:</span><br><span class="line">            cur&#x3D;min(height[left],height[right]) * (right-left)</span><br><span class="line">            area&#x3D;max(area,cur)</span><br><span class="line"></span><br><span class="line">            if height[left]&lt;height[right]:</span><br><span class="line">                left+&#x3D;1</span><br><span class="line">            else:</span><br><span class="line">                right-&#x3D;1</span><br><span class="line">        return area</span><br></pre></td></tr></table></figure>

<h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h3><pre><code>链接：https://leetcode-cn.com/problems/3sum/

给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。

注意：答案中不可以包含重复的三元组。

例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]</code></pre>
<p>题解一|暴力：<br>    使用三重循环进行暴力破解，时间复杂度为O(n^3)，空间复杂度O(n)</p>
<p>题解二|排序+双指针：</p>
<pre><code>继续思考如何优化，可以通过双指针动态消去无效解来优化效率。
铺垫：先将给定 nums 排序，复杂度为 O(nlogn)
思路：固定 3 个指针中最左（最小）数字的指针 k，双指针 i，j 分设在数组索引 (k, len(nums))两端，通过双指针交替向中间移动，记录对于每个固定指针 k 的所有满足 nums[k] + nums[i] + nums[j] == 0 的 i,j 组合。
时间复杂度O(n^2)，空间复杂度O(n)。</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:</span><br><span class="line">        nums.sort()</span><br><span class="line">        lens&#x3D;len(nums)</span><br><span class="line">        res&#x3D;[]</span><br><span class="line"></span><br><span class="line">        for k in range(lens):</span><br><span class="line">            if k&gt;0 and nums[k]&#x3D;&#x3D;nums[k-1]:</span><br><span class="line">                continue</span><br><span class="line"></span><br><span class="line">            i,j&#x3D;k+1,lens-1</span><br><span class="line">            while i&lt;j:</span><br><span class="line">                sum&#x3D;nums[k]+nums[i]+nums[j]</span><br><span class="line">                if sum&#x3D;&#x3D;0:</span><br><span class="line">                    tmp&#x3D;[nums[k],nums[i],nums[j]]</span><br><span class="line">                    res.append(tmp)</span><br><span class="line"></span><br><span class="line">                    while i&lt;j and nums[i]&#x3D;&#x3D;nums[i+1]:</span><br><span class="line">                        i+&#x3D;1</span><br><span class="line">                    while i&lt;j and nums[j]&#x3D;&#x3D;nums[j-1]:</span><br><span class="line">                        j-&#x3D;1</span><br><span class="line"></span><br><span class="line">                    i+&#x3D;1</span><br><span class="line">                    j-&#x3D;1</span><br><span class="line"></span><br><span class="line">                elif sum&lt;0:</span><br><span class="line">                    i+&#x3D;1</span><br><span class="line">                else:</span><br><span class="line">                    j-&#x3D;1</span><br><span class="line"></span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>
<h3 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16.最接近的三数之和"></a>16.最接近的三数之和</h3><pre><code>链接：https://leetcode-cn.com/problems/3sum-closest/

给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。

例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.

与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).</code></pre>
<p>题解一|排序+双指针：</p>
<p>思路类似于三数之和，首先将数组进行排序，同时在左右指针运动过程中，记录与 target 绝对值差值最小的三数之和。</p>
<p>时间复杂度：O(nlogn) + O(n^2) = O(n^2)，空间复杂度O(1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def threeSumClosest(self, nums: List[int], target: int) -&gt; int:</span><br><span class="line">        nums.sort()</span><br><span class="line">        length&#x3D;len(nums)</span><br><span class="line">        res&#x3D;float(&#39;inf&#39;)</span><br><span class="line">        </span><br><span class="line">        for k in range(length):</span><br><span class="line">            # if k&gt;0 and nums[k]&#x3D;&#x3D;nums[k-1]:</span><br><span class="line">            #    continue</span><br><span class="line">            </span><br><span class="line">            i,j&#x3D;k+1,length-1</span><br><span class="line">            while i&lt;j:</span><br><span class="line">                sum&#x3D;nums[k]+nums[i]+nums[j]</span><br><span class="line">                if sum&#x3D;&#x3D;target:</span><br><span class="line">                    return target</span><br><span class="line">                </span><br><span class="line">                if abs(res-target)&gt;abs(sum-target):</span><br><span class="line">                    res&#x3D;sum</span><br><span class="line">                    </span><br><span class="line">                if sum&lt;target:</span><br><span class="line">                    i+&#x3D;1</span><br><span class="line">                else:</span><br><span class="line">                    j-&#x3D;1</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>
<h3 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18.四数之和"></a>18.四数之和</h3><pre><code>链接：https://leetcode-cn.com/problems/4sum/

给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。

注意：

答案中不可以包含重复的四元组。

示例：

给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。

满足要求的四元组集合为：
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]</code></pre>
<p>题解一|排序+双指针：</p>
<p>和三数之和解法类似，先将数组排序固定两个元素，再用两个指针，一个指向头，一个指向尾，看四数之和为多少，太大了右指针左移，太小了左指针右移，因为有可能存在重复的数组，先将结果保存在set中，最后在转为list输出。</p>
<p>时间复杂度：O(n^3)，空间复杂度O(n)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def fourSum(self, nums: List[int], target: int) -&gt; List[List[int]]:</span><br><span class="line">        nums.sort()</span><br><span class="line">        length&#x3D;len(nums)</span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        sets&#x3D;set()</span><br><span class="line">        </span><br><span class="line">        for i in range(length-3):</span><br><span class="line">            for j in range(i+1,length-2):</span><br><span class="line">                left,right&#x3D;j+1,length-1</span><br><span class="line">                </span><br><span class="line">                while left&lt;right:</span><br><span class="line">                    sum&#x3D;nums[i]+nums[j]+nums[left]+nums[right]</span><br><span class="line">                    if sum&#x3D;&#x3D;target:</span><br><span class="line">                        tmp&#x3D;(nums[i],nums[j],nums[left],nums[right])</span><br><span class="line">                        sets.add(tmp) # 去重</span><br><span class="line">                        left+&#x3D;1</span><br><span class="line">                        right-&#x3D;1</span><br><span class="line">                    elif sum&lt;target:</span><br><span class="line">                        left+&#x3D;1</span><br><span class="line">                    else:</span><br><span class="line">                        right-&#x3D;1</span><br><span class="line">                        </span><br><span class="line">        for each in sets:</span><br><span class="line">            res.append(list(each))</span><br><span class="line">        return res </span><br></pre></td></tr></table></figure>
<h3 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26.删除排序数组中的重复项"></a>26.删除排序数组中的重复项</h3><pre><code>链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/

给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

示例 1:

给定数组 nums = [1,1,2], 

函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 

你不需要考虑数组中超出新长度后面的元素。
示例 2:

给定 nums = [0,0,1,1,1,2,2,3,3,4],

函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。

你不需要考虑数组中超出新长度后面的元素。</code></pre>
<p>题解一|双指针：</p>
<p>思路：</p>
<p>采用两指针，一个指针i指向原数组需要判断的元素，一个指针j指向新数组新加入的元素。<br>由于是有序数组，因此只要判断原数组中的元素不同于新数组新加入的元素，就将原数组的元素和新数组后一元素交换位置即可，没有重复元素就是和自身交换位置。</p>
<p>第一个指针 i ：由于数组已完成排序，因为遍历数组，每遇到 nums[i] != nums[j<br>] ,就说明遇到了新的不同数字，记录之；</p>
<p>第二个指针 j ：每遇到新的不同数字时，执行 j += 1 ， j 指针有两个作用：</p>
<pre><code>记录数组中不同数字的数量；
作为修改数组元素的索引index。</code></pre>
<p>最终，返回 k+1 即可。<br>时间复杂度O(n),空间复杂福O(1)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def removeDuplicates(self, nums: List[int]) -&gt; int:</span><br><span class="line">        if not nums:</span><br><span class="line">            return 0</span><br><span class="line">        j&#x3D;0</span><br><span class="line">        for i in range(1,len(nums)):</span><br><span class="line">            if nums[i]!&#x3D;nums[j]:</span><br><span class="line">                nums[j+1]&#x3D;nums[i]</span><br><span class="line">                j+&#x3D;1</span><br><span class="line">        return j+1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def removeDuplicates(self, nums: List[int]) -&gt; int:</span><br><span class="line">        index&#x3D;0</span><br><span class="line">        for i in range(1,len(nums)):</span><br><span class="line">            if nums[i] !&#x3D; nums[index]:</span><br><span class="line">                index+&#x3D;1</span><br><span class="line">                nums[index]&#x3D;nums[i]</span><br><span class="line">        return index+1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def removeDuplicates(self, nums: List[int]) -&gt; int:</span><br><span class="line">        if not nums:</span><br><span class="line">            return 0</span><br><span class="line">        slow&#x3D;0</span><br><span class="line">        for fast in range(len(nums)):</span><br><span class="line">            if nums[slow] !&#x3D; nums[fast]:</span><br><span class="line">                slow+&#x3D;1</span><br><span class="line">            nums[slow]&#x3D;nums[fast]</span><br><span class="line">        return slow+1</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def removeDuplicates(self, nums: List[int]) -&gt; int:</span><br><span class="line">        if not nums:</span><br><span class="line">            return 0</span><br><span class="line">        slow&#x3D;0</span><br><span class="line">        for fast in range(len(nums)):</span><br><span class="line">            if nums[fast] &#x3D;&#x3D; nums[slow]:</span><br><span class="line">                fast+&#x3D;1</span><br><span class="line">            else:</span><br><span class="line">                slow+&#x3D;1</span><br><span class="line">                nums[slow]&#x3D;nums[fast]</span><br><span class="line">        return slow+1</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def removeDuplicates(self, nums: List[int]) -&gt; int:</span><br><span class="line">        pre,cur&#x3D;0,1</span><br><span class="line">        while cur&lt;len(nums):</span><br><span class="line">            if nums[pre]&#x3D;&#x3D;nums[cur]:</span><br><span class="line">                nums.pop(cur)</span><br><span class="line">            else:</span><br><span class="line">                pre,cur&#x3D;pre+1,cur+1</span><br></pre></td></tr></table></figure>
<h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27.移除元素"></a>27.移除元素</h3><pre><code>链接：https://leetcode-cn.com/problems/remove-element/

给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

示例 1:

给定 nums = [3,2,2,3], val = 3,

函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。

你不需要考虑数组中超出新长度后面的元素。
示例 2:

给定 nums = [0,1,2,2,3,0,4,2], val = 2,

函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。

注意这五个元素可为任意顺序。

你不需要考虑数组中超出新长度后面的元素。</code></pre>
<p>题解一|双指针：</p>
<p>可以保留两个指针 i 和 j，其中 i 是慢指针，j 是快指针。当 nums[j]与val相等时，递增 j以跳过该元素。只要 nums[j] 不等于 val，我们就复制 nums[j]到 nums[i] 并同时递增两个索引。重复这一过程，直到 j 到达数组的末尾，该数组的新长度为 i。<br>时间复杂度O(n),空间复杂度O(1).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def removeElement(self, nums: List[int], val: int) -&gt; int:</span><br><span class="line">        i&#x3D;0</span><br><span class="line">        for j in range(0,len(nums)):</span><br><span class="line">            if nums[j] !&#x3D; val:</span><br><span class="line">                nums[i]&#x3D;nums[j]</span><br><span class="line">                i+&#x3D;1</span><br><span class="line">        return i</span><br></pre></td></tr></table></figure>

<h3 id="29-两数相除"><a href="#29-两数相除" class="headerlink" title="29.两数相除"></a>29.两数相除</h3><pre><code>链接：https://leetcode-cn.com/problems/divide-two-integers/submissions/

给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。

返回被除数 dividend 除以除数 divisor 得到的商。

示例 1:

输入: dividend = 10, divisor = 3
输出: 3
示例 2:

输入: dividend = 7, divisor = -3
输出: -2
说明:

被除数和除数均为 32 位有符号整数。
除数不为 0。
假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。</code></pre>
<p>题解一|减法|超时:</p>
<p>超时：当被除数为2147483648，除数为 1，必然超时。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def divide(self, dividend: int, divisor: int) -&gt; int:</span><br><span class="line">        res&#x3D;0</span><br><span class="line">        flag&#x3D;1 if dividend ^ divisor &gt;&#x3D;0 else -1</span><br><span class="line">        dividend&#x3D;abs(dividend)</span><br><span class="line">        divisor&#x3D;abs(divisor)</span><br><span class="line">        while dividend &gt;&#x3D; divisor:</span><br><span class="line">            res+&#x3D;1</span><br><span class="line">            dividend-&#x3D;divisor</span><br><span class="line">        res&#x3D;res*flag</span><br><span class="line">        return min(max(res,-2**31),2**31-1)</span><br></pre></td></tr></table></figure>

<p>题解二|增倍除数:</p>
<pre><code>&lt;&lt; 是左移，末位补0，类比十进制数在末尾添0相当于原数乘以10，x&lt;&lt;1是将x的二进制表示左移一位，相当于原数x乘2。比如整数4在二进制下是100，4&lt;&lt;1左移1位变成1000(二进制)，结果是8。

&gt;&gt;是右移，右移1位相当于除以2。</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def divide(self, dividend: int, divisor: int) -&gt; int:</span><br><span class="line">        res&#x3D;0</span><br><span class="line">        flag&#x3D;1 if dividend ^ divisor &gt;&#x3D;0 else -1</span><br><span class="line">        dividend&#x3D;abs(dividend)</span><br><span class="line">        divisor&#x3D;abs(divisor)</span><br><span class="line">        while dividend &gt;&#x3D; divisor:</span><br><span class="line">            tmp,i&#x3D;divisor,1</span><br><span class="line">            while dividend&gt;&#x3D;tmp:</span><br><span class="line">                dividend-&#x3D;tmp</span><br><span class="line">                res+&#x3D;i</span><br><span class="line">                i &lt;&lt;&#x3D;1</span><br><span class="line">                tmp &lt;&lt;&#x3D;1</span><br><span class="line">        res&#x3D;res*flag</span><br><span class="line">        return min(max(res,-2**31),2**31-1)</span><br></pre></td></tr></table></figure>
<p>题解三（位移）：<br>算法是把除法化归成移位和减法两种运算方法。对于 10 进制数，移位运算就是乘（左移）除（右移）10，而我们都知道计算机中的移位运算是乘（左移）除（右移）2，因为计算机是通过二进制的方法存储数的。这样，类比十进制，二进制的除法（仍以 45/2 为例）可以写作（注意，这里我们并没有用到乘除法）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def divide(self, dividend: int, divisor: int) -&gt; int:</span><br><span class="line">        res&#x3D;0</span><br><span class="line">        flag&#x3D;1 if dividend ^ divisor &gt;&#x3D;0 else -1</span><br><span class="line">        dividend&#x3D;abs(dividend)</span><br><span class="line">        divisor&#x3D;abs(divisor)</span><br><span class="line">        count&#x3D;0</span><br><span class="line"></span><br><span class="line">        # 不断左移，直到大于被除数</span><br><span class="line">        while dividend &gt;&#x3D; divisor:</span><br><span class="line">            count+&#x3D;1</span><br><span class="line">            divisor &lt;&lt;&#x3D;1</span><br><span class="line">        </span><br><span class="line">        while count &gt; 0:</span><br><span class="line">            count -&#x3D;1</span><br><span class="line">            divisor &gt;&gt;&#x3D;1</span><br><span class="line">            res &lt;&lt;&#x3D;1</span><br><span class="line">            if divisor &lt;&#x3D; dividend:</span><br><span class="line">                res+&#x3D;1</span><br><span class="line">                dividend -&#x3D; divisor</span><br><span class="line">        </span><br><span class="line">        res&#x3D;res*flag</span><br><span class="line">        return min(max(res,-2**31),2**31-1)</span><br></pre></td></tr></table></figure>

<h3 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a>31. 下一个排列</h3><pre><code>链接：https://leetcode-cn.com/problems/next-permutation/

实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须原地修改，只允许使用额外常数空间。

以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1</code></pre>
<p>题解一：</p>
<p>1.从右至左遍历nums，发现第一个小于右边的数nums[i]，将该nums[i]之后的数排升序；</p>
<p>2.第二层遍历nums[(i+1):]，发现第一个大于nums[i]的数nums[j]，交换两数，退出遍历break；</p>
<p>3.交换了也排好序了，退出第一次层遍历return nums</p>
<p>这里有个细节：nums本来就是降序，第一次遍历找不到nums[i],那么直接sort()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def nextPermutation(self, nums: List[int]) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Do not return anything, modify nums in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        for i in range(len(nums)-2,-1,-1):</span><br><span class="line">            if nums[i] &lt; nums[i+1]:</span><br><span class="line">                nums[i+1:]&#x3D;sorted(nums[i+1:])</span><br><span class="line">                for j in range(i+1,len(nums)):</span><br><span class="line">                    if nums[i] &lt; nums[j]:</span><br><span class="line">                        nums[i],nums[j]&#x3D;nums[j],nums[i]</span><br><span class="line">                        # break</span><br><span class="line">                        return</span><br><span class="line"></span><br><span class="line">        nums.sort()</span><br></pre></td></tr></table></figure>

<h3 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a>45. 跳跃游戏 II</h3><pre><code>链接：https://leetcode-cn.com/problems/jump-game-ii/

给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

你的目标是使用最少的跳跃次数到达数组的最后一个位置。

示例:

输入: [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</code></pre>
<p>题解一：<br>思路：</p>
<pre><code>1、如果某一个作为 起跳点 的格子可以跳跃的距离是 3，那么表示后面 3 个格子都可以作为 起跳点。
    11. 可以对每一个能作为 起跳点 的格子都尝试跳一次，把 能跳到最远的距离 不断更新。

2、如果从这个 起跳点 起跳叫做第 1 次 跳跃，那么从后面 3 个格子起跳 都 可以叫做第 2 次 跳跃。

3、所以，当一次 跳跃 结束时，从下一个格子开始，到现在 能跳到最远的距离，都 是下一次 跳跃 的 起跳点。
    31. 对每一次 跳跃 用 for 循环来模拟。
    32. 跳完一次之后，更新下一次 起跳点 的范围。
    33. 在新的范围内跳，更新 能跳到最远的距离。

4、记录 跳跃 次数，如果跳到了终点，就得到了结果。</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def jump(self, nums: List[int]) -&gt; int:</span><br><span class="line">        ans&#x3D;0</span><br><span class="line">        start&#x3D;0</span><br><span class="line">        end&#x3D;1</span><br><span class="line">        while end&lt;len(nums):</span><br><span class="line">            maxPos&#x3D;0</span><br><span class="line">            for i in range(start,end):</span><br><span class="line">                maxPos&#x3D;max(maxPos,nums[i]+i)</span><br><span class="line">            start&#x3D;end</span><br><span class="line">            end&#x3D;maxPos+1</span><br><span class="line">            ans+&#x3D;1</span><br><span class="line">        return ans</span><br></pre></td></tr></table></figure>

<p>优化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def jump(self, nums: List[int]) -&gt; int:</span><br><span class="line">        ans&#x3D;0</span><br><span class="line">        end&#x3D;0</span><br><span class="line">        maxPos&#x3D;0</span><br><span class="line">        for i in range(0,len(nums)-1):</span><br><span class="line">            maxPos&#x3D;max(maxPos,nums[i]+i)</span><br><span class="line">            if i&#x3D;&#x3D;end:</span><br><span class="line">                end&#x3D;maxPos</span><br><span class="line">                ans+&#x3D;1</span><br><span class="line">        return ans</span><br></pre></td></tr></table></figure>

<h3 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48.旋转图像"></a>48.旋转图像</h3><pre><code>链接：https://leetcode-cn.com/problems/rotate-image/

给定一个 n × n 的二维矩阵表示一个图像。

将图像顺时针旋转 90 度。

说明：

你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。

示例 1:

给定 matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

原地旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
示例 2:

给定 matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

原地旋转输入矩阵，使其变为:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]</code></pre>
<p>题解一|转置+翻转：</p>
<p>分析：先转置矩阵，然后翻转每一行。这个简单的方法已经能达到最优的时间复杂度O(N^2)。</p>
<p>时间复杂度：O(N^2)<br>空间复杂度：O(1) 由于旋转操作是 就地 完成的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def rotate(self, matrix: List[List[int]]) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Do not return anything, modify matrix in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        n&#x3D;len(matrix[0]) # 矩阵第一行matrix[0]</span><br><span class="line">        # 矩阵转置</span><br><span class="line">        for i in range(n):</span><br><span class="line">            for j in range(i,n):</span><br><span class="line">                matrix[j][i],matrix[i][j]&#x3D;matrix[i][j],matrix[j][i]</span><br><span class="line">        # 翻转每行</span><br><span class="line">        for i in range(n):</span><br><span class="line">            matrix[i].reverse()</span><br><span class="line">        return matrix</span><br></pre></td></tr></table></figure>

<p>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rotate-image/solution/xuan-zhuan-tu-xiang-by-leetcode/">https://leetcode-cn.com/problems/rotate-image/solution/xuan-zhuan-tu-xiang-by-leetcode/</a></p>
<h3 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a>49. 字母异位词分组</h3><pre><code>链接：https://leetcode-cn.com/problems/group-anagrams/

给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。

示例:

输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],
输出:
[
  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],
  [&quot;nat&quot;,&quot;tan&quot;],
  [&quot;bat&quot;]
]
说明：

所有输入均为小写字母。
不考虑答案输出的顺序。</code></pre>
<p>题解一（hash）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:</span><br><span class="line">        hash&#x3D;&#123;&#125;</span><br><span class="line">        for i in strs:</span><br><span class="line">            tmp&#x3D;tuple(sorted(i))</span><br><span class="line">            if tmp not in hash:</span><br><span class="line">                hash[tmp]&#x3D;[i]</span><br><span class="line">            else:</span><br><span class="line">                hash[tmp].append(i)</span><br><span class="line">        # print(hash)</span><br><span class="line">        res&#x3D;[i for i in hash.values()]</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<pre><code>&#123;(&#39;a&#39;, &#39;e&#39;, &#39;t&#39;): [&#39;eat&#39;, &#39;tea&#39;, &#39;ate&#39;], (&#39;a&#39;, &#39;n&#39;, &#39;t&#39;): [&#39;tan&#39;, &#39;nat&#39;], (&#39;a&#39;, &#39;b&#39;, &#39;t&#39;): [&#39;bat&#39;]&#125;</code></pre>
<h3 id="66-加一"><a href="#66-加一" class="headerlink" title="66. 加一"></a>66. 加一</h3><p>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/plus-one/">https://leetcode-cn.com/problems/plus-one/</a></p>
<pre><code>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。

示例 1:

输入: [1,2,3]
输出: [1,2,4]
解释: 输入数组表示数字 123。
示例 2:

输入: [4,3,2,1]
输出: [4,3,2,2]
解释: 输入数组表示数字 4321。</code></pre>
<p>题解一：</p>
<p>思路：转换为int进行加1</p>
<p>题解二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def plusOne(self, digits: List[int]) -&gt; List[int]:</span><br><span class="line">        for i in range(len(digits)-1,-1,-1):</span><br><span class="line">            digits[i]+&#x3D;1</span><br><span class="line">            digits[i] %&#x3D; 10</span><br><span class="line">            if digits[i] !&#x3D; 0:</span><br><span class="line">                return digits</span><br><span class="line">        </span><br><span class="line">        digits&#x3D;[0]*(len(digits)+1) # 解决case[9],输出[1,0]</span><br><span class="line">        digits[0]&#x3D;1 # 解决case[9],输出[1,0]</span><br><span class="line">        return digits    </span><br></pre></td></tr></table></figure>

<p>题解三：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def plusOne(self, digits: List[int]) -&gt; List[int]:</span><br><span class="line">        new&#x3D;[]</span><br><span class="line">        while digits and digits[-1] &#x3D;&#x3D; 9:</span><br><span class="line">            digits.pop()</span><br><span class="line">            new.append(0)</span><br><span class="line">        if not digits:</span><br><span class="line">            return [1]+new</span><br><span class="line">        else:</span><br><span class="line">            digits[-1]+&#x3D;1</span><br><span class="line">            return digits+new</span><br></pre></td></tr></table></figure>

<p>题解四：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def plusOne(self, digits):</span><br><span class="line">        length&#x3D;len(digits)</span><br><span class="line">        i&#x3D;length-1</span><br><span class="line">        while(i&gt;&#x3D;0):</span><br><span class="line">            if i&#x3D;&#x3D;0:</span><br><span class="line">                if (digits[i]+1)&gt;9:</span><br><span class="line">                    digits[i]&#x3D;0</span><br><span class="line">                    result&#x3D;[1]</span><br><span class="line">                    result.extend(digits)</span><br><span class="line">                    return result</span><br><span class="line">            if (digits[i]+1)&lt;&#x3D;9:</span><br><span class="line">                digits[i]+&#x3D;1</span><br><span class="line">                return digits</span><br><span class="line">            else:</span><br><span class="line">                digits[i]&#x3D;0</span><br><span class="line">                i-&#x3D;1</span><br><span class="line">        return digits</span><br></pre></td></tr></table></figure>
<h3 id="69-x的平方根"><a href="#69-x的平方根" class="headerlink" title="69.x的平方根"></a>69.x的平方根</h3><pre><code>链接：https://leetcode-cn.com/problems/sqrtx/

实现 int sqrt(int x) 函数。

计算并返回 x 的平方根，其中 x 是非负整数。

由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

示例 1:

输入: 4
输出: 2
示例 2:

输入: 8
输出: 2
说明: 8 的平方根是 2.82842..., 
     由于返回类型是整数，小数部分将被舍去。</code></pre>
<p>题解一(二分法):</p>
<p>思路分析：使用二分法搜索平方根的思想很简单，就类似于小时候我们看的电视节目中的“猜价格”游戏，高了就往低了猜，低了就往高了猜，范围越来越小。因此，使用二分法猜算术平方根就很自然。</p>
<p>一个数的平方根肯定不会超过它自己，不过直觉还告诉我们，一个数的平方根最多不会超过它的一半，例如 8的平方根，8 的一半是 4，4^2=16&gt;8，如果这个数越大越是如此，因此我们要计算一下，这个边界是多少。为此，解如下不等式：(a/2)^2 &gt;= a</p>
<p>时间复杂度：O(logn)<br>空间复杂度：O(1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def mySqrt(self, x: int) -&gt; int:</span><br><span class="line">        left&#x3D;0</span><br><span class="line">        right&#x3D;x&#x2F;&#x2F;2+1</span><br><span class="line">        while left &lt; right:</span><br><span class="line">            # mid &#x3D; left + (right - left + 1) &#x2F;&#x2F; 2</span><br><span class="line">            # mid&#x3D;(left+right+1)&gt;&gt;1</span><br><span class="line">            mid&#x3D;(left+right+1)&#x2F;&#x2F;2 # 使用除法的耗时比移位多</span><br><span class="line">            square&#x3D;mid*mid</span><br><span class="line"></span><br><span class="line">            if square&gt;x:</span><br><span class="line">                right&#x3D;mid-1</span><br><span class="line">            else:</span><br><span class="line">                left&#x3D;mid</span><br><span class="line">            </span><br><span class="line">        return left</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 单独照顾0这个特例</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def mySqrt(self, x: int) -&gt; int:</span><br><span class="line">        if x&#x3D;&#x3D;0:</span><br><span class="line">            return 0</span><br><span class="line">        left&#x3D;1</span><br><span class="line">        right&#x3D;x&#x2F;&#x2F;2</span><br><span class="line">        while left &lt; right:</span><br><span class="line">            # mid&#x3D;(left+right+1)&gt;&gt;1</span><br><span class="line">            mid&#x3D;(left+right+1)&#x2F;&#x2F;2 # 使用除法的耗时比移位多</span><br><span class="line">            # 一定取右中位数，如果取左中位数(left+right)&#x2F;&#x2F;2，代码可能会进入死循环</span><br><span class="line">            square&#x3D;mid*mid</span><br><span class="line"></span><br><span class="line">            if square&gt;x:</span><br><span class="line">                right&#x3D;mid-1</span><br><span class="line">            else:</span><br><span class="line">                left&#x3D;mid</span><br><span class="line">            </span><br><span class="line">        return left</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line"></span><br><span class="line">    def mySqrt(self, x):</span><br><span class="line">        left &#x3D; 0</span><br><span class="line">        right &#x3D; 999999</span><br><span class="line">        while left &lt; right:</span><br><span class="line">            # 这种取中位数的方法又快又好，是我刚学会的，原因在下面这篇文章的评论区</span><br><span class="line">            # https:&#x2F;&#x2F;www.liwei.party&#x2F;2019&#x2F;06&#x2F;17&#x2F;leetcode-solution-new&#x2F;search-insert-position&#x2F;</span><br><span class="line">            mid &#x3D; (left + right + 1) &gt;&gt; 1</span><br><span class="line">            square &#x3D; mid * mid</span><br><span class="line">            if square &gt; x:</span><br><span class="line">                right &#x3D; mid - 1</span><br><span class="line">            else:</span><br><span class="line">                left &#x3D; mid</span><br><span class="line"></span><br><span class="line">        return left</span><br></pre></td></tr></table></figure>
<p>?题解二（牛顿法）:</p>
<p>牛顿法的应用：一个是求方程的根，另一个是求解最优化问题</p>
<p>使用牛顿法可以得到一个正实数的算术平方根，因为题目中说“结果只保留整数部分”，因此，我们把使用牛顿法得到的浮点数转换为整数即可。</p>
<p>在迭代过程中，以直线代替曲线，用一阶泰勒展式（即在当前点的切线）代替原曲线，求直线与 xx 轴的交点，重复这个过程直到收敛。<br><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/newton.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/newton.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def mySqrt(self, x: int) -&gt; int:</span><br><span class="line">        if x&lt;0:</span><br><span class="line">            # raise Exception(&#39;不能输入负数)</span><br><span class="line">            return -1</span><br><span class="line">        if x&#x3D;&#x3D;0:</span><br><span class="line">            return 0</span><br><span class="line">        </span><br><span class="line">        cur&#x3D;1</span><br><span class="line">        while True:</span><br><span class="line">            pre&#x3D;cur</span><br><span class="line">            cur&#x3D;(cur+x&#x2F;cur)&#x2F;2</span><br><span class="line">            if abs(cur-pre)&lt; 1e-6:</span><br><span class="line">                return int(cur)</span><br></pre></td></tr></table></figure>

<h3 id="73-矩阵置零"><a href="#73-矩阵置零" class="headerlink" title="73. 矩阵置零"></a>73. 矩阵置零</h3><pre><code>链接：https://leetcode-cn.com/problems/set-matrix-zeroes/

给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。

示例 1:

输入: 
[
  [1,1,1],
  [1,0,1],
  [1,1,1]
]
输出: 
[
  [1,0,1],
  [0,0,0],
  [1,0,1]
]
示例 2:

输入: 
[
  [0,1,2,0],
  [3,4,5,2],
  [1,3,1,5]
]
输出: 
[
  [0,0,0,0],
  [0,4,5,0],
  [0,3,1,0]
]
进阶:

一个直接的解决方案是使用  O(mn) 的额外空间，但这并不是一个好的解决方案。
一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。
你能想出一个常数空间的解决方案吗？</code></pre>
<p>题解一：</p>
<p>分析：</p>
<pre><code>用 O(m+n)额外空间
两遍扫matrix,第一遍用集合记录哪些行,哪些列有0;第二遍置0</code></pre>
<p>时间复杂度：O(M*N)<br>空间复杂度：O(M+N)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def setZeroes(self, matrix: List[List[int]]) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Do not return anything, modify matrix in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        m&#x3D;len(matrix)       # 行</span><br><span class="line">        n&#x3D;len(matrix[0])    # 列</span><br><span class="line">        m_zero&#x3D;set()</span><br><span class="line">        n_zero&#x3D;set()</span><br><span class="line">        for i in range(m):</span><br><span class="line">            for j in range(n):</span><br><span class="line">                if matrix[i][j]&#x3D;&#x3D; 0:</span><br><span class="line">                    m_zero.add(i)</span><br><span class="line">                    n_zero.add(j)</span><br><span class="line">        for i in range(m):</span><br><span class="line">            for j in range(n):</span><br><span class="line">                if i in m_zero or j in n_zero: # 不是if 0 in m_zero or 0 in n_zero</span><br><span class="line">                    matrix[i][j]&#x3D;0</span><br><span class="line">        return matrix</span><br></pre></td></tr></table></figure>

<p>题解二：</p>
<p>分析:</p>
<pre><code>用matrix第一行和第一列记录该行该列是否有0,作为标志位
但是对于第一行,和第一列要设置一个标志位,为了防止自己这一行(一列)也有0的情况.


参考：https://leetcode-cn.com/problems/set-matrix-zeroes/solution/li-yong-di-yi-xing-he-di-yi-lie-ji-lu-o1kong-jian-/

定义flag_line=False，判断第一行是否需要置0。
定义flag_row=False，判断第一列是否需要置0。
遍历第一列，若第一列中存在0，将flag_row=True，表示需要将第一列置0。
遍历第一行，若第一行中存在0，将flag_line=True，表示需要将第一行置0。
遍历矩阵，遍历区间，行区间[1,m)，列区间[1,m)，若matrix[i][j]==0，则将对应的行和列记录下来，即将第一行和第一列中对应的位置置为0。matrix[i][0]=matrix[0][j]=0
再遍历一次矩阵，若当前位置的行或列索引对应的第一行或者第一列处为0，即matrix[i][0]==0 or matrix[0][j]==0，将此位置置为0。
根据flag_line，判断是否需要将第一行置为0。
根据flag_row，判断第一列是否需要置0。


时间复杂度：O(M*N)
空间复杂度：O(1)</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def setZeroes(self, matrix: List[List[int]]) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Do not return anything, modify matrix in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 输入：[[1,1,1,1],[1,0,1,1],[1,1,1,1]]</span><br><span class="line">        m&#x3D;len(matrix)       # 行的个数</span><br><span class="line">        n&#x3D;len(matrix[0])    # 列的个数</span><br><span class="line">        m0_flag&#x3D;False</span><br><span class="line">        n0_flag&#x3D;False</span><br><span class="line">        </span><br><span class="line">        # 找第一行是否有0</span><br><span class="line">        for j in range(n):</span><br><span class="line">            if matrix[0][j] &#x3D;&#x3D; 0:</span><br><span class="line">                m0_flag&#x3D;True</span><br><span class="line">                break</span><br><span class="line">        # 找第一列是否有0</span><br><span class="line">        for i in range(m):</span><br><span class="line">            if matrix[i][0]&#x3D;&#x3D;0:</span><br><span class="line">                n0_flag&#x3D;True</span><br><span class="line">                break</span><br><span class="line">        # 把第一行或者第一列作为 标志位</span><br><span class="line">        for i in range(1,m):</span><br><span class="line">            for j in range(1,n):</span><br><span class="line">                if matrix[i][j]&#x3D;&#x3D;0:</span><br><span class="line">                    matrix[i][0]&#x3D;matrix[0][j]&#x3D;0</span><br><span class="line">        # print(matrix)</span><br><span class="line">        # [[1, 0, 1, 1], [0, 0, 1, 1], [1, 1, 1, 1]]</span><br><span class="line"></span><br><span class="line">        # 置0</span><br><span class="line">        for i in range(1,m):</span><br><span class="line">            for j in range(1,n):</span><br><span class="line">                if(matrix[i][0]&#x3D;&#x3D;0 or matrix[0][j]&#x3D;&#x3D;0):</span><br><span class="line">                    matrix[i][j]&#x3D;0    </span><br><span class="line">        # print(matrix)  </span><br><span class="line">        # [[1, 0, 1, 1], [0, 0, 0, 0], [1, 0, 1, 1]]</span><br><span class="line">        </span><br><span class="line">        if m0_flag:</span><br><span class="line">            for j in range(n):</span><br><span class="line">                matrix[0][j]&#x3D;0</span><br><span class="line">        if n0_flag:</span><br><span class="line">            for i in range(m):</span><br><span class="line">                matrix[i][0]&#x3D;0</span><br></pre></td></tr></table></figure>

<p>???</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def setZeroes(self, matrix: List[List[int]]) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Do not return anything, modify matrix in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        flag_col &#x3D; False</span><br><span class="line">        row &#x3D; len(matrix)</span><br><span class="line">        col &#x3D; len(matrix[0])</span><br><span class="line">        for i in range(row):</span><br><span class="line">            if matrix[i][0] &#x3D;&#x3D; 0: flag_col &#x3D; True</span><br><span class="line">            for j in range(1,col):</span><br><span class="line">                if matrix[i][j] &#x3D;&#x3D; 0:</span><br><span class="line">                    matrix[i][0] &#x3D; matrix[0][j] &#x3D; 0</span><br><span class="line">        </span><br><span class="line">        for i in range(row - 1, -1, -1):</span><br><span class="line">            for j in range(col - 1, 0, -1):</span><br><span class="line">                if matrix[i][0] &#x3D;&#x3D; 0 or matrix[0][j] &#x3D;&#x3D; 0:</span><br><span class="line">                    matrix[i][j] &#x3D; 0</span><br><span class="line"></span><br><span class="line">            if flag_col &#x3D;&#x3D; True: matrix[i][0] &#x3D; 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a>88. 合并两个有序数组</h3><pre><code>链接：https://leetcode-cn.com/problems/merge-sorted-array/

给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 num1 成为一个有序数组。

说明:

初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。
你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。
 

示例:

输入:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

输出: [1,2,2,3,5,6]</code></pre>
<p>题解一（合并后再排序）：</p>
<p>时间复杂度 : O((n + m)\log(n + m))<br>空间复杂度 : O(1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Do not return anything, modify nums1 in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        nums1[:]&#x3D;sorted(nums1[:m]+nums2)</span><br></pre></td></tr></table></figure>

<p>题解二（双指针 / 从前往后）：</p>
<p>时间复杂度 : O(n + m)<br>空间复杂度 : O(m)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Do not return anything, modify nums1 in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        copy&#x3D;nums1[:m]</span><br><span class="line">        nums1[:]&#x3D;[]</span><br><span class="line">        p1,p2&#x3D;0,0</span><br><span class="line">        while p1&lt;m and p2&lt;n:</span><br><span class="line">            if copy[p1]&lt;nums2[p2]:</span><br><span class="line">                nums1.append(copy[p1])</span><br><span class="line">                p1+&#x3D;1</span><br><span class="line">            else:</span><br><span class="line">                nums1.append(nums2[p2])</span><br><span class="line">                p2+&#x3D;1</span><br><span class="line">        if p1&lt;m:</span><br><span class="line">            nums1[p1+p2:]&#x3D;copy[p1:]</span><br><span class="line">        if p2&lt;n:</span><br><span class="line">            nums1[p1+p2:]&#x3D;nums2[p2:]</span><br></pre></td></tr></table></figure>

<p>题解三(双指针 / 从后往前)：</p>
<p>时间复杂度 : O(n + m)<br>空间复杂度 : O(1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Do not return anything, modify nums1 in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        p1&#x3D;m-1</span><br><span class="line">        p2&#x3D;n-1</span><br><span class="line">        p&#x3D;m+n-1</span><br><span class="line">        while p1&gt;&#x3D;0 and p2&gt;&#x3D;0:</span><br><span class="line">            if nums1[p1] &lt; nums2[p2]:</span><br><span class="line">                nums1[p]&#x3D;nums2[p2]</span><br><span class="line">                p2-&#x3D;1</span><br><span class="line">            else:</span><br><span class="line">                nums1[p]&#x3D;nums1[p1]</span><br><span class="line">                p1-&#x3D;1</span><br><span class="line">            p-&#x3D;1</span><br><span class="line">        nums1[:p2+1]&#x3D;nums2[:p2+1] # 解决case:[0]，0，[1]，1</span><br></pre></td></tr></table></figure>

<h3 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a>167. 两数之和 II - 输入有序数组</h3><pre><code>链接：https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/

给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。

函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。

说明:

返回的下标值（index1 和 index2）不是从零开始的。
你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。
示例:

输入: numbers = [2, 7, 11, 15], target = 9
输出: [1,2]
解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</code></pre>
<p>题解一|暴力|超时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def twoSum(self, numbers: List[int], target: int) -&gt; List[int]:</span><br><span class="line">        n&#x3D;len(numbers)</span><br><span class="line">        for i in range(n):</span><br><span class="line">            for j in range(i+1,n):</span><br><span class="line">                if numbers[i]+numbers[j]&#x3D;&#x3D;target:</span><br><span class="line">                    return [i+1,j+1]</span><br></pre></td></tr></table></figure>

<p>题解二|双指针:</p>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def twoSum(self, numbers: List[int], target: int) -&gt; List[int]:</span><br><span class="line">        left&#x3D;0</span><br><span class="line">        right&#x3D;len(numbers)-1</span><br><span class="line">        while left &lt; right:</span><br><span class="line">            if numbers[left]+numbers[right]&#x3D;&#x3D;target:</span><br><span class="line">                return [left+1,right+1]</span><br><span class="line">            elif numbers[left]+numbers[right] &gt; target:</span><br><span class="line">                right-&#x3D;1</span><br><span class="line">            else:</span><br><span class="line">                left+&#x3D;1</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure>

<h3 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189. 旋转数组"></a>189. 旋转数组</h3><pre><code>链接：https://leetcode-cn.com/problems/rotate-array/

给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。

示例 1:

输入: [1,2,3,4,5,6,7] 和 k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]
示例 2:

输入: [-1,-100,3,99] 和 k = 2
输出: [3,99,-1,-100]
解释: 
向右旋转 1 步: [99,-1,-100,3]
向右旋转 2 步: [3,99,-1,-100]
说明:

尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
要求使用空间复杂度为 O(1) 的 原地 算法。</code></pre>
<p>题解一|暴力|超时：</p>
<p>时间复杂度：O(n^2)<br>空间复杂度：O(1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def rotate(self, nums: List[int], k: int) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Do not return anything, modify nums in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not nums:</span><br><span class="line">            return &#39;&#39;</span><br><span class="line">        n&#x3D;len(nums)</span><br><span class="line">        k&#x3D;k%n</span><br><span class="line">        while k!&#x3D;0:</span><br><span class="line">            tmp&#x3D;nums[n-1]</span><br><span class="line">            i&#x3D;n-1</span><br><span class="line">            while i&gt;0:</span><br><span class="line">                nums[i]&#x3D;nums[i-1]</span><br><span class="line">                i-&#x3D;1</span><br><span class="line">            nums[0]&#x3D;tmp</span><br><span class="line">            k-&#x3D;1</span><br><span class="line">        return nums</span><br></pre></td></tr></table></figure>

<p>题解二|切片：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def rotate(self, nums: List[int], k: int) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Do not return anything, modify nums in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        n&#x3D;len(nums)</span><br><span class="line">        if n &lt; 2:</span><br><span class="line">            pass</span><br><span class="line">        else:</span><br><span class="line">            while k&gt;0:</span><br><span class="line">                tmp&#x3D;nums[-1]</span><br><span class="line">                nums[1:n]&#x3D;nums[0:n-1]</span><br><span class="line">                nums[0]&#x3D;tmp</span><br><span class="line">                k-&#x3D;1</span><br></pre></td></tr></table></figure>

<h3 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a>283. 移动零</h3><pre><code>链接：https://leetcode-cn.com/problems/move-zeroes/

给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

示例:

输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
说明:

必须在原数组上操作，不能拷贝额外的数组。
尽量减少操作次数。</code></pre>
<p>思路：<br>    循环，统计0的个数，非0元素前移，0放在最后；</p>
<pre><code>新开一个数组，碰到0后放，非0放在前面；

index记录非0的位置；</code></pre>
<p>题解一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def moveZeroes(self, nums: List[int]) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Do not return anything, modify nums in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        index&#x3D;0</span><br><span class="line">        for i in range(len(nums)):</span><br><span class="line">            if nums[i] !&#x3D; 0:</span><br><span class="line">                nums[index]&#x3D;nums[i]</span><br><span class="line">                index+&#x3D;1</span><br><span class="line">        for i in range(index,len(nums)):</span><br><span class="line">            nums[i]&#x3D;0</span><br><span class="line">        return nums</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def moveZeroes(self, nums: List[int]) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Do not return anything, modify nums in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        index&#x3D;0</span><br><span class="line">        for i in range(len(nums)):</span><br><span class="line">            if nums[i] !&#x3D; 0:</span><br><span class="line">                nums[index]&#x3D;nums[i]</span><br><span class="line">                if i !&#x3D; index:</span><br><span class="line">                    nums[i]&#x3D;0</span><br><span class="line">                index+&#x3D;1</span><br><span class="line">        return nums</span><br></pre></td></tr></table></figure>

<h3 id="442-数组中重复的数据"><a href="#442-数组中重复的数据" class="headerlink" title="442. 数组中重复的数据"></a>442. 数组中重复的数据</h3><pre><code>链接：https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/

给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。

找到所有出现两次的元素。

你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗？

示例：

输入:
[4,3,2,7,8,2,3,1]

输出:
[2,3]</code></pre>
<p>题解一|原地变负：</p>
<p>注意：1 ≤ a[i] ≤ n，所以变负时才不会越界。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findDuplicates(self, nums: List[int]) -&gt; List[int]:</span><br><span class="line">        ans&#x3D;[]</span><br><span class="line">        for num in nums:</span><br><span class="line">            if nums[abs(num)-1] &lt; 0:</span><br><span class="line">                ans.append(abs(num))</span><br><span class="line">            nums[abs(num)-1]*&#x3D;-1</span><br><span class="line">        return ans</span><br></pre></td></tr></table></figure>

<h3 id="498-对角线遍历"><a href="#498-对角线遍历" class="headerlink" title="498. 对角线遍历"></a>498. 对角线遍历</h3><pre><code>给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。

示例:

输入:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]

输出:  [1,2,4,7,5,3,6,8,9]

解释:

说明:

给定矩阵中的元素总数不会超过 100000 。</code></pre>
<p>题解一：</p>
<p>规律：</p>
<pre><code>对于矩形来说，矩形对角线是最长的，也是遍历结果最长的一条，从这条线，到两边对称递减

遍历顺序：从左下角到右上角交错进行</code></pre>
<p>根据以上两个特点，我们可以想到是否同一条线上的坐标有数上的关系，而且，交替遍历是否可以看成奇数和偶数的替换呢？带着这种思考我们解析这个矩阵(以图中矩阵为例子)：</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/duijiaoxian.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/duijiaoxian.png"></p>
<pre><code>1、我们现在将每一条对角线作出从0 开始的编号，可以发现最后一个的编号是 M + N - 1；并且如果编号为奇数自上而下遍历，偶数则是自下而上遍历

2、关注每一条对角线上的坐标和：对于每一条对角线上的坐标(m,n)，m + n = 编号 是我们发现的规律

3、最后一步就是确定边界：

    多少次遍历：矩阵有多少个元素就遍历多少次；
    到什么时候结束：对于最长对角线以上来说，到 m 或者 n 中的某一个到 0 为止；对于最长对角线下面来说，到 m 或者 n 中的某一个到达边界为止。</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findDiagonalOrder(self, matrix: List[List[int]]) -&gt; List[int]:</span><br><span class="line">        if not matrix:</span><br><span class="line">            return []</span><br><span class="line">        size&#x3D;len(matrix)*len(matrix[0])</span><br><span class="line">        index&#x3D;0</span><br><span class="line">        result&#x3D;[0]*size</span><br><span class="line">        maxK&#x3D;len(matrix)+len(matrix[0])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        for k in range(maxK):</span><br><span class="line">            m,n&#x3D;0,0</span><br><span class="line">            if k%2&#x3D;&#x3D;0: # 偶数部分</span><br><span class="line">                if k&lt;len(matrix):</span><br><span class="line">                    m&#x3D;k</span><br><span class="line">                    n&#x3D;0</span><br><span class="line">                else:</span><br><span class="line">                    m&#x3D;len(matrix)-1</span><br><span class="line">                    n&#x3D;k-m</span><br><span class="line">                while m&gt;&#x3D;0 and n&lt;len(matrix[0]): # n到达边界为止</span><br><span class="line">                    result[index]&#x3D;matrix[m][n]</span><br><span class="line">                    index+&#x3D;1</span><br><span class="line">                    m-&#x3D;1</span><br><span class="line">                    n+&#x3D;1</span><br><span class="line">            else: # 奇数部分</span><br><span class="line">                if k&lt;len(matrix[0]):</span><br><span class="line">                    m&#x3D;0</span><br><span class="line">                    n&#x3D;k</span><br><span class="line">                else:</span><br><span class="line">                    n&#x3D;len(matrix[0])-1</span><br><span class="line">                    m&#x3D;k-n</span><br><span class="line">                while m&lt;len(matrix) and n&gt;&#x3D;0: # m到达边界为止</span><br><span class="line">                    result[index]&#x3D;matrix[m][n]</span><br><span class="line">                    index+&#x3D;1</span><br><span class="line">                    m+&#x3D;1</span><br><span class="line">                    n-&#x3D;1</span><br><span class="line">        return result</span><br></pre></td></tr></table></figure>

<h3 id="1424-对角线遍历-II"><a href="#1424-对角线遍历-II" class="headerlink" title="1424. 对角线遍历 II"></a>1424. 对角线遍历 II</h3><pre><code>链接：https://leetcode-cn.com/problems/diagonal-traverse-ii/solution/mei-ge-shu-zu-yuan-su-de-wei-zhi-jue-ding-liao-ta-/

给你一个列表 nums ，里面每一个元素都是一个整数列表。请你依照下面各图的规则，按顺序返回 nums 中对角线上的整数。

示例 1：

输入：nums = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,4,2,7,5,3,8,6,9]
示例 2：

输入：nums = [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]]
输出：[1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16]
示例 3：

输入：nums = [[1,2,3],[4],[5,6,7],[8],[9,10,11]]
输出：[1,4,2,5,3,8,6,9,7,10,11]
示例 4：

输入：nums = [[1,2,3,4,5,6]]
输出：[1,2,3,4,5,6]

提示：

1 &lt;= nums.length &lt;= 10^5
1 &lt;= nums[i].length &lt;= 10^5
1 &lt;= nums[i][j] &lt;= 10^9
nums 中最多有 10^5 个数字。</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findDiagonalOrder(self, nums: List[List[int]]) -&gt; List[int]:</span><br><span class="line">        sub&#x3D;[]</span><br><span class="line">        for i in range(len(nums)):</span><br><span class="line">            for j in range(len(nums[i])):</span><br><span class="line">                if i+j &gt;&#x3D; len(sub):</span><br><span class="line">                    sub.append([])</span><br><span class="line">                sub[i+j].append(nums[i][j])</span><br><span class="line">        result&#x3D;[]</span><br><span class="line">        for i in sub:</span><br><span class="line">            result+&#x3D;i[::-1]</span><br><span class="line">        return result</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/LeetCode/" rel="tag"># LeetCode</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92-%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0/" rel="prev" title="线性回归--从0开始实现">
      <i class="fa fa-chevron-left"></i> 线性回归--从0开始实现
    </a></div>
      <div class="post-nav-item">
    <a href="/LeetCode-3-%E6%A0%91-%E4%B8%80/" rel="next" title="LeetCode-3.树-一">
      LeetCode-3.树-一 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E6%95%B0%E7%BB%84"><span class="nav-number">1.</span> <span class="nav-text">一、数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">1.1.</span> <span class="nav-text">1.两数之和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0"><span class="nav-number">1.2.</span> <span class="nav-text">2.两数相加</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%9F%EF%BC%9F4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="nav-number">1.3.</span> <span class="nav-text">？？4.寻找两个有序数组的中位数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2"><span class="nav-number">1.4.</span> <span class="nav-text">6.Z字形变换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC"><span class="nav-number">1.5.</span> <span class="nav-text">7.整数反转</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0-atoi"><span class="nav-number">1.6.</span> <span class="nav-text">8.字符串转换整数(atoi)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E5%9B%9E%E6%96%87%E6%95%B0"><span class="nav-number">1.7.</span> <span class="nav-text">9.回文数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="nav-number">1.8.</span> <span class="nav-text">11.盛最多水的容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">1.9.</span> <span class="nav-text">15.三数之和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">1.10.</span> <span class="nav-text">16.最接近的三数之和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">1.11.</span> <span class="nav-text">18.四数之和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="nav-number">1.12.</span> <span class="nav-text">26.删除排序数组中的重复项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0"><span class="nav-number">1.13.</span> <span class="nav-text">27.移除元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#29-%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4"><span class="nav-number">1.14.</span> <span class="nav-text">29.两数相除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97"><span class="nav-number">1.15.</span> <span class="nav-text">31. 下一个排列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-II"><span class="nav-number">1.16.</span> <span class="nav-text">45. 跳跃游戏 II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F"><span class="nav-number">1.17.</span> <span class="nav-text">48.旋转图像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84"><span class="nav-number">1.18.</span> <span class="nav-text">49. 字母异位词分组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#66-%E5%8A%A0%E4%B8%80"><span class="nav-number">1.19.</span> <span class="nav-text">66. 加一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#69-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9"><span class="nav-number">1.20.</span> <span class="nav-text">69.x的平方根</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#73-%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6"><span class="nav-number">1.21.</span> <span class="nav-text">73. 矩阵置零</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="nav-number">1.22.</span> <span class="nav-text">88. 合并两个有序数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-II-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="nav-number">1.23.</span> <span class="nav-text">167. 两数之和 II - 输入有序数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#189-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="nav-number">1.24.</span> <span class="nav-text">189. 旋转数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#283-%E7%A7%BB%E5%8A%A8%E9%9B%B6"><span class="nav-number">1.25.</span> <span class="nav-text">283. 移动零</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#442-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-number">1.26.</span> <span class="nav-text">442. 数组中重复的数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#498-%E5%AF%B9%E8%A7%92%E7%BA%BF%E9%81%8D%E5%8E%86"><span class="nav-number">1.27.</span> <span class="nav-text">498. 对角线遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1424-%E5%AF%B9%E8%A7%92%E7%BA%BF%E9%81%8D%E5%8E%86-II"><span class="nav-number">1.28.</span> <span class="nav-text">1424. 对角线遍历 II</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Lilly</p>
  <div class="site-description" itemprop="description">Up in the wind!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">128</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lilly</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
