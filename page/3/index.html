<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"gongyanli.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Up in the wind!">
<meta property="og:type" content="website">
<meta property="og:title" content="茉莉Python">
<meta property="og:url" content="http://gongyanli.com/page/3/index.html">
<meta property="og:site_name" content="茉莉Python">
<meta property="og:description" content="Up in the wind!">
<meta property="og:locale">
<meta property="article:author" content="Lilly">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://gongyanli.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>茉莉Python</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">茉莉Python</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">voidqueens@hotmail.com</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/LeetCode-14-database/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/LeetCode-14-database/" class="post-title-link" itemprop="url">LeetCode-14-database</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-29 20:45:14" itemprop="dateCreated datePublished" datetime="2020-03-29T20:45:14+08:00">2020-03-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-18 22:36:54" itemprop="dateModified" datetime="2020-08-18T22:36:54+08:00">2020-08-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="十四、database"><a href="#十四、database" class="headerlink" title="十四、database"></a>十四、database</h2><pre><code>优先顺序：where&gt;group by&gt;having&gt;order by</code></pre>
<h3 id="182-查找重复的电子邮箱"><a href="#182-查找重复的电子邮箱" class="headerlink" title="182. 查找重复的电子邮箱"></a>182. 查找重复的电子邮箱</h3><pre><code>链接：https://leetcode-cn.com/problems/duplicate-emails/

SQL架构
编写一个 SQL 查询，查找 Person 表中所有重复的电子邮箱。

示例：

+----+---------+
| Id | Email   |
+----+---------+
| 1  | a@b.com |
| 2  | c@d.com |
| 3  | a@b.com |
+----+---------+
根据以上输入，你的查询应返回以下结果：

+---------+
| Email   |
+---------+
| a@b.com |
+---------+
说明：所有电子邮箱都是小写字母。</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"># 1.使用group by 和临时表</span><br><span class="line">select Email from</span><br><span class="line">(</span><br><span class="line">select Email, count(Email) as nums </span><br><span class="line">from Person</span><br><span class="line">group by Email</span><br><span class="line">) as tmp</span><br><span class="line">where nums&gt;1;</span><br><span class="line"># 2.使用group by和having条件</span><br><span class="line">select Email</span><br><span class="line">from Person</span><br><span class="line">group by Email</span><br><span class="line">having count(Email) &gt; 1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/LeetCode-13-%E6%95%B0%E5%AD%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/LeetCode-13-%E6%95%B0%E5%AD%A6/" class="post-title-link" itemprop="url">LeetCode-13-数学</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-29 20:12:16" itemprop="dateCreated datePublished" datetime="2020-03-29T20:12:16+08:00">2020-03-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-18 22:36:58" itemprop="dateModified" datetime="2020-08-18T22:36:58+08:00">2020-08-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="十三、数学"><a href="#十三、数学" class="headerlink" title="十三、数学"></a>十三、数学</h2><h3 id="172-阶乘后的零"><a href="#172-阶乘后的零" class="headerlink" title="172. 阶乘后的零"></a>172. 阶乘后的零</h3><pre><code>链接：https://leetcode-cn.com/problems/factorial-trailing-zeroes/

给定一个整数 n，返回 n! 结果尾数中零的数量。

示例 1:

输入: 3
输出: 0
解释: 3! = 6, 尾数中没有零。
示例 2:

输入: 5
输出: 1
解释: 5! = 120, 尾数中有 1 个零.
说明: 你算法的时间复杂度应为 O(log n) 。</code></pre>
<p>题解一：</p>
<p>如果依靠算出阶乘结果，再计算有多少个0，很容易溢出。</p>
<p>思路：末尾有多少个0，只需要给当前数乘以一个10，就可以加一个0.</p>
<p>比如5!，也就是 5 * 4 * 3 * 2 * 1 = 120，我们发现结果会有一个 0，原因就是 2 和 5 相乘构成了一个 10。而对于 10 的话，其实也只有 2 * 5 可以构成，所以我们只需要找有多少对 2/5。</p>
<p>11! = 11 * 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1 = 11 * (2 * 5) * 9 * (4 * 2) * 7 * (3 * 2) * (1 * 5) * (2 * 2) * 3 * (1 * 2) * 1</p>
<p>对于含有 2 的因子的话是 1 * 2, 2 * 2, 3 * 2, 4 * 2 …</p>
<p>对于含有 5 的因子的话是 1 * 5, 2 * 5…</p>
<p>含有 2 的因子每两个出现一次，含有 5 的因子每 5 个出现一次，所有 2 出现的个数远远多于 5，换言之找到一个 5，一定能找到一个 2 与之配对。所以我们只需要找有多少个 5。</p>
<p>直接的，我们只需要判断每个累乘的数有多少个 5 的因子即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def trailingZeroes(self, n: int) -&gt; int:</span><br><span class="line">        count&#x3D;0</span><br><span class="line">        for i in range(n+1):</span><br><span class="line">            tmp&#x3D;i</span><br><span class="line">            while tmp&gt;0:</span><br><span class="line">                if tmp%5&#x3D;&#x3D;0:</span><br><span class="line">                    count+&#x3D;1</span><br><span class="line">                    tmp&#x2F;&#x2F;&#x3D;5</span><br><span class="line">                else:</span><br><span class="line">                    break</span><br><span class="line">        return count</span><br></pre></td></tr></table></figure>

<p>以上算法超时，继续优化。</p>
<p>对于一个数的阶乘，5 的因子一定是每隔 5 个数出现一次，也就是下边的样子。</p>
<pre><code>n! = 1 * 2 * 3 * 4 * (1 * 5) * ... * (2 * 5) * ... * (3 * 5) *... * n</code></pre>
<p>因为每隔 5 个数出现一个 5，所以计算出现了多少个 5，我们只需要用 n/5 就可以算出来。</p>
<p>但还没有结束，继续分析。</p>
<pre><code>... * (1 * 5) * ... * (1 * 5 * 5) * ... * (2 * 5 * 5) * ... * (3 * 5 * 5) * ... * n</code></pre>
<p>每隔 25 个数字，出现的是两个 5，所以除了每隔 5 个数算作一个 5，每隔 25 个数，还需要多算一个 5。</p>
<p>也就是我们需要再加上 n / 25 个 5。</p>
<p>同理我们还会发现每隔 5 * 5 * 5 = 125 个数字，会出现 3 个 5，所以我们还需要再加上 n / 125 。</p>
<p>综上，规律就是每隔 5 个数，出现一个 5，每隔 25 个数，出现 2 个 5，每隔 125 个数，出现 3 个 5，以此类推。</p>
<p>最终 5 的个数就是 n / 5 + n / 25 + n / 125 …</p>
<p>写程序的话，如果直接按照上边的式子计算，分母可能会造成溢出。所以算 n / 25 的时候，我们先把 n 更新，n = n / 5，然后再计算 n / 5 即可，后边的同理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def trailingZeroes(self, n: int) -&gt; int:</span><br><span class="line">        count&#x3D;0</span><br><span class="line">        while n&gt;0:</span><br><span class="line">            count+&#x3D;n&#x2F;&#x2F;5</span><br><span class="line">            n&#x2F;&#x2F;&#x3D;5</span><br><span class="line">        return count</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/LeetCode-12-%E5%AD%97%E7%AC%A6%E4%B8%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/LeetCode-12-%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="post-title-link" itemprop="url">LeetCode-12-字符串</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-28 23:45:50" itemprop="dateCreated datePublished" datetime="2020-03-28T23:45:50+08:00">2020-03-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-01 12:01:03" itemprop="dateModified" datetime="2020-09-01T12:01:03+08:00">2020-09-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>常用函数：</p>
<pre><code>bin() # 十进制转二进制
oct() # 十进制转八进制
hex() # 十进制转十六进制

chr() # 数字转字符串(ascii)
ord() # 字符串(ascii)转数字

65--&#39;A&#39;
97--&#39;a&#39;</code></pre>
<h2 id="十二、字符串"><a href="#十二、字符串" class="headerlink" title="十二、字符串"></a>十二、字符串</h2><h3 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="?5.最长回文子串"></a>?5.最长回文子串</h3><pre><code>链接：https://leetcode-cn.com/problems/longest-palindromic-substring/

给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

示例 1：

输入: &quot;babad&quot;
输出: &quot;bab&quot;
注意: &quot;aba&quot; 也是一个有效答案。
示例 2：

输入: &quot;cbbd&quot;
输出: &quot;bb&quot;</code></pre>
<p>题解一|暴力破解：<br>    很明显，暴力法将选出所有子字符串可能的开始和结束位置，并检验它是不是回文。<br>    时间复杂度：O(n^2),往往利用python的切片可以很好的缩减复杂度<br>    如果不用切片，还需要遍历一次子字符串，时间复杂度就是O(n^3)<br>    空间复杂度：O(1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def longestPalindrome(self, s: str) -&gt; str:</span><br><span class="line">        if s&#x3D;&#x3D;s[::-1]:</span><br><span class="line">            return s</span><br><span class="line"></span><br><span class="line">        maxLen&#x3D;1</span><br><span class="line">        ans&#x3D;s[0]</span><br><span class="line">        for i in range(0,len(s)-1):</span><br><span class="line">            for j in range(i+1,len(s)):</span><br><span class="line">                if j-i+1 &gt; maxLen and self.isPalindrome(s[i:j+1]):</span><br><span class="line">                    maxLen&#x3D;j-i+1</span><br><span class="line">                    ans&#x3D;s[i:j+1]</span><br><span class="line">        return ans</span><br><span class="line"></span><br><span class="line">    def isPalindrome(self, s: str) -&gt; bool:</span><br><span class="line">        left,right&#x3D;0,len(s)-1</span><br><span class="line">        while left&lt;right:</span><br><span class="line">            while left&lt;len(s) and not s[left].isalnum():</span><br><span class="line">                left+&#x3D;1</span><br><span class="line">            while right &gt;-1 and not s[right].isalnum():</span><br><span class="line">                right-&#x3D;1</span><br><span class="line">            if left&gt;right:</span><br><span class="line">                return True</span><br><span class="line">            if s[left].upper() !&#x3D; s[right].upper():</span><br><span class="line">                return False</span><br><span class="line">            else:</span><br><span class="line">                left+&#x3D;1</span><br><span class="line">                right-&#x3D;1</span><br><span class="line">        return True</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def longestPalindrome(self, s: str) -&gt; str:</span><br><span class="line">        if s&#x3D;&#x3D;s[::-1]:</span><br><span class="line">            return s</span><br><span class="line"></span><br><span class="line">        maxLen&#x3D;1</span><br><span class="line">        ans&#x3D;s[0]</span><br><span class="line">        for i in range(0,len(s)-1):</span><br><span class="line">            for j in range(i+1,len(s)):</span><br><span class="line">                if j-i+1 &gt; maxLen and s[i:j+1]&#x3D;&#x3D;s[i:j+1][::-1]: # arr&#x3D;&#39;abb&#39;,arr[0:1]&#x3D;&#39;a&#39;,右边是开区间</span><br><span class="line">                    maxLen&#x3D;j-i+1</span><br><span class="line">                    ans&#x3D;s[i:j+1]</span><br><span class="line">        return ans</span><br></pre></td></tr></table></figure>

<p>题解二：</p>
<pre><code>每个字母当成回文串的中心
考虑两种情况:回文串的长度为奇数或者偶数情况。</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def longestPalindrome(self, s: str) -&gt; str:</span><br><span class="line">        n&#x3D;len(s)</span><br><span class="line">        self.res&#x3D;&#39;&#39;</span><br><span class="line">        def helper(i,j):</span><br><span class="line">            while i&gt;&#x3D; 0 and j&lt;n and s[i]&#x3D;&#x3D;s[j]:</span><br><span class="line">                i-&#x3D;1</span><br><span class="line">                j+&#x3D;1</span><br><span class="line">            if len(self.res) &lt; j-i-1:</span><br><span class="line">                self.res&#x3D;s[i+1:j]</span><br><span class="line">                # print(i,self.res)</span><br><span class="line">        </span><br><span class="line">        for i in range(n):</span><br><span class="line">            helper(i,i)</span><br><span class="line">            helper(i,i+1) # 解决case为&quot;cbbd&quot;,即解决回文串为偶数的情况</span><br><span class="line">        return self.res</span><br></pre></td></tr></table></figure>

<p>题解三：</p>
<pre><code>把每个字母当成回文串的结束</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def longestPalindrome(self, s: str) -&gt; str:</span><br><span class="line">        if not s:</span><br><span class="line">            return &quot;&quot;</span><br><span class="line">        max_len &#x3D; 1</span><br><span class="line">        n &#x3D; len(s)</span><br><span class="line">        start &#x3D; 0</span><br><span class="line">        for i in range(1,n):</span><br><span class="line">            even &#x3D; s[i-max_len:i+1]</span><br><span class="line">            odd &#x3D; s[i - max_len-1:i+1]</span><br><span class="line">            #print(even,odd)</span><br><span class="line">            if i - max_len - 1 &gt;&#x3D; 0 and odd &#x3D;&#x3D; odd[::-1]:</span><br><span class="line">                start &#x3D; i - max_len - 1</span><br><span class="line">                max_len +&#x3D; 2</span><br><span class="line">            elif i - max_len &gt;&#x3D;0 and even &#x3D;&#x3D; even[::-1]:</span><br><span class="line">                start &#x3D; i - max_len</span><br><span class="line">                max_len +&#x3D; 1</span><br><span class="line">                </span><br><span class="line">        #print(start,max_len)</span><br><span class="line">        return s[start: start+max_len]</span><br></pre></td></tr></table></figure>

<p>题解二（动态规划）：<br><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/dp.png"></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/">https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/</a></p>
<pre><code>1、定义数组的定义
    dp[i][j] 表示子串 s[i, j] 是否为回文子串。
2、找出数组的关系式
    dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1]
3、找到初始值</code></pre>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/gao-hao-dong-tai-gui-hua-he-zhong-xin-tuo-zhan-zhu/">https://leetcode-cn.com/problems/longest-palindromic-substring/solution/gao-hao-dong-tai-gui-hua-he-zhong-xin-tuo-zhan-zhu/</a></p>
<h3 id="12-整数转罗马数字"><a href="#12-整数转罗马数字" class="headerlink" title="12.整数转罗马数字"></a>12.整数转罗马数字</h3><pre><code>链接：https://leetcode-cn.com/problems/integer-to-roman/

罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。

字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。

示例 1:

输入: 3
输出: &quot;III&quot;
示例 2:

输入: 4
输出: &quot;IV&quot;
示例 3:

输入: 9
输出: &quot;IX&quot;
示例 4:

输入: 58
输出: &quot;LVIII&quot;
解释: L = 50, V = 5, III = 3.
示例 5:

输入: 1994
输出: &quot;MCMXCIV&quot;
解释: M = 1000, CM = 900, XC = 90, IV = 4.</code></pre>
<p>题解一(贪心算法)：<br><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/rome.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def intToRoman(self, num: int) -&gt; str:</span><br><span class="line">        # dicts&#x3D;&#123;&#39;I&#39;:1,&#39;V&#39;:5,&#39;X&#39;:10,&#39;L&#39;:50,&#39;C&#39;:100,&#39;D&#39;:500,&#39;M&#39;:1000&#125;</span><br><span class="line">        dicts&#x3D;&#123;1:&#39;I&#39;,4:&#39;IV&#39;,5:&#39;V&#39;,9:&#39;IX&#39;,10:&#39;X&#39;,40:&#39;XL&#39;,50:&#39;L&#39;,90:&#39;XC&#39;,100:&#39;C&#39;,400:&#39;CD&#39;,500:&#39;D&#39;,900:&#39;CM&#39;,1000:&#39;M&#39; &#125;</span><br><span class="line">        ans&#x3D;&#39;&#39;</span><br><span class="line">        for key in sorted(dicts.keys())[::-1]:</span><br><span class="line">            if num&#x3D;&#x3D;0:</span><br><span class="line">                break</span><br><span class="line">            tmp&#x3D;num&#x2F;&#x2F;key</span><br><span class="line">            if tmp&#x3D;&#x3D;0:</span><br><span class="line">                continue</span><br><span class="line">            ans+&#x3D;dicts[key]*tmp</span><br><span class="line">            num-&#x3D;key*tmp</span><br><span class="line">        return ans</span><br></pre></td></tr></table></figure>

<h3 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13.罗马数字转整数"></a>13.罗马数字转整数</h3><pre><code>链接：https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/rome.png

罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。

字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。

示例 1:

输入: &quot;III&quot;
输出: 3
示例 2:

输入: &quot;IV&quot;
输出: 4
示例 3:

输入: &quot;IX&quot;
输出: 9
示例 4:

输入: &quot;LVIII&quot;
输出: 58
解释: L = 50, V= 5, III = 3.
示例 5:

输入: &quot;MCMXCIV&quot;
输出: 1994
解释: M = 1000, CM = 900, XC = 90, IV = 4.</code></pre>
<p>题解一(hash)：<br>    首先建立一个HashMap来映射符号和值，然后对字符串从左到右来，如果当前字符代表的值小于其右边，就减去该值；否则就加上该值，以此类推到最右边的数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def romanToInt(self, s: str) -&gt; int:</span><br><span class="line">        arr&#x3D;&#123;&#39;I&#39;:1,&#39;V&#39;:5,&#39;X&#39;:10,&#39;L&#39;:50,&#39;C&#39;:100,&#39;D&#39;:500,&#39;M&#39;:1000&#125;</span><br><span class="line">        ans&#x3D;0</span><br><span class="line">        for i in range(len(s)):</span><br><span class="line">            if i&lt;len(s)-1 and arr[s[i]]&lt;arr[s[i+1]]:</span><br><span class="line">                ans-&#x3D;arr[s[i]]</span><br><span class="line">            else:</span><br><span class="line">                ans+&#x3D;arr[s[i]]</span><br><span class="line">        return ans</span><br></pre></td></tr></table></figure>
<p>题解二（hash）：<br>    # 构建一个字典记录所有罗马数字子串，注意长度为2的子串记录的值是（实际值 - 子串内左边罗马数字代表的数值）</p>
<pre><code># 然后，遍历整个 s 的时候判断当前位置和前一个位置的两个字符组成的字符串是否在字典内，如果在就记录值，不在就说明当前位置不存在小数字在前面的情况，直接记录当前位置字符对应值

# 举个例子，遍历经过 IV 的时候先记录 I 的对应值 1，再往前移动一步记录 IV 的值 3，加起来正好是 IV 的真实值 4。max 函数在这里是为了防止遍历第一个字符的时候出现 [-1:0] 的情况，因为s[-1:0]为空。</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def romanToInt(self, s: str) -&gt; int:</span><br><span class="line">        arr&#x3D;&#123;&#39;I&#39;:1,&#39;IV&#39;:3,&#39;V&#39;:5,&#39;IX&#39;:8,&#39;X&#39;:10,&#39;XL&#39;:30,&#39;L&#39;:50,&#39;XC&#39;:80,&#39;C&#39;:100,&#39;CD&#39;:300,&#39;D&#39;:500,&#39;CM&#39;:800,&#39;M&#39;:1000&#125;</span><br><span class="line">        return sum(arr.get(s[max(i-1,0):i+1],arr[v]) for i,v in enumerate(s))</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def romanToInt(self, s: str) -&gt; int:</span><br><span class="line">        arr&#x3D;&#123;&#39;I&#39;:1,&#39;IV&#39;:3,&#39;V&#39;:5,&#39;IX&#39;:8,&#39;X&#39;:10,&#39;XL&#39;:30,&#39;L&#39;:50,&#39;XC&#39;:80,&#39;C&#39;:100,&#39;CD&#39;:300,&#39;D&#39;:500,&#39;CM&#39;:800,&#39;M&#39;:1000&#125;</span><br><span class="line">        ans&#x3D;0</span><br><span class="line">        for i,v in enumerate(s):</span><br><span class="line">            ans+&#x3D;arr.get(s[i-1:i+1],arr[v])</span><br><span class="line">        return ans</span><br></pre></td></tr></table></figure>


<p>?### 14.最长公共前缀<br>    链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-common-prefix/">https://leetcode-cn.com/problems/longest-common-prefix/</a></p>
<pre><code>编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 &quot;&quot;。

示例 1:

输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]
输出: &quot;fl&quot;
示例 2:

输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]
输出: &quot;&quot;
解释: 输入不存在公共前缀。
说明:

所有输入只包含小写字母 a-z 。</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lz_901/article/details/89021210">https://blog.csdn.net/lz_901/article/details/89021210</a><br>题解一(水平扫描)：</p>
<pre><code>1、先找出 str1 和 str2（注：str1代表第一个字符串，str2代表第二个） 的公共字符串 s1。

2、然后再找出 s1 和 str3 的公共前缀 s2。

3、然后再找出 s2 和 str4 的公共前缀 s3。

4、一直这样遍历重复，用一个变量来保存两个两个字符串之间的公共前缀。</code></pre>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/lcp1.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/lcp1.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def longestCommonPrefix(self, strs: List[str]) -&gt; str:</span><br><span class="line">        # if not strs:</span><br><span class="line">        #     return &#39;&#39;</span><br><span class="line">        # res&#x3D;&#39;&#39;</span><br><span class="line">        # for i in range(0,len(strs[0])):</span><br><span class="line">        #     c&#x3D;strs[0][i]</span><br><span class="line">        #     for j in range(1,len(strs)):</span><br><span class="line">        #         if i &#x3D;&#x3D; len(str[j]) or c !&#x3D; strs[j][i] </span><br><span class="line">        #             return res</span><br><span class="line">        #     res+&#x3D;c</span><br><span class="line">        if not strs:</span><br><span class="line">            return &#39;&#39;</span><br><span class="line">        prefix&#x3D;strs[0]</span><br><span class="line">        for i in range(1,len(strs)):</span><br><span class="line">            while strs[i].find(prefix) !&#x3D; 0: # 此题是寻找最长公共前缀，所以需要找到开始索引是0.</span><br><span class="line">                prefix&#x3D;prefix[0:len(prefix)-1]</span><br><span class="line">                if prefix&#x3D;&#x3D;&#39;&#39;:</span><br><span class="line">                    return &#39;&#39;</span><br><span class="line">        return prefix</span><br></pre></td></tr></table></figure>

<p>find()语法：</p>
<pre><code>str.find(str, beg=0, end=len(string))

参数：
    str -- 指定检索的字符串
    beg -- 开始索引，默认为0。
    end -- 结束索引，默认为字符串的长度。

返回值：
    如果包含子字符串返回开始的索引值，否则返回-1。</code></pre>
<p>题解二(水平扫描优化)：</p>
<pre><code>想象数组的末尾有一个非常短的字符串，使用上述方法仍旧会进行S次比较。
优化这类情况的方法是水平扫描，从前往后枚举字符串的每一列，先比较每个字符串相同列上的字符（即不同字符串相同下标的字符），然后再进行下一列的比较。

我们不横向一个一个字符串遍历，而是采用纵向的方式。例如对于这个[&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]，我们把它看成一个二维字符数组。

然后纵向遍历，一列一列遍历，只要发现某一列出现不同的字符，就遍历结束，例如上面这个例子中，第三列就出现不同了，所以遍历结束，把前两列返回。</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def longestCommonPrefix(self, strs: List[str]) -&gt; str:</span><br><span class="line">        if(not strs):</span><br><span class="line">            return &quot;&quot;</span><br><span class="line">        for i in range(len(strs[0])):</span><br><span class="line">            c&#x3D;strs[0][i]</span><br><span class="line">            for j in range(len(strs)):</span><br><span class="line">                if i&#x3D;&#x3D;len(strs[j]) or strs[j][i] !&#x3D; c:</span><br><span class="line">                    return strs[0][0:i]</span><br><span class="line">        return strs[0]</span><br></pre></td></tr></table></figure>

<p>题解三（分治）：</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/lcp2.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/lcp2.png"></p>
<p>复杂度：<br><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/lcp3.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/lcp3.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def longestCommonPrefix(self, strs: List[str]) -&gt; str:</span><br><span class="line">        def commonPrefix(l, r):</span><br><span class="line">            &#39;&#39;&#39;</span><br><span class="line">            治：从首位开始对比</span><br><span class="line">            :param l:</span><br><span class="line">            :param r:</span><br><span class="line">            :return:</span><br><span class="line">            &#39;&#39;&#39;</span><br><span class="line">            minlen &#x3D; min(len(l), len(r))</span><br><span class="line">            for i in range(minlen):</span><br><span class="line">                if l[i] !&#x3D; r[i]:</span><br><span class="line">                    return l[0:i]</span><br><span class="line">            return l[0:minlen]</span><br><span class="line"></span><br><span class="line">        def lcp(strs, l, r):</span><br><span class="line">            &#39;&#39;&#39;</span><br><span class="line">            分：分为小问题</span><br><span class="line">            :param strs:</span><br><span class="line">            :param l:</span><br><span class="line">            :param r:</span><br><span class="line">            :return:</span><br><span class="line">            &#39;&#39;&#39;</span><br><span class="line"></span><br><span class="line">            # 递归弹出</span><br><span class="line">            if l &#x3D;&#x3D; r:</span><br><span class="line">                return strs[l]</span><br><span class="line">            # 继续分</span><br><span class="line">            else:</span><br><span class="line">                mid &#x3D; (l + r) &#x2F;&#x2F; 2</span><br><span class="line">                left &#x3D; lcp(strs, l, mid)</span><br><span class="line">                right &#x3D; lcp(strs, mid + 1, r)</span><br><span class="line">                return commonPrefix(left, right)</span><br><span class="line"></span><br><span class="line">        if not strs:</span><br><span class="line">            return &#39;&#39;</span><br><span class="line">        return lcp(strs, 0, len(strs) - 1)</span><br></pre></td></tr></table></figure>

<p>题解四（zip）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def longestCommonPrefix(self, strs: List[str]) -&gt; str:</span><br><span class="line">        # print(strs)</span><br><span class="line">        # print(*strs)</span><br><span class="line">        res&#x3D;&#39;&#39;</span><br><span class="line">        for i in zip(*strs):</span><br><span class="line">            # print(i)</span><br><span class="line">            if len(set(i))&#x3D;&#x3D;1:</span><br><span class="line">                res+&#x3D;i[0]</span><br><span class="line">            else:</span><br><span class="line">                break</span><br><span class="line">        return res</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[&#39;flower&#39;, &#39;flow&#39;, &#39;flight&#39;]</span><br><span class="line">flower flow flight</span><br><span class="line">(&#39;f&#39;, &#39;f&#39;, &#39;f&#39;)</span><br><span class="line">(&#39;l&#39;, &#39;l&#39;, &#39;l&#39;)</span><br><span class="line">(&#39;o&#39;, &#39;o&#39;, &#39;i&#39;)</span><br></pre></td></tr></table></figure>

<p>zip()语法：</p>
<pre><code>zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表(python2)/对象(python3)。

如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。

zip 方法在 Python 2 和 Python 3 中的不同：在 Python 3.x 中为了减少内存，zip() 返回的是一个对象。如需展示列表，需手动 list() 转换。在 Python 2.x zip() 返回的是一个列表。

zip([iterable, ...])

参数说明：
    iterabl -- 一个或多个迭代器;
返回值:
返回元组列表/一个对象。</code></pre>
<p>题解五（max和min）：</p>
<p>max()和min()在python字符串中是可以比较的，按照ascii值排序，比如abb，aba，abac，最大为abb，最小为aba。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def longestCommonPrefix(self, strs: List[str]) -&gt; str:</span><br><span class="line">        if not strs:</span><br><span class="line">            return &#39;&#39;</span><br><span class="line">        s1&#x3D;min(strs)</span><br><span class="line">        s2&#x3D;max(strs)</span><br><span class="line">        for i,v in enumerate(s1):</span><br><span class="line">            if v !&#x3D; s2[i]:</span><br><span class="line">                return s1[:i]</span><br><span class="line">        return s1</span><br></pre></td></tr></table></figure>

<h3 id="28-实现-strStr"><a href="#28-实现-strStr" class="headerlink" title="28. 实现 strStr()"></a>28. 实现 strStr()</h3><pre><code>链接：https://leetcode-cn.com/problems/implement-strstr/

实现 strStr() 函数。

给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。

示例 1:

输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;
输出: 2
示例 2:

输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;
输出: -1
说明:

当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</code></pre>
<p>题解一(子串逐一比较 - 线性时间复杂度)：</p>
<p>思路：沿着字符换逐步移动滑动窗口，将窗口内的子串与 needle 字符串比较。</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/str1.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/str1.png"></p>
<p>时间复杂度：O((N - L)L)，其中 N 为 haystack 字符串的长度，L 为 needle 字符串的长度。内循环中比较字符串的复杂度为 L，总共需要比较 (N - L) 次。<br>空间复杂度：O(1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def strStr(self, haystack: str, needle: str) -&gt; int:</span><br><span class="line">        n,length&#x3D;len(haystack),len(needle)</span><br><span class="line">        for i in range(n-length+1):</span><br><span class="line">            if haystack[i:i+length]&#x3D;&#x3D;needle:</span><br><span class="line">                return i</span><br><span class="line">        return -1</span><br></pre></td></tr></table></figure>

<p>？？题解二（双指针 - 线性时间复杂度）：</p>
<p>题解一的缺陷是会将 haystack 所有长度为 L 的子串都与 needle 字符串比较，实际上是不需要这么做的。</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/str.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/str.png"></p>
<pre><code>首先，只有子串的第一个字符跟 needle 字符串第一个字符相同的时候才需要比较。

其次，可以一个字符一个字符比较，一旦不匹配了就立刻终止。

比较到最后一位时发现不匹配，这时候开始回溯。需要注意的是，pn 指针是移动到 pn = pn - curr_len + 1 的位置，而 不是 pn = pn - curr_len 的位置。

这时候再比较一次，就找到了完整匹配的子串，直接返回子串的开始位置 pn - L。</code></pre>
<p>思路：</p>
<pre><code>移动 pn 指针，直到 pn 所指向位置的字符与 needle 字符串第一个字符相等。

通过 pn，pL，curr_len 计算匹配长度。

如果完全匹配（即 curr_len == L），返回匹配子串的起始坐标（即 pn - L）。

如果不完全匹配，回溯。使 pn = pn - curr_len + 1， pL = 0， curr_len = 0。</code></pre>
<p>时间复杂度：最坏时间复杂度为 O((N - L)L)，最优时间复杂度为 O(N)。<br>空间复杂度：O(1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def strStr(self, haystack: str, needle: str) -&gt; int:</span><br><span class="line">        L, n &#x3D; len(needle), len(haystack)</span><br><span class="line">        if L &#x3D;&#x3D; 0:</span><br><span class="line">            return 0</span><br><span class="line"></span><br><span class="line">        pn &#x3D; 0</span><br><span class="line">        while pn &lt; n - L + 1:</span><br><span class="line">            # find the position of the first needle character</span><br><span class="line">            # in the haystack string</span><br><span class="line">            while pn &lt; n - L + 1 and haystack[pn] !&#x3D; needle[0]:</span><br><span class="line">                pn +&#x3D; 1</span><br><span class="line">            </span><br><span class="line">            # compute the max match string</span><br><span class="line">            curr_len &#x3D; pL &#x3D; 0</span><br><span class="line">            while pL &lt; L and pn &lt; n and haystack[pn] &#x3D;&#x3D; needle[pL]:</span><br><span class="line">                pn +&#x3D; 1</span><br><span class="line">                pL +&#x3D; 1</span><br><span class="line">                curr_len +&#x3D; 1</span><br><span class="line">            </span><br><span class="line">            # if the whole needle string is found,</span><br><span class="line">            # return its start position</span><br><span class="line">            if curr_len &#x3D;&#x3D; L:</span><br><span class="line">                return pn - L</span><br><span class="line">            </span><br><span class="line">            # otherwise, backtrack</span><br><span class="line">            pn &#x3D; pn - curr_len + 1</span><br><span class="line">            </span><br><span class="line">        return -1</span><br></pre></td></tr></table></figure>

<p>？？？题解三（KMP）：<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-strstr/solution/kmphua-48xiao-shi-kan-dong-liao-kmpxiang-rang-ni-z/">https://leetcode-cn.com/problems/implement-strstr/solution/kmphua-48xiao-shi-kan-dong-liao-kmpxiang-rang-ni-z/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Px411z7Yo?from=search&amp;seid=13225444196686531503">https://www.bilibili.com/video/BV1Px411z7Yo?from=search&amp;seid=13225444196686531503</a><br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1hW411a7ys/?spm_id_from=333.788.videocard.0">https://www.bilibili.com/video/BV1hW411a7ys/?spm_id_from=333.788.videocard.0</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def strStr(self, haystack: str, needle: str) -&gt; int:</span><br><span class="line">        if not needle:</span><br><span class="line">            return 0</span><br><span class="line">        next&#x3D;self.getNext(needle)</span><br><span class="line">        i&#x3D;j&#x3D;0</span><br><span class="line">        while i&lt;len(haystack) and j&lt;len(needle):</span><br><span class="line">            if j&#x3D;&#x3D;-1 or haystack[i]&#x3D;&#x3D;needle[j]:</span><br><span class="line">                i+&#x3D;1</span><br><span class="line">                j+&#x3D;1</span><br><span class="line">            else:</span><br><span class="line">                j&#x3D;next[j]</span><br><span class="line">        if j&#x3D;&#x3D;len(needle):</span><br><span class="line">            return i-j</span><br><span class="line">        else:</span><br><span class="line">            return -1</span><br><span class="line">    def getNext(self,needle):</span><br><span class="line">        next&#x3D;[0]*len(needle)</span><br><span class="line">        next[0]&#x3D;-1</span><br><span class="line">        print(next)</span><br><span class="line">        i&#x3D;0</span><br><span class="line">        j&#x3D;-1</span><br><span class="line">        while i&lt;len(needle)-1:</span><br><span class="line">            if j&#x3D;&#x3D;-1 or needle[i]&#x3D;&#x3D;needle[j]:</span><br><span class="line">                i+&#x3D;1</span><br><span class="line">                j+&#x3D;1</span><br><span class="line">                next[i]&#x3D;j</span><br><span class="line">            else:</span><br><span class="line">                j&#x3D;next[j]</span><br><span class="line">        return next</span><br></pre></td></tr></table></figure>

<p>题解四：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def strStr(self, haystack: str, needle: str) -&gt; int:</span><br><span class="line">        i&#x3D;haystack.find(needle)</span><br><span class="line">        return i</span><br></pre></td></tr></table></figure>

<h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h3><pre><code>链接：https://leetcode-cn.com/problems/valid-parentheses/

给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;&#123;&#39;，&#39;&#125;&#39;，&#39;[&#39;，&#39;]&#39; 的字符串，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
注意空字符串可被认为是有效字符串。

示例 1:

输入: &quot;()&quot;
输出: true
示例 2:

输入: &quot;()[]&#123;&#125;&quot;
输出: true
示例 3:

输入: &quot;(]&quot;
输出: false
示例 4:

输入: &quot;([)]&quot;
输出: false
示例 5:

输入: &quot;&#123;[]&#125;&quot;
输出: true</code></pre>
<p>题解一：</p>
<p>时间复杂度：O(N)。遍历了一遍字符串。<br>空间复杂度：O(N)。最坏情况下，假如输入是 (((((((，栈的大小将是输入字符串的长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isValid(self, s: str) -&gt; bool:</span><br><span class="line">        dict &#x3D; &#123;&#39;)&#39;:&#39;(&#39;,&#39;]&#39;:&#39;[&#39;,&#39;&#125;&#39;:&#39;&#123;&#39;&#125;</span><br><span class="line">        stack&#x3D;[]</span><br><span class="line">        for i in s:</span><br><span class="line">            if stack and i in dict:</span><br><span class="line">                if stack[-1] &#x3D;&#x3D; dict[i]:</span><br><span class="line">                    stack.pop()</span><br><span class="line">                else:</span><br><span class="line">                    return False</span><br><span class="line">            else:</span><br><span class="line">                stack.append(i)</span><br><span class="line">        return not stack</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isValid(self, s: str) -&gt; bool:</span><br><span class="line">        dicts&#x3D;&#123;&#39;(&#39;:1,&#39;)&#39;:-1,&#39;&#123;&#39;:2,&#39;&#125;&#39;:-2,&#39;[&#39;:3,&#39;]&#39;:-3&#125;</span><br><span class="line">        list&#x3D;[]</span><br><span class="line">        for i in s:</span><br><span class="line">            if len(list)&#x3D;&#x3D;0:</span><br><span class="line">                list.append(i)</span><br><span class="line">            elif dicts[i]+dicts[list[-1]]&#x3D;&#x3D;0:</span><br><span class="line">                del list[-1]</span><br><span class="line">            else:</span><br><span class="line">                list.append(i)</span><br><span class="line">        return len(list)&#x3D;&#x3D;0</span><br></pre></td></tr></table></figure>

<h3 id="38-外观数列"><a href="#38-外观数列" class="headerlink" title="38. 外观数列"></a>38. 外观数列</h3><pre><code>链接：https://leetcode-cn.com/problems/count-and-say/

「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：

1.     1
2.     11
3.     21
4.     1211
5.     111221
1 被读作  &quot;one 1&quot;  (&quot;一个一&quot;) , 即 11。
11 被读作 &quot;two 1s&quot; (&quot;两个一&quot;）, 即 21。
21 被读作 &quot;one 2&quot;,  &quot;one 1&quot; （&quot;一个二&quot; ,  &quot;一个一&quot;) , 即 1211。

给定一个正整数 n（1 ≤ n ≤ 30），输出外观数列的第 n 项。

注意：整数序列中的每一项将表示为一个字符串。

示例 1:

输入: 1
输出: &quot;1&quot;
解释：这是一个基本样例。
示例 2:

输入: 4
输出: &quot;1211&quot;
解释：当 n = 3 时，序列是 &quot;21&quot;，其中我们有 &quot;2&quot; 和 &quot;1&quot; 两组，&quot;2&quot; 可以读作 &quot;12&quot;，也就是出现频次 = 1 而 值 = 2；类似 &quot;1&quot; 可以读作 &quot;11&quot;。所以答案是 &quot;12&quot; 和 &quot;11&quot; 组合在一起，也就是 &quot;1211&quot;。</code></pre>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/106149461">https://zhuanlan.zhihu.com/p/106149461</a></p>
<p>题解一（递归）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def countAndSay(self, n: int) -&gt; str:</span><br><span class="line">        # 初始条件</span><br><span class="line">        if n&#x3D;&#x3D;1:</span><br><span class="line">            return &#39;1&#39;</span><br><span class="line">        print(&#39;调用前：&#39;,n)</span><br><span class="line">        pre&#x3D;self.countAndSay(n-1) # 得到上一行的字符串</span><br><span class="line">        print(&#39;调用后：&#39;,n,pre)</span><br><span class="line">        res&#x3D;&#39;&#39;</span><br><span class="line">        count&#x3D;1</span><br><span class="line">        length&#x3D;len(pre)</span><br><span class="line">        for i in range(1,length):</span><br><span class="line">            if pre[i] !&#x3D; pre[i-1]:</span><br><span class="line">                res+&#x3D;str(count)+pre[i-1]</span><br><span class="line">                count&#x3D;1</span><br><span class="line">            else:</span><br><span class="line">                count+&#x3D;1</span><br><span class="line">        print(pre[length-1])</span><br><span class="line">        res+&#x3D;str(count)+pre[length-1]</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<pre><code>调用前： 5
调用前： 4
调用前： 3
调用前： 2
调用后： 2 1
1
调用后： 3 11
1
调用后： 4 21
1
调用后： 5 1211
1</code></pre>
<p>题解二（迭代）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def countAndSay(self, n: int) -&gt; str:</span><br><span class="line">        res&#x3D;&#39;1&#39;</span><br><span class="line">        while n-1&gt;0:</span><br><span class="line">            tmp&#x3D;&#39;&#39;</span><br><span class="line">            pre&#x3D;res[0]</span><br><span class="line">            count&#x3D;0 # count&#x3D;0</span><br><span class="line">            for i in range(len(res)): # 从0开始</span><br><span class="line">                if pre&#x3D;&#x3D;res[i]:</span><br><span class="line">                    count+&#x3D;1</span><br><span class="line">                else:</span><br><span class="line">                    tmp+&#x3D;str(count)+pre</span><br><span class="line">                    pre&#x3D;res[i]</span><br><span class="line">                    count&#x3D;1</span><br><span class="line">            tmp+&#x3D;str(count)+pre</span><br><span class="line">            res&#x3D;tmp</span><br><span class="line">            n-&#x3D;1</span><br><span class="line">        return res</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def countAndSay(self, n: int) -&gt; str:</span><br><span class="line">        res&#x3D;&#39;1&#39;</span><br><span class="line">        for i in range(n-1,0,-1):</span><br><span class="line">            tmp&#x3D;&#39;&#39;</span><br><span class="line">            pre&#x3D;res[0]</span><br><span class="line">            count&#x3D;1 # count&#x3D;1</span><br><span class="line">            for j in range(1,len(res)): # 从1开始</span><br><span class="line">                if pre&#x3D;&#x3D;res[j]:</span><br><span class="line">                    count+&#x3D;1</span><br><span class="line">                else:</span><br><span class="line">                    tmp+&#x3D;str(count)+pre</span><br><span class="line">                    pre&#x3D;res[j]</span><br><span class="line">                    count&#x3D;1</span><br><span class="line">            tmp+&#x3D;str(count)+pre</span><br><span class="line">            res&#x3D;tmp</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>


<h3 id="58-最后一个单词的长度"><a href="#58-最后一个单词的长度" class="headerlink" title="58. 最后一个单词的长度"></a>58. 最后一个单词的长度</h3><pre><code>链接：https://leetcode-cn.com/problems/length-of-last-word/

给定一个仅包含大小写字母和空格 &#39; &#39; 的字符串 s，返回其最后一个单词的长度。如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。

如果不存在最后一个单词，请返回 0 。

说明：一个单词是指仅由字母组成、不包含任何空格字符的 最大子字符串。

示例:

输入: &quot;Hello World&quot;
输出: 5</code></pre>
<p>题解一（内置函数）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def lengthOfLastWord(self, s: str) -&gt; int:</span><br><span class="line">        return len(s.rstrip().split(&#39; &#39;)[-1])</span><br></pre></td></tr></table></figure>

<p>题解二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def lengthOfLastWord(self, s: str) -&gt; int:</span><br><span class="line">        end&#x3D;len(s)-1</span><br><span class="line">        while end&gt;&#x3D;0 and s[end]&#x3D;&#x3D;&#39; &#39;:</span><br><span class="line">            end-&#x3D;1</span><br><span class="line">        if end &lt; 0: return 0</span><br><span class="line">        start&#x3D;end</span><br><span class="line">        while start &gt;&#x3D;0 and s[start] !&#x3D;&#39; &#39;:</span><br><span class="line">            start-&#x3D;1</span><br><span class="line">        return end-start</span><br></pre></td></tr></table></figure>

<h3 id="67-二进制求和"><a href="#67-二进制求和" class="headerlink" title="67. 二进制求和"></a>67. 二进制求和</h3><pre><code>给你两个二进制字符串，返回它们的和（用二进制表示）。

输入为 非空 字符串且只包含数字 1 和 0。

示例 1:

输入: a = &quot;11&quot;, b = &quot;1&quot;
输出: &quot;100&quot;
示例 2:

输入: a = &quot;1010&quot;, b = &quot;1011&quot;
输出: &quot;10101&quot;


提示：

每个字符串仅由字符 &#39;0&#39; 或 &#39;1&#39; 组成。
1 &lt;= a.length, b.length &lt;= 10^4
字符串如果不是 &quot;0&quot; ，就都不含前导零。</code></pre>
<p>题解一（内置函数）:</p>
<p>时间复杂度为 O(N+M)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def addBinary(self, a: str, b: str) -&gt; str:</span><br><span class="line">        return bin(int(a,2)+int(b,2))[2:]</span><br></pre></td></tr></table></figure>

<p>题解二(逐位运算)：</p>
<p>时间复杂度：O(max(N,M))，其中 N 和 M 是输入字符串 a 和 b 的长度。</p>
<p>空间复杂度：O(max(N,M))，存储求和结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def addBinary(self, a: str, b: str) -&gt; str:</span><br><span class="line">        n&#x3D;max(len(a),len(b))</span><br><span class="line">        a,b&#x3D;a.zfill(n),b.zfill(n)</span><br><span class="line">        carry&#x3D;0</span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        for i in range(n-1,-1,-1):</span><br><span class="line">            if a[i]&#x3D;&#x3D;&#39;1&#39;:</span><br><span class="line">                carry+&#x3D;1</span><br><span class="line">            if b[i]&#x3D;&#x3D;&#39;1&#39;:</span><br><span class="line">                carry+&#x3D;1</span><br><span class="line">            if carry%2&#x3D;&#x3D;1:</span><br><span class="line">                res.append(&#39;1&#39;)</span><br><span class="line">            else:</span><br><span class="line">                res.append(&#39;0&#39;)</span><br><span class="line"></span><br><span class="line">            carry&#x2F;&#x2F;&#x3D;2</span><br><span class="line"></span><br><span class="line">        if carry&#x3D;&#x3D;1:</span><br><span class="line">            res.append(&#39;1&#39;)</span><br><span class="line">        res.reverse()</span><br><span class="line">        return &#39;&#39;.join(res)</span><br></pre></td></tr></table></figure>

<p>zfill()方法语法：<br>    str.zfill(width)<br>    参数:<br>        width – 指定字符串的长度。原字符串右对齐，前面填充0。<br>    返回值:<br>        返回指定长度的字符串。</p>
<p>题解三（位操作）：</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/bit.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/bit.png"></p>
<p>算法:</p>
<pre><code>把 a 和 b 转换成整型数字 x 和 y，x 保存结果，y 保存进位。

当进位不为 0：y != 0：

    计算当前 x 和 y 的无进位相加结果：answer = x^y。

    计算当前 x 和 y 的进位：carry = (x &amp; y) &lt;&lt; 1。

    完成本次循环，更新 x = answer，y = carry。

返回 xx 的二进制形式。</code></pre>
<p>时间复杂度：O(N+M)，其中 N 和 M 是输入字符串 a 和 b 的长度。</p>
<p>空间复杂度：O(max(N,M))，存储计算结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def addBinary(self, a: str, b: str) -&gt; str:</span><br><span class="line">        x,y&#x3D;int(a,2),int(b,2)</span><br><span class="line">        while y:</span><br><span class="line">            res&#x3D;x^y</span><br><span class="line">            carry&#x3D;(x &amp; y) &lt;&lt; 1</span><br><span class="line">            x,y&#x3D;res,carry</span><br><span class="line">        return bin(x)[2:]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def addBinary(self, a, b) -&gt; str:</span><br><span class="line">        x, y &#x3D; int(a, 2), int(b, 2)</span><br><span class="line">        while y:</span><br><span class="line">            x, y &#x3D; x ^ y, (x &amp; y) &lt;&lt; 1</span><br><span class="line">        return bin(x)[2:]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125.验证回文串"></a>125.验证回文串</h3><pre><code>链接：https://leetcode-cn.com/problems/valid-palindrome/

给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

说明：本题中，我们将空字符串定义为有效的回文串。

示例 1:

输入: &quot;A man, a plan, a canal: Panama&quot;
输出: true
示例 2:

输入: &quot;race a car&quot;
输出: false</code></pre>
<p>题解一（双指针）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isPalindrome(self, s: str) -&gt; bool:</span><br><span class="line">        left,right&#x3D;0,len(s)-1</span><br><span class="line">        while left&lt;right:</span><br><span class="line">            while left&lt;len(s) and not s[left].isalnum():</span><br><span class="line">                left+&#x3D;1</span><br><span class="line">            while right &gt;-1 and not s[right].isalnum():</span><br><span class="line">                right-&#x3D;1</span><br><span class="line">            if left&gt;right:</span><br><span class="line">                return True</span><br><span class="line">            if s[left].upper() !&#x3D; s[right].upper():</span><br><span class="line">                return False</span><br><span class="line">            else:</span><br><span class="line">                left+&#x3D;1</span><br><span class="line">                right-&#x3D;1</span><br><span class="line">        return True</span><br></pre></td></tr></table></figure>

<p>isalnum():检测字符串是否由字母和数字组成。</p>
<p>题解二（正则）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isPalindrome(self, s: str) -&gt; bool:</span><br><span class="line">        import re</span><br><span class="line">        p&#x3D;&#39;&#39;.join(re.findall(r&#39;[a-zA-Z0-9+]&#39;,s))</span><br><span class="line">        p&#x3D;p.lower()</span><br><span class="line">        return True if p&#x3D;&#x3D;p[::-1] else False</span><br></pre></td></tr></table></figure>

<p>题解三（内置函数）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isPalindrome(self, s: str) -&gt; bool:</span><br><span class="line">        s &#x3D; [*filter(str.isalnum, s.lower())]</span><br><span class="line">        return s &#x3D;&#x3D; s[::-1]</span><br></pre></td></tr></table></figure>

<h3 id="168-Excel表列名称"><a href="#168-Excel表列名称" class="headerlink" title="168.Excel表列名称"></a>168.Excel表列名称</h3><pre><code>链接：https://leetcode-cn.com/problems/excel-sheet-column-title/

给定一个正整数，返回它在 Excel 表中相对应的列名称。

例如，

    1 -&gt; A
    2 -&gt; B
    3 -&gt; C
    ...
    26 -&gt; Z
    27 -&gt; AA
    28 -&gt; AB 
    ...
示例 1:

输入: 1
输出: &quot;A&quot;
示例 2:

输入: 28
输出: &quot;AB&quot;
示例 3:

输入: 701
输出: &quot;ZY&quot;</code></pre>
<p>题解一（转26进制）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def convertToTitle(self, n: int) -&gt; str:</span><br><span class="line">        res&#x3D;&#39;&#39;</span><br><span class="line">        while n:</span><br><span class="line">            n,y&#x3D;divmod(n,26)</span><br><span class="line">            if y&#x3D;&#x3D;0:</span><br><span class="line">                n-&#x3D;1</span><br><span class="line">                y&#x3D;26</span><br><span class="line">            res&#x3D;chr(y+64)+res</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def convertToTitle(self, n: int) -&gt; str:</span><br><span class="line">        res&#x3D;&#39;&#39;</span><br><span class="line">        while n:</span><br><span class="line">            n-&#x3D;1</span><br><span class="line">            n,y&#x3D;divmod(n,26)</span><br><span class="line">            res&#x3D;chr(y+65)+res</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<p>题解二（递归）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def convertToTitle(self, n: int) -&gt; str:</span><br><span class="line">        if n&#x3D;&#x3D;0:</span><br><span class="line">            return &#39;&#39;</span><br><span class="line">        else:</span><br><span class="line">            return self.convertToTitle((n-1)&#x2F;&#x2F;26) + chr((n-1) % 26 + 65)</span><br></pre></td></tr></table></figure>

<h3 id="171-Excel表列序号"><a href="#171-Excel表列序号" class="headerlink" title="171.Excel表列序号"></a>171.Excel表列序号</h3><pre><code>链接：https://leetcode-cn.com/problems/excel-sheet-column-number/

给定一个Excel表格中的列名称，返回其相应的列序号。

例如，

    A -&gt; 1
    B -&gt; 2
    C -&gt; 3
    ...
    Z -&gt; 26
    AA -&gt; 27
    AB -&gt; 28 
    ...
示例 1:

输入: &quot;A&quot;
输出: 1
示例 2:

输入: &quot;AB&quot;
输出: 28
示例 3:

输入: &quot;ZY&quot;
输出: 701</code></pre>
<p>题解一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def titleToNumber(self, s: str) -&gt; int: </span><br><span class="line">        res&#x3D;0</span><br><span class="line">        for each in s:</span><br><span class="line">            num&#x3D;(ord(each)-65)+1</span><br><span class="line">            res&#x3D;res*26+num</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344.反转字符串"></a>344.反转字符串</h3><pre><code>链接：https://leetcode-cn.com/problems/reverse-string/

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。

示例 1：

输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]
输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]
示例 2：

输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]
输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</code></pre>
<p>字符串逆序：</p>
<p>方法一：利用字符串的切片来实现逆序</p>
<pre><code>def reverse1(str):
    return str[::-1]</code></pre>
<p>方法二：将字符串转换为列表后再使用reverse()</p>
<pre><code>def reverse2(str):
    str_list=list(str)
    str_list.reverse()  # 列表翻转
    return &#39;&#39;.join(str_list) # 将列表转换为字符串

def reverse2(str):
    str_list=[]
    for each in str:
        str_list.append(each)
    str_list.reverse()
    return &#39;&#39;.join(str_list)</code></pre>
<p>方法三：新建列表，从后往前添加元素</p>
<pre><code>def reverse3(str):
    str_list=[]
    for i in range(len(str)-1,-1,-1):
        str_list.append(str[i])
    return &#39;&#39;.join(str_list)    </code></pre>
<p>方法四：递归</p>
<pre><code>def reverse4(str):
    if len(str)&lt;=1:
        return str
    return str[-1]+reverse4(str[:-1])</code></pre>
<p>方法五：借助collections模块extendleft()</p>
<pre><code>import collections

def reverse5(str):
    deque1 = collections.deque(str)
    deque2=collections.deque()
    for char in deque1:
        deque2.extendleft(char)
    return &#39;&#39;.join(deque2)</code></pre>
<p>方法六：swap交换操作，以中间为基准，交换对称位置的字符</p>
<pre><code>def reverse5(str):
str_list = list(str)
if len(str_list) == 0 or len(str_list) == 1:
    return str
i = 0
length = len(str_list)
while i &lt; length / 2:
    str_list[i], str_list[length - i - 1] = str_list[length - i - 1], str_list[i]
    i += 1
return &#39;&#39;.join(str_list)</code></pre>
<p>题解一（内置函数）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reverseString(self, s):</span><br><span class="line">        s.reverse()</span><br></pre></td></tr></table></figure>

<p>题解二（递归）：</p>
<p>时间复杂度：O(N)。执行了 N/2 次的交换。<br>空间复杂度：O(N)，递归过程中使用的堆栈空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reverseString(self, s: List[str]) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Do not return anything, modify s in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        def helper(left,right):</span><br><span class="line">            if left&lt;right:</span><br><span class="line">                s[left],s[right]&#x3D;s[right],s[left]</span><br><span class="line">                helper(left+1,right-1)</span><br><span class="line">        helper(0,len(s)-1)</span><br></pre></td></tr></table></figure>

<p>题解二（双指针）:</p>
<p>时间复杂度：O(N)。执行了 N/2 次的交换。<br>空间复杂度：O(1)，只使用了常数级空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reverseString(self, s: List[str]) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Do not return anything, modify s in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        left,right&#x3D;0,len(s)-1</span><br><span class="line">        while left&lt;right:</span><br><span class="line">            s[left],s[right]&#x3D;s[right],s[left]</span><br><span class="line">            left+&#x3D;1</span><br><span class="line">            right-&#x3D;1</span><br><span class="line">        return s</span><br></pre></td></tr></table></figure>

<h3 id="345-反转字符串中的元音字母"><a href="#345-反转字符串中的元音字母" class="headerlink" title="345. 反转字符串中的元音字母"></a>345. 反转字符串中的元音字母</h3><pre><code>链接：https://leetcode-cn.com/problems/reverse-vowels-of-a-string/

编写一个函数，以字符串作为输入，反转该字符串中的元音字母。

示例 1:

输入: &quot;hello&quot;
输出: &quot;holle&quot;
示例 2:

输入: &quot;leetcode&quot;
输出: &quot;leotcede&quot;</code></pre>
<p>题解一（栈）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reverseVowels(self, s: str) -&gt; str:</span><br><span class="line">        stack&#x3D;[&#39;a&#39;,&#39;e&#39;,&#39;i&#39;,&#39;o&#39;,&#39;u&#39;,&#39;A&#39;,&#39;E&#39;,&#39;I&#39;,&#39;O&#39;,&#39;U&#39;]</span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        tmp&#x3D;[i for i in s if i in stack]</span><br><span class="line">        for i in s:</span><br><span class="line">            if i not in stack:</span><br><span class="line">                res.append(i)</span><br><span class="line">            else:</span><br><span class="line">                res.append(tmp.pop())</span><br><span class="line">        return &#39;&#39;.join(res)</span><br></pre></td></tr></table></figure>

<p>题解二（双指针）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reverseVowels(self, s: str) -&gt; str:</span><br><span class="line">        if not s or len(s)&#x3D;&#x3D;1:</span><br><span class="line">            return s</span><br><span class="line">        stack&#x3D;[&#39;a&#39;,&#39;e&#39;,&#39;i&#39;,&#39;o&#39;,&#39;u&#39;,&#39;A&#39;,&#39;E&#39;,&#39;I&#39;,&#39;O&#39;,&#39;U&#39;]</span><br><span class="line">        s&#x3D;list(s)</span><br><span class="line">        left,right&#x3D;0,len(s)-1</span><br><span class="line">        while left&lt;right:</span><br><span class="line">            if s[left] not in stack:</span><br><span class="line">                left+&#x3D;1</span><br><span class="line">            if s[right] not in stack:</span><br><span class="line">                right-&#x3D;1</span><br><span class="line">            if s[left] in stack and s[right] in stack:</span><br><span class="line">                s[left],s[right]&#x3D;s[right],s[left]</span><br><span class="line">                left+&#x3D;1</span><br><span class="line">                right-&#x3D;1</span><br><span class="line">        return &#39;&#39;.join(s)</span><br></pre></td></tr></table></figure>

<h3 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a>383. 赎金信</h3><pre><code>链接：https://leetcode-cn.com/problems/ransom-note/

给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。

(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。) 

注意：

你可以假设两个字符串均只含有小写字母。

canConstruct(&quot;a&quot;, &quot;b&quot;) -&gt; false
canConstruct(&quot;aa&quot;, &quot;ab&quot;) -&gt; false
canConstruct(&quot;aa&quot;, &quot;aab&quot;) -&gt; true</code></pre>
<p>题解一（Counter）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def canConstruct(self, ransomNote: str, magazine: str) -&gt; bool:</span><br><span class="line">        from collections import Counter</span><br><span class="line">        r&#x3D;Counter(ransomNote)</span><br><span class="line">        m&#x3D;Counter(magazine)</span><br><span class="line">        if not r-m:</span><br><span class="line">            return True</span><br><span class="line">        else:</span><br><span class="line">            return False</span><br></pre></td></tr></table></figure>

<p>题解二(双指针)：</p>
<p>时间复杂度为O(nlog(n)+mlog(m))<br>空间复杂度为O(m + n)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def canConstruct(self, ransomNote: str, magazine: str) -&gt; bool:</span><br><span class="line">        sorted(ransomNote)</span><br><span class="line">        sorted(magazine)</span><br><span class="line">        i,j&#x3D;0,0</span><br><span class="line">        while i&lt;len(ransomNote) and j&lt;len(magazine):</span><br><span class="line">            if ransomNote[i]&gt;magazine[j]:</span><br><span class="line">                j+&#x3D;1</span><br><span class="line">            elif ransomNote[i] &lt; magazine[j]:</span><br><span class="line">                return False</span><br><span class="line">            else:</span><br><span class="line">                i+&#x3D;1</span><br><span class="line">                j+&#x3D;1</span><br><span class="line">        return i&#x3D;&#x3D;len(ransomNote)</span><br></pre></td></tr></table></figure>

<p>题解三（hash）：</p>
<p>时间复杂度: O(N) - N（遍历magazine） + 1（字典检索为O(1)）<br>空间复杂度: O(N)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def canConstruct(self, ransomNote: str, magazine: str) -&gt; bool:</span><br><span class="line">        hash&#x3D;&#123;&#125;</span><br><span class="line">        for i in magazine:</span><br><span class="line">            if i in hash:</span><br><span class="line">                hash[i]+&#x3D;1</span><br><span class="line">            else:</span><br><span class="line">                hash[i]&#x3D;1</span><br><span class="line">        for i in ransomNote:</span><br><span class="line">            if i in hash and hash[i]&gt;0:</span><br><span class="line">                hash[i]-&#x3D;1</span><br><span class="line">            else:</span><br><span class="line">                return False</span><br><span class="line">        return True</span><br></pre></td></tr></table></figure>

<p>题解四（暴力）：</p>
<p>时间复杂度: O(N^2) - N（遍历ransomNote） * N（replace最糟糕的情况是遍历整个magazine）<br>空间复杂度: O(1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def canConstruct(self, ransomNote: str, magazine: str) -&gt; bool:</span><br><span class="line">        for i in ransomNote:</span><br><span class="line">            if i in magazine:</span><br><span class="line">                magazine&#x3D;magazine.replace(i,&#39;&#39;,1) # 可选字符串, 替换不超过 max 次</span><br><span class="line">            else:</span><br><span class="line">                return False</span><br><span class="line">        return True</span><br></pre></td></tr></table></figure>

<h3 id="387-字符串中的第一个唯一字符"><a href="#387-字符串中的第一个唯一字符" class="headerlink" title="387. 字符串中的第一个唯一字符"></a>387. 字符串中的第一个唯一字符</h3><pre><code>链接：https://leetcode-cn.com/problems/first-unique-character-in-a-string/

给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。

案例:

s = &quot;leetcode&quot;
返回 0.

s = &quot;loveleetcode&quot;,
返回 2.


注意事项：您可以假定该字符串只包含小写字母。</code></pre>
<p>题解一（切片）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def firstUniqChar(self, s: str) -&gt; int:</span><br><span class="line">        if len(s)&#x3D;&#x3D;1:</span><br><span class="line">            return 0</span><br><span class="line">        for k in range(len(s)):</span><br><span class="line">            if (s[k] not in s[k+1:]) and (s[k] not in s[:k]):</span><br><span class="line">                return k</span><br><span class="line">        return -1</span><br></pre></td></tr></table></figure>

<p>题解二(内置函数)：</p>
<p>时间复杂度： O(N)，只遍历了两遍字符串，同时散列表中查找操作是常数时间复杂度的。<br>空间复杂度： O(N)，用到了散列表来存储字符串中每个元素出现的次数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def firstUniqChar(self, s: str) -&gt; int:</span><br><span class="line">        from collections import Counter</span><br><span class="line">        count&#x3D;Counter(s)</span><br><span class="line">        for k,v in enumerate(s):</span><br><span class="line">            if count[v]&#x3D;&#x3D;1:</span><br><span class="line">                return k</span><br><span class="line">        return -1</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import collections</span><br><span class="line">class Solution:</span><br><span class="line">    def firstUniqChar(self, s: str) -&gt; int:</span><br><span class="line">        for i,j in collections.Counter(s).items():</span><br><span class="line">            if j&#x3D;&#x3D;1:return s.index(i)</span><br><span class="line">        return -1</span><br></pre></td></tr></table></figure>

<p>题解三（find）:</p>
<p>1.证明字母只出现了一次<br>如果一个字符串中的字符在字符串中从左边搜索和从右边搜索得到的index一样，那就证明只有一个了<br>2.循环每次是从第一个开始的，保证了执行的顺序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def firstUniqChar(self, s):</span><br><span class="line">        for i in s:</span><br><span class="line">            if s.find(i)&#x3D;&#x3D; s.rfind(i):</span><br><span class="line">                return s.find(i)</span><br><span class="line">        return -1</span><br></pre></td></tr></table></figure>

<h3 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415. 字符串相加"></a>415. 字符串相加</h3><pre><code>链接：https://leetcode-cn.com/problems/add-strings/

给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。

注意：

num1 和num2 的长度都小于 5100.
num1 和num2 都只包含数字 0-9.
num1 和num2 都不包含任何前导零。
你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。</code></pre>
<p>题解一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def addStrings(self, num1: str, num2: str) -&gt; str:</span><br><span class="line">        n&#x3D;max(len(num1),len(num2))</span><br><span class="line">        n1&#x3D;num1.zfill(n)</span><br><span class="line">        n2&#x3D;num2.zfill(n)</span><br><span class="line">        print(n1,n2)</span><br><span class="line">        carry&#x3D;0</span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        for i in range(n-1,-1,-1):</span><br><span class="line">            tmp&#x3D;int(n1[i])+int(n2[i])</span><br><span class="line">            carry+&#x3D;tmp</span><br><span class="line">            res.append(carry%10)</span><br><span class="line">            carry&#x2F;&#x2F;&#x3D;10</span><br><span class="line">        if carry&#x3D;&#x3D;1:</span><br><span class="line">            res.append(1)</span><br><span class="line">        res.reverse()</span><br><span class="line">        return &#39;&#39;.join([str(i) for i in res])</span><br></pre></td></tr></table></figure>

<p>题解二（双指针）:</p>
<p>时间复杂度:O(max(M,N))：其中 M，N 为 2 数字长度，按位遍历一遍数字（以较长的数字为准）；<br>空间复杂度:O(1),指针与变量使用常数大小空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def addStrings(self, num1: str, num2: str) -&gt; str:</span><br><span class="line">        res &#x3D; &quot;&quot;</span><br><span class="line">        i, j, carry &#x3D; len(num1) - 1, len(num2) - 1, 0</span><br><span class="line">        while i &gt;&#x3D; 0 or j &gt;&#x3D; 0:</span><br><span class="line">            n1 &#x3D; int(num1[i]) if i &gt;&#x3D; 0 else 0</span><br><span class="line">            n2 &#x3D; int(num2[j]) if j &gt;&#x3D; 0 else 0</span><br><span class="line">            tmp &#x3D; n1 + n2 + carry</span><br><span class="line">            carry &#x3D; tmp &#x2F;&#x2F; 10</span><br><span class="line">            res &#x3D; str(tmp % 10) + res</span><br><span class="line">            i, j &#x3D; i - 1, j - 1</span><br><span class="line">        return &quot;1&quot; + res if carry else res</span><br></pre></td></tr></table></figure>

<h3 id="434-字符串中的单词数"><a href="#434-字符串中的单词数" class="headerlink" title="434. 字符串中的单词数"></a>434. 字符串中的单词数</h3><pre><code>链接：https://leetcode-cn.com/problems/number-of-segments-in-a-string/

统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。

请注意，你可以假定字符串里不包括任何不可打印的字符。

示例:

输入: &quot;Hello, my name is John&quot;
输出: 5
解释: 这里的单词是指连续的不是空格的字符，所以 &quot;Hello,&quot; 算作 1 个单词。</code></pre>
<p>题解一（split）:</p>
<p>时间复杂度 : O(n)。<br>这里用到的内置函数（无论是 Java 还是 Python）的时间复杂度或为 O(n)，或为 O(1) ，故整个算法可以在线性复杂度内完成。</p>
<p>空间复杂度 : O(n)。<br>split 函数 (不管哪种语言) 返回长度为 O(n) 的数组/列表，故算法使用线性的额外空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def countSegments(self, s: str) -&gt; int:</span><br><span class="line">        if not s:</span><br><span class="line">            return 0</span><br><span class="line">        return len(s.split(&#39; &#39;)) # 这段代码是错误的，并不能解决连续过个空格的case</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def countSegments(self, s: str) -&gt; int:</span><br><span class="line">        return len(s.split())</span><br></pre></td></tr></table></figure>

<p>区别：</p>
<pre><code>split()的时候，多个空格当成一个空格；
split(&#39; &#39;)的时候，多个空格也要分割，会分割出来空。</code></pre>
<p>题解二：</p>
<p>时间复杂度 : O(n)，对每个下标进行常数时间的检测。</p>
<p>空间复杂度 : O(1)，只使用了额外的几个整数，因此使用的空间为常数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def countSegments(self, s: str) -&gt; int:</span><br><span class="line">        count&#x3D;0</span><br><span class="line">        for i in range(len(s)):</span><br><span class="line">            if s[i] !&#x3D; &#39; &#39; and (s[i-1] &#x3D;&#x3D;&#39; &#39; or i&#x3D;&#x3D;0 ):</span><br><span class="line">                print(s[i])</span><br><span class="line">                count+&#x3D;1</span><br><span class="line">        return count </span><br></pre></td></tr></table></figure>

<pre><code>### 520. 检测大写字母
链接：https://leetcode-cn.com/problems/detect-capital/

给定一个单词，你需要判断单词的大写使用是否正确。

我们定义，在以下情况时，单词的大写用法是正确的：

全部字母都是大写，比如&quot;USA&quot;。
单词中所有字母都不是大写，比如&quot;leetcode&quot;。
如果单词不只含有一个字母，只有首字母大写， 比如 &quot;Google&quot;。
否则，我们定义这个单词没有正确使用大写字母。

示例 1:

输入: &quot;USA&quot;
输出: True
示例 2:

输入: &quot;FlaG&quot;
输出: False
注意: 输入是由大写和小写拉丁字母组成的非空单词。</code></pre>
<p>题解一（内置函数）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def detectCapitalUse(self, word: str) -&gt; bool:</span><br><span class="line">        if word.isupper() or word.islower() or word.istitle():</span><br><span class="line">            return True</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def detectCapitalUse(self, word: str) -&gt; bool:</span><br><span class="line">        return word.isupper() or word.islower() or word.istitle()</span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<p>题解二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def detectCapitalUse(self, word: str) -&gt; bool:</span><br><span class="line">        c1&#x3D;0</span><br><span class="line">        c2&#x3D;0</span><br><span class="line">        for i in word:</span><br><span class="line">            if (i&gt;&#x3D;&#39;a&#39;):</span><br><span class="line">                c1+&#x3D;1</span><br><span class="line">            else:</span><br><span class="line">                c2+&#x3D;1</span><br><span class="line">        if (c1&#x3D;&#x3D;len(word)) | (c2&#x3D;&#x3D;len(word)):</span><br><span class="line">            return True</span><br><span class="line">                              </span><br><span class="line">        return ((c2&#x3D;&#x3D;1) &amp; (word[0] &lt; &#39;a&#39; ))</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/LeetCode-2-%E6%A0%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/LeetCode-2-%E6%A0%88/" class="post-title-link" itemprop="url">LeetCode-2-栈</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-28 19:55:16" itemprop="dateCreated datePublished" datetime="2020-03-28T19:55:16+08:00">2020-03-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-03 18:11:49" itemprop="dateModified" datetime="2020-09-03T18:11:49+08:00">2020-09-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="二、栈"><a href="#二、栈" class="headerlink" title="二、栈"></a>二、栈</h2><h3 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a>42. 接雨水</h3><pre><code>链接：https://leetcode-cn.com/problems/trapping-rain-water/

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</code></pre>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/youdao/water2.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/youdao/water2.png"></p>
<pre><code>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。

示例:

输入: [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6</code></pre>
<p>思路： 求出每个柱子上面能够存多少水，然后将每根柱子的存水量相加便能得到总的存水量，为求出每根柱子上能够存多少水，就要求出每根柱子左边最高的和右边最高柱子，然后用两者的最小值减去当前柱子的高度。 例如图中从左到右第三根柱子的高度为0，它左边最高柱子的值为1，右边最高柱子的值为3，因此它的最大存水量为 Min（1，3）-0=1。</p>
<p>原文讲解：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u013309870/article/details/70978279">https://blog.csdn.net/u013309870/article/details/70978279</a></p>
<p>题解一|暴力：<br>利用上面的思路，从左到右遍历每根柱子，遍历的时候求出每根柱子左边最高和右边最高柱子的值，然后利用两者的最小值减去当前柱子的高度就行了。</p>
<p>时间复杂度O（n^2）,空间复杂度O（1）。</p>
<p>注意：如果当前柱子大于它左右最大值的任何一个是存不了水的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def trap(self, height: List[int]) -&gt; int:</span><br><span class="line">        waters&#x3D;0</span><br><span class="line">        length&#x3D;len(height)</span><br><span class="line">        </span><br><span class="line">        if height is None or length&lt;2:</span><br><span class="line">            return 0</span><br><span class="line">        </span><br><span class="line">        left,right&#x3D;0,0</span><br><span class="line">        for i in range(length):</span><br><span class="line">            left,right&#x3D;0,0</span><br><span class="line">            for j in range(i):</span><br><span class="line">                left&#x3D;max(left,height[j])</span><br><span class="line">            for j in range(length-1,i,-1):</span><br><span class="line">                right&#x3D;max(right,height[j])</span><br><span class="line">            </span><br><span class="line">            tmp&#x3D;min(left,right)</span><br><span class="line">            if tmp&gt;height[i]:</span><br><span class="line">                waters+&#x3D;tmp-height[i]</span><br><span class="line">            else:</span><br><span class="line">                waters+&#x3D;0</span><br><span class="line">                </span><br><span class="line">        return waters</span><br></pre></td></tr></table></figure>
<p>题解二|优化：</p>
<p>题解一时间复杂度为O(n^2)。原因是对于每个元素都要从左到右，和从右到最左遍历其两边最大值，假如使用两个数组 left[ ] , right[ ]来保存每个元素左边最大值，右边最大值的话，这样就不用每次都遍历了，因此时间复杂度可以减少到O(n)，空间复杂度为O(n)，典型的空间换时间算法。</p>
<pre><code>对于数组[ 5, 2 , 6 , 2 , 4 ]
它的左数组：[5,5,6,6,6]
它的右数组：[6,6,6,4,4]</code></pre>
<p>算法的流程：</p>
<pre><code>从左到右遍历一次求出每个元素左边的最大值，保存在 left 数组中。 
从右到左遍历一次求出每个元素右边的最大值，保存在right数。
最后一次遍历求出每个元素（每根柱子）的存水量。</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def trap(self, height: List[int]) -&gt; int:</span><br><span class="line">        waters&#x3D;0</span><br><span class="line">        length&#x3D;len(height)</span><br><span class="line">        </span><br><span class="line">        if height is None or length&lt;2:</span><br><span class="line">            return 0</span><br><span class="line">        leftLargest,rightLargest&#x3D;0,0</span><br><span class="line">        left,right&#x3D;[0]*length,[0]*length</span><br><span class="line">        </span><br><span class="line">        for i in range(length):</span><br><span class="line">            leftLargest&#x3D;max(leftLargest,height[i])</span><br><span class="line">            left[i]&#x3D;leftLargest</span><br><span class="line">        </span><br><span class="line">        for i in range(length-1,-1,-1):</span><br><span class="line">            rightLargest&#x3D;max(rightLargest,height[i])</span><br><span class="line">            right[i]&#x3D;rightLargest</span><br><span class="line">        </span><br><span class="line">        for i in range(length):</span><br><span class="line">            tmp&#x3D;min(left[i],right[i])</span><br><span class="line">            if tmp&gt;height[i]:</span><br><span class="line">                waters+&#x3D;tmp-height[i]</span><br><span class="line">            else:</span><br><span class="line">                waters+&#x3D;0</span><br><span class="line">                </span><br><span class="line">        return waters</span><br></pre></td></tr></table></figure>
<p>题解三|优化：</p>
<p>优化题解二，分析上面算法发现其实没有必要使用 left 数组，因为当从左到右遍历求存水量的过程中可以利用一个变量来保存当前元素左边的最大值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def trap(self, height: List[int]) -&gt; int:</span><br><span class="line">        waters&#x3D;0</span><br><span class="line">        length&#x3D;len(height)</span><br><span class="line">        </span><br><span class="line">        if height is None or length&lt;2:</span><br><span class="line">            return 0</span><br><span class="line">        leftLargest,rightLargest&#x3D;0,0</span><br><span class="line">        right&#x3D;[0]*length</span><br><span class="line">        </span><br><span class="line">        for i in range(length-1,-1,-1):</span><br><span class="line">            rightLargest&#x3D;max(rightLargest,height[i])</span><br><span class="line">            right[i]&#x3D;rightLargest</span><br><span class="line">        </span><br><span class="line">        for i in range(length):</span><br><span class="line">            leftLargest&#x3D;max(leftLargest,height[i])</span><br><span class="line">            tmp&#x3D;min(leftLargest,right[i])</span><br><span class="line">            if tmp&gt;height[i]:</span><br><span class="line">                waters+&#x3D;tmp-height[i]</span><br><span class="line">            else:</span><br><span class="line">                waters+&#x3D;0</span><br><span class="line">                </span><br><span class="line">        return waters</span><br></pre></td></tr></table></figure>

<p>题解四|双指针：</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/youdao/water1.png" alt="image"></p>
<pre><code>上面左右两边的黄色块分别表示当前元素左边最大值和右边最大值。

left ，right分别代表从左到右移动和从右到左移动的指针。

如果当前元素的左边最大值比右边最大值小，则left指针向右移动，否则right指针向左移动。

这种左右指针移动的目的是为了保证所求的左右最大值一定是当前元素的左右最大值。</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def trap(self, height: List[int]) -&gt; int:</span><br><span class="line">        waters&#x3D;0</span><br><span class="line">        length&#x3D;len(height)</span><br><span class="line">        </span><br><span class="line">        if height is None or length&lt;2:</span><br><span class="line">            return 0</span><br><span class="line">        leftLargest,rightLargest&#x3D;0,0</span><br><span class="line">        left,right&#x3D;0,length-1</span><br><span class="line">        </span><br><span class="line">        while left&lt;right:</span><br><span class="line">            leftLargest&#x3D;max(leftLargest,height[left])</span><br><span class="line">            rightLargest&#x3D;max(rightLargest,height[right])</span><br><span class="line">            </span><br><span class="line">            if leftLargest &gt; rightLargest:</span><br><span class="line">                waters+&#x3D;rightLargest-height[right]</span><br><span class="line">                right-&#x3D;1</span><br><span class="line">            else:</span><br><span class="line">                waters+&#x3D;leftLargest-height[left]</span><br><span class="line">                left+&#x3D;1</span><br><span class="line">                </span><br><span class="line">        return waters</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">def trap(height):</span><br><span class="line">    if not height: return 0</span><br><span class="line">    left &#x3D; 0</span><br><span class="line">    right &#x3D; len(height) - 1</span><br><span class="line">    res &#x3D; 0</span><br><span class="line">    # 记录左右边最大值</span><br><span class="line">    left_max &#x3D; height[left]</span><br><span class="line">    right_max &#x3D; height[right]</span><br><span class="line">    while left &lt; right:</span><br><span class="line">        if height[left] &lt; height[right]:</span><br><span class="line">            if left_max &gt; height[left]:</span><br><span class="line">                res +&#x3D; left_max - height[left]</span><br><span class="line">            else:</span><br><span class="line">                left_max &#x3D; height[left]</span><br><span class="line">            left +&#x3D; 1</span><br><span class="line">        else:</span><br><span class="line">            if right_max &gt; height[right]:</span><br><span class="line">                res +&#x3D; right_max - height[right]</span><br><span class="line">            else:</span><br><span class="line">                right_max &#x3D; height[right]</span><br><span class="line">            right -&#x3D; 1</span><br><span class="line">    return res</span><br></pre></td></tr></table></figure>
<h3 id="58-最后一个单词的长度"><a href="#58-最后一个单词的长度" class="headerlink" title="58.最后一个单词的长度"></a>58.最后一个单词的长度</h3><pre><code>链接：https://leetcode-cn.com/problems/length-of-last-word/

给定一个仅包含大小写字母和空格 &#39; &#39; 的字符串，返回其最后一个单词的长度。

如果不存在最后一个单词，请返回 0 。

说明：一个单词是指由字母组成，但不包含任何空格的字符串。

示例:

输入: &quot;Hello World&quot;
输出: 5</code></pre>
<p>题解一|内置函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def lengthOfLastWord(self, s: str) -&gt; int:</span><br><span class="line">        return len(s.rstrip().split(&#39; &#39;)[-1])</span><br></pre></td></tr></table></figure>
<p>题解二：<br>思路:<br>    从字符串末尾开始向前遍历，其中主要有两种情况<br>    第一种情况，以字符串”Hello World”为例，从后向前遍历直到遍历到头或者遇到空格为止，即为最后一个单词”World”的长度5<br>    第二种情况，以字符串”Hello World “为例，需要先将末尾的空格过滤掉，再进行第一种情况的操作，即认为最后一个单词为”World”，长度为5<br>    所以完整过程为先从后过滤掉空格找到单词尾部，再从尾部向前遍历，找到单词头部，最后两者相减，即为单词的长度<br>    时间复杂度：O(n)，n为结尾空格和结尾单词总体长度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def lengthOfLastWord(self, s: str) -&gt; int:</span><br><span class="line">        # return len(s.rstrip().split(&#39; &#39;)[-1])</span><br><span class="line">        end&#x3D;len(s)-1</span><br><span class="line">        while end&gt;&#x3D;0 and s[end]&#x3D;&#x3D;&#39; &#39;:</span><br><span class="line">            end-&#x3D;1</span><br><span class="line">        if end &lt; 0: return 0</span><br><span class="line">        start&#x3D;end</span><br><span class="line">        while start &gt;&#x3D;0 and s[start] !&#x3D;&#39; &#39;:</span><br><span class="line">            start-&#x3D;1</span><br><span class="line">        return end-start</span><br></pre></td></tr></table></figure>
<h3 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136.只出现一次的数字"></a>136.只出现一次的数字</h3><pre><code>链接：https://leetcode-cn.com/problems/single-number/

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:

输入: [2,2,1]
输出: 1
示例 2:

输入: [4,1,2,1,2]
输出: 4</code></pre>
<p>题解一|list：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def singleNumber(self, nums: List[int]) -&gt; int:</span><br><span class="line">        temp&#x3D;[]</span><br><span class="line">        for i in nums:</span><br><span class="line">            if i not in temp:</span><br><span class="line">                temp.append(i)</span><br><span class="line">            else:</span><br><span class="line">                temp.remove(i)</span><br><span class="line">        # return temp[0]</span><br><span class="line">        return temp.pop()</span><br></pre></td></tr></table></figure>
<p>题解二|hash：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def singleNumber(self, nums: List[int]) -&gt; int:</span><br><span class="line">        temp&#x3D;&#123;&#125;</span><br><span class="line">        for i in nums:</span><br><span class="line">            if i not in temp:</span><br><span class="line">                temp[i]&#x3D;1</span><br><span class="line">            else:</span><br><span class="line">                temp[i]+&#x3D;1</span><br><span class="line">        for k,v in temp.items():</span><br><span class="line">            if v&#x3D;&#x3D;1:</span><br><span class="line">                return k</span><br></pre></td></tr></table></figure>
<p>题解三|位运算：</p>
<p>异或运算有以下三个性质。</p>
<pre><code>任何数和 0 做异或运算，结果仍然是原来的数，即 a⊕0=a。
任何数和其自身做异或运算，结果是 0，即 a⊕a=0。
异或运算满足交换律和结合律，即 a⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b。</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def singleNumber(self, nums: List[int]) -&gt; int:</span><br><span class="line">        res&#x3D;0</span><br><span class="line">        for i in nums:</span><br><span class="line">            res^&#x3D;i</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def singleNumber(self, nums: List[int]) -&gt; int:</span><br><span class="line">        return reduce(lambda x,y:x^y,nums)</span><br></pre></td></tr></table></figure>

<h3 id="137-只出现一次的数字-II"><a href="#137-只出现一次的数字-II" class="headerlink" title="137.只出现一次的数字 II"></a>137.只出现一次的数字 II</h3><pre><code>链接：https://leetcode-cn.com/problems/single-number-ii/

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:

输入: [2,2,3,2]
输出: 3
示例 2:

输入: [0,1,0,1,0,1,99]
输出: 99</code></pre>
<p>题解一|hash：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def singleNumber(self, nums: List[int]) -&gt; int:</span><br><span class="line">        hash&#x3D;&#123;&#125;</span><br><span class="line">        for i in nums:</span><br><span class="line">            if i not in hash:</span><br><span class="line">                hash[i]&#x3D;1</span><br><span class="line">            else:</span><br><span class="line">                hash[i]+&#x3D;1</span><br><span class="line">        for k,v in hash.items():</span><br><span class="line">            if v!&#x3D;3:</span><br><span class="line">                return k</span><br></pre></td></tr></table></figure>

<p>题解二|数学运算：</p>
<pre><code>3×(a+b+c)−(a+a+a+b+b+b+c)=2c

时间复杂度：O(N)，遍历输入数组。
空间复杂度：O(N)，存储 N/3N/3 个元素的集合。</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def singleNumber(self, nums: List[int]) -&gt; int:</span><br><span class="line">        return (3*sum(set(nums))-sum(nums))&#x2F;&#x2F;2</span><br></pre></td></tr></table></figure>

<p>？？？题解三|位运算:</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/or.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/or.png"></p>
<h3 id="409-最长回文串"><a href="#409-最长回文串" class="headerlink" title="409.最长回文串"></a>409.最长回文串</h3><pre><code>链接：https://leetcode-cn.com/problems/longest-palindrome/

给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。

在构造过程中，请注意区分大小写。比如 &quot;Aa&quot; 不能当做一个回文字符串。

注意:
假设字符串的长度不会超过 1010。

示例 1:

输入:
&quot;abccccdd&quot;

输出:
7

解释:
我们可以构造的最长的回文串是&quot;dccaccd&quot;, 它的长度是 7。</code></pre>
<p>题解一|hash：</p>
<p>时间复杂度：O(N)，其中 N 为字符串 s 的长度。我们需要遍历每个字符一次。</p>
<p>空间复杂度：O(S)，其中 S 为字符集大小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def longestPalindrome(self, s: str) -&gt; int:</span><br><span class="line">        if not s:</span><br><span class="line">            return 0</span><br><span class="line">        hash&#x3D;&#123;&#125;</span><br><span class="line">        sum&#x3D;0</span><br><span class="line">        for each in s:</span><br><span class="line">            if each not in hash:</span><br><span class="line">                hash[each]&#x3D;1</span><br><span class="line">            else:</span><br><span class="line">                hash[each]+&#x3D;1</span><br><span class="line">        for key,value in hash.items():</span><br><span class="line">            sum+&#x3D;value&#x2F;&#x2F;2*2</span><br><span class="line">            if sum%2&#x3D;&#x3D;0 and value%2&#x3D;&#x3D;1:</span><br><span class="line">                sum+&#x3D;1</span><br><span class="line">        return sum</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def longestPalindrome(self, s):</span><br><span class="line">        ans &#x3D; 0</span><br><span class="line">        count &#x3D; collections.Counter(s)</span><br><span class="line">        for v in count.values():</span><br><span class="line">            ans +&#x3D; v &#x2F;&#x2F; 2 * 2</span><br><span class="line">            if ans % 2 &#x3D;&#x3D; 0 and v % 2 &#x3D;&#x3D; 1:</span><br><span class="line">                ans +&#x3D; 1</span><br><span class="line">        return ans</span><br></pre></td></tr></table></figure>

<h3 id="836-矩形重叠"><a href="#836-矩形重叠" class="headerlink" title="836.矩形重叠"></a>836.矩形重叠</h3><pre><code>链接：https://leetcode-cn.com/problems/rectangle-overlap/

矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。

如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。

给出两个矩形，判断它们是否重叠并返回结果。



示例 1：

输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]
输出：true
示例 2：

输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1]
输出：false


提示：

两个矩形 rec1 和 rec2 都以含有四个整数的列表的形式给出。
矩形中的所有坐标都处于 -10^9 和 10^9 之间。
x 轴默认指向右，y 轴默认指向上。
你可以仅考虑矩形是正放的情况。</code></pre>
<p>题解一|检查位置：</p>
<p>思路：如果两个矩形不重叠，那么一个矩形肯定在另一个矩形的四周（即左右上下）</p>
<pre><code>矩形 rec1 在矩形 rec2 的左侧；

矩形 rec1 在矩形 rec2 的右侧；

矩形 rec1 在矩形 rec2 的上方；

矩形 rec1 在矩形 rec2 的下方。

左侧：rec1[2] &lt;= rec2[0]；

右侧：rec1[0] &gt;= rec2[2]；

上方：rec1[1] &gt;= rec2[3]；

下方：rec1[3] &lt;= rec2[1]。</code></pre>
<p>时间复杂度：O(1)<br>空间复杂度：O(1)，不需要额外的空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -&gt; bool:</span><br><span class="line">        if rec1[0]&gt;&#x3D;rec2[2] or rec1[1]&gt;&#x3D;rec2[3]:</span><br><span class="line">            return False</span><br><span class="line">        if rec2[0]&gt;&#x3D;rec1[2] or rec2[1]&gt;&#x3D;rec1[3]: # 注意是or，不是and。</span><br><span class="line">            return False</span><br><span class="line">        return True</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -&gt; bool:</span><br><span class="line">        if rec1[2]&lt;&#x3D;rec2[0] or rec1[3]&lt;&#x3D;rec2[1] or rec1[0]&gt;&#x3D;rec2[2] or rec1[1]&gt;&#x3D;rec2[3]:</span><br><span class="line">            return False</span><br><span class="line">        else:</span><br><span class="line">            return True</span><br></pre></td></tr></table></figure>

<p>题解二|检查区域：</p>
<p>思路：如果两个矩形重叠，那么它们重叠的区域一定也是一个矩形，那么这代表了两个矩形与 x 轴平行的边（水平边）投影到 x 轴上时会有交集，与 y 轴平行的边（竖直边）投影到 y 轴上时也会有交集。因此，我们可以将问题看作一维线段是否有交集的问题。</p>
<p>矩形 rec1 和 rec2 的水平边投影到 x 轴上的线段分别为 (rec1[0], rec1[2]) 和 (rec2[0], rec2[2])。根据数学知识我们可以知道，当 min(rec1[2], rec2[2]) &gt; max(rec1[0], rec2[0]) 时，这两条线段有交集。对于矩形 rec1 和 rec2 的竖直边投影到 yy 轴上的线段，同理可以得到，当 min(rec1[3], rec2[3]) &gt; max(rec1[1], rec2[1]) 时，这两条线段有交集。（画图）</p>
<p>时间复杂度：O(1)<br>空间复杂度：O(1)，不需要额外的空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -&gt; bool:</span><br><span class="line">        def isIntersec(pLeft,pRight,qLeft,qRight):</span><br><span class="line">            return min(pRight,qRight)&gt;max(pLeft,qLeft)</span><br><span class="line">        return isIntersec(rec1[0],rec1[2],rec2[0],rec2[2]) and isIntersec(rec1[1],rec1[3],rec2[1],rec2[3])</span><br></pre></td></tr></table></figure>

<h3 id="1160-拼写单词"><a href="#1160-拼写单词" class="headerlink" title="1160.拼写单词"></a>1160.拼写单词</h3><pre><code>链接：https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters/

给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。

假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。

注意：
    每次拼写时，chars 中的每个字母都只能用一次。
    返回词汇表 words 中你掌握的所有单词的 长度之和。

示例 1：

输入：words = [&quot;cat&quot;,&quot;bt&quot;,&quot;hat&quot;,&quot;tree&quot;], chars = &quot;atach&quot;
输出：6
解释： 
可以形成字符串 &quot;cat&quot; 和 &quot;hat&quot;，所以答案是 3 + 3 = 6。
示例 2：

输入：words = [&quot;hello&quot;,&quot;world&quot;,&quot;leetcode&quot;], chars = &quot;welldonehoneyr&quot;
输出：10
解释：
可以形成字符串 &quot;hello&quot; 和 &quot;world&quot;，所以答案是 5 + 5 = 10。</code></pre>
<p> <br>    提示：<br>    1 &lt;= words.length &lt;= 1000<br>    1 &lt;= words[i].length, chars.length &lt;= 100<br>    所有字符串中都仅包含小写英文字母</p>
<p>题解一（hash）：</p>
<p>思路：对于一个单词 word，只要其中的每个字母的数量都不大于 chars 中对应的字母的数量，那么就可以用 chars 中的字母拼写出 word。所以我们只需要用一个哈希表存储 chars 中每个字母的数量，再用一个哈希表存储 word 中每个字母的数量，最后将这两个哈希表的键值对逐一进行比较即可。</p>
<p>时间复杂度：O(n)，其中 n 为所有字符串的长度和。我们需要遍历每个字符串，包括 chars 以及数组 words 中的每个单词。</p>
<p>空间复杂度：O(S)，其中 S 为字符集大小，在本题中 S 的值为 26（所有字符串仅包含小写字母）。程序运行过程中，最多同时存在两个哈希表，使用的空间均不超过字符集大小 S，因此空间复杂度为 O(S)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def countCharacters(self, words: List[str], chars: str) -&gt; int:</span><br><span class="line">        from collections import Counter</span><br><span class="line">        hashChars&#x3D;&#123;&#125;</span><br><span class="line">        hashWords&#x3D;&#123;&#125;</span><br><span class="line">        hashChars&#x3D;Counter(chars)</span><br><span class="line">        res&#x3D;0</span><br><span class="line">        # print(hashChars)</span><br><span class="line">        for word in words:</span><br><span class="line">            hashWords&#x3D;Counter(word)</span><br><span class="line">            # print(hashWords)</span><br><span class="line">            for key in hashWords:</span><br><span class="line">                if hashChars[key] &lt; hashWords[key]:</span><br><span class="line">                    break </span><br><span class="line">            else:</span><br><span class="line">                res+&#x3D;len(word)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def countCharacters(self, words: List[str], chars: str) -&gt; int:</span><br><span class="line">        res&#x3D;0</span><br><span class="line">        hash1&#x3D;&#123;&#125;</span><br><span class="line">        for each in chars:</span><br><span class="line">            if each not in hash1:</span><br><span class="line">                hash1[each]&#x3D;1</span><br><span class="line">            else:</span><br><span class="line">                hash1[each]+&#x3D;1</span><br><span class="line">        for word in words:</span><br><span class="line">            hash2&#x3D;&#123;&#125;</span><br><span class="line">            for w in word:</span><br><span class="line">                if w not in hash2:</span><br><span class="line">                    hash2[w]&#x3D;1</span><br><span class="line">                else:</span><br><span class="line">                    hash2[w]+&#x3D;1</span><br><span class="line">            for key in hash2:</span><br><span class="line">                if hash2.get(key,0) &gt; hash1.get(key,0):</span><br><span class="line">                    break</span><br><span class="line">            else:</span><br><span class="line">                res+&#x3D;len(word)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<p>for-else用法：</p>
<pre><code>如果for循环正常结束，else中语句执行；
如果for循环是break退出的，则else中语句不执行；</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">for i in range(5):</span><br><span class="line">    print(i)</span><br><span class="line">else:</span><br><span class="line">    print(&#39;hello&#39;)</span><br><span class="line">    </span><br><span class="line">for i in range(5):</span><br><span class="line">    print(i)</span><br><span class="line">    if i&#x3D;&#x3D;2:</span><br><span class="line">        break</span><br><span class="line">else:</span><br><span class="line">    print(&#39;hello&#39;)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">hello</span><br><span class="line">------------</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>题解二|hash：</p>
<pre><code>dict.get(key, default=None)
key -- 字典中要查找的键。
default -- 如果指定键的值不存在时，返回该默认值。</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def countCharacters(self, words: List[str], chars: str) -&gt; int:</span><br><span class="line">        res&#x3D;&#39;&#39;</span><br><span class="line">        for word in words:</span><br><span class="line">            hash&#x3D;&#123;&#125;</span><br><span class="line">            for i in range(len(chars)):</span><br><span class="line">                hash[chars[i]]&#x3D;hash.get(chars[i],0)+1</span><br><span class="line">            count&#x3D;0</span><br><span class="line">            for w in word:</span><br><span class="line">                if hash.get(w,0)&gt;&#x3D;1:</span><br><span class="line">                    hash[w]&#x3D;hash.get(w,0)-1</span><br><span class="line">                    count+&#x3D;1</span><br><span class="line">                else:</span><br><span class="line">                    break</span><br><span class="line">            if count &#x3D;&#x3D; len(word):</span><br><span class="line">                res+&#x3D;word</span><br><span class="line">        return len(res)</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/PyTorch-3-%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/PyTorch-3-%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">PyTorch-3.入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-28 20:44:53" itemprop="dateCreated datePublished" datetime="2020-02-28T20:44:53+08:00">2020-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-14 15:22:24" itemprop="dateModified" datetime="2020-04-14T15:22:24+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习和深度学习</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/PyTorch/" itemprop="url" rel="index"><span itemprop="name">PyTorch</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>PyTorch 是一个基于 Python 的科学计算包，主要定位两类人群：</p>
<pre><code>NumPy 的替代品，可以利用 GPU 的性能进行计算。
深度学习研究平台拥有足够的灵活性和速度。</code></pre>
<h2 id="一、张量Tensors"><a href="#一、张量Tensors" class="headerlink" title="一、张量Tensors"></a>一、张量Tensors</h2><p>Tensors 类似于 NumPy 的 ndarrays ，同时 Tensors 可以使用 GPU 进行计算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from __future__ import print_function</span><br><span class="line">import torch</span><br><span class="line"># x&#x3D;torch.empty(5,3) # 构造一个5x3矩阵，不初始化</span><br><span class="line"># x&#x3D;torch.rand(5,3) # 构造一个随机初始化的矩阵</span><br><span class="line"># x&#x3D;torch.zeros(5,3,dtype&#x3D;torch.long) # 构造一个全0的矩阵，数据类型为long</span><br><span class="line">x&#x3D;torch.tensor([5.5,3]) # 构造一个张量，直接使用数据</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x&#x3D;x.new_ones(5,3,dtype&#x3D;torch.double) # 创建一个 tensor 基于已经存在的 tensor</span><br><span class="line">print(x)</span><br><span class="line">x&#x3D;torch.randn_like(x,dtype&#x3D;torch.float) </span><br><span class="line">print(x)</span><br><span class="line">print(x.size()) # 获取x的维度信息</span><br></pre></td></tr></table></figure>

<p>注意：torch.Size 是一个元组，所以它支持左右的元组操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 加法</span><br><span class="line">y&#x3D;torch.rand(5,3)</span><br><span class="line">print(x+y)</span><br><span class="line">print(torch.add(x,y)) </span><br><span class="line">result&#x3D;torch.empty(5,3)</span><br><span class="line">torch.add(x,y,out&#x3D;result) # 提供一个输出tensor为参数</span><br><span class="line">print(result)</span><br><span class="line">y.add_(x) # 加法in-place</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>

<p>注意：任何使张量会发生变化的操作都有一个前缀 ‘’。例如：x.copy(y), x.t_(), 将会改变 x.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(x[:,1]) # 使用标准的Numpy类似的索引操作</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 改变大小：如果你想改变一个 tensor 的大小或者形状，你可以使用 torch.view:</span><br><span class="line">x&#x3D;torch.randn(4,4)</span><br><span class="line">y&#x3D;x.view(16)</span><br><span class="line">z&#x3D;x.view(-1,8) # the size -1 is inferred from other dimensions</span><br><span class="line">print(x.size(),y.size(),z.size())  </span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x&#x3D;torch.randn(1)</span><br><span class="line">print(x)</span><br><span class="line">print(x.item())  # 使用.item() 来获得tensor的value 。</span><br></pre></td></tr></table></figure>
<h2 id="二、自动微分"><a href="#二、自动微分" class="headerlink" title="二、自动微分"></a>二、自动微分</h2><p>autograd 包是 PyTorch 中所有神经网络的核心。autograd 软件包为 Tensors 上的所有操作提供自动微分。它是一个由运行定义的框架，这意味着以代码运行方式定义你的后向传播，并且每次迭代都可以不同。我们从 tensor 和 gradients举例：</p>
<h3 id="2-1-Tensor"><a href="#2-1-Tensor" class="headerlink" title="2.1 Tensor"></a>2.1 Tensor</h3><p>torch.Tensor 是包的核心类。如果将其属性 .requires_grad 设置为 True，则会开始跟踪针对 tensor 的所有操作。完成计算后，您可以调用 .backward() 来自动计算所有梯度。该张量的梯度将累积到 .grad 属性中。</p>
<p>要停止 tensor 历史记录的跟踪，您可以调用 .detach()，它将其与计算历史记录分离，并防止将来的计算被跟踪。</p>
<p>要停止跟踪历史记录（和使用内存），您还可以将代码块使用 with torch.no_grad(): 包装起来。在评估模型时，这是特别有用，因为模型在训练阶段具有 requires_grad = True 的可训练参数有利于调参，但在评估阶段我们不需要梯度。</p>
<p>还有一个类对于 autograd 实现非常重要那就是 Function。Tensor 和 Function 互相连接并构建一个非循环图，它保存整个完整的计算过程的历史信息。每个张量都有一个 .grad_fn 属性保存着创建了张量的 Function 的引用，（如果用户自己创建张量，则g rad_fn 是 None ）。</p>
<p>如果你想计算导数，你可以调用 Tensor.backward()。如果 Tensor 是标量（即它包含一个元素数据），则不需要指定任何参数backward()，但是如果它有更多元素，则需要指定一个gradient 参数来指定张量的形状。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br><span class="line">x&#x3D;torch.ones(2,2,requires_grad&#x3D;True) # 创建一个张量，设置 requires_grad&#x3D;True 来跟踪与它相关的计算</span><br><span class="line">print(x)</span><br><span class="line"></span><br><span class="line">y&#x3D;x+2</span><br><span class="line">print(y)</span><br><span class="line"></span><br><span class="line">print(y.grad_fn) # y 作为操作的结果被创建，所以它有 grad_fn</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<pre><code>tensor([[1., 1.],
        [1., 1.]], requires_grad=True)
tensor([[3., 3.],
        [3., 3.]], grad_fn=&lt;AddBackward0&gt;)
&lt;AddBackward0 object at 0x7f95ccaa0810&gt;</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">z&#x3D;y*y*3</span><br><span class="line">out&#x3D;z.mean()</span><br><span class="line">print(z,out)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<pre><code>tensor([[27., 27.],
    [27., 27.]], grad_fn=&lt;MulBackward0&gt;) tensor(27., grad_fn=&lt;MeanBackward0&gt;)</code></pre>
<p>.requires_grad_( … ) 会改变张量的 requires_grad 标记。输入的标记默认为 False ，如果没有提供相应的参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a&#x3D;torch.randn(2,2)</span><br><span class="line">a&#x3D;(a*3)&#x2F;(a-1)</span><br><span class="line">print(a.requires_grad)</span><br><span class="line">a.requires_grad_(True)</span><br><span class="line">print(a.requires_grad)</span><br><span class="line">b&#x3D;(a*a).sum()</span><br><span class="line">print(b.grad_fn)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<pre><code>False
True
&lt;SumBackward0 object at 0x7fe1db427dd8&gt;</code></pre>
<h3 id="2-2-梯度"><a href="#2-2-梯度" class="headerlink" title="2.2 梯度"></a>2.2 梯度</h3><p>现在后向传播，因为输出包含了一个标量，out.backward() 等同于out.backward(torch.tensor(1.))。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">out.backward()</span><br><span class="line"># out.backward(retain_graph&#x3D;True)</span><br><span class="line">print(x.grad) # 打印梯度 d(out)&#x2F;dx</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<pre><code>tensor([[4.5000, 4.5000],
    [4.5000, 4.5000]])</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x&#x3D;torch.randn(3,requires_grad&#x3D;True)</span><br><span class="line">y&#x3D;x*2</span><br><span class="line">while y.data.norm() &lt; 1000:</span><br><span class="line">    y&#x3D;y*2</span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure>

<p>在这种情况下，y 不再是一个标量。torch.autograd 不能够直接计算整个雅可比，但是如果我们只想要雅可比向量积，只需要简单的传递向量给 backward 作为参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v &#x3D; torch.tensor([0.1, 1.0, 0.0001], dtype&#x3D;torch.float)</span><br><span class="line">y.backward(v)</span><br><span class="line"></span><br><span class="line">print(x.grad)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 将代码包裹在 with torch.no_grad()，来停止对从跟踪历史中 的 .requires_grad&#x3D;True 的张量自动求导。</span><br><span class="line">print(x.requires_grad)</span><br><span class="line">print((x ** 2).requires_grad)</span><br><span class="line"></span><br><span class="line">with torch.no_grad():</span><br><span class="line">    print((x ** 2).requires_grad)</span><br></pre></td></tr></table></figure>

<h2 id="三、神经网络"><a href="#三、神经网络" class="headerlink" title="三、神经网络"></a>三、神经网络</h2><p>神经网络可以通过 torch.nn 包来构建。</p>
<p>现在对于自动梯度(autograd)有一些了解，神经网络是基于自动梯度 (autograd)来定义一些模型。一个 nn.Module 包括层和一个方法 forward(input) 它会返回输出(output)。</p>
<p>数字图片识别的网络：一个简单的前馈神经网络，它接收输入，让输入一个接着一个的通过一些层，最后给出输出。<br><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/nn.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/nn.png"></p>
<p>神经网络训练过程:</p>
<pre><code>1.定义一个包含可训练参数的神经网络

2.迭代整个输入

3.通过神经网络处理输入

4.计算损失(loss)

5.反向传播梯度到神经网络的参数

6.更新网络的参数，典型的用一个简单的更新方法：weight = weight - learning_rate *gradient</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/PyTorch-1-%E7%AE%80%E4%BB%8B%E5%92%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/PyTorch-1-%E7%AE%80%E4%BB%8B%E5%92%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" class="post-title-link" itemprop="url">PyTorch-1.简介和环境搭建</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-28 20:36:09" itemprop="dateCreated datePublished" datetime="2020-02-28T20:36:09+08:00">2020-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-14 15:29:21" itemprop="dateModified" datetime="2020-04-14T15:29:21+08:00">2020-04-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习和深度学习</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/PyTorch/" itemprop="url" rel="index"><span itemprop="name">PyTorch</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>PyTorch是一个基于Torch的Python开源机器学习库，用于自然语言处理等应用程序。它主要由Facebook人工智能小组开发，不仅能够实现强大的GPU加速，同时还支持动态神经网络，这一点是现在很多主流框架如TensorFlow都不支持的。 </p>
<p>PyTorch提供了两个高级功能：<br>    1.具有强大的GPU加速的张量计算（如Numpy）<br>    2.包含自动求导系统的深度神经网络 </p>
<p>除了Facebook之外，Twitter、GMU和Salesforce等机构都采用了PyTorch。</p>
<p>PyTorch的前身是Torch，Torch是一个有大量机器学习算法支持的科学计算框架，是一个与Numpy类似的张量（Tensor） 操作库，其特点是特别灵活，但因其采用了小众的编程语言是Lua，所以流行度不高，这也就有了PyTorch的出现。所以其实Torch是 PyTorch的前身，它们的底层语言相同，只是使用了不同的上层包装语言。</p>
<p>TensorFlow和Caffe都是命令式的编程语言，而且是静态的，首先必须构建一个神经网络，然后一次又一次使用相同的结构，如果想要改变网络的结构，就必须从头开始。但是对于PyTorch，通过反向求导技术，可以让你零延迟地任意改变神经网络的行为，而且其实现速度 快。正是这一灵活性是PyTorch对比TensorFlow的最大优势。</p>
<p>另外，PyTorch的代码对比TensorFlow而言，更加简洁直观，底层代码也更容易看懂，这对于使用它的人来说理解底层肯定是一件令人激动的事。</p>
<p>所以，总结一下PyTorch的优点： </p>
<pre><code>支持GPU；
灵活，支持动态神经网络；
底层代码易于理解；
命令式体验；
自定义扩展；</code></pre>
<p>当然，现今任何一个深度学习框架都有其缺点，PyTorch也不例外，对比TensorFlow，其全面性处于劣势，目前PyTorch还不支持快速傅里叶、沿维翻转张量和检查无穷与非数值张量；针对移动端、嵌入式部署以及高性能服务器端的部署其性能表现有待提升；其次因为这个框 架较新，使得他的社区没有那么强大，在文档方面其C库大多数没有文档。</p>
<h2 id="二、环境搭建"><a href="#二、环境搭建" class="headerlink" title="二、环境搭建"></a>二、环境搭建</h2><pre><code>安装Anaconda；
安装PyTorch;</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/python%E5%B9%B6%E5%8F%91-19-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/python%E5%B9%B6%E5%8F%91-19-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">python并发-19.垃圾回收机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-27 23:49:58" itemprop="dateCreated datePublished" datetime="2020-02-27T23:49:58+08:00">2020-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-18 14:03:12" itemprop="dateModified" datetime="2020-09-18T14:03:12+08:00">2020-09-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/Python%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">Python并发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>我们知道，目前的计算机都采用的是图灵机架构，其本质就是用一条无限长的纸带，对应今天的存储器。随后在工程学的推演中，逐渐出现了寄存器、易失性存储器（内存）以及永久性存储器（硬盘）等产品。由于不同的存储器，其速度越快，单位价格也就越昂贵，因此，妥善利用好每一寸告诉存储器的空间，永远是系统设计的一个核心。</p>
<p>Python 程序在运行时，需要在内存中开辟出一块空间，用于存放运行时产生的临时变量，计算完成后，再将结果输出到永久性存储器中。但是当数据量过大，或者内存空间管理不善，就很容易出现内存溢出的情况，程序可能会被操作系统终止。</p>
<p>而对于服务器这种用于永不中断的系统来说，内存管理就显得更为重要了，不然很容易引发内存泄漏。<br>这里的内存泄漏是指程序本身没有设计好，导致程序未能释放已不再使用的内存，或者直接失去了对某段内存的控制，造成了内存的浪费。</p>
<p>那么，对于不会再用到的内存空间，Python 是通过什么机制来管理的呢？就是引用计数机制。</p>
<h2 id="一、Python引用计数机制"><a href="#一、Python引用计数机制" class="headerlink" title="一、Python引用计数机制"></a>一、Python引用计数机制</h2><p>Python 中一切皆对象，也就是说，在 Python 中你用到的一切变量，本质上都是类对象。</p>
<p>那么，如何知道一个对象永远都不能再使用了呢？很简单，就是当这个对象的引用计数值为 0 时，说明这个对象永不再用，自然它就变成了垃圾，需要被回收。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import psutil # 获取系统信息</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def showMemoryInfo(hint):</span><br><span class="line">    pid &#x3D; os.getpid()</span><br><span class="line">    p &#x3D; psutil.Process(pid)</span><br><span class="line"></span><br><span class="line">    info &#x3D; p.memory_full_info()</span><br><span class="line">    memory &#x3D; info.uss &#x2F; 1024. &#x2F; 1024</span><br><span class="line">    print(&#39;&#123;&#125; memory used: &#123;&#125; MB&#39;.format(hint, memory))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def func():</span><br><span class="line">    showMemoryInfo(&#39;initial&#39;)</span><br><span class="line">    a &#x3D; [i for i in range(10000000)]</span><br><span class="line">    showMemoryInfo(&#39;after a created&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func()</span><br><span class="line">showMemoryInfo(&#39;finished&#39;)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<pre><code>initial memory used: 6.3828125 MB
after a created memory used: 392.92578125 MB
finished memory used: 10.85546875 MB</code></pre>
<p>可以看到，当调用函数 func() 且列表 a 被创建之后，内存占用迅速增加到了 392 MB，而在函数调用结束后，内存则返回正常。这是因为，函数内部声明的列表 a 是局部变量，在函数返回后，局部变量的引用会注销掉，此时列表 a 所指代对象的引用计数为 0，Python 便会执行垃圾回收，因此之前占用的大量内存就又回来了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import psutil</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def showMemoryInfo(hint):</span><br><span class="line">    pid &#x3D; os.getpid()</span><br><span class="line">    p &#x3D; psutil.Process(pid)</span><br><span class="line"></span><br><span class="line">    info &#x3D; p.memory_full_info()</span><br><span class="line">    memory &#x3D; info.uss &#x2F; 1024. &#x2F; 1024</span><br><span class="line">    print(&#39;&#123;&#125; memory used: &#123;&#125; MB&#39;.format(hint, memory))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def func():</span><br><span class="line">    showMemoryInfo(&#39;initial&#39;)</span><br><span class="line">    global a</span><br><span class="line">    a &#x3D; [i for i in range(10000000)]</span><br><span class="line">    showMemoryInfo(&#39;after a created&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func()</span><br><span class="line">showMemoryInfo(&#39;finished&#39;)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">initial memory used: 6.37890625 MB</span><br><span class="line">after a created memory used: 392.74609375 MB</span><br><span class="line">finished memory used: 392.74609375 MB</span><br></pre></td></tr></table></figure>

<p>global a 表示将 a 声明为全局变量，则即使函数返回后，列表的引用依然存在，于是 a 对象就不会被当做垃圾回收掉，依然占用大量内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import psutil</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def showMemoryInfo(hint):</span><br><span class="line">    pid &#x3D; os.getpid()</span><br><span class="line">    p &#x3D; psutil.Process(pid)</span><br><span class="line"></span><br><span class="line">    info &#x3D; p.memory_full_info()</span><br><span class="line">    memory &#x3D; info.uss &#x2F; 1024. &#x2F; 1024</span><br><span class="line">    print(&#39;&#123;&#125; memory used: &#123;&#125; MB&#39;.format(hint, memory))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def func():</span><br><span class="line">    showMemoryInfo(&#39;initial&#39;)</span><br><span class="line">    a &#x3D; [i for i in range(10000000)]</span><br><span class="line">    showMemoryInfo(&#39;after a created&#39;)</span><br><span class="line">    return a</span><br><span class="line"></span><br><span class="line">a &#x3D; func()</span><br><span class="line">showMemoryInfo(&#39;finished&#39;)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">initial memory used: 6.4140625 MB</span><br><span class="line">after a created memory used: 392.86328125 MB</span><br><span class="line">finished memory used: 392.86328125 MB</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果把生成的列表返回，然后在主程序中接收，那么引用依然存在，垃圾回收也不会被触发，大量内存仍然被占用着.</p>
<p>??Python 内部的引用计数机制:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">a &#x3D; []</span><br><span class="line">print(sys.getrefcount(a))  # 两次引用，一次来自 a，一次来自 getrefcount</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def func(a):</span><br><span class="line">    # 四次引用，a，python 的函数调用栈，函数参数，和 getrefcount</span><br><span class="line">    print(sys.getrefcount(a))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func(a)</span><br><span class="line"># 两次引用，一次来自 a，一次来自 getrefcount，函数 func 调用已经不存在</span><br><span class="line">print(sys.getrefcount(a))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<pre><code>2
4
2</code></pre>
<p>注意：sys.getrefcount() 函数用于查看一个变量的引用次数，不过别忘了，getrefcount 本身也会引入一次计数。</p>
<p>注意：在函数调用发生的时候，会产生额外的两次引用，一次来自函数栈，另一个是函数参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">a &#x3D; []</span><br><span class="line">print(sys.getrefcount(a)) # 两次</span><br><span class="line">b &#x3D; a</span><br><span class="line">print(sys.getrefcount(a)) # 三次</span><br><span class="line">c &#x3D; b</span><br><span class="line">d &#x3D; b</span><br><span class="line">e &#x3D; c</span><br><span class="line">f &#x3D; e</span><br><span class="line">g &#x3D; d</span><br><span class="line">print(sys.getrefcount(a)) # 八次</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">8</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<p>a、b、c、d、e、f、g 这些变量全部指代的是同一个对象，而 sys.getrefcount() 函数并不是统计一个指针，而是要统计一个对象被引用的次数，所以最后一共会有 8 次引用。</p>
<p>理解引用这个概念后，引用释放是一种非常自然和清晰的思想。相比 C 语言中需要使用 free 去手动释放内存，Python 的垃圾回收在这里可以说是省心省力了。</p>
<p>不过，有读者还是会好奇，如果想手动释放内存，应该怎么做呢？方法同样很简单，只需要先调用 del a 来删除一个对象，然后强制调用 gc.collect() 即可手动启动垃圾回收。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import psutil</span><br><span class="line">import os</span><br><span class="line">import gc</span><br><span class="line"></span><br><span class="line">def show_memory_info(hint):</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    显示当前 python 程序占用的内存大小</span><br><span class="line">    :param hint:</span><br><span class="line">    :return:</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    pid &#x3D; os.getpid()</span><br><span class="line">    p &#x3D; psutil.Process(pid)</span><br><span class="line"></span><br><span class="line">    info &#x3D; p.memory_full_info()</span><br><span class="line">    memory &#x3D; info.uss &#x2F; 1024. &#x2F; 1024</span><br><span class="line">    print(&#39;&#123;&#125; memory used: &#123;&#125; MB&#39;.format(hint, memory))</span><br><span class="line"></span><br><span class="line">show_memory_info(&#39;initial&#39;)</span><br><span class="line">a&#x3D;[i for i in range(10000000)]</span><br><span class="line">show_memory_info(&#39;after a created&#39;)</span><br><span class="line">del a</span><br><span class="line">gc.collect()</span><br><span class="line">show_memory_info(&#39;finished&#39;)</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">initial memory used: 6.3984375 MB</span><br><span class="line">after a created memory used: 392.77734375 MB</span><br><span class="line">finished memory used: 10.70703125 MB</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&#x2F;Users&#x2F;apple&#x2F;PycharmProjects&#x2F;python-learning&#x2F;test&#x2F;Account.py&quot;, line 24, in &lt;module&gt;</span><br><span class="line">    print(a)</span><br><span class="line">NameError: name &#39;a&#39; is not defined</span><br></pre></td></tr></table></figure>

<p>问题：引用次数为 0 是垃圾回收启动的充要条件吗？还有没有其他可能性呢？</p>
<p>引用计数是其中最简单的实现，引用计数并非充要条件，它只能算作充分非必要条件，至于其他的可能性，下面所讲的循环引用正是其中一种。</p>
<h2 id="二、循环引用"><a href="#二、循环引用" class="headerlink" title="二、循环引用"></a>二、循环引用</h2><p>问题：如果有两个对象，之间互相引用，且不再被别的对象所引用，那么它们应该被垃圾回收吗？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import psutil</span><br><span class="line">import os</span><br><span class="line">import gc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def show_memory_info(hint):</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    显示当前 python 程序占用的内存大小</span><br><span class="line">    :param hint:</span><br><span class="line">    :return:</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    pid &#x3D; os.getpid()</span><br><span class="line">    p &#x3D; psutil.Process(pid)</span><br><span class="line"></span><br><span class="line">    info &#x3D; p.memory_full_info()</span><br><span class="line">    memory &#x3D; info.uss &#x2F; 1024. &#x2F; 1024</span><br><span class="line">    print(&#39;&#123;&#125; memory used: &#123;&#125; MB&#39;.format(hint, memory))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def func():</span><br><span class="line">    show_memory_info(&#39;initial&#39;)</span><br><span class="line">    a &#x3D; [i for i in range(10000000)]</span><br><span class="line">    b &#x3D; [i for i in range(10000000)]</span><br><span class="line">    show_memory_info(&#39;after a,b created&#39;)</span><br><span class="line">    a.append(b)</span><br><span class="line">    b.append(a)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func()</span><br><span class="line">show_memory_info(&#39;finished&#39;)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">initial memory used: 6.4375 MB</span><br><span class="line">after a,b created memory used: 779.69140625 MB</span><br><span class="line">finished memory used: 779.69140625 MB</span><br></pre></td></tr></table></figure>

<p>程序中，a 和 b 互相引用，并且作为局部变量在函数 func 调用结束后，a 和 b 这两个指针从程序意义上已经不存在，但从输出结果中看到，依然有内存占用，这是为什么呢？因为互相引用导致它们的引用数都不为 0。</p>
<p>试想一下，如果这段代码出现在生产环境中，哪怕 a 和 b 一开始占用的空间不是很大，但经过长时间运行后，Python 所占用的内存一定会变得越来越大，最终撑爆服务器，后果不堪设想。</p>
<p>有读者可能会说，互相引用还是很容易被发现的呀，问题不大。可是，更隐蔽的情况是出现一个引用环，在工程代码比较复杂的情况下，引用环真不一定能被轻易发现。那么应该怎么做呢？</p>
<p>Python 本身能够处理这种情况，可以通过显式调用 gc.collect() 来启动垃圾回收，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import psutil</span><br><span class="line">import os</span><br><span class="line">import gc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def show_memory_info(hint):</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    显示当前 python 程序占用的内存大小</span><br><span class="line">    :param hint:</span><br><span class="line">    :return:</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    pid &#x3D; os.getpid()</span><br><span class="line">    p &#x3D; psutil.Process(pid)</span><br><span class="line"></span><br><span class="line">    info &#x3D; p.memory_full_info()</span><br><span class="line">    memory &#x3D; info.uss &#x2F; 1024. &#x2F; 1024</span><br><span class="line">    print(&#39;&#123;&#125; memory used: &#123;&#125; MB&#39;.format(hint, memory))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def func():</span><br><span class="line">    show_memory_info(&#39;initial&#39;)</span><br><span class="line">    a &#x3D; [i for i in range(10000000)]</span><br><span class="line">    b &#x3D; [i for i in range(10000000)]</span><br><span class="line">    show_memory_info(&#39;after a,b created&#39;)</span><br><span class="line">    a.append(b)</span><br><span class="line">    b.append(a)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func()</span><br><span class="line">gc.collect()</span><br><span class="line">show_memory_info(&#39;finished&#39;)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">initial memory used: 6.41015625 MB</span><br><span class="line">after a,b created memory used: 779.81640625 MB</span><br><span class="line">finished memory used: 11.4375 MB</span><br></pre></td></tr></table></figure>

<p>事实上，Python 使用标记清除（mark-sweep）算法和分代收集（generational），来启用针对循环引用的自动垃圾回收。</p>
<p>1、标记清除算法：</p>
<p>先用图论来理解不可达的概念。对于一个有向图，如果从一个节点出发进行遍历，并标记其经过的所有节点；那么，在遍历结束后，所有没有被标记的节点，我们就称之为不可达节点。显而易见，这些节点的存在是没有任何意义的，自然的，我们就需要对它们进行垃圾回收。</p>
<p>当然，每次都遍历全图，对于 Python 而言是一种巨大的性能浪费。所以，在 Python 的垃圾回收实现中，标记清除算法使用双向链表维护了一个数据结构，并且只考虑容器类的对象（只有容器类对象才有可能产生循环引用）。</p>
<p>2、分代收集算法：</p>
<p>将 Python 中的所有对象分为三代。刚刚创立的对象是第 0 代；经过一次垃圾回收后，依然存在的对象，便会依次从上一代挪到下一代。而每一代启动自动垃圾回收的阈值，则是可以单独指定的。当垃圾回收器中新增对象减去删除对象达到相应的阈值时，就会对这一代对象启动垃圾回收。</p>
<p>事实上，分代收集基于的思想是，新生的对象更有可能被垃圾回收，而存活更久的对象也有更高的概率继续存活。因此，通过这种做法，可以节约不少计算量，从而提高 Python 的性能。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/python%E5%B9%B6%E5%8F%91-18-GIL%E5%85%A8%E5%B1%80%E8%A7%A3%E9%87%8A%E5%99%A8%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/python%E5%B9%B6%E5%8F%91-18-GIL%E5%85%A8%E5%B1%80%E8%A7%A3%E9%87%8A%E5%99%A8%E9%94%81/" class="post-title-link" itemprop="url">python并发-18.GIL全局解释器锁</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-27 23:30:32" itemprop="dateCreated datePublished" datetime="2020-02-27T23:30:32+08:00">2020-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-18 14:03:08" itemprop="dateModified" datetime="2020-09-18T14:03:08+08:00">2020-09-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/Python%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">Python并发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>GIL，中文译为全局解释器锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">start &#x3D; time.clock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def count(n):</span><br><span class="line">    while n &gt; 0:</span><br><span class="line">        n -&#x3D; 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">count(10000)</span><br><span class="line">print(&#39;Time used:&#39;, (time.clock() - start))</span><br></pre></td></tr></table></figure>

<p>输出：Time used: 0.0006330000000000016</p>
<p>使用多（适量）线程可以提升程序性能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">from threading import Thread</span><br><span class="line"></span><br><span class="line">start &#x3D; time.clock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def count(n):</span><br><span class="line">    while n &gt; 0:</span><br><span class="line">        n -&#x3D; 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t1 &#x3D; Thread(target&#x3D;count, args&#x3D;[10000 &#x2F;&#x2F; 2])</span><br><span class="line">t2 &#x3D; Thread(target&#x3D;count, args&#x3D;[10000 &#x2F;&#x2F; 2])</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t1.join()</span><br><span class="line">t2.join()</span><br><span class="line">print(&#39;Time used:&#39;, (time.clock() - start))</span><br></pre></td></tr></table></figure>
<p>输出：Time used: 0.0007749999999999979</p>
<p>从输出结果看，多线程不但没有提高性能，反而降低了。</p>
<pre><code>如果使用更多线程进行尝试，会发现其运行效率和 2 个线程效率几乎一样（本机器测试使用 4 个线程，其执行效率约为 0.001）。</code></pre>
<p>事实上，得到这样的结果是肯定的，因为 GIL 限制了 Python 多线程的性能不会像我们预期的那样。</p>
<p>那么，什么是 GIL 呢？GIL 是最流程的 CPython 解释器（平常称为 Python）中的一个技术术语，中文译为全局解释器锁，其本质上类似操作系统的 Mutex。GIL 的功能是：在 CPython 解释器中执行的每一个 Python 线程，都会先锁住自己，以阻止别的线程执行。</p>
<p>当然，CPython 不可能容忍一个线程一直独占解释器，它会轮流执行 Python 线程。这样一来，用户看到的就是“伪”并行，即 Python 线程在交替执行，来模拟真正并行的线程。</p>
<p>有读者可能会问，既然 CPython 能控制线程伪并行，为什么还需要 GIL 呢？其实，这和 CPython 的底层内存管理有关。</p>
<p>CPython 使用引用计数来管理内容，所有 Python 脚本中创建的实例，都会配备一个引用计数，来记录有多少个指针来指向它。当实例的引用计数的值为 0 时，会自动释放其所占的内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import sys</span><br><span class="line">&gt;&gt;&gt; a &#x3D; []</span><br><span class="line">&gt;&gt;&gt; b &#x3D; a</span><br><span class="line">&gt;&gt;&gt; sys.getrefcount(a)</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>a 的引用计数值为 3，因为有 a、b 和作为参数传递的 getrefcount 都引用了一个空列表。</p>
<p>假设有两个 Python 线程同时引用 a，那么双方就都会尝试操作该数据，很有可能造成引用计数的条件竞争，导致引用计数只增加 1（实际应增加 2），这造成的后果是，当第一个线程结束时，会把引用计数减少 1，此时可能已经达到释放内存的条件（引用计数为 0），当第 2 个线程再次视图访问 a 时，就无法找到有效的内存了。</p>
<p>所以，CPython 引进 GIL，可以最大程度上规避类似内存管理这样复杂的竞争风险问题。</p>
<h2 id="一、GIL底层实现原理"><a href="#一、GIL底层实现原理" class="headerlink" title="一、GIL底层实现原理"></a>一、GIL底层实现原理</h2><p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/GIL.gif" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/GIL.gif"></p>
<p>GIL 在 Python 程序的工作流程：</p>
<p>Thread 1、2、3 轮流执行，每一个线程在开始执行时，都会锁住 GIL，以阻止别的线程执行；同样的，每一个线程执行完一段后，会释放 GIL，以允许别的线程开始利用资源。</p>
<p>为什么 Python 线程会去主动释放 GIL 呢？毕竟，如果仅仅要求 Python 线程在开始执行时锁住 GIL，且永远不去释放 GIL，那别的线程就都没有运行的机会。其实，CPython 中还有另一个机制，叫做间隔式检查（check_interval），意思是 CPython 解释器会去轮询检查线程 GIL 的锁住情况，每隔一段时间，Python 解释器就会强制当前线程去释放 GIL，这样别的线程才能有执行的机会。</p>
<p>注意：不同版本的 Python，其间隔式检查的实现方式并不一样。早期的 Python 是 100 个刻度（大致对应了 1000 个字节码）；而 Python 3 以后，间隔时间大致为 15 毫秒。当然，我们不必细究具体多久会强制释放 GIL，读者只需要明白，CPython 解释器会在一个“合理”的时间范围内释放 GIL 就可以了。</p>
<p>每一个 Python 线程都是类似这样循环的封装，来看下面这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for (;;) &#123;</span><br><span class="line">    if (--ticker &lt; 0) &#123;</span><br><span class="line">        ticker &#x3D; check_interval;   </span><br><span class="line">        &#x2F;* Give another thread a chance *&#x2F;</span><br><span class="line">        PyThread_release_lock(interpreter_lock);</span><br><span class="line">        &#x2F;* Other threads may run now *&#x2F;   </span><br><span class="line">        PyThread_acquire_lock(interpreter_lock, 1);</span><br><span class="line">    &#125;</span><br><span class="line">    bytecode &#x3D; *next_instr++;</span><br><span class="line">    switch (bytecode) &#123;</span><br><span class="line">        &#x2F;* execute the next instruction ... *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>每个 Python 线程都会先检查 ticker 计数。只有在 ticker 大于 0 的情况下，线程才会去执行自己的代码。</p>
<h2 id="二、GIL不能绝对保证线程安全"><a href="#二、GIL不能绝对保证线程安全" class="headerlink" title="?二、GIL不能绝对保证线程安全"></a>?二、GIL不能绝对保证线程安全</h2><p>注意：有了 GIL，并不意味着 Python 程序员就不用去考虑线程安全了，因为即便 GIL 仅允许一个 Python 线程执行，但别忘了 Python 还有 check interval 这样的抢占机制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line">n &#x3D; 0</span><br><span class="line"></span><br><span class="line">def foo():</span><br><span class="line">    global n</span><br><span class="line">    n +&#x3D; 1</span><br><span class="line"></span><br><span class="line">threads &#x3D; []</span><br><span class="line">for i in range(100):</span><br><span class="line">    t &#x3D; threading.Thread(target&#x3D;foo)</span><br><span class="line">    threads.append(t)</span><br><span class="line"></span><br><span class="line">for i in threads:</span><br><span class="line">    i.start()</span><br><span class="line"></span><br><span class="line">for i in threads:</span><br><span class="line">    i.join()</span><br><span class="line">print(n)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行此代码会发现，其大部分时候会打印 100，但有时也会打印 99 或者 98，原因在于 n+=1 这一句代码让线程并不安全。如果去翻译 foo 这个函数的字节码就会发现，它实际上是由下面四行字节码组成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import dis</span><br><span class="line">&gt;&gt;&gt; dis.dis(foo)</span><br><span class="line">LOAD_GLOBAL              0 (n)</span><br><span class="line">LOAD_CONST               1 (1)</span><br><span class="line">INPLACE_ADD</span><br><span class="line">STORE_GLOBAL             0 (n)</span><br></pre></td></tr></table></figure>

<p>而这四行字节码中间都是有可能被打断的！所以，千万别以为有了 GIL 程序就不会产生线程问题，我们仍然需要注意线程安全。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/python%E5%B9%B6%E5%8F%91-17-Asyncio%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/python%E5%B9%B6%E5%8F%91-17-Asyncio%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">python并发-17.Asyncio并发编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-27 23:06:24" itemprop="dateCreated datePublished" datetime="2020-02-27T23:06:24+08:00">2020-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-18 14:03:04" itemprop="dateModified" datetime="2020-09-18T14:03:04+08:00">2020-09-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/Python%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">Python并发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>多线程和普通的单线程相比，其运行效率会有极大的提高。但多线程也存在一定的局限性：</p>
<p>1、多线程运行过程中容易被打断，还可能出现多个线程同时竞争同一资源的情况；<br>2、多线程切换本身存在一定的损耗，线程数不能无线增加，因此如果I\O操作非常频繁，多线程很有可能满足不了高效率、高质量的需求。</p>
<p>同步：是指操作一个接一个地执行，下一个操作必须等上一个操作执行完成之后才能开始执行；<br>异步：是指不同操作间可以相互交替执行，如果其中地某个操作被堵塞，程序并不会等待，而是会找出可执行的操作继续执行。</p>
<p>例子（做一份报表，并以邮件的方式提交）：</p>
<p>同步：应先向软件中输入各项数据，接下来等报表生成，再写邮件提交；<br>异步：向软件中输出各项数据后，会先写邮件，等待报表生成后，暂停写邮件的工作去查看生成的报表，确认无误后在写邮件直到发送完毕。</p>
<h2 id="一、关于Asyncio"><a href="#一、关于Asyncio" class="headerlink" title="一、关于Asyncio"></a>一、关于Asyncio</h2><p>Asyncio 和其他 Python 程序一样，是单线程的，它只有一个主线程，但可以进行多个不同的任务。这里的任务，指的就是特殊的 future 对象，我们可以把它类比成多线程版本里的多个线程。</p>
<p>这些不同的任务，被一个叫做事件循环（Event Loop）的对象所控制。<br>所谓事件循环，是指主线程每次将执行序列中的任务清空后，就去事件队列中检查是否有等待执行的任务，如果有则每次取出一个推到执行序列中执行，这个过程是循环往复的。</p>
<p>为了简化讲解这个问题，可以假设任务只有两个状态：，分别是预备状态和等待状态：</p>
<pre><code>预备状态是指任务目前空闲，但随时待命准备运行；
等待状态是指任务已经运行，但正在等待外部的操作完成，比如 I/O 操作。</code></pre>
<p>在这种情况下，事件循环会维护两个任务列表，分别对应这两种状态，并且选取预备状态的一个任务（具体选取哪个任务，和其等待的时间长短、占用的资源等等相关）使其运行，一直到这个任务把控制权交还给事件循环为止。</p>
<p>当任务把控制权交还给事件循环对象时，它会根据其是否完成把任务放到预备或等待状态的列表，然后遍历等待状态列表的任务，查看他们是否完成：如果完成，则将其放到预备状态的列表；反之，则继续放在等待状态的列表。而原先在预备状态列表的任务位置仍旧不变，因为它们还未运行。</p>
<p>这样，当所有任务被重新放置在合适的列表后，新一轮的循环又开始了，事件循环对象继续从预备状态的列表中选取一个任务使其执行…如此周而复始，直到所有任务完成。</p>
<p>值得一提的是，对于 Asyncio 来说，它的任务在运行时不会被外部的一些因素打断，因此 Asyncio 内的操作不会出现竞争资源（多个线程同时使用同一资源）的情况，也就不需要担心线程安全的问题了。</p>
<h2 id="二、Asyncio的使用"><a href="#二、Asyncio的使用" class="headerlink" title="二、Asyncio的使用"></a>二、Asyncio的使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line">import aiohttp</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async def downloadOne(url):</span><br><span class="line">    async with aiohttp.ClientSession() as session:</span><br><span class="line">        async with session.get(url) as resp:</span><br><span class="line">            print(&#39;Read &#123;&#125; from &#123;&#125;&#39;.format(resp.content_length, url))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async def downloadAll(urls):</span><br><span class="line">    tasks &#x3D; [asyncio.ensure_future(downloadOne(url)) for url in urls]</span><br><span class="line">    await asyncio.gather(*tasks)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    urls &#x3D; [</span><br><span class="line">        &#39;http:&#x2F;&#x2F;c.biancheng.net&#39;,</span><br><span class="line">        &#39;http:&#x2F;&#x2F;c.biancheng.net&#x2F;c&#39;,</span><br><span class="line">        &#39;http:&#x2F;&#x2F;c.biancheng.net&#x2F;python&#39;</span><br><span class="line">    ]</span><br><span class="line">    start &#x3D; time.perf_counter()</span><br><span class="line">    loop &#x3D; asyncio.get_event_loop()</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        loop.run_until_complete(downloadAll(urls))</span><br><span class="line">    finally:</span><br><span class="line">        loop.close()</span><br><span class="line"></span><br><span class="line">    end &#x3D; time.perf_counter()</span><br><span class="line">    print(&#39;Download &#123;&#125; urls in &#123;&#125; seconds&#39;.format(len(urls), end - start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<pre><code>Read None from http://c.biancheng.net
Read None from http://c.biancheng.net/c
Read None from http://c.biancheng.net/python
Download 3 urls in 0.10918640485033393 seconds</code></pre>
<p>注意：Async 和 await 关键字是 Asyncio 的最新写法，表示这个语句（函数）是非阻塞的，正好对应前面所讲的事件循环的概念，即如果任务执行的过程需要等待，则将其放入等待状态的列表中，然后继续执行预备状态列表里的任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">loop &#x3D; asyncio.get_event_loop()</span><br><span class="line">    try:</span><br><span class="line">        loop.run_until_complete(downloadll(sites))</span><br><span class="line">    finally:</span><br><span class="line">        loop.close()</span><br></pre></td></tr></table></figure>
<p>上述代码表示拿到事件循环对象，并运行 downloadAll() 函数，直到其结束，最后关闭这个事件循环对象。</p>
<p>注意：如果读者使用 Python 3.7 及以上版本，上述代码可以直接用 asyncio.run(downloadAll(sites)) 来代替。</p>
<p>至于 Asyncio 版本的函数 downloadAll()，和之前多线程版本有很大的区别：</p>
<p>1、这里的 asyncio.ensure_future(coro) 表示对输入的协程 coro 创建一个任务，安排它的执行，并返回此任务对象。可以看到，这里对每一个网站的下载，都创建了一个对应的任务。</p>
<pre><code>注意：Python 3.7+ 版本之后，可以使用 asyncio.create_task(coro) 等效替代 asyncio.ensure_future(coro)。</code></pre>
<p>2、asyncio.gather() 表示在事件循环对象中运行 aws 序列的所有任务。</p>
<pre><code>可以看到，其输出结果显示用时只有 0.11s，比之前的多线程版本效率更高，充分体现其优势。</code></pre>
<p>Asyncio 还有很多其他的用法，可以查看 Python 事件循环官方文档进行了解。</p>
<h2 id="三、Asyncio的缺陷"><a href="#三、Asyncio的缺陷" class="headerlink" title="三、Asyncio的缺陷"></a>三、Asyncio的缺陷</h2><p>在学习多线程编程中使用的是 requests 库，但本节使用的是 aiohttp 库，原因在于 requests 库并不兼容 Asyncio，而 aiohttp 库兼容。Asyncio 软件库的兼容性问题，在 Python3 的早期一直是个大问题，但是随着技术的发展，这个问题正逐步得到解决。</p>
<p>使用 Asyncio 时，因为在任务调度方面有了更大的自主权，写代码时就得更加注意，不然很容易出错。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/python%E5%B9%B6%E5%8F%91-16-Futures%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/python%E5%B9%B6%E5%8F%91-16-Futures%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">python并发-16.Futures并发编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-27 22:25:19" itemprop="dateCreated datePublished" datetime="2020-02-27T22:25:19+08:00">2020-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-18 14:03:00" itemprop="dateModified" datetime="2020-09-18T14:03:00+08:00">2020-09-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/Python%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">Python并发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>下载网站内容并打印（单线程）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def downloadOne(url):</span><br><span class="line">    resp &#x3D; requests.get(url)</span><br><span class="line">    print(&#39;Read &#123;&#125; from &#123;&#125;&#39;.format(len(resp.content), url))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def downloadAll(urls):</span><br><span class="line">    for each in urls:</span><br><span class="line">        downloadOne(each)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    urls &#x3D; [</span><br><span class="line">        &#39;http:&#x2F;&#x2F;c.biancheng.net&#39;,</span><br><span class="line">        &#39;http:&#x2F;&#x2F;c.biancheng.net&#x2F;c&#39;,</span><br><span class="line">        &#39;http:&#x2F;&#x2F;c.biancheng.net&#x2F;python&#39;</span><br><span class="line">    ]</span><br><span class="line">    start &#x3D; time.perf_counter()</span><br><span class="line">    downloadAll(urls)</span><br><span class="line">    end &#x3D; time.perf_counter()</span><br><span class="line">    print(&#39;Download &#123;&#125; urls in &#123;&#125; seconds&#39;.format(len(urls), end - start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<pre><code>Read 51828 from http://c.biancheng.net
Read 31939 from http://c.biancheng.net/c
Read 31996 from http://c.biancheng.net/python
Download 3 urls in 0.5172422020696104 seconds</code></pre>
<p>步骤：</p>
<pre><code>遍历存储网站的列表；
对当前网站执行下载操作；
等到当前操作完成后，再对下一个网站进行同样的操作，一直到结束。

总共耗时约 0.51s。</code></pre>
<p>单线程的优点是简单明了，但是明显效率低下，因为上述程序的绝大多数时间都浪费在了 I/O 等待上。程序每次对一个网站执行下载操作，都必须等到前一个网站下载完成后才能开始。如果放在实际生产环境中，我们需要下载的网站数量至少是以万为单位的，不难想象，这种方案根本行不通。</p>
<p>下载网站内容并打印（多线程）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import concurrent.futures</span><br><span class="line">import requests</span><br><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def downloadOne(url):</span><br><span class="line">    resp &#x3D; requests.get(url)</span><br><span class="line">    print(&#39;Read &#123;&#125; from &#123;&#125;&#39;.format(len(resp.content), url))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def downloadAll(urls):</span><br><span class="line">    with concurrent.futures.ThreadPoolExecutor(max_workers&#x3D;5) as executor:</span><br><span class="line">        executor.map(downloadOne, urls)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    urls &#x3D; [</span><br><span class="line">        &#39;http:&#x2F;&#x2F;c.biancheng.net&#39;,</span><br><span class="line">        &#39;http:&#x2F;&#x2F;c.biancheng.net&#x2F;c&#39;,</span><br><span class="line">        &#39;http:&#x2F;&#x2F;c.biancheng.net&#x2F;python&#39;</span><br><span class="line">    ]</span><br><span class="line">    start &#x3D; time.perf_counter()</span><br><span class="line">    downloadAll(urls)</span><br><span class="line">    end &#x3D; time.perf_counter()</span><br><span class="line">    print(&#39;Download &#123;&#125; urls in &#123;&#125; seconds&#39;.format(len(urls), end - start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<pre><code>Read 31996 from http://c.biancheng.net/python
Read 31939 from http://c.biancheng.net/c
Read 51828 from http://c.biancheng.net
Download 3 urls in 0.16959443595260382 seconds

总耗时0.2，性能提升了很多。</code></pre>
<p>注意：虽然线程的数量可以自己定义，但是线程数并不是越多越好，因为线程的创建、维护和删除也会有一定的开销，所以如果设置的很大，反而可能会导致速度变慢。我们往往需要根据实际的需求做一些测试，来寻找最优的线程数量。</p>
<p>在 downloadOne() 中使用的 requests.get() 方法是线程安全的，在多线程的环境下也可以安全使用，不会出现条件竞争（多个线程同时竞争使用同一资源）的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># with concurrent.futures.ThreadPoolExecutor(max_workers&#x3D;5) as executor:</span><br><span class="line">    with concurrent.futures.ProcessPoolExecutor() as executor:</span><br></pre></td></tr></table></figure>

<p>使用并行的方式去提高程序运行效率，只需要在 downloadAll() 函数中做出下面的变化，ProcessPoolExecutor() 表示创建进程池，使用多个进程并行的执行程序。不过，这里通常省略参数 workers，因为系统会自动返回 CPU 的数量作为可以调用的进程数。</p>
<p>输出：</p>
<pre><code>Read 51828 from http://c.biancheng.net
Read 31939 from http://c.biancheng.net/c
Read 31996 from http://c.biancheng.net/python
Download 3 urls in 0.2866901899687946 seconds</code></pre>
<p>并行的方式一般用在 CPU heavy 的场景中，因为对于 I/O heavy 的操作，多数时间都会用于等待，相比于多线程，使用多进程并不会提升效率。反而很多时候，因为 CPU 数量的限制，会导致其执行效率不如多线程版本。</p>
<h2 id="一、Futures"><a href="#一、Futures" class="headerlink" title="一、Futures"></a>一、Futures</h2><p>Python Futures 模块，位于 concurrent.futures 和 asyncio 中，它们都表示带有延迟的操作。Futures 会将处于等待状态的操作包裹起来放到队列中，这些操作的状态随时可以查询，当然它们的结果（或是异常）也能够在操作完成后被获取。</p>
<p>通常来说，用户不用考虑如何去创建 Futures，这些 Futures 底层都会帮我们处理好，唯一要做的只是去设定这些 Futures 的执行。比如，Futures 中的 Executor 类，当执行 executor.submit(func) 时，它便会安排里面的 func() 函数执行，并返回创建好的 future 实例，以便之后查询调用。</p>
<p>常用函数:</p>
<p>比如 Futures 中的方法 done()，表示相对应的操作是否完成，返回 True 表示完成；返回 False 表示没有完成。不过要注意的是，done() 是非阻塞的，会立即返回结果。相对应的 add_done_callback(fn)，则表示 Futures 完成后，相对应的参数函数 fn 会被通知并执行调用。</p>
<p>Futures 中还有一个重要的函数 result()，它表示当 future 完成后，返回其对应的结果或异常。而 as_completed(fs)，则是针对给定的 future 迭代器 fs，在其完成后返回完成后的迭代器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import concurrent.futures</span><br><span class="line">import requests</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def downloadOne(url):</span><br><span class="line">    resp &#x3D; requests.get(url)</span><br><span class="line">    print(&#39;Read &#123;&#125; from &#123;&#125;&#39;.format(len(resp.content), url))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def downloadAll(urls):</span><br><span class="line">    with concurrent.futures.ThreadPoolExecutor(max_workers&#x3D;5) as executor:</span><br><span class="line">        # with concurrent.futures.ProcessPoolExecutor() as executor:</span><br><span class="line">        todo &#x3D; []</span><br><span class="line">        for url in urls:</span><br><span class="line">            future &#x3D; executor.submit(downloadOne, url)</span><br><span class="line">            todo.append(future)</span><br><span class="line"></span><br><span class="line">        for future in concurrent.futures.as_completed(todo):</span><br><span class="line">            future.result()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    urls &#x3D; [</span><br><span class="line">        &#39;http:&#x2F;&#x2F;c.biancheng.net&#39;,</span><br><span class="line">        &#39;http:&#x2F;&#x2F;c.biancheng.net&#x2F;c&#39;,</span><br><span class="line">        &#39;http:&#x2F;&#x2F;c.biancheng.net&#x2F;python&#39;</span><br><span class="line">    ]</span><br><span class="line">    start &#x3D; time.perf_counter()</span><br><span class="line">    downloadAll(urls)</span><br><span class="line">    end &#x3D; time.perf_counter()</span><br><span class="line">    print(&#39;Download &#123;&#125; urls in &#123;&#125; seconds&#39;.format(len(urls), end - start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<pre><code>Read 31996 from http://c.biancheng.net/python
Read 51828 from http://c.biancheng.net
Read 31939 from http://c.biancheng.net/c
Download 3 urls in 0.2889432869851589 seconds</code></pre>
<p>首先调用 executor.submit()，将下载每一个网站的内容都放进 future 队列 to_do 等待执行。然后是 as_completed() 函数在 future 完成后便输出结果。</p>
<p>注意：future 列表中每个 future 完成的顺序和它在列表中的顺序并不一定完全一致。到底哪个先完成、哪个后完成，取决于系统的调度和每个 future 的执行时间。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Lilly</p>
  <div class="site-description" itemprop="description">Up in the wind!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">132</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">53</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">48</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lilly</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
