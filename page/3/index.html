<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"gongyanli.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Up in the wind!">
<meta property="og:type" content="website">
<meta property="og:title" content="茉莉Python">
<meta property="og:url" content="http://gongyanli.com/page/3/index.html">
<meta property="og:site_name" content="茉莉Python">
<meta property="og:description" content="Up in the wind!">
<meta property="og:locale">
<meta property="article:author" content="Lilly">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://gongyanli.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>茉莉Python</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">茉莉Python</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">voidqueens@hotmail.com</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-1-KMP%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-1-KMP%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">数据结构与算法-1-KMP算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-27 20:32:17" itemprop="dateCreated datePublished" datetime="2020-04-27T20:32:17+08:00">2020-04-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-28 15:26:43" itemprop="dateModified" datetime="2020-10-28T15:26:43+08:00">2020-10-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>参考：<br>    <a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html">http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html</a><br>    <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1jb411V78H?from=search&amp;seid=3722651774629068033">https://www.bilibili.com/video/BV1jb411V78H?from=search&amp;seid=3722651774629068033</a><br>    <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Px411z7Yo?from=search&amp;seid=3722651774629068033">https://www.bilibili.com/video/BV1Px411z7Yo?from=search&amp;seid=3722651774629068033</a><br>    <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1hW411a7ys?from=search&amp;seid=3722651774629068033">https://www.bilibili.com/video/BV1hW411a7ys?from=search&amp;seid=3722651774629068033</a><br>    <a target="_blank" rel="noopener" href="https://www.cnblogs.com/dahu-daqing/p/9302668.html">https://www.cnblogs.com/dahu-daqing/p/9302668.html</a></p>
<h2 id="一、KMP"><a href="#一、KMP" class="headerlink" title="一、KMP"></a>一、KMP</h2><p>KMP算法，又称模式匹配算法，能够在线性时间内判定字符串 T 是否为 S 的子串，并求出字符串 T 在 S 中各次出现的位置。</p>
<h2 id="二、代码"><a href="#二、代码" class="headerlink" title="二、代码"></a>二、代码</h2><pre><code>1、解决奇偶数问题
    在原字符串的每个相邻两个字符中间插入一个分隔符，同时在首尾也添加分隔符，如何#
2、字符串观察
    s:aaaba
    t:#a#a#a#b#a#
    回文半径数组：RL

    RL[i]-1等于回文串的长度</code></pre>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/manacher.jpg" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/manacher.jpg"></p>
<p>时间复杂度：O(m+n)</p>
<pre><code>#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# @contact: voidqueens@hotmail.com
# @software: PyCharm
# @time: 2020/4/26 下午6:50
# @site: www.gongyanli.com
# @file: kmp.py

def getNext(p):
    &#39;&#39;&#39;
    p为模式串
    返回next数组，即部分匹配表，使用p字符的前缀和后缀计算得到。
    等同于从模式字符串的第1位(注意，不包括第0位)开始对自身进行匹配运算。
    :param p:
    :return:
    &#39;&#39;&#39;
    next = [0] * len(p)
    next[0] = -1
    i = 0
    j = -1
    while i &lt; len(p) - 1:
        if j == -1 or p[i] == p[j]: # i遍历的是数组下标，j则为next赋值
            i += 1
            j += 1
            next[i] = j
        else:
            j = next[j]
    return next


def kmp(s, p):
    &#39;&#39;&#39;
    s为主串
    p为模式串
    如果t里有p，返回打头下标
    :param s:
    :param p:
    :return:
    &#39;&#39;&#39;
    next = getNext(p)
    i = j = 0
    while i &lt; len(s) and j &lt; len(p):
        if j == -1 or s[i] == p[j]: 
            i += 1
            j += 1
        else:
            j = next[j]
    if j == len(p):
        return i - j
    else:
        return -1


s = &#39;ababababca&#39;
p = &#39;abababca&#39;
print(getNext(p))
print(kmp(s, p))
</code></pre>
<h2 id="三、中心扩散–验证回文串"><a href="#三、中心扩散–验证回文串" class="headerlink" title="三、中心扩散–验证回文串"></a>三、中心扩散–验证回文串</h2><pre><code>中心扩散主要用于验证字符串是否是回文串。

思路：

    每个字母当成回文串的中心
    考虑两种情况:回文串的长度为奇数或者偶数情况。

缺点：
    奇数和偶数需要分开讨论
    没有充分利用前面查找的结果
    没有思考回文字符本身的特性--对称性</code></pre>
<pre><code>class Solution:
    def longestPalindrome(self, s: str) -&gt; str:
        n=len(s)
        self.res=&#39;&#39;
        def helper(i,j):
            while i&gt;= 0 and j&lt;n and s[i]==s[j]:
                i-=1
                j+=1
            if len(self.res) &lt; j-i-1:
                self.res=s[i+1:j]
                # print(i,self.res)

        for i in range(n):
            helper(i,i)
            helper(i,i+1) # 解决case为&quot;cbbd&quot;,即解决回文串为偶数的情况
        return self.res</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/PyTorch-6-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8F%82%E6%95%B0%E8%A7%A3%E9%87%8A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/PyTorch-6-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8F%82%E6%95%B0%E8%A7%A3%E9%87%8A/" class="post-title-link" itemprop="url">PyTorch-6-卷积神经网络参数解释</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-17 19:05:50" itemprop="dateCreated datePublished" datetime="2020-04-17T19:05:50+08:00">2020-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-30 17:51:43" itemprop="dateModified" datetime="2020-04-30T17:51:43+08:00">2020-04-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习和深度学习</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/PyTorch/" itemprop="url" rel="index"><span itemprop="name">PyTorch</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wanghui-garcia/p/10775859.html">https://www.cnblogs.com/wanghui-garcia/p/10775859.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wanghui-garcia/p/10775859.html">https://www.cnblogs.com/wanghui-garcia/p/10775859.html</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/Haiqiang1995/article/details/90300686">https://blog.csdn.net/Haiqiang1995/article/details/90300686</a><br><a target="_blank" rel="noopener" href="https://medium.com/@pkqiang49/%E4%B8%80%E6%96%87%E7%9C%8B%E6%87%82%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-cnn-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86-%E7%8B%AC%E7%89%B9%E4%BB%B7%E5%80%BC-%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8-6047fb2add35">https://medium.com/@pkqiang49/%E4%B8%80%E6%96%87%E7%9C%8B%E6%87%82%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-cnn-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86-%E7%8B%AC%E7%89%B9%E4%BB%B7%E5%80%BC-%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8-6047fb2add35</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/r1254/article/details/104888502">https://blog.csdn.net/r1254/article/details/104888502</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/dyk4ever/article/details/102841518">https://blog.csdn.net/dyk4ever/article/details/102841518</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44307764/article/details/102353344">https://blog.csdn.net/weixin_44307764/article/details/102353344</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yz2zcx/article/details/100187471/">https://blog.csdn.net/yz2zcx/article/details/100187471/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a2b536945e3c">https://www.jianshu.com/p/a2b536945e3c</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/lzy2014/article/details/25916235">https://blog.csdn.net/lzy2014/article/details/25916235</a><br><a target="_blank" rel="noopener" href="https://yq.aliyun.com/articles/373368">https://yq.aliyun.com/articles/373368</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luxiaoxun/archive/2012/11/10/2764056.html">https://www.cnblogs.com/luxiaoxun/archive/2012/11/10/2764056.html</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fzz9/p/8973315.html">https://www.cnblogs.com/fzz9/p/8973315.html</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6f9d99f7ad54">https://www.jianshu.com/p/6f9d99f7ad54</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42042680/article/details/80994726">https://blog.csdn.net/weixin_42042680/article/details/80994726</a></p>
<h3 id="1、卷积运算函数"><a href="#1、卷积运算函数" class="headerlink" title="1、卷积运算函数"></a>1、卷积运算函数</h3><p>torch.nn.Conv2d的功能是：对由多个输入平面组成的输入信号进行二维卷积。</p>
<pre><code>layer = nn.Conv2d(in_channels=1,out_channels=3,kernel_size=3,stride=1,padding=0)

in_channels:
    1）输入通道数，对于图片层一般为1（灰度）3（RGB）
    2）定义一种输入规则，要求上一层的输出必须和这个输入一致，也可以理解为并发in_channels个channel在上一层feature_map(特征映射)上进行卷积运算

out_channels:
    1)直观理解是输出层通道数，              
    2)换一种理解是kernels（卷积核）个数，其中，每个卷积核会输出局部特征，比如面部中有头发feature，衣服颜色的feature都是由不同的kernel进行卷积运算得到的。

stride(步长)：控制cross-correlation的步长，可以设为1个int型数或者一个(int, int)型的tuple。

padding(补0)：控制zero-padding的数目。

dilation(扩张)：控制kernel点（卷积核点）的间距; 也被称为 &quot;à trous&quot;算法. 可以在此github地址查看:Dilated convolution animations

groups(卷积核个数)：这个比较好理解，通常来说，卷积个数唯一，但是对某些情况，可以设置范围在1 —— in_channels中数目的卷积核：

输出[b,out_channels,w,h],其中w和h是输出的shape.</code></pre>
<pre><code>    mylayer=torch.nn.Conv2d(3,2,kernel_size=3,stride=2,padding=0)
    print(l1.weight.shape)
    input=torch.rand(1,3,7,7)
    out=l1.forward(input)
    print(out.shape)
-----------------------------------------------
    torch.Size([2, 3, 3, 3])
    torch.Size([1, 2, 3, 3])</code></pre>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/cnn1.gif" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/cnn1.gif"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/TensorFlow-7-conv2d%E7%9A%84padding%E5%8F%8A%E5%8F%82%E6%95%B0%E8%A7%A3%E9%87%8A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/TensorFlow-7-conv2d%E7%9A%84padding%E5%8F%8A%E5%8F%82%E6%95%B0%E8%A7%A3%E9%87%8A/" class="post-title-link" itemprop="url">TensorFlow-7-conv2d的padding及参数解释</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-17 15:51:56" itemprop="dateCreated datePublished" datetime="2020-04-17T15:51:56+08:00">2020-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-18 21:13:58" itemprop="dateModified" datetime="2020-09-18T21:13:58+08:00">2020-09-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习和深度学习</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/TensorFlow/" itemprop="url" rel="index"><span itemprop="name">TensorFlow</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1、padding的方式："><a href="#1、padding的方式：" class="headerlink" title="1、padding的方式："></a>1、padding的方式：</h3><p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/padding.jpeg" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/padding.jpeg"></p>
<p>说明：</p>
<p>1、摘录自<a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/37674306/what-is-the-difference-between-same-and-valid-padding-in-tf-nn-max-pool-of-t">http://stackoverflow.com/questions/37674306/what-is-the-difference-between-same-and-valid-padding-in-tf-nn-max-pool-of-t</a></p>
<p>2、不同的padding方式,VALID是采用丢弃的方式,比如上述的input_width=13,只允许滑动2次,多余的元素全部丢掉</p>
<p>3、SAME的方式,采用的是补全的方式,对于上述的情况,允许滑动3次,但是需要补3个元素,左奇右偶,在左边补一个0,右边补2个0</p>
<p>4、For the SAME padding, the output height and width are computed as:</p>
<pre><code>out_height = ceil(float(in_height) / float(strides[1]))

out_width = ceil(float(in_width) / float(strides[2]))

For the VALID padding, the output height and width are computed as:

out_height = ceil(float(in_height - filter_height + 1) / float(strides[1]))

out_width = ceil(float(in_width - filter_width + 1) / float(strides[2]))</code></pre>
<h3 id="2、conv2d的参数："><a href="#2、conv2d的参数：" class="headerlink" title="2、conv2d的参数："></a>2、conv2d的参数：</h3><p>1、strides[0] = strides[3] = 1</p>
<h3 id="3、conv2d的参数解释："><a href="#3、conv2d的参数解释：" class="headerlink" title="3、conv2d的参数解释："></a>3、conv2d的参数解释：</h3><p>tf.nn.conv2d(input, filter, strides, padding, use_cudnn_on_gpu=None, name=None)<br>除去name参数用以指定该操作的name，与方法有关的一共五个参数：</p>
<p>第一个参数input：指需要做卷积的输入图像，它要求是一个Tensor，具有[batch, in_height, in_width, in_channels]这样的shape，具体含义是[训练时一个batch的图片数量, 图片高度, 图片宽度, 图像通道数]，注意这是一个4维的Tensor，要求类型为float32和float64其中之一</p>
<p>第二个参数filter：相当于CNN中的卷积核，它要求是一个Tensor，具有[filter_height, filter_width, in_channels, out_channels]这样的shape，具体含义是[卷积核的高度，卷积核的宽度，图像通道数，卷积核个数]，要求类型与参数input相同,filter的通道数要求与input的in_channels一致，有一个地方需要注意，第三维in_channels，就是参数input的第四维</p>
<p>第三个参数strides：卷积时在图像每一维的步长，这是一个一维的向量，长度4，strides[0]=strides[3]=1</p>
<p>第四个参数padding：string类型的量，只能是”SAME”,”VALID”其中之一，这个值决定了不同的卷积方式（后面会介绍）</p>
<p>第五个参数：use_cudnn_on_gpu:bool类型，是否使用cudnn加速，默认为true</p>
<p>结果返回一个Tensor，这个输出，就是我们常说的feature map</p>
<h3 id="4、conv2d的例子："><a href="#4、conv2d的例子：" class="headerlink" title="4、conv2d的例子："></a>4、conv2d的例子：</h3><p>那么TensorFlow的卷积具体是怎样实现的呢，用一些例子去解释它：</p>
<p>import tensorflow as tf<br>#case 2<br>input = tf.Variable(tf.random_normal([1,3,3,5]))<br>filter = tf.Variable(tf.random_normal([1,1,5,1]))<br>op = tf.nn.conv2d(input, filter, strides=[1, 1, 1, 1], padding=’VALID’)</p>
<p>with tf.Session() as sess:<br>sess.run(tf.initialize_all_variables())<br>res = (sess.run(op))<br>print (res.shape)</p>
<p>import tensorflow as tf</p>
<p>input = tf.Variable(tf.random_normal([1,5,5,5]))<br>filter = tf.Variable(tf.random_normal([3,3,5,1]))<br>op = tf.nn.conv2d(input, filter, strides=[1, 1, 1, 1], padding=’VALID’)</p>
<p>with tf.Session() as sess:<br>sess.run(tf.initialize_all_variables())<br>res = (sess.run(op))<br>print (res.shape)</p>
<p>说明：</p>
<p>1、使用VALID方式,feature map的尺寸为<br>out_height = ceil(float(in_height - filter_height + 1) / float(strides[1]))=(5-3+1)/1 = 3</p>
<p>out_width = ceil(float(in_width - filter_width + 1) / float(strides[2])) = (5-3+1)/1 = 3</p>
<p>所以,feature map的尺寸为3*3</p>
<p>2、filter的参数个数为3<em>3</em>5<em>1,也即对于输入的每个通道数都对应于一个3</em>3的滤波器,然后共5个通道数,conv2d的过程就是对5个输入进行点击然后求和,得到一张feature map。如果要得到3张feature map,那么应该使用的参数为3<em>3</em>5*3个参数.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/PyTorch-5-transforms/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/PyTorch-5-transforms/" class="post-title-link" itemprop="url">PyTorch-5-transforms</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-14 15:27:30 / Modified: 15:28:57" itemprop="dateCreated datePublished" datetime="2020-04-14T15:27:30+08:00">2020-04-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习和深度学习</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/PyTorch/" itemprop="url" rel="index"><span itemprop="name">PyTorch</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>转载于：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u011995719/article/details/85107009">https://blog.csdn.net/u011995719/article/details/85107009</a></p>
<p>本文截取自《PyTorch 模型训练实用教程》，获取全文pdf请点击：<a target="_blank" rel="noopener" href="https://github.com/tensor-yu/PyTorch_Tutorial">https://github.com/tensor-yu/PyTorch_Tutorial</a></p>
<p>本文对transforms.py中的各个预处理方法进行介绍和总结。主要从官方文档中总结而来，官方文档只是将方法陈列，没有归纳总结，顺序很乱，这里总结一共有四大类，方便大家索引：</p>
<p>裁剪——Crop 中心裁剪：transforms.CenterCrop 随机裁剪：transforms.RandomCrop 随机长宽比裁剪：transforms.RandomResizedCrop 上下左右中心裁剪：transforms.FiveCrop 上下左右中心裁剪后翻转，transforms.TenCrop<br>翻转和旋转——Flip and Rotation 依概率p水平翻转：transforms.RandomHorizontalFlip(p=0.5) 依概率p垂直翻转：transforms.RandomVerticalFlip(p=0.5) 随机旋转：transforms.RandomRotation<br>图像变换 resize：transforms.Resize 标准化：transforms.Normalize 转为tensor，并归一化至[0-1]：transforms.ToTensor 填充：transforms.Pad 修改亮度、对比度和饱和度：transforms.ColorJitter 转灰度图：transforms.Grayscale 线性变换：transforms.LinearTransformation() 仿射变换：transforms.RandomAffine 依概率p转为灰度图：transforms.RandomGrayscale 将数据转换为PILImage：transforms.ToPILImage transforms.Lambda：Apply a user-defined lambda as a transform.<br>对transforms操作，使数据增强更灵活 transforms.RandomChoice(transforms)， 从给定的一系列transforms中选一个进行操作 transforms.RandomApply(transforms, p=0.5)，给一个transform加上概率，依概率进行操作 transforms.RandomOrder，将transforms中的操作随机打乱<br>一、 裁剪——Crop<br>1.随机裁剪：transforms.RandomCrop<br>class torchvision.transforms.RandomCrop(size, padding=None, pad_if_needed=False, fill=0, padding_mode=’constant’) 功能：依据给定的size随机裁剪 参数： size- (sequence or int)，若为sequence,则为(h,w)，若为int，则(size,size) padding-(sequence or int, optional)，此参数是设置填充多少个pixel。 当为int时，图像上下左右均填充int个，例如padding=4，则上下左右均填充4个pixel，若为3232，则会变成4040。 当为sequence时，若有2个数，则第一个数表示左右扩充多少，第二个数表示上下的。当有4个数时，则为左，上，右，下。 fill- (int or tuple) 填充的值是什么（仅当填充模式为constant时有用）。int时，各通道均填充该值，当长度为3的tuple时，表示RGB通道需要填充的值。 padding_mode- 填充模式，这里提供了4种填充模式，1.constant，常量。2.edge 按照图片边缘的像素值来填充。3.reflect，暂不了解。 4. symmetric，暂不了解。</p>
<p>2.中心裁剪：transforms.CenterCrop<br>class torchvision.transforms.CenterCrop(size) 功能：依据给定的size从中心裁剪 参数： size- (sequence or int)，若为sequence,则为(h,w)，若为int，则(size,size)</p>
<p>3.随机长宽比裁剪 transforms.RandomResizedCrop<br>class torchvision.transforms.RandomResizedCrop(size, scale=(0.08, 1.0), ratio=(0.75, 1.3333333333333333), interpolation=2) 功能：随机大小，随机长宽比裁剪原始图片，最后将图片resize到设定好的size 参数： size- 输出的分辨率 scale- 随机crop的大小区间，如scale=(0.08, 1.0)，表示随机crop出来的图片会在的0.08倍至1倍之间。 ratio- 随机长宽比设置 interpolation- 插值的方法，默认为双线性插值(PIL.Image.BILINEAR)</p>
<p>4.上下左右中心裁剪：transforms.FiveCrop<br>class torchvision.transforms.FiveCrop(size) 功能：对图片进行上下左右以及中心裁剪，获得5张图片，返回一个4D-tensor 参数： size- (sequence or int)，若为sequence,则为(h,w)，若为int，则(size,size)</p>
<p>5.上下左右中心裁剪后翻转: transforms.TenCrop<br>class torchvision.transforms.TenCrop(size, vertical_flip=False) 功能：对图片进行上下左右以及中心裁剪，然后全部翻转（水平或者垂直），获得10张图片，返回一个4D-tensor。 参数： size- (sequence or int)，若为sequence,则为(h,w)，若为int，则(size,size) vertical_flip (bool) - 是否垂直翻转，默认为flase，即默认为水平翻转</p>
<p>二、翻转和旋转——Flip and Rotation<br>6.依概率p水平翻转transforms.RandomHorizontalFlip<br>class torchvision.transforms.RandomHorizontalFlip(p=0.5) 功能：依据概率p对PIL图片进行水平翻转 参数： p- 概率，默认值为0.5</p>
<p>7.依概率p垂直翻转transforms.RandomVerticalFlip<br>class torchvision.transforms.RandomVerticalFlip(p=0.5) 功能：依据概率p对PIL图片进行垂直翻转 参数： p- 概率，默认值为0.5</p>
<p>8.随机旋转：transforms.RandomRotation<br>class torchvision.transforms.RandomRotation(degrees, resample=False, expand=False, center=None) 功能：依degrees随机旋转一定角度 参数： degress- (sequence or float or int) ，若为单个数，如 30，则表示在（-30，+30）之间随机旋转 若为sequence，如(30，60)，则表示在30-60度之间随机旋转 resample- 重采样方法选择，可选 PIL.Image.NEAREST, PIL.Image.BILINEAR, PIL.Image.BICUBIC，默认为最近邻 expand- ? center- 可选为中心旋转还是左上角旋转</p>
<p>三、图像变换<br>9.resize：transforms.Resize<br>class torchvision.transforms.Resize(size, interpolation=2) 功能：重置图像分辨率 参数： size- If size is an int, if height &gt; width, then image will be rescaled to (size * height / width, size)，所以建议size设定为h*w interpolation- 插值方法选择，默认为PIL.Image.BILINEAR</p>
<p>10.标准化：transforms.Normalize<br>class torchvision.transforms.Normalize(mean, std) 功能：对数据按通道进行标准化，即先减均值，再除以标准差，注意是 hwc</p>
<p>11.转为tensor：transforms.ToTensor<br>class torchvision.transforms.ToTensor 功能：将PIL Image或者 ndarray 转换为tensor，并且归一化至[0-1] 注意事项：归一化至[0-1]是直接除以255，若自己的ndarray数据尺度有变化，则需要自行修改。</p>
<p>12.填充：transforms.Pad<br>class torchvision.transforms.Pad(padding, fill=0, padding_mode=’constant’) 功能：对图像进行填充 参数： padding-(sequence or int, optional)，此参数是设置填充多少个pixel。 当为int时，图像上下左右均填充int个，例如padding=4，则上下左右均填充4个pixel，若为3232，则会变成4040。 当为sequence时，若有2个数，则第一个数表示左右扩充多少，第二个数表示上下的。当有4个数时，则为左，上，右，下。 fill- (int or tuple) 填充的值是什么（仅当填充模式为constant时有用）。int时，各通道均填充该值，当长度为3的tuple时，表示RGB通道需要填充的值。 padding_mode- 填充模式，这里提供了4种填充模式，1.constant，常量。2.edge 按照图片边缘的像素值来填充。3.reflect，？ 4. symmetric，？</p>
<p>13.修改亮度、对比度和饱和度：transforms.ColorJitter<br>class torchvision.transforms.ColorJitter(brightness=0, contrast=0, saturation=0, hue=0) 功能：修改修改亮度、对比度和饱和度</p>
<p>14.转灰度图：transforms.Grayscale<br>class torchvision.transforms.Grayscale(num_output_channels=1) 功能：将图片转换为灰度图 参数： num_output_channels- (int) ，当为1时，正常的灰度图，当为3时， 3 channel with r == g == b</p>
<p>15.线性变换：transforms.LinearTransformation()<br>class torchvision.transforms.LinearTransformation(transformation_matrix) 功能：对矩阵做线性变化，可用于白化处理！ whitening: zero-center the data, compute the data covariance matrix 参数： transformation_matrix (Tensor) – tensor [D x D], D = C x H x W</p>
<p>16.仿射变换：transforms.RandomAffine<br>class torchvision.transforms.RandomAffine(degrees, translate=None, scale=None, shear=None, resample=False, fillcolor=0) 功能：仿射变换</p>
<p>17.依概率p转为灰度图：transforms.RandomGrayscale<br>class torchvision.transforms.RandomGrayscale(p=0.1) 功能：依概率p将图片转换为灰度图，若通道数为3，则3 channel with r == g == b</p>
<p>18.将数据转换为PILImage：transforms.ToPILImage<br>class torchvision.transforms.ToPILImage(mode=None) 功能：将tensor 或者 ndarray的数据转换为 PIL Image 类型数据 参数： mode- 为None时，为1通道， mode=3通道默认转换为RGB，4通道默认转换为RGBA</p>
<p>19.transforms.Lambda<br>Apply a user-defined lambda as a transform. 暂不了解，待补充。</p>
<p>四、对transforms操作，使数据增强更灵活<br>PyTorch不仅可设置对图片的操作，还可以对这些操作进行随机选择、组合</p>
<p>20.transforms.RandomChoice(transforms)<br>功能：从给定的一系列transforms中选一个进行操作，randomly picked from a list</p>
<p>21.transforms.RandomApply(transforms, p=0.5)<br>功能：给一个transform加上概率，以一定的概率执行该操作</p>
<p>22.transforms.RandomOrder<br>功能：将transforms中的操作顺序随机打乱</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/PyTorch-2-%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/PyTorch-2-%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">PyTorch-2-总体结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-04-14 15:16:47 / Modified: 15:22:16" itemprop="dateCreated datePublished" datetime="2020-04-14T15:16:47+08:00">2020-04-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习和深度学习</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/PyTorch/" itemprop="url" rel="index"><span itemprop="name">PyTorch</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://pytorch-cn.readthedocs.io/zh/latest/">https://pytorch-cn.readthedocs.io/zh/latest/</a></p>
<p>PyTorch文档中主要包含2个模块，一个是 torch, 一个 torchvision, torch 是主模块, 用来搭建神经网络的, torchvision 是辅模块, 有数据库, 还有一些已经训练好的神经网络等着你直接用, 比如 (VGG, AlexNet, ResNet).</p>
<pre><code>torch:
    Tensor
    Storage
    nn
    nn.functional
    autograd
    optim
    nn.init
    multiprocessing
    legacy
    cuda
    utils.fit
    utils.data
    utils.model_zoo

torchvison:
    datasets
    models
    transforms
    utils</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-11-%E5%A0%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-11-%E5%A0%86/" class="post-title-link" itemprop="url">数据结构与算法-11-堆</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-01 15:57:57" itemprop="dateCreated datePublished" datetime="2020-04-01T15:57:57+08:00">2020-04-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-26 20:03:45" itemprop="dateModified" datetime="2020-08-26T20:03:45+08:00">2020-08-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h2><p>二叉堆是一种特殊的二叉树, 它总是保证一棵树的最小元素(最小堆)或者最大元素(最大堆)处于树根上, 常见的应用场景就是用于构建优先队列, 在jdk中Doug Lea所实现的ScheduledThreadPoolExecutor中就用到了最小堆;</p>
<h3 id="1、最小堆"><a href="#1、最小堆" class="headerlink" title="1、最小堆"></a>1、最小堆</h3><h4 id="1-1-基本操作"><a href="#1-1-基本操作" class="headerlink" title="1.1 基本操作"></a>1.1 基本操作</h4><pre><code>BinaryHeap() 创建一个新的，空的二叉堆。
insert(k) 向堆添加一个新项。
findMin() 返回具有最小键值的项，并将项留在堆中。
delMin() 返回具有最小键值的项，从堆中删除该项。
如果堆是空的，isEmpty() 返回 true，否则返回 false。
size() 返回堆中的项数。
buildHeap(list) 从键列表构建一个新的堆。</code></pre>
<p>注意，无论我们向堆中添加项的顺序是什么，每次都删除最小的。</p>
<h4 id="1-2-实现"><a href="#1-2-实现" class="headerlink" title="1.2 实现"></a>1.2 实现</h4><p>为了使我们的堆有效地工作，我们将利用二叉树的对数性质来表示我们的堆。 为了保证对数性能，我们必须保持树平衡。平衡二叉树在根的左和右子树中具有大致相同数量的节点。 在我们的堆实现中，我们通过创建一个 完整二叉树 来保持树平衡。 一个完整的二叉树是一个树，其中每个层都有其所有的节点，除了树的最底层，从左到右填充，如图。</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/heap1.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/heap1.png"></p>
<p>完整二叉树的另一个有趣的属性是，我们可以使用单个列表来表示它。 我们不需要使用节点和引用，甚至列表的列表。因为树是完整的，父节点的左子节点（在位置 p 处）是在列表中位置 2p 中找到的节点。 类似地，父节点的右子节点在列表中的位置 2p + 1。为了找到树中任意节点的父节点，我们可以简单地使用Python 的整数除法。 假定节点在列表中的位置 n，则父节点在位置 n/2。如图，请注意父级和子级之间是 2p 和 2p+1 关系。 树的列表表示以及完整的结构属性允许我们仅使用几个简单的数学运算来高效地遍历一个完整的二叉树。 我们将看到，这也是我们的二叉堆的有效实现。</p>
<p>我们用于堆中存储项的方法依赖于维护堆的排序属性。 堆的排序属性如下：在堆中，对于具有父 p 的每个节点 x，p 中的键小于或等于 x 中的键。 下图展示了具有堆顺序属性的完整二叉树。</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/heap2.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/heap2.png"></p>
<p>我们将开始实现一个二叉堆的构造函数。由于整个二叉堆可以由单个列表表示，所以构造函数将初始化列表和一个 currentSize 属性来跟踪堆的当前大小。一个空的二叉堆有一个单一的零作为 heapList 的第一个元素，这个零只是放那里，用于以后简单的整数除法。</p>
<pre><code>class BinHeap:
    def __init__(self):
        self.heapList=[0]
        self.currentSize=0</code></pre>
<p>将项添加到列表中最简单，最有效的方法是将项附加到列表的末尾。 它维护完整的树属性。但可能违反堆结构属性。可以编写一个方法，通过比较新添加的项与其父项，我们可以重新获得堆结构属性。 如果新添加的项小于其父项，则我们可以将项与其父项交换。 </p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/heap3.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/heap3.png"></p>
<p>注意，当我们完成一个项时，我们需要恢复新添加的项和父项之间的堆属性。 我们还需保留任何兄弟节点的堆属性。当然，如果新添加的项非常小，我们可能仍需要将其交换另一上层。事实上，我们可能需要交换到树的顶部。</p>
<p>percUp 方法，它在树中向上遍历一个新项，因为它需要去维护堆属性。注意，我们可以通过使用简单的整数除法来计算任意节点的父节点。 当前节点的父节点可以通过将当前节点的索引除以 2 来计算。</p>
<p>插入方法中的大部分工作都是由 percUp 完成的。 一旦一个新项被追加到树上，percUp 接管并正确定位新项。</p>
<pre><code>def percUp(self,i):
    while i//2&gt;0:
        if self.heapList[i] &lt; self.heapList[i//2]:
            tmp=self.heapList[i//2]
            self.heapList[i//2]=self.heapList[i]
            self.heapList[i]=tmp
        i=i//2

def insert(self,k):
    self.heapList.append(k)
    self.currentSize+=1
    self.percUp(self.currentSize)</code></pre>
<p>因为堆属性要求树的根是树中的最小项，所以找到最小项很容易。delMin 的难点在根被删除后恢复堆结构和堆顺序属性。 我们可以分两步恢复我们的堆。首先，我们将通过获取列表中的最后一个项并将其移动到根位置来恢复根项，保持我们的堆结构属性。 但是，我们可能已经破坏了我们的二叉堆的堆顺序属性。 第二，我们通过将新的根节点沿着树向下推到其正确位置来恢复堆顺序属性。 下图展示了将新的根节点移动到堆中的正确位置所需的交换序列。</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/heap4.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/heap4.png"></p>
<p>为了维护堆顺序属性，我们所需要做的是将根节点和最小的子节点交换。在初始交换之后，我们可以将节点和其子节点重复交换，直到节点被交换到正确的位置，使它小于两个子节点。</p>
<pre><code>def percDown(self, i):
    while (i * 2) &lt;= self.currentSize:
        mc = self.minChild(i)
        if self.heapList[i] &gt; self.heapList[mc]:
            tmp = self.heapList[i]
            self.heapList[i] = self.heapList[mc]
            self.heapList[mc] = tmp
        i = mc


def minChild(self, i):
    &#39;&#39;&#39;
    找到最小子节点：
        如果右子节点不存在，那么最小子节点为左；
        如果右子节点存在，判断左右的大小后再返回；
    :param self:
    :param i:
    :return:
    &#39;&#39;&#39;
    if i * 2 + 1 &gt; self.currentSize:
        return i * 2
    else:
        if self.heapList[i * 2] &lt; self.heapList[i * 2 + 1]:
            return i * 2
        else:
            return i * 2 + 1


def delMin(self):
    retval = self.heapList[1]
    self.heapList[1] = self.heapList[self.currentSize]
    self.currentSize -= 1
    self.heapList.pop()
    self.percDown(1)
    return retval</code></pre>
<p>为了完成我们对二叉堆的讨论，我们将看从一个列表构建整个堆的方法.如图，给定一个列表，通过一次插入一个键轻松地构建一个堆。由于你从一个项的列表开始，该列表是有序的，可以使用二分查找找到正确的位置，以大约 O(logn)O(logn) 操作的成本插入下一个键。 但是，请记住，在列表中间插入项可能需要 O(n)O(n) 操作来移动列表的其余部分，为新项腾出空间。 因此，要在堆中插入 n 个键，将需要总共 O(nlogn)O(nlogn) 操作。 然而，如果我们从整个列表开始，那么我们可以在 O(n)O(n) 操作中构建整个堆。Listing 6 展示了构建整个堆的代码。</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/heap5.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/heap5.png"></p>
<p>buildHeap 方法在 [9,6,5,2,3] 的初始树中的节点移动到其正确位置时所做的交换。虽然我们从树的中间开始，并以我们的方式回到根节点，percDown 方法确保最大的子节点总是沿着树向下移动。因为堆是一个完整的二叉树，超过中途点的任何节点都将是树叶，因此没有子节点。注意，当i = 1 时，我们从树的根节点向下交换，因此可能需要多次交换。正如你在上图最右边的两个树中可以看到的，首先 9 从根位置移出，但是 9 在树中向下移动一级之后，percDown 检查下一组子树，以确保它被推到下一层。在这种情况下，它与 3 进行第二次交换。现在 9 已经移动到树的最低层，不能进行进一步交换。将上图所示的这一系列交换的列表与树进行比较是有用的。</p>
<pre><code>def buildHeap(self, alist):
    i = len(alist) // 2
    self.currentSize = len(alist)
    self.heapList = [0] + alist[:]
    while i &gt; 0:
        self.percDown(i)
        i -= 1</code></pre>
<p>完整代码：</p>
<pre><code>class BinHeap:
    def __init__(self):
        self.heapList = [0]
        self.currentSize = 0


    def percUp(self,i):
        while i // 2 &gt; 0:
          if self.heapList[i] &lt; self.heapList[i // 2]:
             tmp = self.heapList[i // 2]
             self.heapList[i // 2] = self.heapList[i]
             self.heapList[i] = tmp
          i = i // 2

    def insert(self,k):
      self.heapList.append(k)
      self.currentSize = self.currentSize + 1
      self.percUp(self.currentSize)

    def percDown(self,i):
      while (i * 2) &lt;= self.currentSize:
          mc = self.minChild(i)
          if self.heapList[i] &gt; self.heapList[mc]:
              tmp = self.heapList[i]
              self.heapList[i] = self.heapList[mc]
              self.heapList[mc] = tmp
          i = mc

    def minChild(self,i):
      if i * 2 + 1 &gt; self.currentSize:
          return i * 2
      else:
          if self.heapList[i*2] &lt; self.heapList[i*2+1]:
              return i * 2
          else:
              return i * 2 + 1

    def delMin(self):
      retval = self.heapList[1]
      self.heapList[1] = self.heapList[self.currentSize]
      self.currentSize = self.currentSize - 1
      self.heapList.pop()
      self.percDown(1)
      return retval

    def buildHeap(self,alist):
      i = len(alist) // 2
      self.currentSize = len(alist)
      self.heapList = [0] + alist[:]
      while (i &gt; 0):
          self.percDown(i)
          i = i - 1

bh = BinHeap()
bh.buildHeap([9,5,6,2,3])

print(bh.delMin())
print(bh.delMin())
print(bh.delMin())
print(bh.delMin())
print(bh.delMin())</code></pre>
<p>我们可以在 O(n)中构建堆的断言可能看起来有点神秘，证明超出了范围。 然而，理解的关键是记住 logn 因子是从树的高度派生的。 对于buildHeap 中的大部分工作，树比 logn 短。<br>基于可以从 O(n) 时间构建堆的事实，你可以使用堆对列表在 O(nlogn)时间内排序，作为本章结尾的练习。</p>
<h3 id="2、最大堆"><a href="#2、最大堆" class="headerlink" title="2、最大堆"></a>2、最大堆</h3><pre><code>class BinHeap:
    def __init__(self):
        self.heapList = [0]
        self.currentSize = 0

    def percUp(self, i):
        while i // 2 &gt; 0:
            if self.heapList[i] &gt; self.heapList[i // 2]:
                tmp = self.heapList[i // 2]
                self.heapList[i // 2] = self.heapList[i]
                self.heapList[i] = tmp
            i = i // 2

    def insert(self, k):
        self.heapList.append(k)
        self.currentSize = self.currentSize + 1
        self.percUp(self.currentSize)

    def percDown(self, i):
        while (i * 2) &lt;= self.currentSize:
            mc = self.maxChild(i)
            if self.heapList[i] &lt; self.heapList[mc]:
                tmp = self.heapList[i]
                self.heapList[i] = self.heapList[mc]
                self.heapList[mc] = tmp
            i = mc

    def maxChild(self, i):
        if i * 2 + 1 &gt; self.currentSize:
            return i * 2
        else:
            if self.heapList[i * 2] &lt; self.heapList[i * 2 + 1]:
                return i * 2 + 1
            else:
                return i * 2

    def delMax(self):
        retval = self.heapList[1]
        self.heapList[1] = self.heapList[self.currentSize]
        self.currentSize = self.currentSize - 1
        self.heapList.pop()
        self.percDown(1)
        return retval

    def buildHeap(self, alist):
        i = len(alist) // 2
        self.currentSize = len(alist)
        self.heapList = [0] + alist[:]
        while (i &gt; 0):
            self.percDown(i)
            i = i - 1


bh = BinHeap()
bh.buildHeap([9, 5, 6, 2, 3])

print(bh.heapList)
print(bh.currentSize)
print(bh.delMax())
print(bh.heapList)
print(bh.delMax())</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/LeetCode-14-database/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/LeetCode-14-database/" class="post-title-link" itemprop="url">LeetCode-14-database</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-29 20:45:14" itemprop="dateCreated datePublished" datetime="2020-03-29T20:45:14+08:00">2020-03-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-18 22:36:54" itemprop="dateModified" datetime="2020-08-18T22:36:54+08:00">2020-08-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="十四、database"><a href="#十四、database" class="headerlink" title="十四、database"></a>十四、database</h2><pre><code>优先顺序：where&gt;group by&gt;having&gt;order by</code></pre>
<h3 id="182-查找重复的电子邮箱"><a href="#182-查找重复的电子邮箱" class="headerlink" title="182. 查找重复的电子邮箱"></a>182. 查找重复的电子邮箱</h3><pre><code>链接：https://leetcode-cn.com/problems/duplicate-emails/

SQL架构
编写一个 SQL 查询，查找 Person 表中所有重复的电子邮箱。

示例：

+----+---------+
| Id | Email   |
+----+---------+
| 1  | a@b.com |
| 2  | c@d.com |
| 3  | a@b.com |
+----+---------+
根据以上输入，你的查询应返回以下结果：

+---------+
| Email   |
+---------+
| a@b.com |
+---------+
说明：所有电子邮箱都是小写字母。</code></pre>
<pre><code># Write your MySQL query statement below
# 1.使用group by 和临时表
select Email from
(
select Email, count(Email) as nums 
from Person
group by Email
) as tmp
where nums&gt;1;
# 2.使用group by和having条件
select Email
from Person
group by Email
having count(Email) &gt; 1;


</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/LeetCode-13-%E6%95%B0%E5%AD%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/LeetCode-13-%E6%95%B0%E5%AD%A6/" class="post-title-link" itemprop="url">LeetCode-13-数学</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-29 20:12:16" itemprop="dateCreated datePublished" datetime="2020-03-29T20:12:16+08:00">2020-03-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-01 23:00:27" itemprop="dateModified" datetime="2020-11-01T23:00:27+08:00">2020-11-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="十三、数学"><a href="#十三、数学" class="headerlink" title="十三、数学"></a>十三、数学</h2><h3 id="172-阶乘后的零"><a href="#172-阶乘后的零" class="headerlink" title="172. 阶乘后的零"></a>172. 阶乘后的零</h3><pre><code>链接：https://leetcode-cn.com/problems/factorial-trailing-zeroes/

给定一个整数 n，返回 n! 结果尾数中零的数量。

示例 1:

输入: 3
输出: 0
解释: 3! = 6, 尾数中没有零。
示例 2:

输入: 5
输出: 1
解释: 5! = 120, 尾数中有 1 个零.
说明: 你算法的时间复杂度应为 O(log n) 。</code></pre>
<p>题解一：</p>
<p>如果依靠算出阶乘结果，再计算有多少个0，很容易溢出。</p>
<p>思路：末尾有多少个0，只需要给当前数乘以一个10，就可以加一个0.</p>
<p>比如5!，也就是 5 * 4 * 3 * 2 * 1 = 120，我们发现结果会有一个 0，原因就是 2 和 5 相乘构成了一个 10。而对于 10 的话，其实也只有 2 * 5 可以构成，所以我们只需要找有多少对 2/5。</p>
<p>11! = 11 * 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1 = 11 * (2 * 5) * 9 * (4 * 2) * 7 * (3 * 2) * (1 * 5) * (2 * 2) * 3 * (1 * 2) * 1</p>
<p>对于含有 2 的因子的话是 1 * 2, 2 * 2, 3 * 2, 4 * 2 …</p>
<p>对于含有 5 的因子的话是 1 * 5, 2 * 5…</p>
<p>含有 2 的因子每两个出现一次，含有 5 的因子每 5 个出现一次，所有 2 出现的个数远远多于 5，换言之找到一个 5，一定能找到一个 2 与之配对。所以我们只需要找有多少个 5。</p>
<p>直接的，我们只需要判断每个累乘的数有多少个 5 的因子即可。</p>
<pre><code>class Solution:
    def trailingZeroes(self, n: int) -&gt; int:
        count=0
        for i in range(n+1):
            tmp=i
            while tmp&gt;0:
                if tmp%5==0:
                    count+=1
                    tmp//=5
                else:
                    break
        return count</code></pre>
<p>以上算法超时，继续优化。</p>
<p>对于一个数的阶乘，5 的因子一定是每隔 5 个数出现一次，也就是下边的样子。</p>
<pre><code>n! = 1 * 2 * 3 * 4 * (1 * 5) * ... * (2 * 5) * ... * (3 * 5) *... * n</code></pre>
<p>因为每隔 5 个数出现一个 5，所以计算出现了多少个 5，我们只需要用 n/5 就可以算出来。</p>
<p>但还没有结束，继续分析。</p>
<pre><code>... * (1 * 5) * ... * (1 * 5 * 5) * ... * (2 * 5 * 5) * ... * (3 * 5 * 5) * ... * n</code></pre>
<p>每隔 25 个数字，出现的是两个 5，所以除了每隔 5 个数算作一个 5，每隔 25 个数，还需要多算一个 5。</p>
<p>也就是我们需要再加上 n / 25 个 5。</p>
<p>同理我们还会发现每隔 5 * 5 * 5 = 125 个数字，会出现 3 个 5，所以我们还需要再加上 n / 125 。</p>
<p>综上，规律就是每隔 5 个数，出现一个 5，每隔 25 个数，出现 2 个 5，每隔 125 个数，出现 3 个 5，以此类推。</p>
<p>最终 5 的个数就是 n / 5 + n / 25 + n / 125 …</p>
<p>写程序的话，如果直接按照上边的式子计算，分母可能会造成溢出。所以算 n / 25 的时候，我们先把 n 更新，n = n / 5，然后再计算 n / 5 即可，后边的同理。</p>
<pre><code>class Solution:
    def trailingZeroes(self, n: int) -&gt; int:
        count=0
        while n&gt;0:
            count+=n//5
            n//=5
        return count
</code></pre>
<h3 id="204-计数质数"><a href="#204-计数质数" class="headerlink" title="204. 计数质数"></a>204. 计数质数</h3><pre><code>统计所有小于非负整数 n 的质数的数量。

示例 1：

输入：n = 10
输出：4
解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。
示例 2：

输入：n = 0
输出：0
示例 3：

输入：n = 1
输出：0


提示：

0 &lt;= n &lt;= 5 * 106</code></pre>
<p>题解一|暴力|超时：</p>
<p>注意：题意是小于，而不是小于等于。</p>
<pre><code>class Solution:
    def countPrimes(self, n: int) -&gt; int:
        if n&lt;2:
            return 0
        count=0
        for i in range(2,n):
            flag=True
            for j in range(2,i):
                if j!=i and i%j==0: # if i%j==0:
                    flag=False
                    break
            if flag:
                count+=1
        return count</code></pre>
<p> 题解二|暴力优化：</p>
<pre><code>class Solution:
   def countPrimes(self, n: int) -&gt; int:
       if n&lt;3:
           return 0
       count=1
       for i in range(3,n):
           if i%2 == 0: # 排除偶数，使用if i^1==0:有可以
               continue
           flag=True
           for j in range(3,int(i**0.5)+1,2): # 因为排除偶数，加2会更快。
               if i%j==0:
                   flag=False
                   break
           if flag:
               count+=1
       return count</code></pre>
<p>题解三|厄拉多塞筛法:</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-primes/solution/ji-shu-zhi-shu-bao-li-fa-ji-you-hua-shai-fa-ji-you/">https://leetcode-cn.com/problems/count-primes/solution/ji-shu-zhi-shu-bao-li-fa-ji-you-hua-shai-fa-ji-you/</a></p>
<p>思路：</p>
<pre><code>选中数字2，并排除2的倍数；
选中数字3，并排除3的倍数；
选中数字5，并排除5的倍数；
...</code></pre>
<pre><code>class Solution:
    def countPrimes(self, n: int) -&gt; int:
        count=0
        sign=[True]*n
        for i in range(2,n):
            if sign[i]:
                count+=1
                for j in range(i+i,n,i):
                    sign[j]=False
        return count</code></pre>
<h3 id="326-3的幂"><a href="#326-3的幂" class="headerlink" title="326. 3的幂"></a>326. 3的幂</h3><pre><code>链接：https://leetcode-cn.com/problems/power-of-three/

给定一个整数，写一个函数来判断它是否是 3 的幂次方。

示例 1:

输入: 27
输出: true
示例 2:

输入: 0
输出: false
示例 3:

输入: 9
输出: true
示例 4:

输入: 45
输出: false
进阶：
你能不使用循环或者递归来完成本题吗？</code></pre>
<p>题解一|循环：</p>
<p>时间复杂度：O(logb(n))，我们的例子中是 O(logn)，除数是用对数表示的。<br>空间复杂度：O(1)，没有使用额外的空间。</p>
<pre><code>class Solution:
    def isPowerOfThree(self, n: int) -&gt; bool:
        if n&lt;1: # 不加这里，会在0里面陷入死循环
            return 0
        while n%3==0:
            n//=3
        return n==1</code></pre>
<p>题解二|递归：</p>
<pre><code>class Solution:
    def isPowerOfThree(self, n: int) -&gt; bool:
        if n==1:
            return True
        if n&lt;=0 or n%3!=0:
            return False
        n=n//3
        return self.isPowerOfThree(n)</code></pre>
<p>题解三|换底公式：</p>
<pre><code>class Solution:
    import math
    def isPowerOfThree(self, n: int) -&gt; bool:
        if n&lt;1:
            return False
        res=math.log10(n)/math.log10(3) # 不能使用math.log()，会有小数
        return True if res-int(res)==0 else False
        # return (math.log10(n) / math.log10(3))%1 == 0</code></pre>
<h3 id="412-Fizz-Buzz"><a href="#412-Fizz-Buzz" class="headerlink" title="412. Fizz Buzz"></a>412. Fizz Buzz</h3><pre><code>链接：https://leetcode-cn.com/problems/fizz-buzz/

写一个程序，输出从 1 到 n 数字的字符串表示。

1. 如果 n 是3的倍数，输出“Fizz”；

2. 如果 n 是5的倍数，输出“Buzz”；

3.如果 n 同时是3和5的倍数，输出 “FizzBuzz”。

示例：

n = 15,

返回:
[
    &quot;1&quot;,
    &quot;2&quot;,
    &quot;Fizz&quot;,
    &quot;4&quot;,
    &quot;Buzz&quot;,
    &quot;Fizz&quot;,
    &quot;7&quot;,
    &quot;8&quot;,
    &quot;Fizz&quot;,
    &quot;Buzz&quot;,
    &quot;11&quot;,
    &quot;Fizz&quot;,
    &quot;13&quot;,
    &quot;14&quot;,
    &quot;FizzBuzz&quot;
]</code></pre>
<p>题解一：</p>
<pre><code>class Solution:
    def fizzBuzz(self, n: int) -&gt; List[str]:
        res=[]
        for i in range(1,n+1):
            if i%3==0 and i%5==0:
                res.append(&#39;FizzBuzz&#39;)
            elif i%3==0:
                res.append(&#39;Fizz&#39;)
            elif i%5==0:
                res.append(&#39;Buzz&#39;)
            else:
                res.append(str(i))
        return res</code></pre>
<p>题解二|递归：</p>
<pre><code>class Solution:
    def __init__(self):
        self.res=[]

    def fizzBuzz(self, n: int) -&gt; List[str]:
        if not n:
            self.res.reverse()
            return self.res
        if n%3==0 and n%5==0:
            self.res.append(&#39;FizzBuzz&#39;)
        elif n%3==0:
            self.res.append(&#39;Fizz&#39;)
        elif n%5==0:
            self.res.append(&#39;Buzz&#39;)
        else:
            self.res.append(str(n))
        return self.fizzBuzz(n-1)</code></pre>
<p>题解三|hash：</p>
<pre><code>class Solution:
    def fizzBuzz(self, n: int) -&gt; List[str]:
        hash=&#123;3:&#39;Fizz&#39;,5:&#39;Buzz&#39;&#125;
        res=[]
        for i in range(1,n+1):
            tmp=&#39;&#39;
            for key in hash.keys():
                if i%key==0:
                    tmp+=hash[key]
            if not tmp:
                tmp=str(i)
            res.append(tmp)
        return res</code></pre>
<h3 id="1447-最简分数"><a href="#1447-最简分数" class="headerlink" title="1447. 最简分数"></a>1447. 最简分数</h3><pre><code>链接：https://leetcode-cn.com/problems/simplified-fractions/

给你一个整数 n ，请你返回所有 0 到 1 之间（不包括 0 和 1）满足分母小于等于  n 的 最简 分数 。分数可以以 任意 顺序返回。

示例 1：

输入：n = 2
输出：[&quot;1/2&quot;]
解释：&quot;1/2&quot; 是唯一一个分母小于等于 2 的最简分数。
示例 2：

输入：n = 3
输出：[&quot;1/2&quot;,&quot;1/3&quot;,&quot;2/3&quot;]
示例 3：

输入：n = 4
输出：[&quot;1/2&quot;,&quot;1/3&quot;,&quot;1/4&quot;,&quot;2/3&quot;,&quot;3/4&quot;]
解释：&quot;2/4&quot; 不是最简分数，因为它可以化简为 &quot;1/2&quot; 。
示例 4：

输入：n = 1
输出：[]


提示：

1 &lt;= n &lt;= 100</code></pre>
<p>题解一：</p>
<pre><code>class Solution:
    def simplifiedFractions(self, n: int) -&gt; List[str]:
        def gcd(x,y):
            while y:
                x,y=y,x%y
            return x

        res=[]
        tmp=set()
        for i in range(2,n+1):
            for j in range(1,i):
                c=gcd(i,j)
                a,b=j//c,i//c
                if (a,b) in tmp:
                    continue
                tmp.add((a,b))
                res.append(str(a)+&#39;/&#39;+str(b))
        return res</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/LeetCode-12-%E5%AD%97%E7%AC%A6%E4%B8%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/LeetCode-12-%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="post-title-link" itemprop="url">LeetCode-12-字符串</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-28 23:45:50" itemprop="dateCreated datePublished" datetime="2020-03-28T23:45:50+08:00">2020-03-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-29 19:29:02" itemprop="dateModified" datetime="2020-10-29T19:29:02+08:00">2020-10-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>常用函数：</p>
<pre><code>bin() # 十进制转二进制
oct() # 十进制转八进制
hex() # 十进制转十六进制

chr() # 数字转字符串(ascii)
ord() # 字符串(ascii)转数字

65--&#39;A&#39;
97--&#39;a&#39;</code></pre>
<h2 id="十二、字符串"><a href="#十二、字符串" class="headerlink" title="十二、字符串"></a>十二、字符串</h2><h3 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5.最长回文子串"></a>5.最长回文子串</h3><pre><code>链接：https://leetcode-cn.com/problems/longest-palindromic-substring/

给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

示例 1：

输入: &quot;babad&quot;
输出: &quot;bab&quot;
注意: &quot;aba&quot; 也是一个有效答案。
示例 2：

输入: &quot;cbbd&quot;
输出: &quot;bb&quot;</code></pre>
<p>题解一|暴力破解：<br>    很明显，暴力法将选出所有子字符串可能的开始和结束位置，并检验它是不是回文。<br>    时间复杂度：O(n^2),往往利用python的切片可以很好的缩减复杂度<br>    如果不用切片，还需要遍历一次子字符串，时间复杂度就是O(n^3)<br>    空间复杂度：O(1)</p>
<pre><code>class Solution:
    def longestPalindrome(self, s: str) -&gt; str:
        if s==s[::-1]:
            return s

        maxLen=1
        ans=s[0]
        for i in range(0,len(s)-1):
            for j in range(i+1,len(s)):
                if j-i+1 &gt; maxLen and self.isPalindrome(s[i:j+1]):
                    maxLen=j-i+1
                    ans=s[i:j+1]
        return ans

    def isPalindrome(self, s: str) -&gt; bool:
        left,right=0,len(s)-1
        while left&lt;right:
            while left&lt;len(s) and not s[left].isalnum():
                left+=1
            while right &gt;-1 and not s[right].isalnum():
                right-=1
            if left&gt;right:
                return True
            if s[left].upper() != s[right].upper():
                return False
            else:
                left+=1
                right-=1
        return True</code></pre>
<pre><code>class Solution:
    def longestPalindrome(self, s: str) -&gt; str:
        if s==s[::-1]:
            return s

        maxLen=1
        ans=s[0]
        for i in range(0,len(s)-1):
            for j in range(i+1,len(s)):
                if j-i+1 &gt; maxLen and s[i:j+1]==s[i:j+1][::-1]: # arr=&#39;abb&#39;,arr[0:1]=&#39;a&#39;,右边是开区间
                    maxLen=j-i+1
                    ans=s[i:j+1]
        return ans</code></pre>
<p>题解二：</p>
<pre><code>每个字母当成回文串的中心
考虑两种情况:回文串的长度为奇数或者偶数情况。</code></pre>
<pre><code>class Solution:
    def longestPalindrome(self, s: str) -&gt; str:
        n=len(s)
        self.res=&#39;&#39;
        def helper(i,j):
            while i&gt;= 0 and j&lt;n and s[i]==s[j]:
                i-=1
                j+=1
            if len(self.res) &lt; j-i-1:
                self.res=s[i+1:j]
                # print(i,self.res)

        for i in range(n):
            helper(i,i)
            helper(i,i+1) # 解决case为&quot;cbbd&quot;,即解决回文串为偶数的情况
        return self.res</code></pre>
<p>?题解三：</p>
<pre><code>把每个字母当成回文串的结束</code></pre>
<pre><code>class Solution:
    def longestPalindrome(self, s: str) -&gt; str:
        if not s:
            return &quot;&quot;
        max_len = 1
        n = len(s)
        start = 0
        for i in range(1,n):
            even = s[i-max_len:i+1]
            odd = s[i - max_len-1:i+1]
            #print(even,odd)
            if i - max_len - 1 &gt;= 0 and odd == odd[::-1]:
                start = i - max_len - 1
                max_len += 2
            elif i - max_len &gt;=0 and even == even[::-1]:
                start = i - max_len
                max_len += 1

        #print(start,max_len)
        return s[start: start+max_len]</code></pre>
<p>题解四|动态规划：<br><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/dp.png"></p>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/">https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/</a></p>
<pre><code>1、定义数组的定义
    dp[i][j] 表示子串 s[i, j] 是否为回文子串。
2、找出数组的关系式
    dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1]

    说明：

        「动态规划」事实上是在填一张二维表格，由于构成子串，因此 i 和 j 的关系是 i &lt;= j ，因此，只需要填这张表格对角线以上的部分。

        看到 dp[i + 1][j - 1] 就得考虑边界情况。

    边界条件是：表达式 [i + 1, j - 1] 不构成区间，即长度严格小于 2，即 j - 1 - (i + 1) + 1 &lt; 2 ，整理得 j - i &lt; 3。

    这个结论很显然：j - i &lt; 3 等价于 j - i + 1 &lt; 4，即当子串 s[i..j] 的长度等于 2 或者等于 3 的时候，其实只需要判断一下头尾两个字符是否相等就可以直接下结论了。

        如果子串 s[i + 1..j - 1] 只有 1 个字符，即去掉两头，剩下中间部分只有 11 个字符，显然是回文；
        如果子串 s[i + 1..j - 1] 为空串，那么子串 s[i, j] 一定是回文子串。

    因此，在 s[i] == s[j] 成立和 j - i &lt; 3 的前提下，直接可以下结论，dp[i][j] = true，否则才执行状态转移。

3、找到初始值
    初始化的时候，单个字符一定是回文串，因此把对角线先初始化为 true，即 dp[i][i] = true 。

    事实上，初始化的部分都可以省去。因为只有一个字符的时候一定是回文，dp[i][i] 根本不会被其它状态值所参考。

4、考虑输出

    只要一得到 dp[i][j] = true，就记录子串的长度和起始位置，没有必要截取，这是因为截取字符串也要消耗性能，记录此时的回文子串的「起始位置」和「回文长度」即可。</code></pre>
<pre><code>class Solution:
    def longestPalindrome(self, s: str) -&gt; str:
        n=len(s)
        if n &lt; 2:
            return s
        dp=[[False]*n for i in range(n)]
        res=1
        start=0

        for i in range(n):
            dp[i][i]=True

        for j in range(1,n):
            for i in range(0,j):
                if s[i]==s[j]:
                    if j-i &lt; 3:
                        dp[i][j]=True
                    else:
                        dp[i][j]=dp[i+1][j-1]
                else:
                    dp[i][j]=False

                if dp[i][j]:
                    cur=j-i+1
                    if cur&gt;res:
                        res=cur
                        start=i
        return s[start:start+res]
</code></pre>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/gao-hao-dong-tai-gui-hua-he-zhong-xin-tuo-zhan-zhu/">https://leetcode-cn.com/problems/longest-palindromic-substring/solution/gao-hao-dong-tai-gui-hua-he-zhong-xin-tuo-zhan-zhu/</a></p>
<h3 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7. 整数反转"></a>7. 整数反转</h3><pre><code>链接：https://leetcode-cn.com/problems/reverse-integer/

给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。

示例 1:

输入: 123
输出: 321
 示例 2:

输入: -123
输出: -321
示例 3:

输入: 120
输出: 21
注意:

假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回0</code></pre>
<p>题解一：</p>
<pre><code>class Solution:
    def reverse(self, x: int) -&gt; int:
        flag=1 if x&gt;0 else -1
        new=abs(x)
        res=0
        while new:
            res=res*10 + new%10
            new//=10
        if res&gt;pow(-2,31) and res&lt;pow(2,31)-1:
            return flag*res
        else:
            return 0</code></pre>
<p>题解二：</p>
<pre><code>class Solution:
    def reverse(self, x: int) -&gt; int:
        x=int(str(x)[::-1]) if x&gt;=0 else -int(str(-x)[::-1])
        return x if x&lt;pow(2,31)-1 and x&gt;-pow(2,31) else 0</code></pre>
<h3 id="8-字符串转换整数-atoi"><a href="#8-字符串转换整数-atoi" class="headerlink" title="8. 字符串转换整数 (atoi)"></a>8. 字符串转换整数 (atoi)</h3><p>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/string-to-integer-atoi/">https://leetcode-cn.com/problems/string-to-integer-atoi/</a></p>
<pre><code>请你来实现一个 atoi 函数，使其能将字符串转换成整数。

首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：

如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。
假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。
该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。
注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。

在任何情况下，若函数不能进行有效的转换时，请返回 0 。

提示：

本题中的空白字符只包括空格字符 &#39; &#39; 。
假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。


示例 1:

输入: &quot;42&quot;
输出: 42
示例 2:

输入: &quot;   -42&quot;
输出: -42
解释: 第一个非空白字符为 &#39;-&#39;, 它是一个负号。
     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。
示例 3:

输入: &quot;4193 with words&quot;
输出: 4193
解释: 转换截止于数字 &#39;3&#39; ，因为它的下一个字符不为数字。
示例 4:

输入: &quot;words and 987&quot;
输出: 0
解释: 第一个非空字符是 &#39;w&#39;, 但它不是数字或正、负号。
     因此无法执行有效的转换。
示例 5:

输入: &quot;-91283472332&quot;
输出: -2147483648
解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 
     因此返回 INT_MIN (−231) 。</code></pre>
<p>题解一：</p>
<pre><code>class Solution:
    def myAtoi(self, str: str) -&gt; int:
        str=str.lstrip()

        if len(str)==0:
            return 0
        last=0
        i=1 if str[0]==&#39;+&#39; or str[0]==&#39;-&#39; else 0
        #循环，直到无法强转成int，跳出循环
        while i&lt;=len(str):
            try:
                last=int(str[:i+1]) # int[&#39;aa&#39;]会报错，所以走break
                print(last)
                i+=1
            except:
                break
        # 判断数字是否超出范围
        if last&lt;-2**31:
            return -2**31
        if last&gt;2**31-1:
            return 2**31-1
        return last</code></pre>
<h3 id="12-转罗马数字"><a href="#12-转罗马数字" class="headerlink" title="12.转罗马数字"></a>12.转罗马数字</h3><pre><code>链接：https://leetcode-cn.com/problems/integer-to-roman/

罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。

字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。

示例 1:

输入: 3
输出: &quot;III&quot;
示例 2:

输入: 4
输出: &quot;IV&quot;
示例 3:

输入: 9
输出: &quot;IX&quot;
示例 4:

输入: 58
输出: &quot;LVIII&quot;
解释: L = 50, V = 5, III = 3.
示例 5:

输入: 1994
输出: &quot;MCMXCIV&quot;
解释: M = 1000, CM = 900, XC = 90, IV = 4.</code></pre>
<p>题解一|贪心算法：</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/rome.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/rome.png"></p>
<pre><code>class Solution:
    def intToRoman(self, num: int) -&gt; str:
        # dicts=&#123;&#39;I&#39;:1,&#39;V&#39;:5,&#39;X&#39;:10,&#39;L&#39;:50,&#39;C&#39;:100,&#39;D&#39;:500,&#39;M&#39;:1000&#125;

        dicts=&#123;1:&#39;I&#39;,4:&#39;IV&#39;,5:&#39;V&#39;,9:&#39;IX&#39;,10:&#39;X&#39;,40:&#39;XL&#39;,50:&#39;L&#39;,90:&#39;XC&#39;,100:&#39;C&#39;,400:&#39;CD&#39;,500:&#39;D&#39;,900:&#39;CM&#39;,1000:&#39;M&#39; &#125;
        ans=&#39;&#39;
        for key in sorted(dicts.keys())[::-1]:
            if num==0:
                break
            tmp=num//key
            if tmp==0:
                continue
            ans+=dicts[key]*tmp
            num-=key*tmp
        return ans</code></pre>
<h3 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13.罗马数字转整数"></a>13.罗马数字转整数</h3><pre><code>链接：https://leetcode-cn.com/problems/roman-to-integer/

罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。

字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。

示例 1:

输入: &quot;III&quot;
输出: 3
示例 2:

输入: &quot;IV&quot;
输出: 4
示例 3:

输入: &quot;IX&quot;
输出: 9
示例 4:

输入: &quot;LVIII&quot;
输出: 58
解释: L = 50, V= 5, III = 3.
示例 5:

输入: &quot;MCMXCIV&quot;
输出: 1994
解释: M = 1000, CM = 900, XC = 90, IV = 4.</code></pre>
<p>题解一|hash：</p>
<pre><code>首先建立一个HashMap来映射符号和值，然后对字符串从左到右来，如果当前字符代表的值小于其右边，就减去该值；否则就加上该值，以此类推到最右边的数</code></pre>
<pre><code>class Solution:
    def romanToInt(self, s: str) -&gt; int:
        arr=&#123;&#39;I&#39;:1,&#39;V&#39;:5,&#39;X&#39;:10,&#39;L&#39;:50,&#39;C&#39;:100,&#39;D&#39;:500,&#39;M&#39;:1000&#125;
        ans=0
        for i in range(len(s)):
            if i&lt;len(s)-1 and arr[s[i]]&lt;arr[s[i+1]]:
                ans-=arr[s[i]]
            else:
                ans+=arr[s[i]]
        return ans</code></pre>
<p>题解二|hash：</p>
<pre><code>构建一个字典记录所有罗马数字子串，注意长度为2的子串记录的值是（实际值 - 子串内左边罗马数字代表的数值）

然后，遍历整个 s 的时候判断当前位置和前一个位置的两个字符组成的字符串是否在字典内，如果在就记录值，不在就说明当前位置不存在小数字在前面的情况，直接记录当前位置字符对应值

举个例子，遍历经过 IV 的时候先记录 I 的对应值 1，再往前移动一步记录 IV 的值 3，加起来正好是 IV 的真实值 4。max 函数在这里是为了防止遍历第一个字符的时候出现 [-1:0] 的情况，因为s[-1:0]为空。</code></pre>
<pre><code>class Solution:
    def romanToInt(self, s: str) -&gt; int:
        arr=&#123;&#39;I&#39;:1,&#39;IV&#39;:3,&#39;V&#39;:5,&#39;IX&#39;:8,&#39;X&#39;:10,&#39;XL&#39;:30,&#39;L&#39;:50,&#39;XC&#39;:80,&#39;C&#39;:100,&#39;CD&#39;:300,&#39;D&#39;:500,&#39;CM&#39;:800,&#39;M&#39;:1000&#125;
        return sum(arr.get(s[max(i-1,0):i+1],arr[v]) for i,v in enumerate(s))</code></pre>
<pre><code>class Solution:
    def romanToInt(self, s: str) -&gt; int:
        arr=&#123;&#39;I&#39;:1,&#39;IV&#39;:3,&#39;V&#39;:5,&#39;IX&#39;:8,&#39;X&#39;:10,&#39;XL&#39;:30,&#39;L&#39;:50,&#39;XC&#39;:80,&#39;C&#39;:100,&#39;CD&#39;:300,&#39;D&#39;:500,&#39;CM&#39;:800,&#39;M&#39;:1000&#125;
        ans=0
        for i,v in enumerate(s):
            ans+=arr.get(s[i-1:i+1],arr[v])
        return ans</code></pre>
<h3 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14.最长公共前缀"></a>14.最长公共前缀</h3><pre><code>链接：https://leetcode-cn.com/problems/longest-common-prefix/

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 &quot;&quot;。

示例 1:

输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]
输出: &quot;fl&quot;
示例 2:

输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]
输出: &quot;&quot;
解释: 输入不存在公共前缀。
说明:

所有输入只包含小写字母 a-z 。</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lz_901/article/details/89021210">https://blog.csdn.net/lz_901/article/details/89021210</a></p>
<p>题解一|水平扫描：</p>
<pre><code>1、先找出 str1 和 str2（注：str1代表第一个字符串，str2代表第二个） 的公共字符串 s1。

2、然后再找出 s1 和 str3 的公共前缀 s2。

3、然后再找出 s2 和 str4 的公共前缀 s3。

4、一直这样遍历重复，用一个变量来保存两个两个字符串之间的公共前缀。</code></pre>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/lcp1.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/lcp1.png"></p>
<pre><code>class Solution:
    def longestCommonPrefix(self, strs: List[str]) -&gt; str:
        if not strs:
            return &#39;&#39;
        prefix=strs[0]
        for i in range(1,len(strs)):
            while strs[i].find(prefix) != 0: # 此题是寻找最长公共前缀，所以需要找到开始索引是0.
                prefix=prefix[0:len(prefix)-1]
                if prefix==&#39;&#39;:
                    return &#39;&#39;
        return prefix</code></pre>
<p>find()语法：</p>
<pre><code>str.find(str, beg=0, end=len(string))

参数：
    str -- 指定检索的字符串
    beg -- 开始索引，默认为0。
    end -- 结束索引，默认为字符串的长度。

返回值：
    如果包含子字符串返回开始的索引值，否则返回-1。</code></pre>
<p>题解二|水平扫描优化：</p>
<pre><code>想象数组的末尾有一个非常短的字符串，使用上述方法仍旧会进行S次比较。
优化这类情况的方法是水平扫描，从前往后枚举字符串的每一列，先比较每个字符串相同列上的字符（即不同字符串相同下标的字符），然后再进行下一列的比较。

我们不横向一个一个字符串遍历，而是采用纵向的方式。例如对于这个[&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]，我们把它看成一个二维字符数组。

然后纵向遍历，一列一列遍历，只要发现某一列出现不同的字符，就遍历结束，例如上面这个例子中，第三列就出现不同了，所以遍历结束，把前两列返回。</code></pre>
<pre><code>class Solution:
    def longestCommonPrefix(self, strs: List[str]) -&gt; str:
        if not strs:
            return &#39;&#39;
        for i in range(len(strs[0])):
            tmp=strs[0][i]
            for j in range(1,len(strs)):
                if i==len(strs[j]) or strs[j][i]!=tmp:
                    return strs[0][0:i]
        return strs[0]
</code></pre>
<p>题解三|分治：</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/lcp2.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/lcp2.png"></p>
<p>复杂度：<br><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/lcp3.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/lcp3.png"></p>
<pre><code>class Solution:
    def longestCommonPrefix(self, strs: List[str]) -&gt; str:
        def commonPrefix(l, r):
            &#39;&#39;&#39;
            治：从首位开始对比
            :param l:
            :param r:
            :return:
            &#39;&#39;&#39;
            minlen = min(len(l), len(r))
            for i in range(minlen):
                if l[i] != r[i]:
                    return l[0:i]
            return l[0:minlen]

        def lcp(strs, l, r):
            &#39;&#39;&#39;
            分：分为小问题
            :param strs:
            :param l:
            :param r:
            :return:
            &#39;&#39;&#39;

            # 递归弹出
            if l == r:
                return strs[l]
            # 继续分
            else:
                mid = (l + r) // 2
                left = lcp(strs, l, mid)
                right = lcp(strs, mid + 1, r)
                return commonPrefix(left, right)

        if not strs:
            return &#39;&#39;
        return lcp(strs, 0, len(strs) - 1)</code></pre>
<p>题解四|zip：</p>
<pre><code>class Solution:
    def longestCommonPrefix(self, strs: List[str]) -&gt; str:
        # print(strs)
        # print(*strs)
        res=&#39;&#39;
        for i in zip(*strs):
            # print(i)
            if len(set(i))==1:
                res+=i[0]
            else:
                break
        return res

输出：
[&#39;flower&#39;, &#39;flow&#39;, &#39;flight&#39;]
flower flow flight
(&#39;f&#39;, &#39;f&#39;, &#39;f&#39;)
(&#39;l&#39;, &#39;l&#39;, &#39;l&#39;)
(&#39;o&#39;, &#39;o&#39;, &#39;i&#39;)</code></pre>
<p>zip()语法：</p>
<pre><code>zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表(python2)/对象(python3)。

如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。

zip 方法在 Python 2 和 Python 3 中的不同：在 Python 3.x 中为了减少内存，zip() 返回的是一个对象。如需展示列表，需手动 list() 转换。在 Python 2.x zip() 返回的是一个列表。

zip([iterable, ...])

参数说明：
    iterabl -- 一个或多个迭代器;
返回值:
返回元组列表/一个对象。</code></pre>
<p>题解五|max和min：</p>
<p>max()和min()在python字符串中是可以比较的，按照ascii值排序，比如abb，aba，abac，最大为abb，最小为aba。</p>
<pre><code>class Solution:
    def longestCommonPrefix(self, strs: List[str]) -&gt; str:
        if not strs:
            return &#39;&#39;
        s1=min(strs)
        s2=max(strs)
        for i,v in enumerate(s1):
            if v != s2[i]:
                return s1[:i]
        return s1</code></pre>
<h3 id="28-实现-strStr"><a href="#28-实现-strStr" class="headerlink" title="28. 实现 strStr()"></a>28. 实现 strStr()</h3><pre><code>链接：https://leetcode-cn.com/problems/implement-strstr/

实现 strStr() 函数。

给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。

示例 1:

输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;
输出: 2
示例 2:

输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;
输出: -1
说明:

当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</code></pre>
<p>题解一|子串逐一比较|线性时间复杂度：</p>
<p>思路：沿着字符换逐步移动滑动窗口，将窗口内的子串与 needle 字符串比较。</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/str1.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/str1.png"></p>
<p>时间复杂度：O((N - L)L)，其中 N 为 haystack 字符串的长度，L 为 needle 字符串的长度。内循环中比较字符串的复杂度为 L，总共需要比较 (N - L) 次。<br>空间复杂度：O(1)</p>
<pre><code>class Solution:
    def strStr(self, haystack: str, needle: str) -&gt; int:
        n1,n2=len(haystack),len(needle)
        for i in range(n1-n2+1):
            if haystack[i:i+n2] == needle:
                return i
        return -1</code></pre>
<p>题解二|双指针|线性时间复杂度：</p>
<p>题解一的缺陷是会将 haystack 所有长度为 L 的子串都与 needle 字符串比较，实际上是不需要这么做的。</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/str.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/str.png"></p>
<pre><code>首先，只有子串的第一个字符跟 needle 字符串第一个字符相同的时候才需要比较。

其次，可以一个字符一个字符比较，一旦不匹配了就立刻终止。

比较到最后一位时发现不匹配，这时候开始回溯。需要注意的是，i 指针是移动到 i = i - index + 1 的位置，而 不是 i = i - index 的位置。

这时候再比较一次，就找到了完整匹配的子串，直接返回子串的开始位置 i - n2。</code></pre>
<p>思路：</p>
<pre><code>移动 i 指针，直到 i 所指向位置的字符与 needle 字符串第一个字符相等。

通过 i，j，index 计算匹配长度。

如果完全匹配（即 index == n2），返回匹配子串的起始坐标（即 i - n2）。

如果不完全匹配，回溯，使 i = i - index + 1， j = 0， index = 0。</code></pre>
<p>时间复杂度：最坏时间复杂度为 O((n1 - n2)n2)，最优时间复杂度为 O(n2)。<br>空间复杂度：O(1)</p>
<pre><code>class Solution:
    def strStr(self, haystack: str, needle: str) -&gt; int:
        n1,n2=len(haystack),len(needle)
        if not n2:
            return 0
        i=0
        while i&lt;(n1-n2+1):
            while i&lt;(n1-n2+1) and haystack[i] != needle[0]:
                i+=1
            j,index=0,0
            while i&lt;n1 and j&lt;n2 and haystack[i]==needle[j]:
                i+=1
                j+=1
                index+=1
            if index==n2:
                return i-n2
            i=i-index+1 # 如果使用i=i-index会超时。

        return -1</code></pre>
<p>题解三|KMP：</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-strstr/solution/kmphua-48xiao-shi-kan-dong-liao-kmpxiang-rang-ni-z/">https://leetcode-cn.com/problems/implement-strstr/solution/kmphua-48xiao-shi-kan-dong-liao-kmpxiang-rang-ni-z/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Px411z7Yo?from=search&amp;seid=13225444196686531503">https://www.bilibili.com/video/BV1Px411z7Yo?from=search&amp;seid=13225444196686531503</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1hW411a7ys/?spm_id_from=333.788.videocard.0">https://www.bilibili.com/video/BV1hW411a7ys/?spm_id_from=333.788.videocard.0</a></p>
<pre><code>class Solution:
    def strStr(self, haystack: str, needle: str) -&gt; int:
        if not needle:
            return 0
        next=self.getNext(needle)
        i=j=0
        while i&lt;len(haystack) and j&lt;len(needle):
            if j==-1 or haystack[i]==needle[j]:
                i+=1
                j+=1
            else:
                j=next[j]
        if j==len(needle):
            return i-j
        else:
            return -1

    def getNext(self,needle):
        next=[0]*len(needle)
        next[0]=-1
        print(next)
        i=0
        j=-1
        while i&lt;len(needle)-1:
            if j==-1 or needle[i]==needle[j]:
                i+=1
                j+=1
                next[i]=j
            else:
                j=next[j]
        return next</code></pre>
<p>题解四：</p>
<pre><code>class Solution:
    def strStr(self, haystack: str, needle: str) -&gt; int:
        i=haystack.find(needle)
        return i</code></pre>
<h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h3><pre><code>链接：https://leetcode-cn.com/problems/valid-parentheses/

给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;&#123;&#39;，&#39;&#125;&#39;，&#39;[&#39;，&#39;]&#39; 的字符串，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
注意空字符串可被认为是有效字符串。

示例 1:

输入: &quot;()&quot;
输出: true
示例 2:

输入: &quot;()[]&#123;&#125;&quot;
输出: true
示例 3:

输入: &quot;(]&quot;
输出: false
示例 4:

输入: &quot;([)]&quot;
输出: false
示例 5:

输入: &quot;&#123;[]&#125;&quot;
输出: true</code></pre>
<p>题解一：</p>
<p>时间复杂度：O(N)。遍历了一遍字符串。<br>空间复杂度：O(N)。最坏情况下，假如输入是 (((((((，栈的大小将是输入字符串的长度。</p>
<pre><code>class Solution:
    def isValid(self, s: str) -&gt; bool:
        dict = &#123;&#39;)&#39;:&#39;(&#39;,&#39;]&#39;:&#39;[&#39;,&#39;&#125;&#39;:&#39;&#123;&#39;&#125;
        stack=[]
        for i in s:
            if stack and i in dict:
                if stack[-1] == dict[i]:
                    stack.pop()
                else:
                    return False
            else:
                stack.append(i)
        return not stack</code></pre>
<pre><code>class Solution:
    def isValid(self, s: str) -&gt; bool:
        dicts=&#123;&#39;(&#39;:1,&#39;)&#39;:-1,&#39;&#123;&#39;:2,&#39;&#125;&#39;:-2,&#39;[&#39;:3,&#39;]&#39;:-3&#125;
        list=[]
        for i in s:
            if len(list)==0:
                list.append(i)
            elif dicts[i]+dicts[list[-1]]==0:
                del list[-1]
            else:
                list.append(i)
        return len(list)==0</code></pre>
<h3 id="38-外观数列"><a href="#38-外观数列" class="headerlink" title="38. 外观数列"></a>38. 外观数列</h3><pre><code>链接：https://leetcode-cn.com/problems/count-and-say/

「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：

1.     1
2.     11
3.     21
4.     1211
5.     111221
1 被读作  &quot;one 1&quot;  (&quot;一个一&quot;) , 即 11。
11 被读作 &quot;two 1s&quot; (&quot;两个一&quot;）, 即 21。
21 被读作 &quot;one 2&quot;,  &quot;one 1&quot; （&quot;一个二&quot; ,  &quot;一个一&quot;) , 即 1211。

给定一个正整数 n（1 ≤ n ≤ 30），输出外观数列的第 n 项。

注意：整数序列中的每一项将表示为一个字符串。

示例 1:

输入: 1
输出: &quot;1&quot;
解释：这是一个基本样例。
示例 2:

输入: 4
输出: &quot;1211&quot;
解释：当 n = 3 时，序列是 &quot;21&quot;，其中我们有 &quot;2&quot; 和 &quot;1&quot; 两组，&quot;2&quot; 可以读作 &quot;12&quot;，也就是出现频次 = 1 而 值 = 2；类似 &quot;1&quot; 可以读作 &quot;11&quot;。所以答案是 &quot;12&quot; 和 &quot;11&quot; 组合在一起，也就是 &quot;1211&quot;。</code></pre>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/106149461">https://zhuanlan.zhihu.com/p/106149461</a></p>
<p>题解一|递归:</p>
<pre><code>class Solution:
    def countAndSay(self, n: int) -&gt; str:
        if n==1:
            return &#39;1&#39;
        pre=self.countAndSay(n-1)
        res=&#39;&#39;
        count=1
        n=len(pre)
        for i in range(1,n):
            if pre[i] != pre[i-1]:
                res+=str(count)+pre[i-1]
                count=1
            else:
                count+=1
        res+=str(count)+pre[n-1]
        return res
</code></pre>
<p>题解二|迭代:</p>
<pre><code>class Solution:
    def countAndSay(self, n: int) -&gt; str:
        res=&#39;1&#39;
        while n-1&gt;0:
            tmp=&#39;&#39;
            count=0 # 计数
            pre=res[0] # 实际字符
            for i in range(len(res)):
                if pre==res[i]:
                    count+=1
                else:
                    tmp+=str(count)+pre
                    pre=res[i]
                    count=1
            tmp+=str(count)+pre
            res=tmp
            n-=1
        return res
</code></pre>
<pre><code>class Solution:
    def countAndSay(self, n: int) -&gt; str:
        res=&#39;1&#39;
        for i in range(n-1,0,-1):
            tmp=&#39;&#39;
            count=1 # count=1
            pre=res[0]
            for j in range(1,len(res)): # 从1开始
                if pre==res[j]:
                    count+=1
                else:
                    tmp+=str(count)+pre
                    pre=res[j]
                    count=1
            tmp+=str(count)+pre
            res=tmp
        return res</code></pre>
<h3 id="58-最后一个单词的长度"><a href="#58-最后一个单词的长度" class="headerlink" title="58. 最后一个单词的长度"></a>58. 最后一个单词的长度</h3><pre><code>链接：https://leetcode-cn.com/problems/length-of-last-word/

给定一个仅包含大小写字母和空格 &#39; &#39; 的字符串 s，返回其最后一个单词的长度。如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。

如果不存在最后一个单词，请返回 0 。

说明：一个单词是指仅由字母组成、不包含任何空格字符的 最大子字符串。

示例:

输入: &quot;Hello World&quot;
输出: 5</code></pre>
<p>题解一|内置函数:</p>
<pre><code>class Solution:
    def lengthOfLastWord(self, s: str) -&gt; int:
        return len(s.rstrip().split(&#39; &#39;)[-1])</code></pre>
<p>题解二：</p>
<pre><code>class Solution:
    def lengthOfLastWord(self, s: str) -&gt; int:
        end=len(s)-1
        while end&gt;=0 and s[end]==&#39; &#39;:
            end-=1
        if end &lt; 0: return 0
        start=end
        while start &gt;=0 and s[start] !=&#39; &#39;:
            start-=1
        return end-start</code></pre>
<h3 id="67-二进制求和"><a href="#67-二进制求和" class="headerlink" title="67. 二进制求和"></a>67. 二进制求和</h3><pre><code>链接：https://leetcode-cn.com/problems/add-binary/

给你两个二进制字符串，返回它们的和（用二进制表示）。

输入为 非空 字符串且只包含数字 1 和 0。

示例 1:

输入: a = &quot;11&quot;, b = &quot;1&quot;
输出: &quot;100&quot;
示例 2:

输入: a = &quot;1010&quot;, b = &quot;1011&quot;
输出: &quot;10101&quot;


提示：

每个字符串仅由字符 &#39;0&#39; 或 &#39;1&#39; 组成。
1 &lt;= a.length, b.length &lt;= 10^4
字符串如果不是 &quot;0&quot; ，就都不含前导零。</code></pre>
<p>题解一|内置函数:</p>
<p>时间复杂度为 O(N+M)</p>
<pre><code>class Solution:
    def addBinary(self, a: str, b: str) -&gt; str:
        return bin(int(a,2)+int(b,2))[2:]</code></pre>
<p>题解二|按位运算：</p>
<p>时间复杂度：O(max(N,M))，其中 N 和 M 是输入字符串 a 和 b 的长度。</p>
<p>空间复杂度：O(max(N,M))，存储求和结果。</p>
<pre><code>class Solution:
    def addBinary(self, a: str, b: str) -&gt; str:
        n=max(len(a),len(b))
        a,b=a.zfill(n),b.zfill(n)
        carry=0
        res=[]
        for i in range(n-1,-1,-1):
            if a[i]==&#39;1&#39;:
                carry+=1
            if b[i]==&#39;1&#39;:
                carry+=1
            if carry%2==1:
                res.append(&#39;1&#39;)
            else:
                res.append(&#39;0&#39;)

            carry//=2

        if carry==1:
            res.append(&#39;1&#39;)
        res.reverse()
        return &#39;&#39;.join(res)</code></pre>
<p>zfill()方法语法：<br>    str.zfill(width)<br>    参数:<br>        width – 指定字符串的长度。原字符串右对齐，前面填充0。<br>    返回值:<br>        返回指定长度的字符串。</p>
<p>题解三|位运算：</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/bit.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/bit.png"></p>
<p>算法:</p>
<pre><code>把 a 和 b 转换成整型数字 x 和 y，x 保存结果，y 保存进位。

当进位不为 0：y != 0：

    计算当前 x 和 y 的无进位相加结果：answer = x^y。

    计算当前 x 和 y 的进位：carry = (x &amp; y) &lt;&lt; 1。

    完成本次循环，更新 x = answer，y = carry。

返回 xx 的二进制形式。</code></pre>
<p>时间复杂度：O(N+M)，其中 N 和 M 是输入字符串 a 和 b 的长度。</p>
<p>空间复杂度：O(max(N,M))，存储计算结果。</p>
<pre><code>class Solution:
    def addBinary(self, a: str, b: str) -&gt; str:
        x,y=int(a,2),int(b,2)
        while y:
            res=x^y
            carry=(x &amp; y) &lt;&lt; 1
            x,y=res,carry
        return bin(x)[2:]
</code></pre>
<pre><code>class Solution:
    def addBinary(self, a, b) -&gt; str:
        x, y = int(a, 2), int(b, 2)
        while y:
            x, y = x ^ y, (x &amp; y) &lt;&lt; 1
        return bin(x)[2:]
</code></pre>
<h3 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125.验证回文串"></a>125.验证回文串</h3><pre><code>链接：https://leetcode-cn.com/problems/valid-palindrome/

给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

说明：本题中，我们将空字符串定义为有效的回文串。

示例 1:

输入: &quot;A man, a plan, a canal: Panama&quot;
输出: true
示例 2:

输入: &quot;race a car&quot;
输出: false</code></pre>
<p>题解一|双指针：</p>
<pre><code>class Solution:
    def isPalindrome(self, s: str) -&gt; bool:
        left,right=0,len(s)-1
        while left&lt;right:
            while left&lt;len(s) and not s[left].isalnum():
                left+=1
            while right &gt;-1 and not s[right].isalnum():
                right-=1
            if left&gt;right:
                return True
            if s[left].upper() != s[right].upper():
                return False
            else:
                left+=1
                right-=1
        return True</code></pre>
<p>isalnum():检测字符串是否由字母和数字组成。</p>
<p>题解二|正则：</p>
<pre><code>class Solution:
    def isPalindrome(self, s: str) -&gt; bool:
        import re
        p=&#39;&#39;.join(re.findall(r&#39;[a-zA-Z0-9+]&#39;,s))
        p=p.lower()
        return True if p==p[::-1] else False</code></pre>
<p>题解三|内置函数：</p>
<pre><code>class Solution:
    def isPalindrome(self, s: str) -&gt; bool:
        s = [*filter(str.isalnum, s.lower())]
        return s == s[::-1]</code></pre>
<h3 id="168-Excel表列名称"><a href="#168-Excel表列名称" class="headerlink" title="168.Excel表列名称"></a>168.Excel表列名称</h3><pre><code>链接：https://leetcode-cn.com/problems/excel-sheet-column-title/

给定一个正整数，返回它在 Excel 表中相对应的列名称。

例如，

    1 -&gt; A
    2 -&gt; B
    3 -&gt; C
    ...
    26 -&gt; Z
    27 -&gt; AA
    28 -&gt; AB 
    ...

示例 1:

输入: 1
输出: &quot;A&quot;
示例 2:

输入: 28
输出: &quot;AB&quot;
示例 3:

输入: 701
输出: &quot;ZY&quot;</code></pre>
<p>65–’A’<br>97–’a’</p>
<p>chr(65)  输出’A’<br>ord(‘A’) 输出65</p>
<p>divmod() 函数把除数和余数运算结果结合起来，返回一个包含商和余数的元组(a // b, a % b)。</p>
<p>除留余数法：<br>1、将486由10进制转换为10进制</p>
<pre><code>486 / 10^0 % 10 = 6
486 / 10^1 % 10 = 8
486 / 10^2 % 10 = 4

10 的 3 次幂大于 486 循环结束，可拆解出 10 进制数的个位、十位、百位…，再反向罗列得到 486</code></pre>
<p>2、将486由10进制转换为2进制</p>
<pre><code>486 / 2^0 % 10 = 0
486 / 2^1 % 10 = 1
486 / 2^2 % 10 = 1
486 / 2^3 % 10 = 0
486 / 2^4 % 10 = 0
486 / 2^5 % 10 = 1
486 / 2^6 % 10 = 1
486 / 2^7 % 10 = 1
486 / 2^8 % 10 = 1

2 的 9 次幂大于 486 循环结束，可拆解出 2 进制数 逻辑上的 个位、十位、百位…，再反向罗列得到 111100110</code></pre>
<p>3、486 由 10 进制转换为 26 进制</p>
<pre><code>486 / 26^0 % 10 = 6
486 / 26^1 % 10 = 1</code></pre>
<p>10 进制包括数字：0<del>9<br>2 进制包括：0、1<br>26 进制应包括：0</del>25</p>
<p>题解一|转26进制：</p>
<pre><code>class Solution:
    def convertToTitle(self, n: int) -&gt; str:
        res=&#39;&#39;
        while n:
            n,y=divmod(n,26)
            if y==0:
                n-=1
                y=26
            res=chr(y+64)+res
        return res</code></pre>
<pre><code>class Solution:
    def convertToTitle(self, n: int) -&gt; str:
        res=&#39;&#39;
        while n:
            n-=1 # 26字母中没有任何一个字母是表示0, 所以我们可以从 商 借一个给余数。
            n,y=divmod(n,26)
            res=chr(y+65)+res
        return res</code></pre>
<p>题解二|递归：</p>
<pre><code>class Solution:
    def convertToTitle(self, n: int) -&gt; str:
        if n==0:
            return &#39;&#39;
        else:
            return self.convertToTitle((n-1)//26) + chr((n-1) % 26 + 65)</code></pre>
<h3 id="171-Excel表列序号"><a href="#171-Excel表列序号" class="headerlink" title="171.Excel表列序号"></a>171.Excel表列序号</h3><pre><code>链接：https://leetcode-cn.com/problems/excel-sheet-column-number/

给定一个Excel表格中的列名称，返回其相应的列序号。

例如，

    A -&gt; 1
    B -&gt; 2
    C -&gt; 3
    ...
    Z -&gt; 26
    AA -&gt; 27
    AB -&gt; 28 
    ...
示例 1:

输入: &quot;A&quot;
输出: 1
示例 2:

输入: &quot;AB&quot;
输出: 28
示例 3:

输入: &quot;ZY&quot;
输出: 701</code></pre>
<p>题解一：</p>
<pre><code>class Solution:
    def titleToNumber(self, s: str) -&gt; int: 
        res=0
        for each in s:
            num=(ord(each)-65)+1
            res=res*26+num
        return res</code></pre>
<h3 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a>242. 有效的字母异位词</h3><pre><code>链接：https://leetcode-cn.com/problems/valid-anagram/

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

示例 1:

输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;
输出: true
示例 2:

输入: s = &quot;rat&quot;, t = &quot;car&quot;
输出: false
说明:
你可以假设字符串只包含小写字母。

进阶:
如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</code></pre>
<p>题解一|排序：</p>
<pre><code>class Solution:
    def isAnagram(self, s: str, t: str) -&gt; bool:
        if len(s) != len(t):
            return False
        if sorted(s) != sorted(t):
            return False
        return True</code></pre>
<p>题解二|hash：</p>
<pre><code>class Solution:
    def isAnagram(self, s: str, t: str) -&gt; bool:
        if len(s) != len(t):
            return False
        hash=&#123;&#125;
        for i in range(len(s)):
            hash[s[i]]=hash.get(s[i],0)+1
            hash[t[i]]=hash.get(t[i],0)-1
        for k,v in hash.items():
            if v != 0:
                return False
        return True</code></pre>
<p>题解三|hash:</p>
<pre><code>class Solution(object):
    def isAnagram(self, s, t):
        if len(s) != len(t):
            return False
        dicts = collections.defaultdict(int)
        for i in range(len(s)):
            dicts[s[i]] = dicts[s[i]] + 1
            dicts[t[i]] = dicts[t[i]] - 1
        for val in dicts.values():
            if val != 0:
                return False
        return True</code></pre>
<p>题解四|内置函数：</p>
<pre><code>import collections
class Solution:
    def isAnagram(self, s: str, t: str) -&gt; bool:
        return collections.Counter(s) == collections.Counter(t)</code></pre>
<h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344.反转字符串"></a>344.反转字符串</h3><pre><code>链接：https://leetcode-cn.com/problems/reverse-string/

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。

示例 1：

输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]
输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]
示例 2：

输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]
输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</code></pre>
<p>字符串逆序：</p>
<p>方法一：利用字符串的切片来实现逆序</p>
<pre><code>def reverse1(str):
    return str[::-1]</code></pre>
<p>方法二：将字符串转换为列表后再使用reverse()</p>
<pre><code>def reverse2(str):
    str_list=list(str)
    str_list.reverse()  # 列表翻转
    return &#39;&#39;.join(str_list) # 将列表转换为字符串

def reverse2(str):
    str_list=[]
    for each in str:
        str_list.append(each)
    str_list.reverse()
    return &#39;&#39;.join(str_list)</code></pre>
<p>方法三：新建列表，从后往前添加元素</p>
<pre><code>def reverse3(str):
    str_list=[]
    for i in range(len(str)-1,-1,-1):
        str_list.append(str[i])
    return &#39;&#39;.join(str_list)    </code></pre>
<p>方法四：递归</p>
<pre><code>def reverse4(str):
    if len(str)&lt;=1:
        return str
    return str[-1]+reverse4(str[:-1])</code></pre>
<p>方法五：借助collections模块extendleft()</p>
<pre><code>import collections

def reverse5(str):
    deque1 = collections.deque(str)
    deque2=collections.deque()
    for char in deque1:
        deque2.extendleft(char)
    return &#39;&#39;.join(deque2)</code></pre>
<p>方法六：swap交换操作，以中间为基准，交换对称位置的字符</p>
<pre><code>def reverse5(str):
    str_list = list(str)
    if len(str_list) == 0 or len(str_list) == 1:
        return str
    i = 0
    length = len(str_list)
    while i &lt; length / 2:
        str_list[i], str_list[length - i - 1] = str_list[length - i - 1], str_list[i]
        i += 1
    return &#39;&#39;.join(str_list)</code></pre>
<p>题解一|内置函数：</p>
<pre><code>class Solution:
    def reverseString(self, s):
        s.reverse()</code></pre>
<p>题解二|递归：</p>
<p>时间复杂度：O(N)。执行了 N/2 次的交换。<br>空间复杂度：O(N)，递归过程中使用的堆栈空间。</p>
<pre><code>class Solution:
    def reverseString(self, s: List[str]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify s in-place instead.
        &quot;&quot;&quot;
        def helper(left,right):
            if left&lt;right:
                s[left],s[right]=s[right],s[left]
                helper(left+1,right-1)
        helper(0,len(s)-1)</code></pre>
<p>题解三|双指针:</p>
<p>时间复杂度：O(N)。执行了 N/2 次的交换。<br>空间复杂度：O(1)，只使用了常数级空间。</p>
<pre><code>class Solution:
    def reverseString(self, s: List[str]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify s in-place instead.
        &quot;&quot;&quot;
        left,right=0,len(s)-1
        while left&lt;right:
            s[left],s[right]=s[right],s[left]
            left+=1
            right-=1
        return s</code></pre>
<h3 id="345-反转字符串中的元音字母"><a href="#345-反转字符串中的元音字母" class="headerlink" title="345. 反转字符串中的元音字母"></a>345. 反转字符串中的元音字母</h3><pre><code>链接：https://leetcode-cn.com/problems/reverse-vowels-of-a-string/

编写一个函数，以字符串作为输入，反转该字符串中的元音字母。

示例 1:

输入: &quot;hello&quot;
输出: &quot;holle&quot;
示例 2:

输入: &quot;leetcode&quot;
输出: &quot;leotcede&quot;</code></pre>
<p>题解一|栈：</p>
<pre><code>class Solution:
    def reverseVowels(self, s: str) -&gt; str:
        stack=[&#39;a&#39;,&#39;e&#39;,&#39;i&#39;,&#39;o&#39;,&#39;u&#39;,&#39;A&#39;,&#39;E&#39;,&#39;I&#39;,&#39;O&#39;,&#39;U&#39;]
        res=[]
        tmp=[i for i in s if i in stack]
        for i in s:
            if i not in stack:
                res.append(i)
            else:
                res.append(tmp.pop())
        return &#39;&#39;.join(res)</code></pre>
<p>题解二|双指针：</p>
<pre><code>class Solution:
    def reverseVowels(self, s: str) -&gt; str:
        if not s or len(s)==1:
            return s
        stack=[&#39;a&#39;,&#39;e&#39;,&#39;i&#39;,&#39;o&#39;,&#39;u&#39;,&#39;A&#39;,&#39;E&#39;,&#39;I&#39;,&#39;O&#39;,&#39;U&#39;]
        s=list(s)
        left,right=0,len(s)-1
        while left&lt;right:
            if s[left] not in stack:
                left+=1
            if s[right] not in stack:
                right-=1
            if s[left] in stack and s[right] in stack:
                s[left],s[right]=s[right],s[left]
                left+=1
                right-=1
        return &#39;&#39;.join(s)</code></pre>
<h3 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a>383. 赎金信</h3><pre><code>链接：https://leetcode-cn.com/problems/ransom-note/

给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。

(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。) 

注意：

你可以假设两个字符串均只含有小写字母。

canConstruct(&quot;a&quot;, &quot;b&quot;) -&gt; false
canConstruct(&quot;aa&quot;, &quot;ab&quot;) -&gt; false
canConstruct(&quot;aa&quot;, &quot;aab&quot;) -&gt; true</code></pre>
<p>题解一|Counter：</p>
<pre><code>class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -&gt; bool:
        from collections import Counter
        r=Counter(ransomNote)
        m=Counter(magazine)
        if not r-m:
            return True
        else:
            return False</code></pre>
<p>题解二|双指针：</p>
<p>时间复杂度为O(nlog(n)+mlog(m))<br>空间复杂度为O(m + n)</p>
<pre><code>class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -&gt; bool:
        ransomNoteList=list(ransomNote)
        magazineList=list(magazine)
        ransomNoteList.sort()
        magazineList.sort()
        i,j=0,0
        while i&lt;len(ransomNoteList) and j&lt;len(magazineList):
            if ransomNoteList[i]&gt;magazineList[j]:
                j+=1
            elif ransomNoteList[i] &lt; magazineList[j]:
                return False
            else:
                i+=1
                j+=1
        return i==len(ransomNoteList)</code></pre>
<p>题解三|hash：</p>
<p>时间复杂度: O(N) - N（遍历magazine） + 1（字典检索为O(1)）<br>空间复杂度: O(N)</p>
<pre><code>class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -&gt; bool:
        hash=&#123;&#125;
        for i in magazine:
            if i in hash:
                hash[i]+=1
            else:
                hash[i]=1
        for i in ransomNote:
            if i in hash and hash[i]&gt;0:
                hash[i]-=1
            else:
                return False
        return True</code></pre>
<p>题解四|暴力：</p>
<p>时间复杂度: O(N^2) - N（遍历ransomNote） * N（replace最糟糕的情况是遍历整个magazine）<br>空间复杂度: O(1)</p>
<pre><code>class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -&gt; bool:
        for i in ransomNote:
            if i in magazine:
                magazine=magazine.replace(i,&#39;&#39;,1) # 可选字符串, 1代表替换不超过 max 次
            else:
                return False
        return True</code></pre>
<h3 id="387-字符串中的第一个唯一字符"><a href="#387-字符串中的第一个唯一字符" class="headerlink" title="387. 字符串中的第一个唯一字符"></a>387. 字符串中的第一个唯一字符</h3><pre><code>链接：https://leetcode-cn.com/problems/first-unique-character-in-a-string/

给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。

案例:

s = &quot;leetcode&quot;
返回 0.

s = &quot;loveleetcode&quot;,
返回 2.


注意事项：您可以假定该字符串只包含小写字母。</code></pre>
<p>题解一|切片：</p>
<pre><code>class Solution:
    def firstUniqChar(self, s: str) -&gt; int:
        if len(s)==1:
            return 0
        for k in range(len(s)):
            if (s[k] not in s[k+1:]) and (s[k] not in s[:k]):
                return k
        return -1</code></pre>
<p>题解二|内置函数：</p>
<p>时间复杂度： O(N)，只遍历了两遍字符串，同时散列表中查找操作是常数时间复杂度的。<br>空间复杂度： O(N)，用到了散列表来存储字符串中每个元素出现的次数。</p>
<pre><code>class Solution:
    def firstUniqChar(self, s: str) -&gt; int:
        from collections import Counter
        count=Counter(s)
        for k,v in enumerate(s):
            if count[v]==1:
                return k
        return -1</code></pre>
<pre><code>import collections
class Solution:
    def firstUniqChar(self, s: str) -&gt; int:
        for i,j in collections.Counter(s).items():
            if j==1:return s.index(i)
        return -1</code></pre>
<p>题解三|find:</p>
<p>1.证明字母只出现了一次<br>如果一个字符串中的字符在字符串中从左边搜索和从右边搜索得到的index一样，那就证明只有一个了<br>2.循环每次是从第一个开始的，保证了执行的顺序</p>
<pre><code>class Solution(object):
    def firstUniqChar(self, s):
        for i in s:
            if s.find(i)== s.rfind(i):
                return s.find(i)
        return -1</code></pre>
<h3 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415. 字符串相加"></a>415. 字符串相加</h3><pre><code>链接：https://leetcode-cn.com/problems/add-strings/

给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。

注意：

num1 和num2 的长度都小于 5100.
num1 和num2 都只包含数字 0-9.
num1 和num2 都不包含任何前导零。
你不能使用任何內建 BigInteger 库，也不能直接将输入的字符串转换为整数形式。</code></pre>
<p>题解一：</p>
<p>zfill() 方法返回指定长度的字符串，原字符串右对齐，前面填充0。</p>
<pre><code>class Solution:
    def addStrings(self, num1: str, num2: str) -&gt; str:
        n=max(len(num1),len(num2))
        n1=num1.zfill(n)
        n2=num2.zfill(n)
        # print(n1,n2)
        carry=0
        res=[]
        for i in range(n-1,-1,-1):
            tmp=int(n1[i])+int(n2[i])
            carry+=tmp
            res.append(carry%10)
            carry//=10
        if carry==1:
            res.append(1)
        res.reverse() # res里面的数字是int
        return &#39;&#39;.join([str(i) for i in res])</code></pre>
<p>题解二|双指针:</p>
<p>时间复杂度:O(max(M,N))：其中 M，N 为 2 数字长度，按位遍历一遍数字（以较长的数字为准）；<br>空间复杂度:O(1),指针与变量使用常数大小空间。</p>
<pre><code>class Solution:
    def addStrings(self, num1: str, num2: str) -&gt; str:
        res = &quot;&quot;
        i, j, carry = len(num1) - 1, len(num2) - 1, 0
        while i &gt;= 0 or j &gt;= 0:
            n1 = int(num1[i]) if i &gt;= 0 else 0
            n2 = int(num2[j]) if j &gt;= 0 else 0
            tmp = n1 + n2 + carry
            carry = tmp // 10
            res = str(tmp % 10) + res
            i, j = i - 1, j - 1
        return &quot;1&quot; + res if carry else res</code></pre>
<h3 id="434-字符串中的单词数"><a href="#434-字符串中的单词数" class="headerlink" title="434. 字符串中的单词数"></a>434. 字符串中的单词数</h3><pre><code>链接：https://leetcode-cn.com/problems/number-of-segments-in-a-string/

统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。

请注意，你可以假定字符串里不包括任何不可打印的字符。

示例:

输入: &quot;Hello, my name is John&quot;
输出: 5
解释: 这里的单词是指连续的不是空格的字符，所以 &quot;Hello,&quot; 算作 1 个单词。</code></pre>
<p>题解一|split:</p>
<p>时间复杂度 : O(n)。<br>这里用到的内置函数（无论是 Java 还是 Python）的时间复杂度或为 O(n)，或为 O(1) ，故整个算法可以在线性复杂度内完成。</p>
<p>空间复杂度 : O(n)。<br>split 函数 (不管哪种语言) 返回长度为 O(n) 的数组/列表，故算法使用线性的额外空间。</p>
<pre><code>class Solution:
    def countSegments(self, s: str) -&gt; int:
        if not s:
            return 0
        return len(s.split(&#39; &#39;)) # 这段代码是错误的，并不能解决连续多个空格的case</code></pre>
<pre><code>class Solution:
    def countSegments(self, s: str) -&gt; int:
        return len(s.split())</code></pre>
<p>区别：</p>
<pre><code>split()的时候，多个空格当成一个空格；
split(&#39; &#39;)的时候，多个空格也要分割，会分割出来空。</code></pre>
<p>题解二：</p>
<p>时间复杂度 : O(n)，对每个下标进行常数时间的检测。<br>空间复杂度 : O(1)，只使用了额外的几个整数，因此使用的空间为常数。</p>
<pre><code>class Solution:
    def countSegments(self, s: str) -&gt; int:
        count=0
        for i in range(len(s)):
            if s[i] != &#39; &#39; and (s[i-1] ==&#39; &#39; or i==0 ):
                # print(s[i])
                count+=1
        return count </code></pre>
<h3 id="520-检测大写字母"><a href="#520-检测大写字母" class="headerlink" title="520. 检测大写字母"></a>520. 检测大写字母</h3><pre><code>链接：https://leetcode-cn.com/problems/detect-capital/

给定一个单词，你需要判断单词的大写使用是否正确。

我们定义，在以下情况时，单词的大写用法是正确的：

全部字母都是大写，比如&quot;USA&quot;。
单词中所有字母都不是大写，比如&quot;leetcode&quot;。
如果单词不只含有一个字母，只有首字母大写， 比如 &quot;Google&quot;。
否则，我们定义这个单词没有正确使用大写字母。

示例 1:

输入: &quot;USA&quot;
输出: True
示例 2:

输入: &quot;FlaG&quot;
输出: False
注意: 输入是由大写和小写拉丁字母组成的非空单词。</code></pre>
<p>题解一|内置函数:</p>
<pre><code>class Solution:
    def detectCapitalUse(self, word: str) -&gt; bool:
        if word.isupper() or word.islower() or word.istitle():
            return True
        return False

class Solution:
    def detectCapitalUse(self, word: str) -&gt; bool:
        return word.isupper() or word.islower() or word.istitle()
</code></pre>
<p>题解二：</p>
<pre><code>class Solution:
    def detectCapitalUse(self, word: str) -&gt; bool:
        c1=0
        c2=0
        for i in word:
            if (i&gt;=&#39;a&#39;):
                c1+=1
            else:
                c2+=1
        if (c1==len(word)) | (c2==len(word)):
            return True

        return ((c2==1) &amp; (word[0] &lt; &#39;a&#39; ))</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/LeetCode-2-%E6%A0%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/LeetCode-2-%E6%A0%88/" class="post-title-link" itemprop="url">LeetCode-2-栈</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-28 19:55:16" itemprop="dateCreated datePublished" datetime="2020-03-28T19:55:16+08:00">2020-03-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-21 13:26:51" itemprop="dateModified" datetime="2020-10-21T13:26:51+08:00">2020-10-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="二、栈"><a href="#二、栈" class="headerlink" title="二、栈"></a>二、栈</h2><h3 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a>42. 接雨水</h3><pre><code>链接：https://leetcode-cn.com/problems/trapping-rain-water/

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</code></pre>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/youdao/water2.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/youdao/water2.png"></p>
<pre><code>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。

示例:

输入: [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6</code></pre>
<p>思路： 求出每个柱子上面能够存多少水，然后将每根柱子的存水量相加便能得到总的存水量，为求出每根柱子上能够存多少水，就要求出每根柱子左边最高的和右边最高柱子，然后用两者的最小值减去当前柱子的高度。 例如图中从左到右第三根柱子的高度为0，它左边最高柱子的值为1，右边最高柱子的值为3，因此它的最大存水量为 Min（1，3）-0=1。</p>
<p>原文讲解：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u013309870/article/details/70978279">https://blog.csdn.net/u013309870/article/details/70978279</a></p>
<p>题解一|暴力：<br>利用上面的思路，从左到右遍历每根柱子，遍历的时候求出每根柱子左边最高和右边最高柱子的值，然后利用两者的最小值减去当前柱子的高度就行了。</p>
<p>时间复杂度O（n^2）,空间复杂度O（1）。</p>
<p>注意：如果当前柱子大于它左右最大值的任何一个是存不了水的。</p>
<pre><code>class Solution:
    def trap(self, height: List[int]) -&gt; int:
        waters=0
        length=len(height)

        if height is None or length&lt;2:
            return 0

        left,right=0,0
        for i in range(length):
            left,right=0,0
            for j in range(i):
                left=max(left,height[j])
            for j in range(length-1,i,-1):
                right=max(right,height[j])

            tmp=min(left,right)
            if tmp&gt;height[i]:
                waters+=tmp-height[i]
            else:
                waters+=0

        return waters</code></pre>
<p>题解二|优化：</p>
<p>题解一时间复杂度为O(n^2)。原因是对于每个元素都要从左到右，和从右到最左遍历其两边最大值，假如使用两个数组 left[ ] , right[ ]来保存每个元素左边最大值，右边最大值的话，这样就不用每次都遍历了，因此时间复杂度可以减少到O(n)，空间复杂度为O(n)，典型的空间换时间算法。</p>
<pre><code>对于数组[ 5, 2 , 6 , 2 , 4 ]
它的左数组：[5,5,6,6,6]
它的右数组：[6,6,6,4,4]</code></pre>
<p>算法的流程：</p>
<pre><code>从左到右遍历一次求出每个元素左边的最大值，保存在 left 数组中。 
从右到左遍历一次求出每个元素右边的最大值，保存在right数。
最后一次遍历求出每个元素（每根柱子）的存水量。</code></pre>
<pre><code>class Solution:
    def trap(self, height: List[int]) -&gt; int:
        waters=0
        length=len(height)

        if height is None or length&lt;2:
            return 0
        leftLargest,rightLargest=0,0
        left,right=[0]*length,[0]*length

        for i in range(length):
            leftLargest=max(leftLargest,height[i])
            left[i]=leftLargest

        for i in range(length-1,-1,-1):
            rightLargest=max(rightLargest,height[i])
            right[i]=rightLargest

        for i in range(length):
            tmp=min(left[i],right[i])
            if tmp&gt;height[i]:
                waters+=tmp-height[i]
            else:
                waters+=0

        return waters</code></pre>
<p>题解三|优化：</p>
<p>优化题解二，分析上面算法发现其实没有必要使用 left 数组，因为当从左到右遍历求存水量的过程中可以利用一个变量来保存当前元素左边的最大值。</p>
<pre><code>class Solution:
    def trap(self, height: List[int]) -&gt; int:
        waters=0
        length=len(height)

        if height is None or length&lt;2:
            return 0
        leftLargest,rightLargest=0,0
        right=[0]*length

        for i in range(length-1,-1,-1):
            rightLargest=max(rightLargest,height[i])
            right[i]=rightLargest

        for i in range(length):
            leftLargest=max(leftLargest,height[i])
            tmp=min(leftLargest,right[i])
            if tmp&gt;height[i]:
                waters+=tmp-height[i]
            else:
                waters+=0

        return waters</code></pre>
<p>题解四|双指针：</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/youdao/water1.png" alt="image"></p>
<pre><code>上面左右两边的黄色块分别表示当前元素左边最大值和右边最大值。

left ，right分别代表从左到右移动和从右到左移动的指针。

如果当前元素的左边最大值比右边最大值小，则left指针向右移动，否则right指针向左移动。

这种左右指针移动的目的是为了保证所求的左右最大值一定是当前元素的左右最大值。</code></pre>
<pre><code>class Solution:
    def trap(self, height: List[int]) -&gt; int:
        waters=0
        length=len(height)

        if height is None or length&lt;2:
            return 0
        leftLargest,rightLargest=0,0
        left,right=0,length-1

        while left&lt;right:
            leftLargest=max(leftLargest,height[left])
            rightLargest=max(rightLargest,height[right])

            if leftLargest &gt; rightLargest:
                waters+=rightLargest-height[right]
                right-=1
            else:
                waters+=leftLargest-height[left]
                left+=1

        return waters</code></pre>
<pre><code>def trap(height):
    if not height: return 0
    left = 0
    right = len(height) - 1
    res = 0
    # 记录左右边最大值
    left_max = height[left]
    right_max = height[right]
    while left &lt; right:
        if height[left] &lt; height[right]:
            if left_max &gt; height[left]:
                res += left_max - height[left]
            else:
                left_max = height[left]
            left += 1
        else:
            if right_max &gt; height[right]:
                res += right_max - height[right]
            else:
                right_max = height[right]
            right -= 1
    return res</code></pre>
<h3 id="58-最后一个单词的长度"><a href="#58-最后一个单词的长度" class="headerlink" title="58.最后一个单词的长度"></a>58.最后一个单词的长度</h3><pre><code>链接：https://leetcode-cn.com/problems/length-of-last-word/

给定一个仅包含大小写字母和空格 &#39; &#39; 的字符串，返回其最后一个单词的长度。

如果不存在最后一个单词，请返回 0 。

说明：一个单词是指由字母组成，但不包含任何空格的字符串。

示例:

输入: &quot;Hello World&quot;
输出: 5</code></pre>
<p>题解一|内置函数:</p>
<pre><code>class Solution:
    def lengthOfLastWord(self, s: str) -&gt; int:
        return len(s.rstrip().split(&#39; &#39;)[-1])</code></pre>
<p>题解二：<br>思路:<br>    从字符串末尾开始向前遍历，其中主要有两种情况<br>    第一种情况，以字符串”Hello World”为例，从后向前遍历直到遍历到头或者遇到空格为止，即为最后一个单词”World”的长度5<br>    第二种情况，以字符串”Hello World “为例，需要先将末尾的空格过滤掉，再进行第一种情况的操作，即认为最后一个单词为”World”，长度为5<br>    所以完整过程为先从后过滤掉空格找到单词尾部，再从尾部向前遍历，找到单词头部，最后两者相减，即为单词的长度<br>    时间复杂度：O(n)，n为结尾空格和结尾单词总体长度</p>
<pre><code>class Solution:
    def lengthOfLastWord(self, s: str) -&gt; int:
        # return len(s.rstrip().split(&#39; &#39;)[-1])
        end=len(s)-1
        while end&gt;=0 and s[end]==&#39; &#39;:
            end-=1
        if end &lt; 0: return 0
        start=end
        while start &gt;=0 and s[start] !=&#39; &#39;:
            start-=1
        return end-start</code></pre>
<h3 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136.只出现一次的数字"></a>136.只出现一次的数字</h3><pre><code>链接：https://leetcode-cn.com/problems/single-number/

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:

输入: [2,2,1]
输出: 1
示例 2:

输入: [4,1,2,1,2]
输出: 4</code></pre>
<p>题解一|list：</p>
<pre><code>class Solution:
    def singleNumber(self, nums: List[int]) -&gt; int:
        temp=[]
        for i in nums:
            if i not in temp:
                temp.append(i)
            else:
                temp.remove(i)
        # return temp[0]
        return temp.pop()</code></pre>
<p>题解二|hash：</p>
<pre><code>class Solution:
    def singleNumber(self, nums: List[int]) -&gt; int:
        temp=&#123;&#125;
        for i in nums:
            if i not in temp:
                temp[i]=1
            else:
                temp[i]+=1
        for k,v in temp.items():
            if v==1:
                return k</code></pre>
<p>题解三|位运算：</p>
<p>异或运算有以下三个性质。</p>
<pre><code>任何数和 0 做异或运算，结果仍然是原来的数，即 a⊕0=a。
任何数和其自身做异或运算，结果是 0，即 a⊕a=0。
异或运算满足交换律和结合律，即 a⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b。</code></pre>
<pre><code>class Solution:
    def singleNumber(self, nums: List[int]) -&gt; int:
        res=0
        for i in nums:
            res^=i
        return res</code></pre>
<pre><code>class Solution:
    def singleNumber(self, nums: List[int]) -&gt; int:
        return reduce(lambda x,y:x^y,nums)</code></pre>
<h3 id="137-只出现一次的数字-II"><a href="#137-只出现一次的数字-II" class="headerlink" title="137.只出现一次的数字 II"></a>137.只出现一次的数字 II</h3><pre><code>链接：https://leetcode-cn.com/problems/single-number-ii/

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:

输入: [2,2,3,2]
输出: 3
示例 2:

输入: [0,1,0,1,0,1,99]
输出: 99</code></pre>
<p>题解一|hash：</p>
<pre><code>class Solution:
    def singleNumber(self, nums: List[int]) -&gt; int:
        hash=&#123;&#125;
        for i in nums:
            if i not in hash:
                hash[i]=1
            else:
                hash[i]+=1
        for k,v in hash.items():
            if v!=3:
                return k</code></pre>
<p>题解二|数学运算：</p>
<pre><code>3×(a+b+c)−(a+a+a+b+b+b+c)=2c

时间复杂度：O(N)，遍历输入数组。
空间复杂度：O(N)，存储 N/3N/3 个元素的集合。</code></pre>
<pre><code>class Solution:
    def singleNumber(self, nums: List[int]) -&gt; int:
        return (3*sum(set(nums))-sum(nums))//2</code></pre>
<p>？？？题解三|位运算:</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/or.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/or.png"></p>
<h3 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84. 柱状图中最大的矩形"></a>84. 柱状图中最大的矩形</h3><pre><code>链接：https://leetcode-cn.com/problems/largest-rectangle-in-histogram/

给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。

图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。

示例:

输入: [2,1,5,6,2,3]
输出: 10</code></pre>
<p>题解一|暴力|超时：</p>
<pre><code>class Solution:
    def largestRectangleArea(self, heights: List[int]) -&gt; int:
        if not heights:
            return 0
        n=len(heights)
        area=0
        for i in range(n):
            tmp=heights[i]
            for j in range(i,n):
                tmp=min(tmp,heights[j])
                area=max(area,tmp*(j-i+1))
        return area</code></pre>
<p>题解二|递增栈：</p>
<pre><code>class Solution:
    def largestRectangleArea(self, heights: List[int]) -&gt; int:
        if not heights:
            return 0
        n=len(heights)
        stack=[]
        area,i=0,0
        while i &lt; n:
            if not stack or (heights[i] &gt; heights[stack[-1]]):
                stack.append(i)
                i+=1
            else:
                tmp=stack.pop()
                area=max(area,heights[tmp]*((i-stack[-1]-1) if stack else i))
        while stack:
            tmp=stack.pop()
            area=max(area,heights[tmp]*((i-stack[-1]-1) if stack else i))
        return area</code></pre>
<h3 id="85-最大矩形"><a href="#85-最大矩形" class="headerlink" title="85. 最大矩形"></a>85. 最大矩形</h3><pre><code>链接：https://leetcode-cn.com/problems/maximal-rectangle/

给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。

示例:

输入:
[
  [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],
  [&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],
  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],
  [&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]
]
输出: 6</code></pre>
<p>题解一|暴力：</p>
<p>时间复杂度：O（m²n）。<br>空间复杂度：O（mn）。</p>
<pre><code>class Solution:
    def maximalRectangle(self, matrix: List[List[str]]) -&gt; int:
        if not matrix:
            return 0
        m=len(matrix)
        n=len(matrix[0])
        dp=[[0] * n for i in range(m)]
        area=0
        for i in range(m):
            for j in range(n):
                if matrix[i][j]==&#39;1&#39;:
                    if n==0:
                        dp[i][j]=1
                    else:
                        dp[i][j]=dp[i][j-1]+1
                else:
                    dp[i][j]=0   

                minWidth=dp[i][j]
                for k in range(i,-1,-1):
                    height=i-k+1
                    minWidth=min(minWidth,dp[k][j])
                    area=max(area,height*minWidth)

        return area</code></pre>
<h3 id="409-最长回文串"><a href="#409-最长回文串" class="headerlink" title="409.最长回文串"></a>409.最长回文串</h3><pre><code>链接：https://leetcode-cn.com/problems/longest-palindrome/

给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。

在构造过程中，请注意区分大小写。比如 &quot;Aa&quot; 不能当做一个回文字符串。

注意:
假设字符串的长度不会超过 1010。

示例 1:

输入:
&quot;abccccdd&quot;

输出:
7

解释:
我们可以构造的最长的回文串是&quot;dccaccd&quot;, 它的长度是 7。</code></pre>
<p>题解一|hash：</p>
<p>时间复杂度：O(N)，其中 N 为字符串 s 的长度。我们需要遍历每个字符一次。</p>
<p>空间复杂度：O(S)，其中 S 为字符集大小。</p>
<pre><code>class Solution:
    def longestPalindrome(self, s: str) -&gt; int:
        if not s:
            return 0
        hash=&#123;&#125;
        sum=0
        for each in s:
            if each not in hash:
                hash[each]=1
            else:
                hash[each]+=1
        for key,value in hash.items():
            sum+=value//2*2
            if sum%2==0 and value%2==1:
                sum+=1
        return sum</code></pre>
<pre><code>class Solution:
    def longestPalindrome(self, s):
        ans = 0
        count = collections.Counter(s)
        for v in count.values():
            ans += v // 2 * 2
            if ans % 2 == 0 and v % 2 == 1:
                ans += 1
        return ans</code></pre>
<h3 id="836-矩形重叠"><a href="#836-矩形重叠" class="headerlink" title="836.矩形重叠"></a>836.矩形重叠</h3><pre><code>链接：https://leetcode-cn.com/problems/rectangle-overlap/

矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。

如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。

给出两个矩形，判断它们是否重叠并返回结果。



示例 1：

输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]
输出：true
示例 2：

输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1]
输出：false


提示：

两个矩形 rec1 和 rec2 都以含有四个整数的列表的形式给出。
矩形中的所有坐标都处于 -10^9 和 10^9 之间。
x 轴默认指向右，y 轴默认指向上。
你可以仅考虑矩形是正放的情况。</code></pre>
<p>题解一|检查位置：</p>
<p>思路：如果两个矩形不重叠，那么一个矩形肯定在另一个矩形的四周（即左右上下）</p>
<pre><code>矩形 rec1 在矩形 rec2 的左侧；

矩形 rec1 在矩形 rec2 的右侧；

矩形 rec1 在矩形 rec2 的上方；

矩形 rec1 在矩形 rec2 的下方。

左侧：rec1[2] &lt;= rec2[0]；

右侧：rec1[0] &gt;= rec2[2]；

上方：rec1[1] &gt;= rec2[3]；

下方：rec1[3] &lt;= rec2[1]。</code></pre>
<p>时间复杂度：O(1)<br>空间复杂度：O(1)，不需要额外的空间。</p>
<pre><code>class Solution:
    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -&gt; bool:
        if rec1[0]&gt;=rec2[2] or rec1[1]&gt;=rec2[3]:
            return False
        if rec2[0]&gt;=rec1[2] or rec2[1]&gt;=rec1[3]: # 注意是or，不是and。
            return False
        return True</code></pre>
<pre><code>class Solution:
    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -&gt; bool:
        if rec1[2]&lt;=rec2[0] or rec1[3]&lt;=rec2[1] or rec1[0]&gt;=rec2[2] or rec1[1]&gt;=rec2[3]:
            return False
        else:
            return True</code></pre>
<p>题解二|检查区域：</p>
<p>思路：如果两个矩形重叠，那么它们重叠的区域一定也是一个矩形，那么这代表了两个矩形与 x 轴平行的边（水平边）投影到 x 轴上时会有交集，与 y 轴平行的边（竖直边）投影到 y 轴上时也会有交集。因此，我们可以将问题看作一维线段是否有交集的问题。</p>
<p>矩形 rec1 和 rec2 的水平边投影到 x 轴上的线段分别为 (rec1[0], rec1[2]) 和 (rec2[0], rec2[2])。根据数学知识我们可以知道，当 min(rec1[2], rec2[2]) &gt; max(rec1[0], rec2[0]) 时，这两条线段有交集。对于矩形 rec1 和 rec2 的竖直边投影到 yy 轴上的线段，同理可以得到，当 min(rec1[3], rec2[3]) &gt; max(rec1[1], rec2[1]) 时，这两条线段有交集。（画图）</p>
<p>时间复杂度：O(1)<br>空间复杂度：O(1)，不需要额外的空间。</p>
<pre><code>class Solution:
    def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -&gt; bool:
        def isIntersec(pLeft,pRight,qLeft,qRight):
            return min(pRight,qRight)&gt;max(pLeft,qLeft)
        return isIntersec(rec1[0],rec1[2],rec2[0],rec2[2]) and isIntersec(rec1[1],rec1[3],rec2[1],rec2[3])</code></pre>
<h3 id="1160-拼写单词"><a href="#1160-拼写单词" class="headerlink" title="1160.拼写单词"></a>1160.拼写单词</h3><pre><code>链接：https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters/

给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。

假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。

注意：
    每次拼写时，chars 中的每个字母都只能用一次。
    返回词汇表 words 中你掌握的所有单词的 长度之和。

示例 1：

输入：words = [&quot;cat&quot;,&quot;bt&quot;,&quot;hat&quot;,&quot;tree&quot;], chars = &quot;atach&quot;
输出：6
解释： 
可以形成字符串 &quot;cat&quot; 和 &quot;hat&quot;，所以答案是 3 + 3 = 6。
示例 2：

输入：words = [&quot;hello&quot;,&quot;world&quot;,&quot;leetcode&quot;], chars = &quot;welldonehoneyr&quot;
输出：10
解释：
可以形成字符串 &quot;hello&quot; 和 &quot;world&quot;，所以答案是 5 + 5 = 10。</code></pre>
<p> <br>    提示：<br>    1 &lt;= words.length &lt;= 1000<br>    1 &lt;= words[i].length, chars.length &lt;= 100<br>    所有字符串中都仅包含小写英文字母</p>
<p>题解一（hash）：</p>
<p>思路：对于一个单词 word，只要其中的每个字母的数量都不大于 chars 中对应的字母的数量，那么就可以用 chars 中的字母拼写出 word。所以我们只需要用一个哈希表存储 chars 中每个字母的数量，再用一个哈希表存储 word 中每个字母的数量，最后将这两个哈希表的键值对逐一进行比较即可。</p>
<p>时间复杂度：O(n)，其中 n 为所有字符串的长度和。我们需要遍历每个字符串，包括 chars 以及数组 words 中的每个单词。</p>
<p>空间复杂度：O(S)，其中 S 为字符集大小，在本题中 S 的值为 26（所有字符串仅包含小写字母）。程序运行过程中，最多同时存在两个哈希表，使用的空间均不超过字符集大小 S，因此空间复杂度为 O(S)。</p>
<pre><code>class Solution:
    def countCharacters(self, words: List[str], chars: str) -&gt; int:
        from collections import Counter
        hashChars=&#123;&#125;
        hashWords=&#123;&#125;
        hashChars=Counter(chars)
        res=0
        # print(hashChars)
        for word in words:
            hashWords=Counter(word)
            # print(hashWords)
            for key in hashWords:
                if hashChars[key] &lt; hashWords[key]:
                    break 
            else:
                res+=len(word)
        return res</code></pre>
<pre><code>class Solution:
    def countCharacters(self, words: List[str], chars: str) -&gt; int:
        res=0
        hash1=&#123;&#125;
        for each in chars:
            if each not in hash1:
                hash1[each]=1
            else:
                hash1[each]+=1
        for word in words:
            hash2=&#123;&#125;
            for w in word:
                if w not in hash2:
                    hash2[w]=1
                else:
                    hash2[w]+=1
            for key in hash2:
                if hash2.get(key,0) &gt; hash1.get(key,0):
                    break
            else:
                res+=len(word)
        return res</code></pre>
<p>for-else用法：</p>
<pre><code>如果for循环正常结束，else中语句执行；
如果for循环是break退出的，则else中语句不执行；</code></pre>
<pre><code>for i in range(5):
    print(i)
else:
    print(&#39;hello&#39;)

for i in range(5):
    print(i)
    if i==2:
        break
else:
    print(&#39;hello&#39;)

输出：
0
1
2
3
4
hello
------------
0
1
2</code></pre>
<p>题解二|hash：</p>
<pre><code>dict.get(key, default=None)
key -- 字典中要查找的键。
default -- 如果指定键的值不存在时，返回该默认值。</code></pre>
<pre><code>class Solution:
    def countCharacters(self, words: List[str], chars: str) -&gt; int:
        res=&#39;&#39;
        for word in words:
            hash=&#123;&#125;
            for i in range(len(chars)):
                hash[chars[i]]=hash.get(chars[i],0)+1
            count=0
            for w in word:
                if hash.get(w,0)&gt;=1:
                    hash[w]=hash.get(w,0)-1
                    count+=1
                else:
                    break
            if count == len(word):
                res+=word
        return len(res)</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Lilly</p>
  <div class="site-description" itemprop="description">Up in the wind!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">133</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lilly</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
