<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"gongyanli.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Up in the wind!">
<meta property="og:type" content="website">
<meta property="og:title" content="茉莉Python">
<meta property="og:url" content="http://gongyanli.com/page/6/index.html">
<meta property="og:site_name" content="茉莉Python">
<meta property="og:description" content="Up in the wind!">
<meta property="og:locale">
<meta property="article:author" content="Lilly">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://gongyanli.com/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>茉莉Python</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">茉莉Python</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">voidqueens@hotmail.com</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/python%E5%B9%B6%E5%8F%91-3-%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/python%E5%B9%B6%E5%8F%91-3-%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" class="post-title-link" itemprop="url">python并发-3.线程生命周期</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-21 21:01:44" itemprop="dateCreated datePublished" datetime="2020-02-21T21:01:44+08:00">2020-02-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-18 14:03:21" itemprop="dateModified" datetime="2020-09-18T14:03:21+08:00">2020-09-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/Python%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">Python并发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>当程序中包含多个线程时，CPU 不会一直被特定的线程霸占，而是轮流执行各个线程。</p>
<p>CPU 在轮换执行线程过程中，线程都经历了什么呢？线程从创建到消亡的整个过程，可能会历经 5 种状态，分别是新建、就绪、运行、阻塞和死亡。</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/thread1.gif" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/thread1.gif"></p>
<h2 id="一、新建和就绪"><a href="#一、新建和就绪" class="headerlink" title="一、新建和就绪"></a>一、新建和就绪</h2><p>无论是通过 Thread 类直接实例化对象创建线程，还是通过继承自 Thread 类的子类实例化创建线程，新创建的线程在调用 start() 方法之前，不会得到执行，此阶段的线程就处于新建状态。</p>
<p>所以，只有当线程刚刚创建，且未调用 start() 方法时，该线程才处于新建状态，而一旦线程调用 start() 方法之后，线程将无法再回到新建状态。</p>
<p>当位于新建状态的线程调用 start() 方法后，该线程就转换到就绪状态。所谓就绪，就是告诉 CPU，该线程已经可以执行了，但是具体什么时候执行，取决于 CPU 什么时候调度它。换句话说，如果一个线程处于就绪状态，只能说明此线程已经做好了准备，随时等待 CPU 调度执行，并不是说执行了 start() 方法此线程就会立即被执行。</p>
<p>注意：start() 方法只能由处于新建状态的线程调用，而一旦调用 start() 方法，线程状态就会由新建状态转为就绪状态。所以，每一个线程最多只能调用一次 start() 方法。如果多次调用，则 Python 解释器将抛出 RuntimeError 异常。</p>
<p>线程由新建状态转到就绪状态，只有一个办法，就是调用 start() 方法。<br>直接调用 Thread 类构造方法中 target 参数指定的函数，或者直接调用 Thread 子类中的 run() 实例方法，不可以吗？当然不可以，这 2 种方法是可以执行目标代码，但是由主线程 MianThread 负责执行，而不是由新创建的子线程负责执行。</p>
<p>一方面 Python解释器会将它们看做是普通的函数调用和类方法调用。另一方面，由于新建的线程属于新建状态而不是就绪状态，因此不会得到 CPU 的调度。</p>
<h2 id="二、运行和阻塞"><a href="#二、运行和阻塞" class="headerlink" title="二、运行和阻塞"></a>二、运行和阻塞</h2><p>当位于就绪状态的线程得到了 CPU，并开始执行 target 参数执行的目标函数或者 run() 方法，就表明当前线程处于运行状态。</p>
<p>如果当前有多个线程处于就绪状态（等待 CPU 调度）时，处于运行状态的线程将无法一直霸占 CPU 资源，为了使其它线程也有执行的机会，CPU 会在一定时间内强制当前运行的线程让出 CPU 资源，以供其他线程使用。而对于获得 CPU 调度却没有执行完毕的线程，就会进入阻塞状态。</p>
<p>目前几乎所有的桌面和服务器操作系统，都采用的是抢占式优先级调度策略。即 CPU 会给每一个就绪线程一段固定时间来处理任务，当该时间用完后，系统就会阻止该线程继续使用 CPU 资源，让其他线程获得执行的机会。而对于具体选择那个线程上 CPU，不同的平台采用不同的算法，比如先进先出算法（FIFO）、时间片轮转算法、优先级算法等，每种算法各有优缺点，适用于不同的场景。</p>
<p>如果处于运行状态的线程发生如下几种情况，也将会由运行状态转到阻塞状态：</p>
<pre><code>线程调用了 sleep() 方法；
线程等待接收用户输入的数据；
线程试图获取某个对象的同步锁（后续章节会详细讲解）时，如果该锁被其他线程所持有，则当前线程进入阻塞状态；
线程调用 wait() 方法，等待特定条件的满足；</code></pre>
<p>以上 4 种可能发生线程阻塞的情况，解决措施分别如下：</p>
<pre><code>sleep() 方法规定的时间已过；
线程接收到了用户输入的数据；
其他线程释放了该同步锁，并由该线程获得；
调用 set() 方法发出通知；</code></pre>
<h2 id="三、死亡"><a href="#三、死亡" class="headerlink" title="三、死亡"></a>三、死亡</h2><p>对于获得 CPU 调度却未执行完毕的线程，它会转入阻塞状态，待条件成熟之后继续转入就绪状态，重复争取 CPU 资源，直到其执行结束。执行结束的线程将处于死亡状态。</p>
<p>线程执行结束，除了正常执行结束外，如果程序执行过程发生异常（Exception）或者错误（Error），线程也会进入死亡状态。</p>
<p>对于处于死亡状态的线程，有以下 2 点需要注意：</p>
<pre><code>主线程死亡，并不意味着所有线程全部死亡。也就是说，主线程的死亡，不会影响子线程继续执行；反之也是如此。

对于死亡的线程，无法再调用 start() 方法使其重新启动，否则 Python 解释器将抛出 RuntimeError 异常。</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/python%E5%B9%B6%E5%8F%91-1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/python%E5%B9%B6%E5%8F%91-1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">python并发-1.进程和线程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-21 11:29:02" itemprop="dateCreated datePublished" datetime="2020-02-21T11:29:02+08:00">2020-02-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-18 14:02:29" itemprop="dateModified" datetime="2020-09-18T14:02:29+08:00">2020-09-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/Python%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">Python并发</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、并发与并行"><a href="#一、并发与并行" class="headerlink" title="一、并发与并行"></a>一、并发与并行</h2><p>区别：</p>
<pre><code>并发和并行是两个概念，并行指在同一时刻有多条指令在多个处理器上同时执行；
并发是指在同一时刻只能有一条指令执行，但多个进程指令被快速轮换执行，使得在宏观上具有多个进程同时执行的效果。</code></pre>
<p>对于一个 CPU 而言，在某个时间点它只能执行一个程序。也就是说，只能运行一个进程，CPU 不断地在这些进程之间轮换执行。那么，为什么用户感觉不到任何中断呢？</p>
<p>这是因为相对人的感觉来说，CPU 的执行速度太快了（如果启动的程序足够多，则用户依然可以感觉到程序的运行速度下降了）。所以，虽然 CPU 在多个进程之间轮换执行，但用户感觉到好像有多个进程在同时执行。</p>
<h2 id="二、线程和多线程"><a href="#二、线程和多线程" class="headerlink" title="二、线程和多线程"></a>二、线程和多线程</h2><p>线程 是可以在操作系统中执行的最小执行单元。它本身不是一个程序，而是在一个程序中运行。换句话说，线程不是彼此独立的。每个线程与其他线程共享代码段，数据段等。它们也被称为轻量级过程。</p>
<p>线程组成 ：</p>
<pre><code>程序计数器，包含下一个可执行指令的地址
堆
寄存器集
一唯一的id</code></pre>
<p>多线程 是CPU通过并发执行多个线程来管理操作系统使用的能力。多线程的主要思想是通过将进程划分为多个线程来实现并行性。</p>
<p>一个进程只能有一个线程，称为主线程，或者多个线程有自己的寄存器，程序计数器和堆栈。</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/thread.jpg" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/thread.jpg"></p>
<p>进程和线程的关系是这样的：操作系统可以同时执行多个任务，每一个任务就是一个进程，进程可以同时执行多个任务，每一个任务就是一个线程。</p>
<p>线程是进程的组成部分，一个进程可以拥有多个线程。在多线程中，会有一个主线程来完成整个进程从开始到结束的全部操作，而其他的线程会在主线程的运行过程中被创建或退出。</p>
<p>当进程被初始化后，主线程就被创建了，对于绝大多数的应用程序来说，通常仅要求有一个主线程，但也可以在进程内创建多个顺序执行流，这些顺序执行流就是线程。<br>当一个进程里只有一个线程时，叫作单线程。超过一个线程就叫作多线程。</p>
<p>每个线程必须有自己的父进程，且它可以拥有自己的堆栈、程序计数器和局部变量，但不拥有系统资源，因为它和父进程的其他线程共享该进程所拥有的全部资源。线程可以完成一定的任务，可以与其他线程共享父进程中的共享变量及部分环境，相互之间协同完成进程所要完成的任务。<br>多个线程共享父进程里的全部资源，会使得编程更加方便，需要注意的是，要确保线程不会妨碍同一进程中的其他线程。</p>
<p>线程是独立运行的，它并不知道进程中是否还有其他线程存在。线程的运行是抢占式的，也就是说，当前运行的线程在任何时候都可能被挂起，以便另外一个线程可以运行。<br>多线程也是并发执行的，即同一时刻，Python 主程序只允许有一个线程执行，这和全局解释器锁有关系，后续会做详细介绍。</p>
<p>一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发运行。</p>
<p>从逻辑的角度来看，多线程存在于一个应用程序中，让一个应用程序可以有多个执行部分同时执行，但操作系统无须将多个线程看作多个独立的应用，对多线程实现调度和管理以及资源分配，线程的调度和管理由进程本身负责完成。</p>
<p>python并发编程有用api：线程，并发功能，多处理，asyncio，gevent和greenlets</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/LeetCode-11-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/LeetCode-11-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" class="post-title-link" itemprop="url">LeetCode-11-滑动窗口</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-19 21:23:58" itemprop="dateCreated datePublished" datetime="2020-02-19T21:23:58+08:00">2020-02-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-03 21:16:50" itemprop="dateModified" datetime="2021-01-03T21:16:50+08:00">2021-01-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="十一、滑动窗口"><a href="#十一、滑动窗口" class="headerlink" title="十一、滑动窗口"></a>十一、滑动窗口</h2><h3 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3.无重复字符的最长子串"></a>3.无重复字符的最长子串</h3><pre><code>链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/

给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

示例 1:

输入: &quot;abcabcbb&quot;
输出: 3 
解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。
示例 2:

输入: &quot;bbbbb&quot;
输出: 1
解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。
示例 3:

输入: &quot;pwwkew&quot;
输出: 3
解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</code></pre>
<p>题解一|暴力破解：<br>时间复杂度O(n^3)</p>
<pre><code>class Solution:
    def lengthOfLongestSubstring(self, s: str) -&gt; int:
        length=len(s)

        if s == &#39;&#39;:
            return 0
        ans=1

        for i in range(length):
            for j in range(i+1,length):  
                if s[i] != s[j]:
                    # print(i,j)
                    # print(s[i:j+1])
                    if self.isUnique(s[i:j+1]):
                        ans=max(ans,len(s[i:j+1]))
        return ans

    def isUnique(self,s):
        for i in range(len(s)):
            if s[i] in s[i+1:]:
                return False
        return True</code></pre>
<p>输出：</p>
<pre><code>0 1
ha
0 3
haha
1 2
ah
2 3
ha</code></pre>
<p>题解二|滑动窗口|万能模版：</p>
<pre><code>class Solution:
    def lengthOfLongestSubstring(self, s: str) -&gt; int:
        from collections import defaultdict
        lookup=defaultdict(int) # 使用int的话，默认值变为0
        left,right=0,0
        res=0
        count=0
        while right &lt; len(s):
            if lookup[s[right]]&gt;0:
                count+=1
            lookup[s[right]]+=1
            right+=1
            while count &gt; 0:
                if lookup[s[left]]&gt;1:
                    count-=1
                lookup[s[left]]-=1
                left+=1
            res=max(res,right-left)
        return res</code></pre>
<p>题解二|滑动窗口：</p>
<pre><code>我们使用两个指针表示字符串中的某个子串的左右边界，其中左指针代表着上文中「枚举子串的起始位置」，而右指针即为上文中的 right；

在每一步的操作中，我们会将左指针向右移动一格，表示我们开始枚举下一个字符作为起始位置，然后我们可以不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着以左指针开始的，不包含重复字符的最长子串。我们记录下这个子串的长度；

在枚举结束后，我们找到的最长的子串的长度即为答案。</code></pre>
<p>时间复杂度：O(N)，其中 N 是字符串的长度。左指针和右指针分别会遍历整个字符串一次。<br>空间复杂度：O(∣Σ∣)</p>
<pre><code>class Solution:
    def lengthOfLongestSubstring(self, s):
        &quot;&quot;&quot;
        :type s: str
        :rtype: int
        &quot;&quot;&quot;
        occ=set()
        n=len(s)
        right,ans=-1,0
        for i in range(n):
            if i!=0:
                occ.remove(s[i-1])
            while right+1&lt;n and s[right+1] not in occ:
                occ.add(s[right+1])
                right+=1
            ans=max(ans,right-i+1)
        return ans</code></pre>
<pre><code>class Solution:
    def lengthOfLongestSubstring(self, s: str) -&gt; int:
        if s is None:
            return 0
        maxLen=0
        curLen=0
        left=0
        lookup=set()
        for i in range(len(s)):
            curLen+=1
            while s[i] in lookup: # 注意此处是while，如果s[i]在lookup里，会一直循环
                print(left,i,s[left],lookup)
                lookup.remove(s[left]) # set是无序无排列的，注意是s[left]
                left+=1
                curLen-=1
            maxLen=max(maxLen,curLen)
            lookup.add(s[i])
        return maxLen</code></pre>
<p>输入：”abcabcbb”<br>输出：</p>
<pre><code>0 3 a &#123;&#39;c&#39;, &#39;a&#39;, &#39;b&#39;&#125;
1 4 b &#123;&#39;c&#39;, &#39;a&#39;, &#39;b&#39;&#125;
2 5 c &#123;&#39;c&#39;, &#39;a&#39;, &#39;b&#39;&#125;
3 6 a &#123;&#39;c&#39;, &#39;a&#39;, &#39;b&#39;&#125;
4 6 b &#123;&#39;c&#39;, &#39;b&#39;&#125;
5 7 c &#123;&#39;c&#39;, &#39;b&#39;&#125;
6 7 b &#123;&#39;b&#39;&#125;

</code></pre>
<h3 id="28-实现-strStr"><a href="#28-实现-strStr" class="headerlink" title="28. 实现 strStr()"></a>28. 实现 strStr()</h3><pre><code>链接：https://leetcode-cn.com/problems/implement-strstr/

实现 strStr() 函数。

给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。

示例 1:

输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;
输出: 2
示例 2:

输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;
输出: -1
说明:

当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</code></pre>
<p>题解一|子串逐一比较|线性时间复杂度：</p>
<p>思路：沿着字符换逐步移动滑动窗口，将窗口内的子串与 needle 字符串比较。</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/str1.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/str1.png"></p>
<p>时间复杂度：O((N - L)L)，其中 N 为 haystack 字符串的长度，L 为 needle 字符串的长度。内循环中比较字符串的复杂度为 L，总共需要比较 (N - L) 次。<br>空间复杂度：O(1)</p>
<pre><code>class Solution:
    def strStr(self, haystack: str, needle: str) -&gt; int:
        n,length=len(haystack),len(needle)
        for i in range(n-length+1):
            if haystack[i:i+length]==needle:
                return i
        return -1</code></pre>
<p>题解二|双指针:</p>
<p>题解一的缺陷是会将 haystack 所有长度为 L 的子串都与 needle 字符串比较，实际上是不需要这么做的。</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/str.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/str.png"></p>
<pre><code>首先，只有子串的第一个字符跟 needle 字符串第一个字符相同的时候才需要比较。

其次，可以一个字符一个字符比较，一旦不匹配了就立刻终止。

比较到最后一位时发现不匹配，这时候开始回溯。需要注意的是，pn 指针是移动到 pn = pn - curr_len + 1 的位置，而 不是 pn = pn - curr_len 的位置。

这时候再比较一次，就找到了完整匹配的子串，直接返回子串的开始位置 pn - L。</code></pre>
<p>思路：</p>
<pre><code>移动 pn 指针，直到 pn 所指向位置的字符与 needle 字符串第一个字符相等。

通过 pn，pL，curr_len 计算匹配长度。

如果完全匹配（即 curr_len == L），返回匹配子串的起始坐标（即 pn - L）。

如果不完全匹配，回溯。使 pn = pn - curr_len + 1， pL = 0， curr_len = 0。</code></pre>
<p>时间复杂度：最坏时间复杂度为 O((N - L)L)，最优时间复杂度为 O(N)。<br>空间复杂度：O(1)</p>
<pre><code>class Solution:
    def strStr(self, haystack: str, needle: str) -&gt; int:
        m,n=len(haystack),len(needle)
        if n==0:
            return 0
        p1=0
        while p1&lt;m-n+1:
            while p1&lt;m-n+1 and haystack[p1] != needle[0]:
                p1+=1
            curr=p2=0
            while p1&lt;m and p2&lt;n and haystack[p1]==needle[p2]:
                p1+=1
                p2+=1
                curr+=1
            if curr==n:
                return p1-n
            p1=p1-curr+1
        return -1</code></pre>
<p>？？？题解三|KMP：<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-strstr/solution/kmphua-48xiao-shi-kan-dong-liao-kmpxiang-rang-ni-z/">https://leetcode-cn.com/problems/implement-strstr/solution/kmphua-48xiao-shi-kan-dong-liao-kmpxiang-rang-ni-z/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Px411z7Yo?from=search&amp;seid=13225444196686531503">https://www.bilibili.com/video/BV1Px411z7Yo?from=search&amp;seid=13225444196686531503</a><br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1hW411a7ys/?spm_id_from=333.788.videocard.0">https://www.bilibili.com/video/BV1hW411a7ys/?spm_id_from=333.788.videocard.0</a></p>
<pre><code>class Solution:
    def strStr(self, haystack: str, needle: str) -&gt; int:
        if not needle:
            return 0
        next=self.getNext(needle)
        i=j=0
        while i&lt;len(haystack) and j&lt;len(needle):
            if j==-1 or haystack[i]==needle[j]:
                i+=1
                j+=1
            else:
                j=next[j]
        if j==len(needle):
            return i-j
        else:
            return -1
    def getNext(self,needle):
        next=[0]*len(needle)
        next[0]=-1
        # print(next)
        i=0
        j=-1
        while i&lt;len(needle)-1:
            if j==-1 or needle[i]==needle[j]:
                i+=1
                j+=1
                next[i]=j
            else:
                j=next[j]
        return next</code></pre>
<p>题解四：</p>
<pre><code>class Solution:
    def strStr(self, haystack: str, needle: str) -&gt; int:
        i=haystack.find(needle)
        return i</code></pre>
<h3 id="30-串联所有单词的子串"><a href="#30-串联所有单词的子串" class="headerlink" title="30. 串联所有单词的子串"></a>30. 串联所有单词的子串</h3><pre><code>链接：https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/

给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。

注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。

示例 1：

输入：
  s = &quot;barfoothefoobarman&quot;,
  words = [&quot;foo&quot;,&quot;bar&quot;]
输出：[0,9]
解释：
从索引 0 和 9 开始的子串分别是 &quot;barfoo&quot; 和 &quot;foobar&quot; 。
输出的顺序不重要, [9,0] 也是有效答案。
示例 2：

输入：
  s = &quot;wordgoodgoodgoodbestword&quot;,
  words = [&quot;word&quot;,&quot;good&quot;,&quot;best&quot;,&quot;word&quot;]
输出：[]</code></pre>
<p>题解一|逐字母前进：</p>
<pre><code>时间复杂度：O(m*n)</code></pre>
<pre><code>class Solution:
    def findSubstring(self, s: str, words: List[str]) -&gt; List[int]:
        ans=[]
        if not s or not words:
            return ans

        word_hash=&#123;&#125;
        for each in words:
            word_hash[each]=word_hash.get(each,0)+1

        s_len,w_len=len(s),len(words[0])
        n=w_len * len(words) # 符合要求的子串长度

        for i in range(s_len-n+1):
            res_hash=word_hash.copy()
            j=i+w_len
            while s[j-w_len:j] in res_hash and res_hash[s[j-w_len:j]]&gt;0:
                res_hash[s[j-w_len:j]]-=1
                j+=w_len
            if sum(res_hash.values())==0:
                ans.append(i)
        return ans</code></pre>
<pre><code>class Solution:
    def findSubstring(self, s: str, words: List[str]) -&gt; List[int]:
        ans=[]
        if not s or not words:
            return ans

        word_hash=&#123;&#125;
        for each in words:
            word_hash[each]=word_hash.get(each,0)+1

        s_len,w_len=len(s),len(words[0])
        n=w_len * len(words) # 符合要求的子串长度

        for i in range(s_len-n+1):
            tmp=s[i:i+n]
            res_hash=&#123;&#125;
            for j in range(0,n,w_len):
                res_hash[tmp[j:j+w_len]]=res_hash.get(tmp[j:j+w_len],0)+1
            if word_hash==res_hash:
                ans.append(i)
        return ans</code></pre>
<p>题解二|逐单词前进</p>
<pre><code>class Solution:
    def findSubstring(self, s: str, words: List[str]) -&gt; List[int]:
        ans=[]
        if not words:
            return ans

        word_hash=&#123;&#125;
        for each in words:
            word_hash[each]=word_hash.get(each,0)+1

        s_len,w_len=len(s),len(words[0])
        n=w_len * len(words) # 符合要求的子串长度

        for offset in range(w_len):
            tmp_hash=&#123;&#125;
            for i in range(offset,offset+n-w_len,w_len):
                tmp_hash[s[i:i+w_len]]=tmp_hash.get(s[i:i+w_len],0)+1
            for begin in range(offset,s_len-n+1,w_len):
                tmp_hash[s[begin+n-w_len:begin+n]]=tmp_hash.get(s[begin+n-w_len:begin+n],0)+1
                if tmp_hash==word_hash:
                    ans.append(begin)
                tmp_hash[s[begin:begin+w_len]]-=1
                if tmp_hash[s[begin:begin+w_len]]==0:
                    del tmp_hash[s[begin:begin+w_len]]
        return ans
</code></pre>
<pre><code>class Solution:
    def findSubstring(self, s: str, words: List[str]) -&gt; List[int]:
        from collections import Counter
        ans=[]
        if not s or not words:
            return ans

        word_hash=Counter(words)

        s_len,w_len=len(s),len(words[0])
        n=w_len * len(words) # 符合要求的子串长度

        for i in range(w_len):
            cnt=0
            left,right=i,i
            cur_hash=Counter()
            while right+w_len &lt;= s_len:
                each=s[right:right+w_len]
                right+=w_len
                cur_hash[each]+=1
                cnt+=1
                print(cur_hash)
                while cur_hash[each] &gt; word_hash[each]:
                    tmp=s[left:left+w_len]
                    left+=w_len
                    cur_hash[tmp]-=1
                    cnt-=1
                if cnt==len(words):
                    ans.append(left)
        return ans</code></pre>
<p>优化：</p>
<pre><code>class Solution:
    def findSubstring(self, s: str, words: List[str]) -&gt; List[int]:
        from collections import Counter
        ans=[]
        if not s or not words:
            return ans

        word_hash=Counter(words)

        s_len,w_len=len(s),len(words[0])
        n=w_len * len(words) # 符合要求的子串长度

        for i in range(w_len):
            cnt=0
            left,right=i,i
            cur_hash=Counter()
            while right+w_len &lt;= s_len:
                each=s[right:right+w_len]
                right+=w_len
                if each not in words:
                    left=right
                    cur_hash.clear()
                    cnt=0
                else:
                    cur_hash[each]+=1
                    cnt+=1
                    while cur_hash[each] &gt; word_hash[each]:
                        tmp=s[left:left+w_len]
                        left+=w_len
                        cur_hash[tmp]-=1
                        cnt-=1
                    if cnt==len(words):
                        ans.append(left)
        return ans</code></pre>
<h3 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76.最小覆盖子串"></a>76.最小覆盖子串</h3><pre><code>链接：https://leetcode-cn.com/problems/minimum-window-substring/

给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字母的最小子串。

示例：

输入: S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot;
输出: &quot;BANC&quot;
说明：

如果 S 中不存这样的子串，则返回空字符串 &quot;&quot;。
如果 S 中存在这样的子串，我们保证它是唯一的答案。</code></pre>
<p>题解一|滑动窗口|万能模版：</p>
<pre><code>class Solution:
    def minWindow(self, s: str, t: str) -&gt; str:
        from collections import defaultdict
        lookup=defaultdict(int)
        for each in t:
            lookup[each]+=1
        left,right=0,0
        count=len(t)
        min_len=float(&#39;inf&#39;)
        res=&#39;&#39;

        while right&lt;len(s):
            if lookup[s[right]]&gt;0:
                count-=1
            lookup[s[right]]-=1
            right+=1
            while count==0:
                if min_len&gt;right-left:
                    min_len=right-left
                    res=s[left:right]
                if lookup[s[left]]==0:
                    count+=1
                lookup[s[left]]+=1
                left+=1
        return res
</code></pre>
<p>题解一|滑动窗口：</p>
<pre><code>保证窗口(队列)字符串含有t中字符的个数大于等于t里相应元素个数</code></pre>
<pre><code>class Solution:
    def minWindow(self, s: str, t: str) -&gt; str:
        from collections import Counter
        t=Counter(t)
        lookup=Counter()
        start,end=0,0
        minLen=float(&#39;inf&#39;)
        res=&#39;&#39;
        while end &lt; len(s):
            lookup[s[end]]+=1
            end+=1
            while all(map(lambda x:lookup[x] &gt;= t[x],t.keys())):
                # print(lookup)
                if end-start &lt; minLen:
                    res=s[start:end]
                    minLen=end-start
                lookup[s[start]]-=1
                start+=1
        return res</code></pre>
<pre><code>记录队列元素和t中元素的差值</code></pre>
<pre><code>class Solution:
    def minWindow(self, s: str, t: str) -&gt; str:
        from collections import defaultdict
        lookup=defaultdict(int)
        for each in t:
            lookup[each]+=1
        start,end=0,0
        minLen=float(&#39;inf&#39;)
        counter=len(t)
        res=&#39;&#39;
        while end &lt; len(s):
            if lookup[s[end]] &gt; 0:
                counter-=1
            lookup[s[end]]-=1
            end+=1
            while counter==0:
                if minLen&gt; end-start:
                    minLen=end-start
                    res=s[start:end]
                if lookup[s[start]]==0:
                    counter+=1
                lookup[s[start]]+=1
                start+=1
        return res
</code></pre>
<h3 id="159-至多包含两个不同字符的最长子串"><a href="#159-至多包含两个不同字符的最长子串" class="headerlink" title="159. 至多包含两个不同字符的最长子串"></a>159. 至多包含两个不同字符的最长子串</h3><pre><code>给定一个字符串 s ，找出 至多 包含两个不同字符的最长子串 t 。

示例 1:

输入: &quot;eceba&quot;
输出: 3
解释: t 是 &quot;ece&quot;，长度为3。
1
2
3
示例 2:

输入: &quot;ccaabbb&quot;
输出: 5
解释: t 是 &quot;aabbb&quot;，长度为5。</code></pre>
<p>题解一|滑动窗口|万能模版：</p>
<pre><code>class Solution:
    def lengthOfLongestSubstringTwoDistinct(self, s: str) -&gt; int:
        from collections import defaultdict
        lookup=defaultdict(int)
        left,right=0,0
        res=0
        count=0
        while right&lt;len(s):
            if lookup[s[right]]==0:
                count+=1
            lookup[s[right]]+=1
            right+=1
            while count&gt;2:
                if lookup[s[left]]==1:
                    count-=1
                lookup[s[left]]-=1
                left+=1
            res=max(res,right-left)
            return res</code></pre>
<h3 id="340-至多包含-K-个不同字符的最长子串"><a href="#340-至多包含-K-个不同字符的最长子串" class="headerlink" title="340. 至多包含 K 个不同字符的最长子串"></a>340. 至多包含 K 个不同字符的最长子串</h3><pre><code>给定一个字符串 s ，找出 至多 包含 k 个不同字符的最长子串 T。

示例1：

输入: s = &quot;eceba&quot;, k = 2
输出: 3
解释: 则 T 为 &quot;ece&quot;，所以长度为 3。</code></pre>
<p>题解一|滑动窗口|万能模版：</p>
<pre><code>class Solution:
    def lengthOfLongestSubstringKDistinct(self, s: str, k: int) -&gt; int:
        from collections import defaultdict
        lookup=defaultdict(int)
        left,right=0,0
        res=0
        count=0
        while right &lt; len(s):
            lookup[s[right]]==0:
                count+=1
            lookup[s[right]]+=1
            right+=1
            while count &gt; k:
                if lookup[s[left]]==1:
                    count-=1
                lookup[s[left]]-=1
                left+=1
            res=max(res,right-left)
        return res</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/TensorFlow-6-TensorBoard/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/TensorFlow-6-TensorBoard/" class="post-title-link" itemprop="url">TensorFlow-6.TensorBoard</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-18 23:40:54" itemprop="dateCreated datePublished" datetime="2020-02-18T23:40:54+08:00">2020-02-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-18 21:13:55" itemprop="dateModified" datetime="2020-09-18T21:13:55+08:00">2020-09-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习和深度学习</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/TensorFlow/" itemprop="url" rel="index"><span itemprop="name">TensorFlow</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>TensorFlow 使用 TensorBoard 来提供计算图形的图形图像。这使得理解、调试和优化复杂的神经网络程序变得很方便。TensorBoard 也可以提供有关网络执行的量化指标。它读取 TensorFlow 事件文件，其中包含运行 TensorFlow 会话期间生成的摘要数据。</p>
<h2 id="一、步骤"><a href="#一、步骤" class="headerlink" title="一、步骤"></a>一、步骤</h2><pre><code>确定想要的 OP 摘要
loss=tf...

tf.summary.scalar(&#39;loss&#39;,loss)

tf.summary.histogram 可视化梯度、权重或特定层的输出分布</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/TensorFlow-5-%E7%9F%A9%E9%98%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/TensorFlow-5-%E7%9F%A9%E9%98%B5/" class="post-title-link" itemprop="url">TensorFlow-5.矩阵</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-18 23:19:19" itemprop="dateCreated datePublished" datetime="2020-02-18T23:19:19+08:00">2020-02-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-18 21:13:51" itemprop="dateModified" datetime="2020-09-18T21:13:51+08:00">2020-09-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习和深度学习</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/TensorFlow/" itemprop="url" rel="index"><span itemprop="name">TensorFlow</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>代码：4-matrix.ipynb</p>
<p>矩阵运算，例如执行乘法、加法和减法，是任何神经网络中信号传播的重要操作。通常在计算中需要随机矩阵、零矩阵、一矩阵或者单位矩阵。</p>
<p>所有加法、减、除、乘（按元素相乘）、取余等矩阵的算术运算都要求两个张量矩阵是相同的数据类型，否则就会产生错误。</p>
<p>可以使用 tf.cast() 将张量从一种数据类型转换为另一种数据类型。</p>
<p>如果在整数张量之间进行除法，最好使用 tf.truediv(a，b)，因为它首先将整数张量转换为浮点类，然后再执行按位相除。</p>
<pre><code>import tensorflow as tf

m1=tf.eye(5)
m2=tf.Variable(tf.eye(10))
m3=tf.Variable(tf.random.normal([5,10]))
m4=tf.matmul(m3,m2)
m5=tf.Variable(tf.random.uniform([5,10],0,2,dtype=tf.int32))
m6=tf.cast(m5,dtype=tf.float32)
m7=tf.add(m1,tf.ones(5))
m8=m1-tf.ones(5)</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/TensorFlow-4-%E5%B8%B8%E9%87%8F%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%8D%A0%E4%BD%8D%E7%AC%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/TensorFlow-4-%E5%B8%B8%E9%87%8F%E3%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E5%8D%A0%E4%BD%8D%E7%AC%A6/" class="post-title-link" itemprop="url">TensorFlow-4.常量、变量和占位符</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-18 21:42:33" itemprop="dateCreated datePublished" datetime="2020-02-18T21:42:33+08:00">2020-02-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-18 21:16:27" itemprop="dateModified" datetime="2020-09-18T21:16:27+08:00">2020-09-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习和深度学习</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/TensorFlow/" itemprop="url" rel="index"><span itemprop="name">TensorFlow</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>文档：<a target="_blank" rel="noopener" href="https://www.tensorflow.org/api_docs/python/">https://www.tensorflow.org/api_docs/python/</a><br>代码：3-var.ipynb</p>
<p>张量，可理解为一个 n 维矩阵，所有类型的数据，包括标量、矢量和矩阵等都是特殊类型的张量。</p>
<p>TensorFlow 支持以下三种类型的张量：</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/tensor.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/tensor.png"></p>
<p>1、常量：常量是其值不能改变的张量。</p>
<p>2、变量：当一个量在会话中的值需要更新时，使用变量来表示。例如，在神经网络中，权重需要在训练期间更新，可以通过将权重声明为变量来实现。变量在使用前需要被显示初始化。另外需要注意的是，常量存储在计算图的定义中，每次加载图时都会加载相关变量。换句话说，它们是占用内存的。另一方面，变量又是分开存储的。它们可以存储在参数服务器上。</p>
<p>3、占位符：用于将值输入 TensorFlow 图中。它们可以和 feed_dict 一起使用来输入数据。在训练神经网络时，它们通常用于提供新的训练样本。在会话中运行计算图时，可以为占位符赋值。这样在构建一个计算图时不需要真正地输入数据。需要注意的是，占位符不包含任何数据，因此不需要初始化它们。</p>
<h2 id="一、常量"><a href="#一、常量" class="headerlink" title="一、常量"></a>一、常量</h2><pre><code>import tensorflow as tf

t1=tf.constant(4)
t2=tf.constant([1,2,3])

# tf.zeros([M,N],tf.dtype)
# 创建一个形如 [M，N] 的零元素矩阵，数据类型（dtype）可以是 int32、float32 等
t3=tf.zeros([2,3],tf.int32)

t4=tf.zeros_like(t2)
t5=tf.ones_like(t2)

# 创建一个所有元素都设为 1 的张量
# tf.ones([M,N],tf.dtype)
t6=tf.ones([2,3],tf.int32)

# 在一定范围内生成一个从初值到终值等差排布的序列：tf.linspace(start,stop,num)
# 相应的值为 (stop-start)/(num-1)
t7=tf.linspace(2.0,5.0,5)

# 从开始（默认值=0）生成一个数字序列，增量为 delta（默认值=1），直到终值（但不包括终值）：tf.range(start,limit,delta)
t8=tf.range(10)



# TensorFlow 允许创建具有不同分布的随机张量：
# 1.使用以下语句创建一个具有一定均值（默认值=0.0）和标准差（默认值=1.0）、形状为 [M，N] 的正态分布随机数组：
# t9=tf.random_normal([2,3],mead=2.0,stddev=4.0,seed=12)
t9=tf.random.normal([2,3],mean=2.0,stddev=4.0,seed=12) # 2.0语法

# 参数:
# shape: 一维的张量，也是输出的张量。
# mean: 正态分布的均值。
# stddev: 正态分布的标准差。
# dtype: 输出的类型。
# seed: 一个整数，当设置之后，每次生成的随机数都一样。
# name: 操作的名字。
# tf.random.normal(shape, mean=0.0, stddev=1.0, dtype=tf.float32, seed=None, name=None)

# 2.创建一个具有一定均值（默认值=0.0）和标准差（默认值=1.0）、形状为 [M，N] 的截尾正态分布随机数组:
t10=tf.random.truncated_normal([1,5],stddev=2,seed=12)

# 3.要在种子的 [minval（default=0），maxval] 范围内创建形状为 [M，N] 的给定伽马分布随机数组:
t11=tf.random.uniform([2,3],maxval=4,seed=12)

# 4.要将给定的张量随机裁剪为指定的大小:
# t12=tf.random_crop(t11,[2,5],seed=12) # ??? 随机从张量 t11 中裁剪出一个大小为 [2，5] 的张量
t13=tf.random.shuffle(t11) # 以随机的顺序来呈现训练样本


# 5.随机生成的张量受初始种子值的影响。要在多次运行或会话中获得相同的随机数，应该将种子设置为一个常数值。当使用大量的随机张量时，可以使用 tf.set_random_seed() 来为所有随机产生的张量设置种子
t14=tf.compat.v1.set_random_seed(54) # 种子只能有整数值。</code></pre>
<pre><code>tf.Tensor(4, shape=(), dtype=int32)
tf.Tensor([1 2 3], shape=(3,), dtype=int32)
tf.Tensor(
[[0 0 0]
 [0 0 0]], shape=(2, 3), dtype=int32)
tf.Tensor([0 0 0], shape=(3,), dtype=int32)
tf.Tensor([1 1 1], shape=(3,), dtype=int32)
tf.Tensor(
[[1 1 1]
 [1 1 1]], shape=(2, 3), dtype=int32)
tf.Tensor([2.   2.75 3.5  4.25 5.  ], shape=(5,), dtype=float32)
tf.Tensor([0 1 2 3 4 5 6 7 8 9], shape=(10,), dtype=int32)
tf.Tensor(
[[-2.2231169 -0.7829838 -2.3765397]
 [-2.0533948  5.207492   4.025979 ]], shape=(2, 3), dtype=float32)
tf.Tensor([[-1.9783968   0.05632517 -3.7346437  -0.21532871 -1.6093115 ]], shape=(1, 5), dtype=float32)
tf.Tensor(
[[0.94491434 2.346364   0.2467246 ]
 [2.254159   3.8856897  0.30119896]], shape=(2, 3), dtype=float32)
tf.Tensor(
[[2.254159   3.8856897  0.30119896]
 [0.94491434 2.346364   0.2467246 ]], shape=(2, 3), dtype=float32)
None</code></pre>
<h2 id="二、变量"><a href="#二、变量" class="headerlink" title="二、变量"></a>二、变量</h2><pre><code>通过使用变量类来创建。变量的定义还包括应该初始化的常量/随机值。</code></pre>
<pre><code>ta=tf.random.uniform([50,50],0,10,seed=0)
tb=tf.Variable(ta)
tc=tf.Variable(ta)

# 注意：变量通常在神经网络中表示权重和偏置。
# 权重变量使用正态分布随机初始化，均值为 0，标准差为 2，权重大小为 100×100。偏置由 100 个元素组成，每个元素初始化为 0。
weights=tf.Variable(tf.random.normal([100,100],stddev=2))
bias=tf.Variable(tf.zeros([100]),name=&#39;biases&#39;)

# 指定一个变量来初始化另一个变量
weight2=tf.Variable(weights.initialized_value(),name=&#39;w2&#39;)

# 变量的定义将指定变量如何被初始化，但是必须显式初始化所有的声明变量。
inital_op=tf.compat.v1.global_variables_initializer()

# 每个变量也可以在运行图中单独使用 tf.Variable.initializer 来初始化
bias.initializer

# 保存变量：使用 Saver 类来保存变量，定义一个 Saver 操作对象
# saver=tf.compat.v1.train.Saver() ???</code></pre>
<h2 id="三、占位符"><a href="#三、占位符" class="headerlink" title="三、占位符"></a>三、占位符</h2><pre><code>作用：用于将数据提供给计算图。
tf.placeholder(dtype,shape=None,name=None)
dtype 定占位符的数据类型，并且必须在声明占位符时指定。</code></pre>
<p>注意，与 Python/Numpy 序列不同，TensorFlow 序列不可迭代。<br>for i in tf.range(10) # error</p>
<h2 id="四、追加"><a href="#四、追加" class="headerlink" title="四、追加"></a>四、追加</h2><h2 id="TensorFlow基础架构"><a href="#TensorFlow基础架构" class="headerlink" title="TensorFlow基础架构"></a>TensorFlow基础架构</h2><h3 id="Session–会话控制"><a href="#Session–会话控制" class="headerlink" title="Session–会话控制"></a>Session–会话控制</h3><p>Session 是 TensorFlow 为了控制,和输出文件的执行的语句.<br>运行 session.run() 可以获得你的运算结果, 或者是你所要运算的部分.</p>
<pre><code>`# method 1
sess = tf.Session()
result = sess.run(product)
print(result)
sess.close()

# method 2
with tf.Session() as sess:
    result2 = sess.run(product)
    print(result2)`</code></pre>
<h3 id="Variable–变量"><a href="#Variable–变量" class="headerlink" title="Variable–变量"></a>Variable–变量</h3><p>在 Tensorflow 中，定义了某字符串是变量，它才是变量，这一点是与 Python 所不同的。</p>
<p>定义语法： state = tf.Variable()</p>
<pre><code>`import tensorflow as tf

state = tf.Variable(0, name=&#39;counter&#39;)

# 定义常量 one
one = tf.constant(1)

# 定义加法步骤 (注: 此步并没有直接计算)
new_value = tf.add(state, one)

# 将 State 更新成 new_value
update = tf.assign(state, new_value)
# 如果定义 Variable, 就一定要 initialize
init = tf.global_variables_initializer()

# 使用 Session
with tf.Session() as sess:
    sess.run(init)
    for _ in range(3):
        sess.run(update)
        print(sess.run(state))`</code></pre>
<p>注意：直接 print(state) 不起作用！！</p>
<p>一定要把 sess 的指针指向 state 再进行 print 才能得到想要的结果！</p>
<h3 id="Placeholder–传入值"><a href="#Placeholder–传入值" class="headerlink" title="Placeholder–传入值"></a>Placeholder–传入值</h3><p>placeholder 是 Tensorflow 中的占位符，暂时储存变量.</p>
<p>Tensorflow 如果想要从外部传入data, 那就需要用到 tf.placeholder(), 然后以这种形式传输数据 sess.run(***, feed_dict={input: **}).</p>
<pre><code>`import tensorflow as tf

#在 Tensorflow 中需要定义 placeholder 的 type ，一般为 float32 形式
input1 = tf.placeholder(tf.float32)
input2 = tf.placeholder(tf.float32)

# mul = multiply 是将input1和input2 做乘法运算，并输出为 output 
ouput = tf.multiply(input1, input2)
with tf.Session() as sess:
    print(sess.run(ouput, feed_dict=&#123;input1: [7.], input2: [2.]&#125;))
# [ 14.]`</code></pre>
<h3 id="激励函数–Activation-Function"><a href="#激励函数–Activation-Function" class="headerlink" title="激励函数–Activation Function"></a>激励函数–Activation Function</h3><p>神经网络两三层–任意激励函数均可<br>卷积神经网络–推荐激励函数Relu<br>循环神经网络–添加激励函数tanh</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/TensorFlow-3-%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/TensorFlow-3-%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84/" class="post-title-link" itemprop="url">TensorFlow-3.程序结构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-18 21:27:41" itemprop="dateCreated datePublished" datetime="2020-02-18T21:27:41+08:00">2020-02-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-18 21:13:45" itemprop="dateModified" datetime="2020-09-18T21:13:45+08:00">2020-09-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习和深度学习</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/TensorFlow/" itemprop="url" rel="index"><span itemprop="name">TensorFlow</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、结构"><a href="#一、结构" class="headerlink" title="一、结构"></a>一、结构</h2><p>TensorFlow程序分为两个独立的部分:<br>    构建任何拟创建神经网络的蓝图，包括计算图的定义及其执行。<br>    图定义和执行的分开设计使得 TensorFlow 能够多平台工作以及并行执行，TensorFlow 也因此更加强大。</p>
<p>计算图：是包含节点和边的网络。本节定义所有要使用的数据，也就是张量（tensor）对象（常量、变量和占位符），同时定义要执行的所有计算，即运算操作对象（Operation Object，简称 OP）。</p>
<p>每个节点可以有零个或多个输入，但只有一个输出。网络中的节点表示对象（张量和运算操作），边表示运算操作之间流动的张量。计算图定义神经网络的蓝图，但其中的张量还没有相关的数值。</p>
<p>为了构建计算图，需要定义所有要执行的常量、变量和运算操作。</p>
<h2 id="二、代码"><a href="#二、代码" class="headerlink" title="二、代码"></a>二、代码</h2><pre><code>通过定义并执行计算图来实现两个向量相加：2-add.ipynb</code></pre>
<p>计算图的执行：使用会话对象来实现计算图的执行。会话对象封装了评估张量和操作对象的环境。这里真正实现了运算操作并将信息从网络的一层传递到另外一层。不同张量对象的值仅在会话对象中被初始化、访问和保存。在此之前张量对象只被抽象定义，在会话中才被赋予实际的意义。</p>
<p>注意，使用 TensorBoard 可视化图形是 TensorFlow 最有用的功能之一，特别是在构建复杂的神经网络时。我们构建的计算图可以在图形对象的帮助菜单下进行查看。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/TensorFlow-2-HelloWorld/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/TensorFlow-2-HelloWorld/" class="post-title-link" itemprop="url">TensorFlow-2.HelloWorld</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-18 21:25:36" itemprop="dateCreated datePublished" datetime="2020-02-18T21:25:36+08:00">2020-02-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-18 21:18:13" itemprop="dateModified" datetime="2020-09-18T21:18:13+08:00">2020-09-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习和深度学习</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/TensorFlow/" itemprop="url" rel="index"><span itemprop="name">TensorFlow</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>TensorFlow1.x和TensorFlow2.0函数区别：<a target="_blank" rel="noopener" href="https://docs.google.com/spreadsheets/d/1FLFJLzg7WNP6JHODX5q8BDgptKafq_slHpnHVbJIteQ/edit#gid=0">https://docs.google.com/spreadsheets/d/1FLFJLzg7WNP6JHODX5q8BDgptKafq_slHpnHVbJIteQ/edit#gid=0</a></p>
<p>代码：1-helloWorld.ipynb</p>
<pre><code># 级别 1 是提示，级别 2 是警告，级别 3 是错误
import os
os.environ[&#39;TF_CPP_MIN_LOG_LEVEL&#39;]=&#39;2&#39;</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/TensorFlow-1-%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/TensorFlow-1-%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">TensorFlow-1.介绍</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-18 21:24:09" itemprop="dateCreated datePublished" datetime="2020-02-18T21:24:09+08:00">2020-02-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-18 16:56:20" itemprop="dateModified" datetime="2020-09-18T16:56:20+08:00">2020-09-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习和深度学习</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/TensorFlow/" itemprop="url" rel="index"><span itemprop="name">TensorFlow</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>参考：<a target="_blank" rel="noopener" href="https://morvanzhou.github.io/tutorials/machine-learning/tensorflow/">莫烦TensorFlow</a></p>
<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><pre><code>900百亿神经细胞组成了我们的生物神经网络，而它是通过刺激来产生新的联结，让信号能够
通过新的联结传递来形成反馈；
    人工神经网络一种典型模式就是通过训练数据来进行预测，而预测的结果不一定很好，所以就
通过正向或是反向传播来更新神经元，从而再形成一个好的神经系统。其在本质上，是一个能
让计算机处理和优化的数学模型。

    当今神经网络是是深度学习最流行的一种框架，它的基本原理就是梯度下降(Gradient Descent)
机制，其中的梯度就是我们大学所学的求导求微分。一般来说, 神经网络是一连串神经层所组成的把输入进行加工再输出的系统。</code></pre>
<p>开源深度学习库 TensorFlow 允许将深度神经网络的计算部署到任意数量的 CPU 或 GPU 的服务器、PC 或移动设备上，且只利用一个 TensorFlow API。你可能会问，还有很多其他的深度学习库，如 Torch、Theano、Caffe 和 MxNet，那 TensorFlow 与其他深度学习库的区别在哪里呢？包括 TensorFlow 在内的大多数深度学习库能够自动求导、开源、支持多种 CPU/GPU、拥有预训练模型，并支持常用的NN架构，如递归神经网络（RNN）、卷积神经网络（CNN）和深度置信网络（DBN）。</p>
<p>TensorFlow 则还有更多的特点，如下：<br>    支持所有流行语言，如 Python、C++、Java、R和Go。<br>    可以在多种平台上工作，甚至是移动平台和分布式平台。<br>    它受到所有云服务（AWS、Google和Azure）的支持。<br>    Keras——高级神经网络 API，已经与 TensorFlow 整合。<br>    与 Torch/Theano 比较，TensorFlow 拥有更好的计算图表可视化。<br>    允许模型部署到工业生产中，并且容易使用。<br>    有非常好的社区支持。<br>    TensorFlow 不仅仅是一个软件库，它是一套包括 TensorFlow，TensorBoard 和 TensorServing 的软件。</p>
<p>谷歌 research 博客列出了全球一些使用 TensorFlow 开发的有趣项目：</p>
<pre><code>Google 翻译运用了 TensorFlow 和 TPU（Tensor Processing Units）。
Project Magenta 能够使用强化学习模型生成音乐，运用了 TensorFlow。
澳大利亚海洋生物学家使用了 TensorFlow 来发现和理解濒临灭绝的海牛。
一位日本农民运用 TensorFlow 开发了一个应用程序，使用大小和形状等物理特性对黄瓜进行分类。</code></pre>
<h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><pre><code>$ conda --version

CPU 与 GPU 的对比：中央处理器（CPU）由对顺序串行处理优化的内核（4～8个）组成。图形处理器（GPU）具有大规模并行架构，由数千个更小且更有效的核芯（大致以千计）组成，能够同时处理多个任务。

$ conda create -n tensorflow python=3.5 # 虚拟环境
$ source activate tensorflow # 激活
$ source deactivate 
$ pip install tensorflow

$ conda install -c anaconda ipython # 安装ipython
$ conda install -channel=conda-forge nb_conda_kernels # 安装nb_conda_kernels
$ jupyter notebook # 启动

$ conda install dateutil</code></pre>
<h3 id="2-1-Linux下安装"><a href="#2-1-Linux下安装" class="headerlink" title="2.1 Linux下安装"></a>2.1 Linux下安装</h3><pre><code>官网：https://www.anaconda.com/distribution/#macos
参考：https://www.jianshu.com/p/742dc4d8f4c5

# Linux 下安装anaconda
$ wget https://repo.anaconda.com/archive/Anaconda3-2019.10-Linux-x86_64.sh
$ sh Anaconda3-2019.10-Linux-x86_64.sh
$ vi ~/.bashrc
  Anaconda3-2019.10-Linux-x86_64.sh


$ conda create -n tensorflow python=3.7
$ source activate tensorflow # 激活
$ source deactivate   # conda deactivate</code></pre>
<h3 id="2-2-Linux安装jupyter-notebook"><a href="#2-2-Linux安装jupyter-notebook" class="headerlink" title="2.2 Linux安装jupyter notebook"></a>2.2 Linux安装jupyter notebook</h3><pre><code># 本地访问Linux服务器上的jupyter notebook
$ conda install nb_conda

1. 生成配置文件
$ jupyter notebook --generate-config
生成了.jupyter/jupyter_notebook_config.py配置文件.

2. 打开python,生成密钥:</code></pre>
<pre><code>&gt;&gt;&gt;from notebook.auth import passwd

&gt;&gt;&gt;passwd()

#输入新的登陆密码（本地访问的时候使用）

#再次确认

#生成key，复制留存并修改到配置文件中去</code></pre>
<pre><code>3. 修改配置文件
$ vim  ~/.jupyter/jupyter_notebook_config.py</code></pre>
<pre><code>c.NotebookApp.ip=&#39;*&#39;                     # 就是设置所有ip地址皆可访问

c.NotebookApp.password = u&#39;sha:ce...     # 复制上步的那个密文key替换等号后面的内容，注意，有u&#39;

c.NotebookApp.open_browser = False       # 禁止自动打开浏览器

c.NotebookApp.port =8888                 # 指定一个可用端口,也可以是其他闲置的端口</code></pre>
<pre><code>4. 在服务器终端中执行jupyter notebook 并放入后台中
$ nohup jupyter notebook &amp;</code></pre>
<h3 id="2-3-Linux安装TensorFlow、cuda等"><a href="#2-3-Linux安装TensorFlow、cuda等" class="headerlink" title="2.3 Linux安装TensorFlow、cuda等"></a>2.3 Linux安装TensorFlow、cuda等</h3><pre><code>#安装指定 版本的TensorFlow
pip install tensorflow-gpu==1.9.0

# 安装的包
conda install cudatoolkit=9.0 -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/linux-64/
conda install cudnn=7.1.2 -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/linux-64/


1.检查CUDA版本：
使用：
nvcc -V
或：
cat /usr/local/cuda/version.txt

2.检查cuDNN版本：
cat /usr/local/cuda/include/cudnn.h | grep CUDNN_MAJOR -A 2

3.检查TensorFlow版本：
直接使用pip list查看</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/LeetCode-10-%E5%9B%BE-%E4%BA%8C-%E5%B2%9B%E5%B1%BF%E7%B3%BB%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/LeetCode-10-%E5%9B%BE-%E4%BA%8C-%E5%B2%9B%E5%B1%BF%E7%B3%BB%E5%88%97/" class="post-title-link" itemprop="url">LeetCode-10-图-二-岛屿系列</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-17 14:55:49" itemprop="dateCreated datePublished" datetime="2020-02-17T14:55:49+08:00">2020-02-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-06-16 20:55:25" itemprop="dateModified" datetime="2021-06-16T20:55:25+08:00">2021-06-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="十、图"><a href="#十、图" class="headerlink" title="十、图"></a>十、图</h2><h3 id="133-克隆图"><a href="#133-克隆图" class="headerlink" title="133.克隆图"></a>133.克隆图</h3><pre><code>链接：https://leetcode-cn.com/problems/clone-graph/

给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。

图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。

class Node &#123;
    public int val;
    public List&lt;Node&gt; neighbors;
&#125;
</code></pre>
<p>题解一|dfs|hash：</p>
<p>思路：</p>
<p>1、使用一个哈希表存储所有已被访问和克隆的节点。哈希表中的 key 是原始图中的节点，value 是克隆图中的对应节点。</p>
<p>2、从给定节点开始遍历图。如果某个节点已经被访问过，则返回其克隆图中的对应节点。我们给定无向边边 A - B，表示 A 能连接到 B，且 B 能连接到 A。如果不对访问过的节点做标记，则会陷入死循环中。</p>
<p>3、如果当前访问的节点不在哈希表中，则创建它的克隆节点并存储在哈希表中。注意：在进入递归之前，必须先创建克隆节点并保存在哈希表中。如果不保证这种顺序，可能会在递归中再次遇到同一个节点，再次遍历该节点时，陷入死循环。</p>
<p>4、递归调用每个节点的邻接点。每个节点递归调用的次数等于邻接点的数量，每一次调用返回其对应邻接点的克隆节点，最终返回这些克隆邻接点的列表，将其放入对应克隆节点的邻接表中。这样就可以克隆给定的节点和其邻接点。</p>
<pre><code>&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val = 0, neighbors = []):
        self.val = val
        self.neighbors = neighbors
&quot;&quot;&quot;
class Solution:
    def cloneGraph(self, node: &#39;Node&#39;) -&gt; &#39;Node&#39;:
        lookup=&#123;&#125;
        def dfs(node):
            # print(node.val)
            if not node:
                return
            if node in lookup:
                return lookup[node]
            clone=Node(node.val,[])
            lookup[node]=clone
            for n in node.neighbors:
                clone.neighbors.append(dfs(n))
            return clone
        return dfs(node)
</code></pre>
<p>题解二|bfs：</p>
<pre><code>&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val = 0, neighbors = None):
        self.val = val
        self.neighbors = neighbors if neighbors is not None else []
&quot;&quot;&quot;
from collections import deque
class Solution:
    def cloneGraph(self, node: &#39;Node&#39;) -&gt; &#39;Node&#39;:
        if not node:
            return
        visited=&#123;&#125;
        queue=deque([node])
        visited[node]=Node(node.val,[])
        while queue:
            n=queue.popleft()
            for neighbor in n.neighbors:
                if neighbor not in visited:
                    visited[neighbor]=Node(neighbor.val,[])
                    queue.append(neighbor)
                visited[n].neighbors.append(visited[neighbor]) # 更新当前节点的邻居列表
        return visited[node]
</code></pre>
<h3 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a>200. 岛屿数量</h3><pre><code>链接：https://leetcode-cn.com/problems/number-of-islands/

给你一个由 &#39;1&#39;（陆地）和 &#39;0&#39;（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

 

示例 1：

输入：grid = [
  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],
  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],
  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],
  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]
]
输出：1
示例 2：

输入：grid = [
  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],
  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],
  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],
  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]
]
输出：3
 

提示：

m == grid.length
n == grid[i].length
1 &lt;= m, n &lt;= 300
grid[i][j] 的值为 &#39;0&#39; 或 &#39;1&#39;
</code></pre>
<p>题解一|DFS：</p>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-islands/solution/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/">https://leetcode-cn.com/problems/number-of-islands/solution/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/</a></p>
<pre><code>class Solution:
    def numIslands(self, grid: List[List[str]]) -&gt; int:
        def helper(grid,i,j):
            if i&lt;0 or i&gt;=len(grid) or j&lt;0 or j&gt;=len(grid[0]) or grid[i][j]==&#39;0&#39; or grid[i][j]==&#39;2&#39;: # 判断是否在网格中
                return
            grid[i][j]=&#39;2&#39; # 避免重复遍历

            # 访问上、下、左、右四个相邻结点
            helper(grid,i-1,j) # 上
            helper(grid,i+1,j) # 下
            helper(grid,i,j-1) # 左
            helper(grid,i,j+1) # 右
        
        if not grid or len(grid[0])==0:
            return 0
        count=0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j]==&#39;1&#39;:
                    count+=1
                    helper(grid,i,j)
        return count
</code></pre>
<p>题解二|BFS|超时：</p>
<pre><code>class Solution:
    def numIslands(self, grid: List[List[str]]) -&gt; int:
        def bfs(grid,i,j):
            queue=[[i,j]]
            while queue:
                i,j=queue.pop(0)
                if 0 &lt;= i &lt; len(grid) and 0 &lt;= j &lt; len(grid[0]) and grid[i][j] ==&#39;1&#39;:
                    grid[i][j]==&#39;2&#39;
                    queue+=[[i+1,j],[i-1,j],[i,j+1],[i,j-1]]
        count=0
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                # if grid[i][j]==&#39;0&#39; or grid[i][j]==&#39;2&#39;:
                #     continue
                if grid[i][j]==&#39;1&#39;:
                    bfs(grid,i,j)
                    count+=1
        return count
</code></pre>
<pre><code>class Solution:
    def __init__(self) -&gt; None:
        self.directions=[(1,0),(-1,0),(0,1),(0,-1)]

    def inArea(self,i,j,rows,cols):
        return i&gt;=0 and i&lt;rows and j&gt;=0 and j&lt;cols

    def numIslands(self, grid: List[List[str]]) -&gt; int:
        if not grid or not grid[0]:
            return 0
            
        m,n=len(grid),len(grid[0])

        count=0

        for i in range(m):
            for j in range(n):
                if grid[i][j]==&#39;1&#39;:
                    grid[i][j]==&#39;2&#39;
                    self.bfs(grid,i,j,m,n)
                    count+=1
        return count

    def bfs(self,grid,i,j,rows,cols):
        queue=[(i,j)]
        while queue:
            front=queue.pop(0)
            x=front[0]
            y=front[1]
            for direction in self.directions:
                newx=x+direction[0]
                newy=y+direction[1]
                if self.inArea(newx,newy,rows,cols) and grid[newx][newy]==&#39;1&#39;:
                    grid[newx][newy]=&#39;2&#39;
                    queue.append((newx,newy))
        return True
</code></pre>
<h3 id="463-岛屿的周长"><a href="#463-岛屿的周长" class="headerlink" title="463. 岛屿的周长"></a>463. 岛屿的周长</h3><pre><code>链接：https://leetcode-cn.com/problems/island-perimeter/

给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。

网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。

岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。

示例 :

输入:
[[0,1,0,0],
 [1,1,1,0],
 [0,1,0,0],
 [1,1,0,0]]

输出: 16

解释: 它的周长是下面图片中的 16 个黄色的边：
</code></pre>
<p>题解一|DFS：</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/grid.jpg" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/grid.jpg"></p>
<p>当我们的 dfs 函数因为「坐标 (r, c) 超出网格范围」返回的时候，实际上就经过了一条黄色的边；而当函数因为「当前格子是海洋格子」返回的时候，实际上就经过了一条蓝色的边。</p>
<pre><code>class Solution:
    def islandPerimeter(self, grid: List[List[int]]) -&gt; int:

        def dfs(grid,i,j):
            # if i&lt;0 or i&gt;=len(grid) or j&lt;0 or j&gt;=len(grid[0]):
            #     return 1
            if not (0 &lt;= i &lt; m and 0 &lt;= j &lt; n):
                return 1
            if grid[i][j]==0:
                return 1
            if grid[i][j]!=1:
                return 0
            grid[i][j]=2
            return dfs(grid,i-1,j)+dfs(grid,i+1,j)+dfs(grid,i,j-1)+dfs(grid,i,j+1)

        if not grid or len(grid[0])==0:
            return 0
        m=len(grid)
        n=len(grid[0])
        for x in range(m):
            for y in range(n):
                if grid[x][y]==1:
                    return dfs(grid,x,y)
</code></pre>
<h3 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695. 岛屿的最大面积"></a>695. 岛屿的最大面积</h3><pre><code>链接：https://leetcode-cn.com/problems/max-area-of-island/

给定一个包含了一些 0 和 1 的非空二维数组 grid 。

一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。

找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)

示例 1:

[[0,0,1,0,0,0,0,1,0,0,0,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,1,1,0,1,0,0,0,0,0,0,0,0],
 [0,1,0,0,1,1,0,0,1,0,1,0,0],
 [0,1,0,0,1,1,0,0,1,1,1,0,0],
 [0,0,0,0,0,0,0,0,0,0,1,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,0,0,0,0,0,0,1,1,0,0,0,0]]
对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。

示例 2:

[[0,0,0,0,0,0,0,0]]
对于上面这个给定的矩阵, 返回 0。

注意: 给定的矩阵grid 的长度和宽度都不超过 50。
</code></pre>
<p>题解一|DFS：</p>
<pre><code>class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -&gt; int:
        def dfs(grid,i,j):
            if not (0&lt;=i&lt;m and 0&lt;=j&lt;n):
                return 0
            if grid[i][j]!=1: # 注意这样判断，才能递归走到dfs
                return 0
            grid[i][j]=2
            return 1+dfs(grid,i+1,j)+dfs(grid,i-1,j)+dfs(grid,i,j+1)+dfs(grid,i,j-1)
            
        m=len(grid)
        n=len(grid[0])
        area=0
        if not grid or not n:
            return 0
        for i in range(m):
            for j in range(n):
                if grid[i][j]==1:
                    tmp=dfs(grid,i,j)
                    area=max(area,tmp)
        return area
</code></pre>
<p>题解二|bfs：</p>
<p>时间复杂度：O(m*n)，这里 m 表示二维矩阵的行数、n 表示二维矩阵的列数，最坏情况下每一个单元格都会被遍历一次；<br>空间复杂度：O(m)<em>n，数组 visited 的大小为<br>m×n，队列的大小最多为 m</em>n。</p>
<pre><code>class Solution:
    def __init__(self) -&gt; None:
        self.directions=[(0,1),(0,-1),(1,0),(-1,0)]

    def inArea(self,i,j,rows,cols):
        return i&gt;=0 and i&lt;rows and j&gt;=0 and j&lt;cols

    def maxAreaOfIsland(self, grid: List[List[int]]) -&gt; int:
        m,n=len(grid),len(grid[0])
        visited=[[False]*n for i in range(m)]
        maxArea=0
        for i in range(m):
            for j in range(n):
                if grid[i][j]==1 and not visited[i][j]:
                    maxArea=max(maxArea,self.bfs(grid,i,j,m,n,visited))
        return maxArea
    
    def bfs(self,grid,i,j,rows,cols,visited):
        count=0
        queue=[(i,j)]
        visited[i][j]=True
        while queue:
            front=queue.pop(0)
            x=front[0]
            y=front[1]
            count+=1
            for direction in self.directions:
                newx=x+direction[0]
                newy=y+direction[1]

                if self.inArea(newx,newy,rows,cols) and grid[newx][newy] == 1 and not visited[newx][newy]:
                    queue.append((newx,newy))
                    visited[newx][newy]=True
        return count
</code></pre>
<p>转换为一维向量：</p>
<pre><code>class Solution:
    def __init__(self) -&gt; None:
        self.directions=[(0,1),(0,-1),(1,0),(-1,0)]

    def inArea(self,i,j,rows,cols):
        return i&gt;=0 and i&lt;rows and j&gt;=0 and j&lt;cols

    def getIndex(self,x,y,cols):
        return x*cols+y

    def maxAreaOfIsland(self, grid: List[List[int]]) -&gt; int:
        m,n=len(grid),len(grid[0])
        visited=[False]* (m*n)
        maxArea=0
        for i in range(m):
            for j in range(n):
                if grid[i][j]==1 and not visited[self.getIndex(i,j,n)]:
                    maxArea=max(maxArea,self.bfs(grid,i,j,m,n,visited))
        return maxArea
    
    def bfs(self,grid,i,j,rows,cols,visited):
        count=0
        index=self.getIndex(i,j,cols)
        queue=[index]
        visited[index]=True
        while queue:
            front=queue.pop(0)
            x=front//cols
            y=front%cols
            count+=1
            for direction in self.directions:
                newx=x+direction[0]
                newy=y+direction[1]
                newindex=self.getIndex(newx,newy,cols)

                if self.inArea(newx,newy,rows,cols) and grid[newx][newy] == 1 and not visited[newindex]:
                    queue.append(newindex)
                    visited[newindex]=True
        return count
</code></pre>
<h3 id="827-最大人工岛"><a href="#827-最大人工岛" class="headerlink" title="827. 最大人工岛"></a>827. 最大人工岛</h3><pre><code>链接：https://leetcode-cn.com/problems/making-a-large-island/

在二维地图上， 0代表海洋， 1代表陆地，我们最多只能将一格 0 海洋变成 1变成陆地。

进行填海之后，地图上最大的岛屿面积是多少？（上、下、左、右四个方向相连的 1 可形成岛屿）

示例 1:

输入: [[1, 0], [0, 1]]
输出: 3
解释: 将一格0变成1，最终连通两个小岛得到面积为 3 的岛屿。
示例 2:

输入: [[1, 1], [1, 0]]
输出: 4
解释: 将一格0变成1，岛屿的面积扩大为 4。
示例 3:

输入: [[1, 1], [1, 1]]
输出: 4
解释: 没有0可以让我们变成1，面积依然为 4。
说明:

1 &lt;= grid.length = grid[0].length &lt;= 50
0 &lt;= grid[i][j] &lt;= 1
</code></pre>
<p>题解一|DFS：</p>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-islands/solution/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/">https://leetcode-cn.com/problems/number-of-islands/solution/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/</a></p>
<pre><code>class Solution:
    def largestIsland(self, grid: List[List[int]]) -&gt; int:
        def inArea(grid,i,j):
            return (0&lt;=i&lt;m and 0&lt;=j&lt;n)

        def area(grid,i,j,value): # value代表当前岛屿的编号,求得单个岛屿的面积
            if not inArea(grid,i,j):
                return 0
            if grid[i][j]!=1:
                return 0
            grid[i][j]=value
            return 1+area(grid,i+1,j,value)+area(grid,i-1,j,value)+area(grid,i,j+1,value)+area(grid,i,j-1,value)

        def thisArea(grid,i,j,hash): # 将(i,j)填海后，最大岛屿的面积
            if grid[i][j]!=0:
                return hash[grid[i][j]]
            res=0
            adjs=set()
            if inArea(grid,i-1,j) and grid[i-1][j]&gt;0: # 格子不越界，格子是陆地
                adjs.add(grid[i-1][j])
            if inArea(grid,i+1,j) and grid[i+1][j]&gt;0:
                adjs.add(grid[i+1][j])
            if inArea(grid,i,j-1) and grid[i][j-1]&gt;0:
                adjs.add(grid[i][j-1])
            if inArea(grid,i,j+1) and grid[i][j+1]&gt;0:
                adjs.add(grid[i][j+1])

            for each in adjs:
                res+=hash[each]
            return res+1

        m,n=len(grid),len(grid[0])
        value=2
        hash=&#123;&#125;
        res=0

        for i in range(m):
            for j in range(n):
                if grid[i][j]==1:
                    tmp=area(grid,i,j,value)
                    hash[value]=tmp
                    value+=1

        for i in range(m): # DFS 遍历海洋格子，观察每个海洋格子相邻的陆地格子。
            for j in range(n):
                tmp=thisArea(grid,i,j,hash) 
                res=max(res,tmp)
        return res
</code></pre>
<h3 id="1254-统计封闭岛屿的数目"><a href="#1254-统计封闭岛屿的数目" class="headerlink" title="1254. 统计封闭岛屿的数目"></a>1254. 统计封闭岛屿的数目</h3><pre><code>链接：https://leetcode-cn.com/problems/number-of-closed-islands/

有一个二维矩阵 grid ，每个位置要么是陆地（记号为 0 ）要么是水域（记号为 1 ）。

我们从一块陆地出发，每次可以往上下左右 4 个方向相邻区域走，能走到的所有陆地区域，我们将其称为一座「岛屿」。

如果一座岛屿 完全 由水域包围，即陆地边缘上下左右所有相邻区域都是水域，那么我们将其称为 「封闭岛屿」。

请返回封闭岛屿的数目。

示例 1：

输入：grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]]
输出：2
解释：
灰色区域的岛屿是封闭岛屿，因为这座岛屿完全被水域包围（即被 1 区域包围）。
示例 2：

输入：grid = [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]]
输出：1
示例 3：

输入：grid = [[1,1,1,1,1,1,1],
            [1,0,0,0,0,0,1],
            [1,0,1,1,1,0,1],
            [1,0,1,0,1,0,1],
            [1,0,1,1,1,0,1],
            [1,0,0,0,0,0,1],
            [1,1,1,1,1,1,1]]
输出：2

提示：

1 &lt;= grid.length, grid[0].length &lt;= 100
0 &lt;= grid[i][j] &lt;=1
</code></pre>
<p>题解一|dfs：</p>
<pre><code>class Solution:
    def __init__(self):
        self.val=1

    def closedIsland(self, grid: List[List[int]]) -&gt; int:
        def dfs(grid,i,j):
            if i&lt;0 or i&gt;=m or j&lt;0 or j&gt;=n:
                self.val=0
                return
            if grid[i][j] != 0:
                return
            grid[i][j]=2
            dfs(grid,i+1,j)
            dfs(grid,i-1,j)
            dfs(grid,i,j+1)                
            dfs(grid,i,j-1)


        if not grid or len(grid[0])==0:
            return 0
        m,n=len(grid),len(grid[0])
        count=0
        for i in range(m):
            for j in range(n):
                if grid[i][j]==0:
                    self.val=1
                    dfs(grid,i,j)
                    count+=self.val
        return count
</code></pre>
<pre><code>class Solution:
    def closedIsland(self, grid: List[List[int]]) -&gt; int:
        def dfs(grid,i,j):
            if i&lt;0 or i&gt;=m or j&lt;0 or j&gt;=n:
                return False # 到达边界，非封闭
            if grid[i][j] != 0:
                return True
            grid[i][j]=2
            up = dfs(grid,i-1,j);
            down = dfs(grid,i+1,j);
            left = dfs(grid,i,j-1);
            right = dfs(grid,i,j+1);
            if up and down and left and right:
                return True
            # return dfs(grid,i-1,j) &amp;&amp; dfs(grid,i+1,j) &amp;&amp; dfs(grid,i,j-1) &amp;&amp; dfs(grid,i,j+1) 注意：此处改成这样子运行不能全部case，原因是在这里作为return返回，会被截断。
            return False

        if not grid or len(grid[0])==0:
            return 0
        m,n=len(grid),len(grid[0])
        count=0
        for i in range(m):
            for j in range(n):
                if grid[i][j]==0:
                    if dfs(grid,i,j):
                        count+=1
        return count
</code></pre>
<pre><code>class Solution:
    def closedIsland(self, grid: List[List[int]]) -&gt; int:
        def dfs(grid,i,j):
            if i&lt;0 or i&gt;=m or j&lt;0 or j&gt;=n:
                return True # 到达边界，非封闭
            if grid[i][j] != 0:
                return False
            grid[i][j]=2
            up = dfs(grid,i-1,j);
            down = dfs(grid,i+1,j);
            left = dfs(grid,i,j-1);
            right = dfs(grid,i,j+1);
            
            # return dfs(grid,i-1,j) or dfs(grid,i+1,j) or dfs(grid,i,j-1) or dfs(grid,i,j+1)
            return up or down or left or right

        if not grid or len(grid[0])==0:
            return 0
        m,n=len(grid),len(grid[0])
        count=0
        for i in range(m):
            for j in range(n):
                if grid[i][j]==0:
                    if not dfs(grid,i,j):
                        count+=1
        return count
</code></pre>
<h3 id="1568-使陆地分离的最少天数"><a href="#1568-使陆地分离的最少天数" class="headerlink" title="1568. 使陆地分离的最少天数"></a>1568. 使陆地分离的最少天数</h3><pre><code>链接：https://leetcode-cn.com/problems/minimum-number-of-days-to-disconnect-island

给你一个由若干 0 和 1 组成的二维网格 grid ，其中 0 表示水，而 1 表示陆地。岛屿由水平方向或竖直方向上相邻的 1 （陆地）连接形成。

如果 恰好只有一座岛屿 ，则认为陆地是 连通的 ；否则，陆地就是 分离的 。

一天内，可以将任何单个陆地单元（1）更改为水单元（0）。

返回使陆地分离的最少天数。

示例 1：

输入：grid = [[0,1,1,0],[0,1,1,0],[0,0,0,0]]
输出：2
解释：至少需要 2 天才能得到分离的陆地。
将陆地 grid[1][1] 和 grid[0][2] 更改为水，得到两个分离的岛屿。
示例 2：

输入：grid = [[1,1]]
输出：2
解释：如果网格中都是水，也认为是分离的 ([[1,1]] -&gt; [[0,0]])，0 岛屿。
示例 3：

输入：grid = [[1,0,1,0]]
输出：0
示例 4：

输入：grid = [[1,1,0,1,1],
            [1,1,1,1,1],
            [1,1,0,1,1],
            [1,1,0,1,1]]
输出：1
示例 5：

输入：grid = [[1,1,0,1,1],
            [1,1,1,1,1],
            [1,1,0,1,1],
            [1,1,1,1,1]]
输出：2


提示：

1 &lt;= grid.length, grid[i].length &lt;= 30
grid[i][j] 为 0 或 1
</code></pre>
<p>题解一|dfs:</p>
<pre><code>class Solution:
    def minDays(self, grid: List[List[int]]) -&gt; int:
        def dfs(grid,i,j):
            if i&lt;0 or i&gt;=m or j&lt;0 or j&gt;=n or grid[i][j]==0 or grid[i][j]==2:
                return
            grid[i][j]=2
            dfs(grid,i+1,j)
            dfs(grid,i-1,j)
            dfs(grid,i,j+1)
            dfs(grid,i,j-1)

        def count():
            cnt=0
            for i in range(m):
                for j in range(n):
                    if grid[i][j]==1:
                        cnt+=1
                        dfs(grid,i,j)
            # 还原
            for i in range(m):
                for j in range(n):
                    if grid[i][j]==2:
                        grid[i][j]=1
            return cnt
        m,n=len(grid),len(grid[0])

        if count() !=1:
            return 0 # 如果岛屿个数已经大于1个，或者为0个，得出不需要分离。
        for i in range(m):
            for j in range(n):
                if grid[i][j]:
                    grid[i][j]=0
                    if count() != 1: # 分隔1个岛屿，如果岛屿个数已经大于1个，或者为0个，得出需要分离1个。
                        return 1
                    grid[i][j]=1
        return 2 # 如果以上都没有返回，说明需要分隔2个。因为任意连通岛屿通过分隔2次，都能分隔成功。
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Lilly</p>
  <div class="site-description" itemprop="description">Up in the wind!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">135</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lilly</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
