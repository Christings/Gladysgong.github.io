<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"gongyanli.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Up in the wind!">
<meta property="og:type" content="website">
<meta property="og:title" content="茉莉Python">
<meta property="og:url" content="http://gongyanli.com/page/6/index.html">
<meta property="og:site_name" content="茉莉Python">
<meta property="og:description" content="Up in the wind!">
<meta property="og:locale">
<meta property="article:author" content="Lilly">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://gongyanli.com/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>茉莉Python</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">茉莉Python</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">voidqueens@hotmail.com</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/TensorFlow-1-%E4%BB%8B%E7%BB%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/TensorFlow-1-%E4%BB%8B%E7%BB%8D/" class="post-title-link" itemprop="url">TensorFlow-1.介绍</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-18 21:24:09" itemprop="dateCreated datePublished" datetime="2020-02-18T21:24:09+08:00">2020-02-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-18 16:55:26" itemprop="dateModified" datetime="2020-09-18T16:55:26+08:00">2020-09-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习和深度学习</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/TensorFlow/" itemprop="url" rel="index"><span itemprop="name">TensorFlow</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>参考：<a target="_blank" rel="noopener" href="https://morvanzhou.github.io/tutorials/machine-learning/tensorflow/">莫烦TensorFlow</a></p>
<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><pre><code>900百亿神经细胞组成了我们的生物神经网络，而它是通过刺激来产生新的联结，让信号能够
通过新的联结传递来形成反馈；
    人工神经网络一种典型模式就是通过训练数据来进行预测，而预测的结果不一定很好，所以就
通过正向或是反向传播来更新神经元，从而再形成一个好的神经系统。其在本质上，是一个能
让计算机处理和优化的数学模型。

    当今神经网络是是深度学习最流行的一种框架，它的基本原理就是梯度下降(Gradient Descent)
机制，其中的梯度就是我们大学所学的求导求微分。一般来说, 神经网络是一连串神经层所组成的把输入进行加工再输出的系统。</code></pre>
<p>开源深度学习库 TensorFlow 允许将深度神经网络的计算部署到任意数量的 CPU 或 GPU 的服务器、PC 或移动设备上，且只利用一个 TensorFlow API。你可能会问，还有很多其他的深度学习库，如 Torch、Theano、Caffe 和 MxNet，那 TensorFlow 与其他深度学习库的区别在哪里呢？包括 TensorFlow 在内的大多数深度学习库能够自动求导、开源、支持多种 CPU/GPU、拥有预训练模型，并支持常用的NN架构，如递归神经网络（RNN）、卷积神经网络（CNN）和深度置信网络（DBN）。</p>
<p>TensorFlow 则还有更多的特点，如下：<br>    支持所有流行语言，如 Python、C++、Java、R和Go。<br>    可以在多种平台上工作，甚至是移动平台和分布式平台。<br>    它受到所有云服务（AWS、Google和Azure）的支持。<br>    Keras——高级神经网络 API，已经与 TensorFlow 整合。<br>    与 Torch/Theano 比较，TensorFlow 拥有更好的计算图表可视化。<br>    允许模型部署到工业生产中，并且容易使用。<br>    有非常好的社区支持。<br>    TensorFlow 不仅仅是一个软件库，它是一套包括 TensorFlow，TensorBoard 和 TensorServing 的软件。</p>
<p>谷歌 research 博客列出了全球一些使用 TensorFlow 开发的有趣项目：</p>
<pre><code>Google 翻译运用了 TensorFlow 和 TPU（Tensor Processing Units）。
Project Magenta 能够使用强化学习模型生成音乐，运用了 TensorFlow。
澳大利亚海洋生物学家使用了 TensorFlow 来发现和理解濒临灭绝的海牛。
一位日本农民运用 TensorFlow 开发了一个应用程序，使用大小和形状等物理特性对黄瓜进行分类。</code></pre>
<h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><pre><code>$ conda --version

CPU 与 GPU 的对比：中央处理器（CPU）由对顺序串行处理优化的内核（4～8个）组成。图形处理器（GPU）具有大规模并行架构，由数千个更小且更有效的核芯（大致以千计）组成，能够同时处理多个任务。

$ conda create -n tensorflow python=3.5 # 虚拟环境
$ source activate tensorflow # 激活
$ source deactivate 
$ pip install tensorflow

$ conda install -c anaconda ipython # 安装ipython
$ conda install -channel=conda-forge nb_conda_kernels # 安装nb_conda_kernels
$ jupyter notebook # 启动

$ conda install dateutil</code></pre>
<h3 id="2-1-Linux下安装"><a href="#2-1-Linux下安装" class="headerlink" title="2.1 Linux下安装"></a>2.1 Linux下安装</h3><pre><code>官网：https://www.anaconda.com/distribution/#macos
参考：https://www.jianshu.com/p/742dc4d8f4c5

# Linux 下安装anaconda
$ wget https://repo.anaconda.com/archive/Anaconda3-2019.10-Linux-x86_64.sh
$ sh Anaconda3-2019.10-Linux-x86_64.sh
$ vi ~/.bashrc
  Anaconda3-2019.10-Linux-x86_64.sh


$ conda create -n tensorflow python=3.7
$ source activate tensorflow # 激活
$ source deactivate   # conda deactivate</code></pre>
<h3 id="2-2-Linux安装jupyter-notebook"><a href="#2-2-Linux安装jupyter-notebook" class="headerlink" title="2.2 Linux安装jupyter notebook"></a>2.2 Linux安装jupyter notebook</h3><pre><code># 本地访问Linux服务器上的jupyter notebook
$ conda install nb_conda

1. 生成配置文件
$ jupyter notebook --generate-config
生成了.jupyter/jupyter_notebook_config.py配置文件.

2. 打开python,生成密钥:</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;from notebook.auth import passwd</span><br><span class="line"> </span><br><span class="line">&gt;&gt;&gt;passwd()</span><br><span class="line"> </span><br><span class="line">#输入新的登陆密码（本地访问的时候使用）</span><br><span class="line"> </span><br><span class="line">#再次确认</span><br><span class="line"> </span><br><span class="line">#生成key，复制留存并修改到配置文件中去</span><br></pre></td></tr></table></figure>
<pre><code>3. 修改配置文件
$ vim  ~/.jupyter/jupyter_notebook_config.py</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c.NotebookApp.ip&#x3D;&#39;*&#39;                     # 就是设置所有ip地址皆可访问</span><br><span class="line"> </span><br><span class="line">c.NotebookApp.password &#x3D; u&#39;sha:ce...     # 复制上步的那个密文key替换等号后面的内容，注意，有u&#39;</span><br><span class="line"> </span><br><span class="line">c.NotebookApp.open_browser &#x3D; False       # 禁止自动打开浏览器</span><br><span class="line"> </span><br><span class="line">c.NotebookApp.port &#x3D;8888                 # 指定一个可用端口,也可以是其他闲置的端口</span><br></pre></td></tr></table></figure>

<pre><code>4. 在服务器终端中执行jupyter notebook 并放入后台中
$ nohup jupyter notebook &amp;</code></pre>
<h3 id="2-3-Linux安装TensorFlow、cuda等"><a href="#2-3-Linux安装TensorFlow、cuda等" class="headerlink" title="2.3 Linux安装TensorFlow、cuda等"></a>2.3 Linux安装TensorFlow、cuda等</h3><pre><code>#安装指定 版本的TensorFlow
pip install tensorflow-gpu==1.9.0

# 安装的包
conda install cudatoolkit=9.0 -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/linux-64/
conda install cudnn=7.1.2 -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/linux-64/


1.检查CUDA版本：
使用：
nvcc -V
或：
cat /usr/local/cuda/version.txt

2.检查cuDNN版本：
cat /usr/local/cuda/include/cudnn.h | grep CUDNN_MAJOR -A 2

3.检查TensorFlow版本：
直接使用pip list查看</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/LeetCode-10-%E5%9B%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/LeetCode-10-%E5%9B%BE/" class="post-title-link" itemprop="url">LeetCode-10-图</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-17 14:55:49" itemprop="dateCreated datePublished" datetime="2020-02-17T14:55:49+08:00">2020-02-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-01 13:54:29" itemprop="dateModified" datetime="2020-09-01T13:54:29+08:00">2020-09-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="十、图"><a href="#十、图" class="headerlink" title="十、图"></a>十、图</h2><h3 id="133-克隆图"><a href="#133-克隆图" class="headerlink" title="???133.克隆图"></a>???133.克隆图</h3><pre><code>链接：https://leetcode-cn.com/problems/clone-graph/

给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。

图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。

class Node &#123;
    public int val;
    public List&lt;Node&gt; neighbors;
&#125;</code></pre>
<p>题解一(dfs)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line"># Definition for a Node.</span><br><span class="line">class Node:</span><br><span class="line">    def __init__(self, val &#x3D; 0, neighbors &#x3D; []):</span><br><span class="line">        self.val &#x3D; val</span><br><span class="line">        self.neighbors &#x3D; neighbors</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">class Solution:</span><br><span class="line">    def cloneGraph(self, node: &#39;Node&#39;) -&gt; &#39;Node&#39;:</span><br><span class="line">        lookup&#x3D;&#123;&#125;</span><br><span class="line">        def dfs(node):</span><br><span class="line">            # print(node.val)</span><br><span class="line">            if not node:</span><br><span class="line">                return</span><br><span class="line">            if node in lookup:</span><br><span class="line">                return lookup[node]</span><br><span class="line">            clone&#x3D;Node(node.val,[])</span><br><span class="line">            lookup[node]&#x3D;clone</span><br><span class="line">            for n in node.neighbors:</span><br><span class="line">                clone.neighbors.append(dfs(n))</span><br><span class="line">            return clone</span><br><span class="line">        return dfs(node)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-12-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-12-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/" class="post-title-link" itemprop="url">数据结构与算法-12-二叉搜索树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-05 21:37:06" itemprop="dateCreated datePublished" datetime="2020-02-05T21:37:06+08:00">2020-02-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-26 20:03:41" itemprop="dateModified" datetime="2020-08-26T20:03:41+08:00">2020-08-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、二叉搜索树"><a href="#一、二叉搜索树" class="headerlink" title="一、二叉搜索树"></a>一、二叉搜索树</h2><p>二叉搜索树（Binary Search Tree）是指一棵空树或具有如下性质的二叉树：</p>
<pre><code>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值
若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值
任意节点的左、右子树也分别为二叉搜索树
没有键值相等的节点</code></pre>
<p>基于以上性质，我们可以得出一个二叉搜索树的特性：二叉搜索树的中序遍历结果为递增序列。</p>
<h2 id="二、二叉搜索树的后序遍历"><a href="#二、二叉搜索树的后序遍历" class="headerlink" title="二、二叉搜索树的后序遍历"></a>二、二叉搜索树的后序遍历</h2><pre><code>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。

例如：输入数组&#123;5,7,6,9,11,10,8&#125;，则返回Yes，因为这个整数序列是下图二叉搜索树的后序遍历结果。
       8
      / \
     6   10
    / \  / \
   5  7 9   11

如果输入数组是&#123;7,4,6,5&#125;则由于没有哪个二叉搜索树的后序遍历结果是这个序列，因此返回False</code></pre>
<p>递归：<br>    二叉树的后序遍历特点：序列的最后一个值为二叉树的根 root ；二叉搜索树左子树值都比 root 小，右子树值都比 root 大。</p>
<pre><code>所以：
1、确定找出 root；

2、遍历序列（除去root结点），找到第一个大于root的位置，则该位置左边为左子树，右边为右子树；

3、遍历右子树，若发现有小于root的值，则是不符合二叉树搜索树的规则的，则直接返回false；

4、分别判断左子树和右子树是否仍是二叉搜索树（即递归步骤1、2、3）。</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">def VerifySquenceOfBST(self, nums):</span><br><span class="line">    if nums is None or len(nums) &lt; 1:</span><br><span class="line">        return False</span><br><span class="line">    index &#x3D; 0</span><br><span class="line">    for i in range(len(nums)):</span><br><span class="line">        if nums[i] &gt; nums[-1]:</span><br><span class="line">            index &#x3D; i</span><br><span class="line">            break</span><br><span class="line"></span><br><span class="line">    for j in range(index, len(nums)):</span><br><span class="line">        if nums[j] &lt; nums[-1]:</span><br><span class="line">            return False</span><br><span class="line"></span><br><span class="line">    left &#x3D; True</span><br><span class="line">    right &#x3D; True</span><br><span class="line"></span><br><span class="line">    if len(nums[:index]) &gt; 0:</span><br><span class="line">        left &#x3D; self.VerifySquenceOfBST(nums[:index])</span><br><span class="line">    if len(nums[index:-1]) &gt; 0:</span><br><span class="line">        right &#x3D; self.VerifySquenceOfBST(nums[index:-1])</span><br><span class="line"></span><br><span class="line">    return left and right</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-10-%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-10-%E6%A0%91/" class="post-title-link" itemprop="url">数据结构与算法-10-树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-02 22:12:32" itemprop="dateCreated datePublished" datetime="2020-02-02T22:12:32+08:00">2020-02-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-26 20:03:47" itemprop="dateModified" datetime="2020-08-26T20:03:47+08:00">2020-08-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>参考文章：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/bjwu/p/9284534.html">https://www.cnblogs.com/bjwu/p/9284534.html</a></p>
<h2 id="一、如何遍历一棵树？"><a href="#一、如何遍历一棵树？" class="headerlink" title="一、如何遍历一棵树？"></a>一、如何遍历一棵树？</h2><pre><code>有两种通用的遍历树的策略：</code></pre>
<p>1、深度优先搜索（DFS）</p>
<pre><code>在这个策略中，我们采用深度作为优先级，以便从跟开始一直到达某个确定的叶子，然后再返回根到达另一个分支。

深度优先搜索策略又可以根据根节点、左孩子和右孩子的相对顺序被细分为先序遍历，中序遍历和后序遍历。</code></pre>
<p>2、宽度优先搜索（BFS）</p>
<pre><code>我们按照高度顺序一层一层的访问整棵树，高层次的节点将会比低层次的节点先被访问到。</code></pre>
<p>下图中的顶点按照访问的顺序编号，按照 1-2-3-4-5 的顺序来比较不同的策略。<br><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/tree5.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/tree5.png"></p>
<h2 id="二、二叉树的前序遍历"><a href="#二、二叉树的前序遍历" class="headerlink" title="二、二叉树的前序遍历"></a>二、二叉树的前序遍历</h2><p>递归：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Definition for a binary tree node.</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.left &#x3D; None</span><br><span class="line">#         self.right &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def preorderTraversal(self, root: TreeNode) -&gt; List[int]:</span><br><span class="line">        ans&#x3D;[]</span><br><span class="line">        if root:</span><br><span class="line">            ans.append(root.val)</span><br><span class="line">            ans+&#x3D;self.preorderTraversal(root.left) # 这儿我之前直接用append，出来的结果会列表中嵌套列表</span><br><span class="line">            ans+&#x3D;self.preorderTraversal(root.right)</span><br><span class="line">        return ans</span><br></pre></td></tr></table></figure>

<p>迭代–辅助栈（后进先出）：</p>
<pre><code>1、把二叉树的根节点 root 放进栈。

2、如果栈不为空，从栈中取出一个节点，把该节点放入容器的尾部；如果该节点的右子树不为空，则把有节点放入栈；如果该节点的左子树不为空，则把左子树放入栈中。

3、一直重复步骤 2 ，直到栈为空，此时遍历结束。</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># Definition for a binary tree node.</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.left &#x3D; None</span><br><span class="line">#         self.right &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def preorderTraversal(self, root: TreeNode) -&gt; List[int]:</span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        stack&#x3D;[]</span><br><span class="line">        stack.append(root)</span><br><span class="line">        if root is None:</span><br><span class="line">            return res</span><br><span class="line">        while stack:</span><br><span class="line">            tmp&#x3D;stack.pop()</span><br><span class="line">            res.append(tmp.val)</span><br><span class="line">            if tmp.right: # 栈后进先出，所以先放右节点</span><br><span class="line">                stack.append(tmp.right)</span><br><span class="line">            if tmp.left:</span><br><span class="line">                stack.append(tmp.left)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<p>迭代：和上面代码稍有差异，但是不如上面直观。</p>
<p>前序遍历，我们使用栈stack，由于前序遍历的顺序是中左右，所以我们每次先打印当前结点curr，并将右子结点push到栈中，然后将左子结点设为当前结点。入栈和出栈条件（当前结点curr不为None时，每一次循环将当前结点curr入栈；当前结点curr为None时，则出栈一个结点）以及循环结束条件（整个循环在stack和curr皆为None的时候结束），与中序遍历一模一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Definition for a binary tree node.</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.left &#x3D; None</span><br><span class="line">#         self.right &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def preorderTraversal(self, root: TreeNode) -&gt; List[int]:</span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        stack&#x3D;[]</span><br><span class="line">        curr&#x3D;root</span><br><span class="line">        while stack or curr:</span><br><span class="line">            if curr:</span><br><span class="line">                res.append(curr.val)</span><br><span class="line">                stack.append(curr.right)</span><br><span class="line">                curr&#x3D;curr.left</span><br><span class="line">            else:</span><br><span class="line">                curr&#x3D;stack.pop()</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<h2 id="三、二叉树的中序遍历"><a href="#三、二叉树的中序遍历" class="headerlink" title="三、二叉树的中序遍历"></a>三、二叉树的中序遍历</h2><p>递归：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># Definition for a binary tree node.</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.left &#x3D; None</span><br><span class="line">#         self.right &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def inorderTraversal(self, root: TreeNode) -&gt; List[int]:</span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        if root:</span><br><span class="line">            if root.left: # 其实这里不用再判断一次，因为递归时已经判断了。</span><br><span class="line">                res+&#x3D;(self.inorderTraversal(root.left))</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            if root.right:</span><br><span class="line">                res+&#x3D;self.inorderTraversal(root.right)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def inorderTraversal(self, root: TreeNode) -&gt; List[int]:</span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        if root:</span><br><span class="line">            res&#x3D;self.inorderTraversal(root.left) # 注意不能使用append,否则结果是[1,[3],2]，而不是[1,3,2]</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            res+&#x3D;self.inorderTraversal(root.right)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<p>更加简洁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def inorderTraversal(self, root):</span><br><span class="line">        if not root:</span><br><span class="line">            return [] </span><br><span class="line">        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)</span><br></pre></td></tr></table></figure>

<p>递归–辅助栈：</p>
<p>对于中序遍历的循环实现，每次将当前结点(curr)的左子结点push到栈中，直到当前结点(curr)为None。这时，pop出栈顶的第一个元素，设其为当前结点，并输出该结点的value值，且开始遍历该结点的右子树。</p>
<p>规律为：当前结点curr不为None时，每一次循环将当前结点curr入栈；当前结点curr为None时，则出栈一个结点，且打印出栈结点的value值。整个循环在stack和curr皆为None的时候结束。</p>
<pre><code>1、进入 while 循环，接着把根节点及其所有左子节点放入栈中。

2、从栈中取出一个节点，把该节点放入容器的尾部；如果该节点的右子节点不为空，则把右子节点及其右子节点的所有左子节点放入队列。

3、一直重复步骤 2 ，直到栈为空并且当前节点也为空则退出循环。</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Definition for a binary tree node.</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.left &#x3D; None</span><br><span class="line">#         self.right &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def inorderTraversal(self, root: TreeNode) -&gt; List[int]:</span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        stack&#x3D;[]</span><br><span class="line">        while root or stack:</span><br><span class="line">            if root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root&#x3D;root.left</span><br><span class="line">            else:</span><br><span class="line">                root&#x3D;stack.pop()</span><br><span class="line">                res.append(root.val)</span><br><span class="line">                root&#x3D;root.right</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<p>同上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def inorderTraversal(self, root: TreeNode) -&gt; List[int]:</span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        stack&#x3D;[]</span><br><span class="line">        curr&#x3D;root</span><br><span class="line">        while stack or curr:</span><br><span class="line">            if curr:</span><br><span class="line">                stack.append(curr)</span><br><span class="line">                curr&#x3D;curr.left</span><br><span class="line">            else:</span><br><span class="line">                curr&#x3D;stack.pop()</span><br><span class="line">                res.append(curr.val)</span><br><span class="line">                curr&#x3D;curr.right</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<h2 id="四、二叉树的后序遍历"><a href="#四、二叉树的后序遍历" class="headerlink" title="四、二叉树的后序遍历"></a>四、二叉树的后序遍历</h2><p>递归：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Definition for a binary tree node.</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.left &#x3D; None</span><br><span class="line">#         self.right &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def postorderTraversal(self, root: TreeNode) -&gt; List[int]:</span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        if root:</span><br><span class="line">            res&#x3D;self.postorderTraversal(root.left)</span><br><span class="line">            res+&#x3D;self.postorderTraversal(root.right)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<p>递归–辅助栈：</p>
<p>1、把二叉树的根节点 root 放进栈。</p>
<p>2、如果栈不为空，从栈中取出一个节点，把该节点插入到容器的头部。；如果该节点的左子树不为空，则把该左子树放入栈中；如果该节点的右子树不为空，则把右子树放入栈中。，</p>
<p>注意，之前的前序遍历和中序遍历，我们都是用 ArrayList 容器，并且是把节点插入到容器的尾部，这就是后序遍历的不同点。</p>
<p>3、一直重复步骤 2 ，直到栈为空，此时遍历结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># Definition for a binary tree node.</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.left &#x3D; None</span><br><span class="line">#         self.right &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def postorderTraversal(self, root: TreeNode) -&gt; List[int]:</span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        stack&#x3D;[]</span><br><span class="line">        if root is None:</span><br><span class="line">            return res</span><br><span class="line">        stack.append(root)</span><br><span class="line">        while stack:</span><br><span class="line">            tmp&#x3D;stack.pop()</span><br><span class="line">            res.insert(0,tmp.val)</span><br><span class="line">            if tmp.left:</span><br><span class="line">                stack.append(tmp.left)</span><br><span class="line">            if tmp.right:</span><br><span class="line">                stack.append(tmp.right)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<p>递归：</p>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--34/">https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--34/</a></p>
<p>如果当前节点的右节点和上一次遍历的节点相同，那就表明当前是从右节点过来的了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def postorderTraversal(self, root: TreeNode) -&gt; List[int]:</span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        stack&#x3D;[]</span><br><span class="line">        cur&#x3D;root</span><br><span class="line">        last&#x3D;None</span><br><span class="line">        </span><br><span class="line">        while cur or stack:</span><br><span class="line">            if cur:</span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur&#x3D;cur.left</span><br><span class="line">            else:</span><br><span class="line">                tmp&#x3D;stack[-1]</span><br><span class="line">                # 是否变到右子树</span><br><span class="line">                if tmp.right and tmp.right !&#x3D;last:</span><br><span class="line">                    cur&#x3D;tmp.right</span><br><span class="line">                else:</span><br><span class="line">                    res.append(tmp.val)</span><br><span class="line">                    last&#x3D;tmp</span><br><span class="line">                    stack.pop()</span><br><span class="line">        return res</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="五、二叉树的层次遍历（即逐层地，从左到右访问所有节点）"><a href="#五、二叉树的层次遍历（即逐层地，从左到右访问所有节点）" class="headerlink" title="五、二叉树的层次遍历（即逐层地，从左到右访问所有节点）"></a>五、二叉树的层次遍历（即逐层地，从左到右访问所有节点）</h2><p>递归：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># Definition for a binary tree node.</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.left &#x3D; None</span><br><span class="line">#         self.right &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line"></span><br><span class="line">    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:</span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        </span><br><span class="line">        def helper(node,depth):</span><br><span class="line">            if not node:</span><br><span class="line">                return</span><br><span class="line">            if len(res)&#x3D;&#x3D;depth:</span><br><span class="line">                res.append([])</span><br><span class="line">            res[depth].append(node.val)</span><br><span class="line">            helper(node.left,depth+1)</span><br><span class="line">            helper(node.right,depth+1)</span><br><span class="line">        helper(root,0)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>
<p>迭代：</p>
<p>思想是采用广度优先遍历，借助一个辅助队列，步骤如下：</p>
<p>1、把二叉树的根节点 root 放进队列。</p>
<p>2、如果队列不为空，取出队列的一个节点，把这个节点的左右孩子放进队列中(为空的话就不用放)，然后打印这个节点。</p>
<p>3、一直重复步骤 2 ，直到队列为空，此时遍历结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># Definition for a binary tree node.</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.left &#x3D; None</span><br><span class="line">#         self.right &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line"></span><br><span class="line">    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:</span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        queue&#x3D;[]</span><br><span class="line">        if root is None:</span><br><span class="line">            return res</span><br><span class="line">        queue.append(root)</span><br><span class="line">        while queue:</span><br><span class="line">            tmp&#x3D;queue[0]</span><br><span class="line">            res.append(tmp.val)</span><br><span class="line">            if tmp.left:</span><br><span class="line">                queue.append(tmp.left)</span><br><span class="line">            if tmp.right:</span><br><span class="line">                queue.append(tmp.right)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from collections import deque</span><br><span class="line">class Solution:</span><br><span class="line"></span><br><span class="line">    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:</span><br><span class="line">        if root is None:</span><br><span class="line">            return </span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        queue&#x3D;deque() # queue&#x3D;[]</span><br><span class="line">        queue.append(root)</span><br><span class="line">        while len(queue)&gt;0:</span><br><span class="line">            p&#x3D;queue.popleft() # p&#x3D;queue.pop(0)</span><br><span class="line">            res.append(p.val)</span><br><span class="line"></span><br><span class="line">            if p.left:</span><br><span class="line">                queue.append(p.left)</span><br><span class="line">            if p.right:</span><br><span class="line">                queue.append(p.right)</span><br><span class="line">        </span><br><span class="line">        return res</span><br><span class="line">            </span><br><span class="line">预期输出：[[3],[9,20],[15,7]]</span><br><span class="line">实际输出：[3, 9, 20, 15, 7]</span><br><span class="line"></span><br><span class="line">所以，要想得到预期输出，需要增加深度。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line"></span><br><span class="line">    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:</span><br><span class="line">        if root is None:</span><br><span class="line">            return </span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        queue&#x3D;[root] # 不能使用这个queue.append([root])</span><br><span class="line">        depth&#x3D;0</span><br><span class="line">        </span><br><span class="line">        while queue:</span><br><span class="line">            res.append([])</span><br><span class="line">            for i in range(len(queue)):</span><br><span class="line">                node&#x3D;queue.pop(0)</span><br><span class="line">                res[depth].append(node.val)</span><br><span class="line">                if node.left:</span><br><span class="line">                    queue.append(node.left)</span><br><span class="line">                if node.right:</span><br><span class="line">                    queue.append(node.right)</span><br><span class="line">            depth+&#x3D;1</span><br><span class="line">        </span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:</span><br><span class="line">        if not root: return []</span><br><span class="line">        res &#x3D; []</span><br><span class="line">        cur_level &#x3D; [root]</span><br><span class="line">        while cur_level:</span><br><span class="line">            tmp &#x3D; []</span><br><span class="line">            next_level &#x3D; []</span><br><span class="line">            for node in cur_level:</span><br><span class="line">                tmp.append(node.val)</span><br><span class="line">                if node.left:</span><br><span class="line">                    next_level.append(node.left)</span><br><span class="line">                if node.right:</span><br><span class="line">                    next_level.append(node.right)</span><br><span class="line">            res.append(tmp)</span><br><span class="line">            cur_level &#x3D; next_level</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<h2 id="六、求二叉树中任意两个结点的距离"><a href="#六、求二叉树中任意两个结点的距离" class="headerlink" title="六、求二叉树中任意两个结点的距离"></a>六、求二叉树中任意两个结点的距离</h2><p>步骤：</p>
<pre><code>（1）计算根到第一个结点的距离；
（2）计算根到第二个结点的距离；
（3）计算最近公共祖先lca；
（4）计算根到lca结点的距离；
结果为(1) + (2) - 2 * (4)，因为重复计算了两次的从跟到lca结点的距离；</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">class Node(object):</span><br><span class="line">    def __init__(self, value&#x3D;0):</span><br><span class="line">        self.value &#x3D; value</span><br><span class="line">        self.left &#x3D; None</span><br><span class="line">        self.right &#x3D; None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_path_length(root, node, path):</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    计算根到结点node的距离</span><br><span class="line">    :param root: 根</span><br><span class="line">    :param node: 结点node</span><br><span class="line">    :param path: 距离</span><br><span class="line">    :return:</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    if not root:</span><br><span class="line">        return 0</span><br><span class="line">    if root.value &#x3D;&#x3D; node:</span><br><span class="line">        return path</span><br><span class="line">    else:</span><br><span class="line">        return get_path_length(root.left, node, path + 1) or get_path_length(root.right, node, path + 1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def find_lca(root, node1, node2):</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    找到node1和node2的最近公共祖先lca</span><br><span class="line">    :param root:</span><br><span class="line">    :param node1:</span><br><span class="line">    :param node2:</span><br><span class="line">    :return:</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    if root is None:</span><br><span class="line">        return None</span><br><span class="line">    if root.value &#x3D;&#x3D; node1 or root.value &#x3D;&#x3D; node2:</span><br><span class="line">        return root</span><br><span class="line">    left &#x3D; find_lca(root.left, node1, node2)</span><br><span class="line">    right &#x3D; find_lca(root.right, node1, node2)</span><br><span class="line">    if left and right:</span><br><span class="line">        return root</span><br><span class="line">    elif left:</span><br><span class="line">        return left</span><br><span class="line">    elif right:</span><br><span class="line">        return right</span><br><span class="line">    else:</span><br><span class="line">        return None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def find_distance(root, node1, node2):</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    计算任意两个结点node1和node2之间的距离</span><br><span class="line">    :param root:</span><br><span class="line">    :param node1:</span><br><span class="line">    :param node2:</span><br><span class="line">    :return:</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    x &#x3D; get_path_length(root, node1, 0)</span><br><span class="line">    y &#x3D; get_path_length(root, node2, 0)</span><br><span class="line">    lca &#x3D; find_lca(root, node1, node2).value</span><br><span class="line">    lca_dis &#x3D; get_path_length(root, lca, 0)</span><br><span class="line">    return (x + y) - 2 * lca_dis</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    root &#x3D; Node(1)</span><br><span class="line">    root.left &#x3D; Node(2)</span><br><span class="line">    root.right &#x3D; Node(3)</span><br><span class="line">    root.left.left &#x3D; Node(4)</span><br><span class="line">    root.right.right &#x3D; Node(7)</span><br><span class="line">    root.right.left &#x3D; Node(6)</span><br><span class="line">    root.left.right &#x3D; Node(5)</span><br><span class="line">    root.right.left.right &#x3D; Node(8)</span><br><span class="line">    dist &#x3D; find_distance(root, 4, 5)</span><br><span class="line">    print(&quot;Distance between node &#123;&#125; &amp; &#123;&#125;: &#123;&#125;&quot;.format(4, 5, dist))</span><br><span class="line">    dist &#x3D; find_distance(root, 4, 6)</span><br><span class="line">    print(&quot;Distance between node &#123;&#125; &amp; &#123;&#125;: &#123;&#125;&quot;.format(4, 6, dist))</span><br><span class="line">    dist &#x3D; find_distance(root, 3, 4)</span><br><span class="line">    print(&quot;Distance between node &#123;&#125; &amp; &#123;&#125;: &#123;&#125;&quot;.format(3, 4, dist))</span><br><span class="line">    dist &#x3D; find_distance(root, 2, 4)</span><br><span class="line">    print(&quot;Distance between node &#123;&#125; &amp; &#123;&#125;: &#123;&#125;&quot;.format(2, 4, dist))</span><br><span class="line">    dist &#x3D; find_distance(root, 8, 5)</span><br><span class="line">    print(&quot;Distance between node &#123;&#125; &amp; &#123;&#125;: &#123;&#125;&quot;.format(8, 5, dist))</span><br></pre></td></tr></table></figure>






      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/LeetCode-8-%E4%B8%AD%E4%BD%8D%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/LeetCode-8-%E4%B8%AD%E4%BD%8D%E6%95%B0/" class="post-title-link" itemprop="url">LeetCode-8-中位数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-02 15:28:41" itemprop="dateCreated datePublished" datetime="2020-02-02T15:28:41+08:00">2020-02-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-18 22:37:05" itemprop="dateModified" datetime="2020-08-18T22:37:05+08:00">2020-08-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="八、中位数"><a href="#八、中位数" class="headerlink" title="八、中位数"></a>八、中位数</h2><p>首先假设我们的变量都是 int 值，二分查找中我们需要根据 start 和 end 求中点，正常情况下加起来除以 2 即可。</p>
<pre><code>int mid = (start + end) / 2</code></pre>
<p>但这样有一个缺点，我们知道int的最大值是 Integer.MAX_VALUE ，也就是2147483647（2^31-1）。那么有一个问题，如果 start = 2147483645，end = 2147483645，虽然 start 和 end都没有超出最大值，但是如果利用上边的公式，加起来的话就会造成溢出，从而导致mid计算错误。</p>
<p>解决的一个方案就是利用数学上的技巧，我们可以加一个 start 再减一个 start 将公式变形：</p>
<pre><code>(start + end) / 2 = (start + end + start - start) / 2 = start + (end - start) / 2</code></pre>
<p>然后当时和同学看到jdk源码中，求mid的方法如下，通过移位实现了除以2：</p>
<pre><code>int mid = (start + end) &gt;&gt;&gt; 1</code></pre>
<p>补码：</p>
<p>其实问题的关键就是这里了&gt;&gt;&gt; ，我们知道还有一种右移是&gt;&gt;。区别在于&gt;&gt;为有符号右移，右移以后最高位保持原来的最高位。而&gt;&gt;&gt;这个右移的话最高位补 0。</p>
<p>所以这里其实利用到了整数的补码形式，最高位其实是符号位，所以当 start + end 溢出的时候，其实本质上只是符号位收到了进位，而&gt;&gt;&gt;这个右移不仅可以把符号位右移，同时最高位只是补零，不会对数字的大小造成影响。</p>
<p>但&gt;&gt;有符号右移就会出现问题了，事实上 JDK6 之前都用的&gt;&gt;，这个 BUG 在 java 里竟然隐藏了十年之久。</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/median2.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/median2.png"><br><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/median3.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/median3.png"><br><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/median4.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/median4.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/LeetCode-6-%E8%B4%AA%E5%BF%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/LeetCode-6-%E8%B4%AA%E5%BF%83/" class="post-title-link" itemprop="url">LeetCode-6-贪心</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-31 12:09:27" itemprop="dateCreated datePublished" datetime="2020-01-31T12:09:27+08:00">2020-01-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-26 19:54:18" itemprop="dateModified" datetime="2020-08-26T19:54:18+08:00">2020-08-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="六、贪心"><a href="#六、贪心" class="headerlink" title="六、贪心"></a>六、贪心</h2><p>贪心和动态规划一样，考验的是对问题分析的能力，贪心算法解题的关键在于如何找到每次的局部最优解，动态规划则是如何找到状态转移方程。</p>
<p>什么是贪心算法呢？贪心算法可以认为是动态规划算法的一个特例，相比动态规划，使用贪心算法需要满足更多的条件（贪心选择性质），但是效率比动态规划要高。</p>
<p>比如说一个算法问题使用暴力解法需要指数级时间，如果能使用动态规划消除重叠子问题，就可以降到多项式级别的时间，如果满足贪心选择性质，那么可以进一步降低时间复杂度，达到线性级别的。</p>
<p>什么是贪心选择性质呢，简单说就是：每一步都做出一个局部最优的选择，最终的结果就是全局最优。注意哦，这是一种特殊性质，其实只有一小部分问题拥有这个性质。</p>
<p>问题：Interval Scheduling（区间调度问题）。给你很多形如[start,end]的闭区间，请你设计一个算法，算出这些区间中最多有几个互不相交的区间。</p>
<p>举个例子，intvs=[[1,3],[2,4],[3,6]]，这些区间最多有两个区间互不相交，即[[1,3],[3,6]]，你的算法应该返回 2。注意边界相同并不算相交。比如你今天有好几个活动，每个活动都可以用区间[start,end]表示开始和结束的时间，请问你今天最多能参加几个活动呢？</p>
<p>思路：</p>
<pre><code>1、从区间集合 intvs 中选择一个区间 x，这个 x 是在当前所有区间中结束最早的（end 最小）。
2、把所有与 x 区间相交的区间从区间集合 intvs 中删除。
3、重复步骤 1 和 2，直到 intvs 为空为止。之前选出的那些 x 就是最大不相交子集。</code></pre>
<p>实现：按每个区间的end数值升序排序</p>
<pre><code>步骤 1：由于我们预先按照end排了序，所以选择 x 是很容易的。关键在于，如何去除与 x 相交的区间，选择下一轮循环的 x 呢？

由于我们事先排了序，不难发现所有与 x 相交的区间必然会与 x 的end相交；如果一个区间不想与 x 的end相交，它的start必须要大于（或等于）x 的end</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def intervalSchedule(intvs):</span><br><span class="line">    if not intvs:</span><br><span class="line">        return 0</span><br><span class="line">    intvs.sort(key&#x3D;lambda x:x[1]) # 升序排序</span><br><span class="line">    count&#x3D;1 # 至少应该有1个区间不相交</span><br><span class="line">    x_end&#x3D;intvs[0][1] # 排序后，第一个区间就是x</span><br><span class="line">    for interval in intvs:</span><br><span class="line">        start&#x3D;interval[0]</span><br><span class="line">        if start &gt;&#x3D; x_end:</span><br><span class="line">            count+&#x3D;1</span><br><span class="line">            x_end&#x3D;interval[1] # 更新x</span><br><span class="line">    return count</span><br></pre></td></tr></table></figure>

<h3 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45.跳跃游戏 II"></a>45.跳跃游戏 II</h3><pre><code>链接：https://leetcode-cn.com/problems/jump-game-ii/

给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

你的目标是使用最少的跳跃次数到达数组的最后一个位置。

示例:

输入: [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
说明:

假设你总是可以到达数组的最后一个位置。</code></pre>
<p>参考：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&amp;mid=2247486128&amp;idx=2&amp;sn=bcec6b9eb7374169d823963bb7ca8415&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&amp;mid=2247486128&amp;idx=2&amp;sn=bcec6b9eb7374169d823963bb7ca8415&amp;scene=21#wechat_redirect</a></p>
<p>问题是：保证你一定可以跳到最后一格，请问你最少要跳多少次，才能跳过去？</p>
<p>题解一|从右向左搜索：</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/greepy2.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/greepy2.png"></p>
<p>时间复杂度为 O(n^2)，空间复杂度为 O(1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def jump(self, nums: List[int]) -&gt; int:</span><br><span class="line">        right&#x3D;len(nums)-1</span><br><span class="line">        sum&#x3D;0</span><br><span class="line">        while right&gt;0:</span><br><span class="line">            cur&#x3D;right-1</span><br><span class="line">            for i in range(right-2,-1,-1):</span><br><span class="line">                if (i+nums[i]) &gt;&#x3D; right:</span><br><span class="line">                    cur&#x3D;i</span><br><span class="line">            right&#x3D;cur</span><br><span class="line">            sum+&#x3D;1</span><br><span class="line">        return sum</span><br></pre></td></tr></table></figure>

<p>题解二|自顶向下的动态规划：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; memo;</span><br><span class="line">&#x2F;&#x2F; 主函数</span><br><span class="line">int jump(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    int n &#x3D; nums.size();</span><br><span class="line">    &#x2F;&#x2F; 备忘录都初始化为 n，相当于 INT_MAX</span><br><span class="line">    &#x2F;&#x2F; 因为从 0 调到 n - 1 最多 n - 1 步</span><br><span class="line">    memo &#x3D; vector&lt;int&gt;(n, n);</span><br><span class="line">    return dp(nums, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int dp(vector&lt;int&gt;&amp; nums, int p) &#123;</span><br><span class="line">    int n &#x3D; nums.size();</span><br><span class="line">    &#x2F;&#x2F; base case</span><br><span class="line">    if (p &gt;&#x3D; n - 1) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 子问题已经计算过</span><br><span class="line">    if (memo[p] !&#x3D; n) &#123;</span><br><span class="line">        return memo[p];</span><br><span class="line">    &#125;</span><br><span class="line">    int steps &#x3D; nums[p];</span><br><span class="line">    &#x2F;&#x2F; 你可以选择跳 1 步，2 步...</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; steps; i++) &#123;</span><br><span class="line">        &#x2F;&#x2F; 穷举每一个选择</span><br><span class="line">        &#x2F;&#x2F; 计算每一个子问题的结果</span><br><span class="line">        int subProblem &#x3D; dp(nums, p + i);</span><br><span class="line">        &#x2F;&#x2F; 取其中最小的作为最终结果</span><br><span class="line">        memo[p] &#x3D; min(memo[p], subProblem + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    return memo[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题解三|贪心:</p>
<p>贪心选择性质，我们不需要「递归地」计算出所有选择的具体结果然后比较求最值，而只需要做出那个最有「潜力」，看起来最优的选择即可。</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/greepy1.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/greepy1.png"></p>
<p>时间复杂度是 O(n)，空间复杂度是 O(1)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def jump(self, nums: List[int]) -&gt; int:</span><br><span class="line">        if len(nums)&lt;2:</span><br><span class="line">            return 0</span><br><span class="line">        sum,end,maxDistance&#x3D;0,0,0</span><br><span class="line">        # end代表能跳到的最远距离，maxDistance代表下一步能跳到的最远距离。</span><br><span class="line">        for i in range(len(nums)-1):</span><br><span class="line">            maxDistance&#x3D;max(maxDistance,i+nums[i])</span><br><span class="line">            if i&#x3D;&#x3D;end:</span><br><span class="line">                end&#x3D;maxDistance</span><br><span class="line">                sum+&#x3D;1</span><br><span class="line">        return sum</span><br></pre></td></tr></table></figure>

<h3 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55.跳跃游戏"></a>55.跳跃游戏</h3><pre><code>链接：https://leetcode-cn.com/problems/jump-game/

给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个位置。

示例 1:

输入: [2,3,1,1,4]
输出: true
解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。
示例 2:

输入: [3,2,1,0,4]
输出: false
解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</code></pre>
<p>题解一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def canJump(self, nums: List[int]) -&gt; bool:</span><br><span class="line">        right&#x3D;len(nums)-1</span><br><span class="line">        for i in range(len(nums)-2,-1,-1):</span><br><span class="line">            if (i+nums[i]) &gt;&#x3D; right:</span><br><span class="line">                right&#x3D;i</span><br><span class="line">        if right&#x3D;&#x3D;0:</span><br><span class="line">            return True</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure>

<p>题解二|贪心：</p>
<p>思考：<br>    通过题目中的跳跃规则，最多能跳多远？如果能够越过最后一格，返回 true，否则返回 false。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def canJump(self, nums: List[int]) -&gt; bool:</span><br><span class="line">        n&#x3D;len(nums)</span><br><span class="line">        maxDistance&#x3D;0</span><br><span class="line">        for i in range(n-1):</span><br><span class="line">            maxDistance&#x3D;max(maxDistance,i+nums[i])</span><br><span class="line">            if maxDistance &lt;&#x3D; i:</span><br><span class="line">                return False</span><br><span class="line">        return maxDistance &gt;&#x3D; n-1</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def canJump(self, nums: List[int]) -&gt; bool:</span><br><span class="line">        if len(nums)&lt;2:</span><br><span class="line">            return True</span><br><span class="line">        end,maxDistance&#x3D;0,0</span><br><span class="line">        # end代表能跳到的最远距离，maxDistance代表下一步能跳到的最远距离。</span><br><span class="line">        for i in range(len(nums)-1): # for i in range(len(nums)):</span><br><span class="line">            maxDistance&#x3D;max(maxDistance,i+nums[i])</span><br><span class="line">            if i&#x3D;&#x3D;end:</span><br><span class="line">                end&#x3D;maxDistance</span><br><span class="line">            if end &gt;&#x3D; len(nums)-1:</span><br><span class="line">                return True</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure>

<h3 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135.分发糖果"></a>135.分发糖果</h3><pre><code>链接：https://leetcode-cn.com/problems/candy/

老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。

你需要按照以下要求，帮助老师给这些孩子分发糖果：

每个孩子至少分配到 1 个糖果。
相邻的孩子中，评分高的孩子必须获得更多的糖果。
那么这样下来，老师至少需要准备多少颗糖果呢？

示例 1:

输入: [1,0,2]
输出: 5
解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。
示例 2:

输入: [1,2,2]
输出: 4
解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。
     第三个孩子只得到 1 颗糖果，这已满足上述两个条件。</code></pre>
<p>题解一：<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/candy/solution/candy-cong-zuo-zhi-you-cong-you-zhi-zuo-qu-zui-da-/">https://leetcode-cn.com/problems/candy/solution/candy-cong-zuo-zhi-you-cong-you-zhi-zuo-qu-zui-da-/</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def candy(self, ratings: List[int]) -&gt; int:</span><br><span class="line">        left&#x3D;[1 for _ in range(len(ratings))]</span><br><span class="line">        right&#x3D;left[:]</span><br><span class="line">        for i in range(1,len(ratings)):</span><br><span class="line">            if ratings[i]&gt;ratings[i-1]:</span><br><span class="line">                left[i]&#x3D;left[i-1]+1</span><br><span class="line">        count&#x3D;left[-1] # 从右向左遍历时，最后一个元素没有比较大小，所以此处计算count。</span><br><span class="line">        for i in range(len(ratings)-2,-1,-1):</span><br><span class="line">            if ratings[i]&gt;ratings[i+1]:</span><br><span class="line">                right[i]&#x3D;right[i+1]+1</span><br><span class="line">            count+&#x3D;max(left[i],right[i])</span><br><span class="line">        return count</span><br></pre></td></tr></table></figure>
<p>题解二：<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/candy/solution/fen-fa-tang-guo-by-powcai/">https://leetcode-cn.com/problems/candy/solution/fen-fa-tang-guo-by-powcai/</a></p>
<h3 id="316-去除重复字母"><a href="#316-去除重复字母" class="headerlink" title="316.去除重复字母"></a>316.去除重复字母</h3><pre><code>链接：https://leetcode-cn.com/problems/remove-duplicate-letters/

给定一个仅包含小写字母的字符串，去除字符串中重复的字母，使得每个字母只出现一次。需保证返回结果的字典序最小（要求不能打乱其他字符的相对位置）。

示例 1:

输入: &quot;bcabc&quot;
输出: &quot;abc&quot;
示例 2:

输入: &quot;cbacdcbc&quot;
输出: &quot;acdb&quot;</code></pre>
<p>名词解释：</p>
<pre><code>字典序：对于字符而言，按 ascii 码值进行比较，小的排在前，大的排在后。对于字符串，从第 0 位字符开始比较，ascii 码数值小的排在前面，如果相同，就延后一位比较 ascii 码值大小。

子序列：子序列不同于子串，子串要求它们在原串中连续，而子序列则不要求连续。例如acd是abcd的子序列，但不是子串。</code></pre>
<p>?题解一（递归）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def removeDuplicateLetters(self, s: str) -&gt; str:</span><br><span class="line">        for i in sorted(set(s)):</span><br><span class="line">            tmp&#x3D;s[s.index(i):]</span><br><span class="line">            if len(set(tmp)) &#x3D;&#x3D; len(set(s)):</span><br><span class="line">                return i+self.removeDuplicateLetters(tmp.replace(i,&#39;&#39;))</span><br><span class="line">        return &#39;&#39;</span><br></pre></td></tr></table></figure>
<p>?题解二（迭代）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def removeDuplicateLetters(self, s: str) -&gt; str:</span><br><span class="line">        res &#x3D; &quot;&quot;</span><br><span class="line">        while s:</span><br><span class="line">            # 从右往左找，找到最小位置的索引号</span><br><span class="line">            loc &#x3D; min(map(s.rindex, s))</span><br><span class="line">            # 找该索引前面最小的字母</span><br><span class="line">            a &#x3D; min(s[:loc + 1])</span><br><span class="line">            res +&#x3D; a</span><br><span class="line">            s &#x3D; s[s.index(a):].replace(a, &quot;&quot;)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>
<p>题解三(栈):<br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&amp;mid=2247486367&amp;idx=2&amp;sn=b25c0701241325f644acda12599ec06a&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&amp;mid=2247486367&amp;idx=2&amp;sn=b25c0701241325f644acda12599ec06a&amp;scene=21#wechat_redirect</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def removeDuplicateLetters(self, s: str) -&gt; str:</span><br><span class="line">        from collections import Counter</span><br><span class="line">        count&#x3D;Counter(s)</span><br><span class="line">        stack&#x3D;[]</span><br><span class="line">        existed&#x3D;set()</span><br><span class="line">        for i in s:</span><br><span class="line">            if i not in existed:</span><br><span class="line">                while stack and stack[-1]&gt;i and count[stack[-1]]&gt;0:</span><br><span class="line">                    existed.remove(stack.pop())</span><br><span class="line">                stack.append(i)</span><br><span class="line">                existed.add(i)</span><br><span class="line">            count[i]-&#x3D;1</span><br><span class="line">        return &#39;&#39;.join(stack)</span><br></pre></td></tr></table></figure>

<h3 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435.无重叠区间"></a>435.无重叠区间</h3><pre><code>链接:https://leetcode-cn.com/problems/non-overlapping-intervals/

给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。

注意:

可以认为区间的终点总是大于它的起点。
区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。
示例 1:

输入: [ [1,2], [2,3], [3,4], [1,3] ]

输出: 1

解释: 移除 [1,3] 后，剩下的区间没有重叠。
示例 2:

输入: [ [1,2], [1,2], [1,2] ]

输出: 2

解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。
示例 3:

输入: [ [1,2], [2,3] ]

输出: 0

解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</code></pre>
<p>已经会求最多有几个区间不会重叠了，那么剩下的不就是至少需要去除的区间吗？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def eraseOverlapIntervals(intervals) &#123;</span><br><span class="line">    n&#x3D;len(intervals)</span><br><span class="line">    return n - intervalSchedule(intervals);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题解一（贪心）:</p>
<pre><code>先计算能组成不重叠最多区间个数： 
（1）按区间结尾排序
（2）每次选择结尾最小，且与前一个区间不重叠</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def eraseOverlapIntervals(self, intervals: List[List[int]]) -&gt; int:</span><br><span class="line">        if not intervals:</span><br><span class="line">            return 0</span><br><span class="line">        intervals.sort(key&#x3D;lambda x:x[1])</span><br><span class="line"></span><br><span class="line">        curr&#x3D;0</span><br><span class="line">        count&#x3D;1</span><br><span class="line">        for i in range(1,len(intervals)):</span><br><span class="line">            if intervals[i][0]&gt;&#x3D;intervals[curr][1]:</span><br><span class="line">                curr&#x3D;i</span><br><span class="line">                count+&#x3D;1</span><br><span class="line">        return len(intervals)-count</span><br></pre></td></tr></table></figure>

<h3 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452. 用最少数量的箭引爆气球"></a>452. 用最少数量的箭引爆气球</h3><pre><code>链接：https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/

在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以y坐标并不重要，因此只要知道开始和结束的x坐标就足够了。开始坐标总是小于结束坐标。平面内最多存在104个气球。

一支弓箭可以沿着x轴从不同点完全垂直地射出。在坐标x处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。

Example:

输入:
[[10,16], [2,8], [1,6], [7,12]]

输出:
2

解释:
对于该样例，我们可以在x = 6（射爆[2,8],[1,6]两个气球）和 x = 11（射爆另外两个气球）。</code></pre>
<p>思考：</p>
<p>只是有一点不一样，在intervalSchedule算法中，如果两个区间的边界触碰，不算重叠；而按照这道题目的描述，箭头如果碰到气球的边界气球也会爆炸，所以说相当于区间的边界触碰也算重叠。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findMinArrowShots(self, points: List[List[int]]) -&gt; int:</span><br><span class="line">        if not points:</span><br><span class="line">            return 0</span><br><span class="line">        points.sort(key&#x3D;lambda x:x[1])</span><br><span class="line">        n&#x3D;len(points)</span><br><span class="line">        count&#x3D;1</span><br><span class="line">        x_end&#x3D;points[0][1]</span><br><span class="line">        for point in points:</span><br><span class="line">            start&#x3D;point[0]</span><br><span class="line">            if start &gt; x_end:</span><br><span class="line">                count+&#x3D;1</span><br><span class="line">                x_end&#x3D;point[1]</span><br><span class="line">        return count</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/LeetCode-9-%E5%9B%9E%E6%BA%AF%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/LeetCode-9-%E5%9B%9E%E6%BA%AF%E6%B3%95/" class="post-title-link" itemprop="url">LeetCode-9-回溯法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-21 17:20:06" itemprop="dateCreated datePublished" datetime="2020-01-21T17:20:06+08:00">2020-01-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-26 16:46:56" itemprop="dateModified" datetime="2020-08-26T16:46:56+08:00">2020-08-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>参考文章：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaomangxie/p/10208441.html">https://www.cnblogs.com/xiaomangxie/p/10208441.html</a><br>参考文章：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-xiang-jie-by-labuladong-2/">https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-xiang-jie-by-labuladong-2/</a></p>
<h2 id="九、回溯法"><a href="#九、回溯法" class="headerlink" title="九、回溯法"></a>九、回溯法</h2><p>回溯法（back tracking）（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</p>
<p>解决一个回溯问题，实际上就是一个决策树的遍历过程。你只需要思考 3 个问题：</p>
<pre><code>1、路径：也就是已经做出的选择。

2、选择列表：也就是你当前可以做的选择。

3、结束条件：也就是到达决策树底层，无法再做选择的条件。</code></pre>
<p>回溯算法的框架: 其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result &#x3D; []</span><br><span class="line">def backtrack(路径, 选择列表):</span><br><span class="line">    if 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        return</span><br><span class="line">    </span><br><span class="line">    for 选择 in 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure>

<pre><code>「路径」，记录你已经做过的选择；
「选择列表」，表示你当前可以做出的选择；
「结束条件」就是遍历到树的底层，在这里就是选择列表为空的时候。</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for 选择 in 选择列表:</span><br><span class="line">    # 做选择</span><br><span class="line">    将该选择从选择列表移除</span><br><span class="line">    路径.add(选择)</span><br><span class="line">    backtrack(路径, 选择列表)</span><br><span class="line">    # 撤销选择</span><br><span class="line">    路径.remove(选择)</span><br><span class="line">    将该选择再加入选择列表</span><br></pre></td></tr></table></figure>

<h3 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a>17. 电话号码的字母组合</h3><pre><code>链接：https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/

给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

示例:

输入：&quot;23&quot;
输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].
说明:
尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</code></pre>
<p>题解一|暴力：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def letterCombinations(self, digits: str) -&gt; List[str]:</span><br><span class="line">        key_all&#x3D;&#123;</span><br><span class="line">            &#39;2&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;],</span><br><span class="line">            &#39;3&#39;: [&#39;d&#39;, &#39;e&#39;, &#39;f&#39;],</span><br><span class="line">            &#39;4&#39;: [&#39;g&#39;, &#39;h&#39;, &#39;i&#39;],</span><br><span class="line">            &#39;5&#39;: [&#39;j&#39;, &#39;k&#39;, &#39;l&#39;],</span><br><span class="line">            &#39;6&#39;: [&#39;m&#39;, &#39;n&#39;, &#39;o&#39;],</span><br><span class="line">            &#39;7&#39;: [&#39;p&#39;, &#39;q&#39;, &#39;r&#39;, &#39;s&#39;],</span><br><span class="line">            &#39;8&#39;: [&#39;t&#39;, &#39;u&#39;, &#39;v&#39;],</span><br><span class="line">            &#39;9&#39;: [&#39;w&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;]</span><br><span class="line">        &#125;</span><br><span class="line">        if digits&#x3D;&#x3D;&#39;&#39;:</span><br><span class="line">            return &#39;&#39;</span><br><span class="line">        ans&#x3D;[&#39;&#39;]</span><br><span class="line">        for num in digits:</span><br><span class="line">            ans&#x3D;[pre+suf for pre in ans for suf in key_all[num]]</span><br><span class="line">        return ans</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def letterCombinations(self, digits):</span><br><span class="line">        key_all&#x3D;&#123;</span><br><span class="line">            &#39;2&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;],</span><br><span class="line">            &#39;3&#39;: [&#39;d&#39;, &#39;e&#39;, &#39;f&#39;],</span><br><span class="line">            &#39;4&#39;: [&#39;g&#39;, &#39;h&#39;, &#39;i&#39;],</span><br><span class="line">            &#39;5&#39;: [&#39;j&#39;, &#39;k&#39;, &#39;l&#39;],</span><br><span class="line">            &#39;6&#39;: [&#39;m&#39;, &#39;n&#39;, &#39;o&#39;],</span><br><span class="line">            &#39;7&#39;: [&#39;p&#39;, &#39;q&#39;, &#39;r&#39;, &#39;s&#39;],</span><br><span class="line">            &#39;8&#39;: [&#39;t&#39;, &#39;u&#39;, &#39;v&#39;],</span><br><span class="line">            &#39;9&#39;: [&#39;w&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;]</span><br><span class="line">        &#125;</span><br><span class="line">        if digits&#x3D;&#x3D;&#39;&#39;:</span><br><span class="line">            return &#39;&#39;</span><br><span class="line">        ans&#x3D;[&#39;&#39;]</span><br><span class="line">        for num in digits:</span><br><span class="line">            tmp&#x3D;[]</span><br><span class="line">            for pre in ans:</span><br><span class="line">                for suf in key_all[num]:</span><br><span class="line">                    tmp.append(pre+suf)</span><br><span class="line">            ans&#x3D;tmp[:]</span><br><span class="line">        return ans</span><br></pre></td></tr></table></figure>

<p>题解二|回溯：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def letterCombinations(self, digits: str) -&gt; List[str]:</span><br><span class="line">        if not digits:</span><br><span class="line">            return []</span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        hash&#x3D;&#123;</span><br><span class="line">            1:&#39;&#39;,</span><br><span class="line">            2:&#39;abc&#39;,</span><br><span class="line">            3:&#39;def&#39;,</span><br><span class="line">            4:&#39;ghi&#39;,</span><br><span class="line">            5:&#39;jkl&#39;,</span><br><span class="line">            6:&#39;mno&#39;,</span><br><span class="line">            7:&#39;pqrs&#39;,</span><br><span class="line">            8:&#39;tuv&#39;,</span><br><span class="line">            9:&#39;wxyz&#39;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        def traceback(digits,index,path):</span><br><span class="line">            if index &#x3D;&#x3D; len(digits):</span><br><span class="line">                res.append(&#39;&#39;.join(path))</span><br><span class="line">                return</span><br><span class="line">            </span><br><span class="line">            digit&#x3D;int(digits[index])</span><br><span class="line">            for i in hash.get(digit,[]):</span><br><span class="line">                path.append(i)</span><br><span class="line">                traceback(digits,index+1,path)</span><br><span class="line">                path.pop()</span><br><span class="line">        traceback(digits,0,[])</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<h3 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a>22. 括号生成</h3><pre><code>链接：https://leetcode-cn.com/problems/generate-parentheses/

数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。

示例：

输入：n = 3
输出：[
       &quot;((()))&quot;,
       &quot;(()())&quot;,
       &quot;(())()&quot;,
       &quot;()(())&quot;,
       &quot;()()()&quot;
     ]</code></pre>
<p>题解一|暴力：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def generateParenthesis(self, n: int) -&gt; List[str]:</span><br><span class="line">        def generate(A):</span><br><span class="line">            if len(A) &#x3D;&#x3D; 2*n:</span><br><span class="line">                if valid(A):</span><br><span class="line">                    ans.append(&quot;&quot;.join(A))</span><br><span class="line">            else:</span><br><span class="line">                A.append(&#39;(&#39;)</span><br><span class="line">                generate(A)</span><br><span class="line">                A.pop()</span><br><span class="line">                A.append(&#39;)&#39;)</span><br><span class="line">                generate(A)</span><br><span class="line">                A.pop()</span><br><span class="line"></span><br><span class="line">        def valid(A):</span><br><span class="line">            bal &#x3D; 0</span><br><span class="line">            for c in A:</span><br><span class="line">                if c &#x3D;&#x3D; &#39;(&#39;: bal +&#x3D; 1</span><br><span class="line">                else: bal -&#x3D; 1</span><br><span class="line">                if bal &lt; 0: return False</span><br><span class="line">            return bal &#x3D;&#x3D; 0</span><br><span class="line"></span><br><span class="line">        ans &#x3D; []</span><br><span class="line">        generate([])</span><br><span class="line">        return ans</span><br></pre></td></tr></table></figure>

<p>题解二|回溯：</p>
<p>可以只在序列仍然保持有效时才添加 ‘(‘ or ‘)’，而不是像 方法一 那样每次添加。</p>
<p>我们可以通过跟踪到目前为止放置的左括号和右括号的数目来做到这一点，</p>
<p>如果左括号数量不大于 n，我们可以放一个左括号。如果右括号数量小于左括号的数量，我们可以放一个右括号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def generateParenthesis(self, n: int) -&gt; List[str]:</span><br><span class="line">        </span><br><span class="line">        def backtrace(S,left,right):</span><br><span class="line">            if len(S) &#x3D;&#x3D; 2*n:</span><br><span class="line">                res.append(&#39;&#39;.join(S))</span><br><span class="line">                return</span><br><span class="line">            </span><br><span class="line">            if left &lt; n:</span><br><span class="line">                S.append(&#39;(&#39;)</span><br><span class="line">                backtrace(S,left+1,right)</span><br><span class="line">                S.pop()</span><br><span class="line">            if right &lt; left:</span><br><span class="line">                S.append(&#39;)&#39;)</span><br><span class="line">                backtrace(S,left,right+1)</span><br><span class="line">                S.pop()</span><br><span class="line"></span><br><span class="line">        res &#x3D; []</span><br><span class="line">        backtrace([],0,0)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def generateParenthesis(self, n: int) -&gt; List[str]:</span><br><span class="line">        </span><br><span class="line">        def backtrace(S,index):</span><br><span class="line">            if len(S) &#x3D;&#x3D; 2*n:</span><br><span class="line">                if index &#x3D;&#x3D; 0:</span><br><span class="line">                    res.append(&#39;&#39;.join(S))</span><br><span class="line">                return</span><br><span class="line">            </span><br><span class="line">            if index &lt; n:</span><br><span class="line">                S.append(&#39;(&#39;)</span><br><span class="line">                backtrace(S,index+1)</span><br><span class="line">                S.pop()</span><br><span class="line">            if index &gt; 0:</span><br><span class="line">                S.append(&#39;)&#39;)</span><br><span class="line">                backtrace(S,index-1)</span><br><span class="line">                S.pop()</span><br><span class="line"></span><br><span class="line">        res &#x3D; []</span><br><span class="line">        backtrace([],0)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<p>题解三|递归：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def generateParenthesis(self, n: int) -&gt; List[str]:</span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        def helper(left,right,n,s):</span><br><span class="line">            if left&#x3D;&#x3D;n and right&#x3D;&#x3D;n:</span><br><span class="line">                res.append(s)</span><br><span class="line">                return</span><br><span class="line">            if left &lt; n:</span><br><span class="line">                helper(left+1,right,n,s+&#39;(&#39;)</span><br><span class="line">            if left &gt; right:</span><br><span class="line">            # if left &gt; right and right &lt; n:</span><br><span class="line">                helper(left,right+1,n,s+&#39;)&#39;)</span><br><span class="line"></span><br><span class="line">        helper(0,0,n,&#39;&#39;)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>
<h3 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37. 解数独"></a>37. 解数独</h3><pre><code>链接：https://leetcode-cn.com/problems/sudoku-solver/

编写一个程序，通过已填充的空格来解决数独问题。

一个数独的解法需遵循如下规则：

数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。
空白格用 &#39;.&#39; 表示。

一个数独。

答案被标成红色。

Note:

给定的数独序列只包含数字 1-9 和字符 &#39;.&#39; 。
你可以假设给定的数独只有唯一解。
给定数独永远是 9x9 形式的。</code></pre>
<p>题解一|回溯：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def solveSudoku(self, board: List[List[str]]) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Do not return anything, modify board in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        def backtrace(board,i,j):</span><br><span class="line">            m,n&#x3D;9,9</span><br><span class="line">            if j&#x3D;&#x3D;n: # 走到9越界，进入下一行</span><br><span class="line">                return backtrace(board,i+1,0)</span><br><span class="line">            if i&#x3D;&#x3D;m: # 走到最后一行，找到一个可行解</span><br><span class="line">                return True</span><br><span class="line">            if board[i][j] !&#x3D; &#39;.&#39;: # 当前是预设数字，直接跳到下一个</span><br><span class="line">                return backtrace(board,i,j+1)</span><br><span class="line">            chars&#x3D;[str(i) for i in range(1,10)]</span><br><span class="line">            for char in chars:</span><br><span class="line">                if not isValid(board,i,j,char): # 遇到不合法的数字，跳过</span><br><span class="line">                    continue</span><br><span class="line"></span><br><span class="line">                board[i][j]&#x3D;char # 做选择</span><br><span class="line">                if backtrace(board,i,j+1): # 如果找到一个可行解，立即结束</span><br><span class="line">                    return True</span><br><span class="line">                board[i][j]&#x3D;&#39;.&#39; # 撤销选择</span><br><span class="line">            return False</span><br><span class="line"></span><br><span class="line">        def isValid(board,r,c,char):</span><br><span class="line">            for i in range(9):</span><br><span class="line">                # 判断行是否存在重复</span><br><span class="line">                if board[r][i] &#x3D;&#x3D; char:</span><br><span class="line">                    return False</span><br><span class="line">                # 判断列是否存在重复</span><br><span class="line">                if board[i][c] &#x3D;&#x3D; char:</span><br><span class="line">                    return False</span><br><span class="line">                # 判断 3 * 3 方框是否存在重复</span><br><span class="line">                if board[(r&#x2F;&#x2F;3)*3+i&#x2F;&#x2F;3][(c&#x2F;&#x2F;3)*3+i%3] &#x3D;&#x3D; char:</span><br><span class="line">                    return False</span><br><span class="line">            return True</span><br><span class="line">        backtrace(board,0,0)</span><br></pre></td></tr></table></figure>

<h3 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a>39. 组合总和</h3><pre><code>链接：https://leetcode-cn.com/problems/combination-sum/

给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的数字可以无限制重复被选取。

说明：

所有数字（包括 target）都是正整数。
解集不能包含重复的组合。 
示例 1:

输入: candidates = [2,3,6,7], target = 7,
所求解集为:
[
  [7],
  [2,2,3]
]
示例 2:

输入: candidates = [2,3,5], target = 8,
所求解集为:
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]</code></pre>
<p>题解一（回溯）:<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/">https://leetcode-cn.com/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def combinationSum(self, candidates: List[int], target: int) -&gt; List[List[int]]:</span><br><span class="line">        size&#x3D;len(candidates)</span><br><span class="line">        if size&#x3D;&#x3D;0:</span><br><span class="line">            return []</span><br><span class="line">            </span><br><span class="line">        candidates.sort()</span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        path&#x3D;[]</span><br><span class="line">        return self.helper(candidates,0,size,target,res,path)</span><br><span class="line">    def helper(self,candidates,begin,size,target,res,path):</span><br><span class="line">        if target&#x3D;&#x3D;0:</span><br><span class="line">            res.append(path[:])</span><br><span class="line">        for i in range(begin,size):</span><br><span class="line">            residue&#x3D;target-candidates[i]</span><br><span class="line">            if residue &lt; 0:</span><br><span class="line">                break</span><br><span class="line">            path.append(candidates[i])</span><br><span class="line">            self.helper(candidates,i,size,residue,res,path)</span><br><span class="line">            path.pop()</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def combinationSum(self, candidates: List[int], target: int) -&gt; List[List[int]]:</span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        def backtrace(candidates,start,path,target):</span><br><span class="line">            if target&#x3D;&#x3D;0:</span><br><span class="line">                # res.append(path[:])</span><br><span class="line">                res.append(path+[])</span><br><span class="line">                return</span><br><span class="line"></span><br><span class="line">            for i in range(start,len(candidates)):</span><br><span class="line">                tmp&#x3D;target-candidates[i]</span><br><span class="line">                if tmp &lt; 0:</span><br><span class="line">                    continue</span><br><span class="line">                path.append(candidates[i])</span><br><span class="line">                backtrace(candidates,i,path,tmp) # 注意此处i的取值</span><br><span class="line">                path.pop()</span><br><span class="line">        </span><br><span class="line">        backtrace(candidates,0,[],target)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>
<h3 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40.组合总和 II"></a>40.组合总和 II</h3><pre><code>链接：https://leetcode-cn.com/problems/combination-sum-ii/

给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的每个数字在每个组合中只能使用一次。

说明：

所有数字（包括目标数）都是正整数。
解集不能包含重复的组合。 
示例 1:

输入: candidates = [10,1,2,7,6,1,5], target = 8,
所求解集为:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
示例 2:

输入: candidates = [2,5,2,1,2], target = 5,
所求解集为:
[
  [1,2,2],
  [5]
]</code></pre>
<p>这道题与上一问的区别在于：</p>
<p>第 39 题：candidates 中的数字可以无限制重复被选取。<br>第 40 题：candidates 中的每个数字在每个组合中只能使用一次。<br>编码的不同在于下一层递归的起始索引不一样。</p>
<p>第 39 题：还从候选数组的当前索引值开始。<br>第 40 题：从候选数组的当前索引值的下一位开始。<br>相同之处：解集不能包含重复的组合。</p>
<p>题解一（回溯）:<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum-ii/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-3/">https://leetcode-cn.com/problems/combination-sum-ii/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-3/</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def combinationSum2(self, candidates: List[int], target: int) -&gt; List[List[int]]:</span><br><span class="line">        size&#x3D;len(candidates)</span><br><span class="line">        if size&#x3D;&#x3D;0:</span><br><span class="line">            return []</span><br><span class="line">            </span><br><span class="line">        candidates.sort()</span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        path&#x3D;[]</span><br><span class="line">        return self.helper(candidates,0,size,target,res,path)</span><br><span class="line">    def helper(self,candidates,begin,size,target,res,path):</span><br><span class="line">        if target&#x3D;&#x3D;0:</span><br><span class="line">            res.append(path[:])</span><br><span class="line">        for i in range(begin,size):</span><br><span class="line">            residue&#x3D;target-candidates[i]</span><br><span class="line">            if residue &lt; 0:</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">            if i &gt; begin and candidates[i-1] &#x3D;&#x3D; candidates[i]:</span><br><span class="line">                continue</span><br><span class="line"></span><br><span class="line">            path.append(candidates[i])</span><br><span class="line">            self.helper(candidates,i+1,size,residue,res,path)</span><br><span class="line">            path.pop()</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>


<p>去重：无论是求组合/子集/排列，只要原数组中含有重复元素，通用一个去重方法：</p>
<pre><code>1.先排序，使相同元素相邻；
2.在backtrack的for循环里：
    if(i&gt;start &amp;&amp; candidates[i]==candidates[i-1]) continue;</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">这个避免重复当思想是在是太重要了。</span><br><span class="line">这个方法最重要的作用是，可以让同一层级，不出现相同的元素。即</span><br><span class="line">                  1</span><br><span class="line">                 &#x2F; \</span><br><span class="line">                2   2  这种情况不会发生 但是却允许了不同层级之间的重复即：</span><br><span class="line">               &#x2F;     \</span><br><span class="line">              5       5</span><br><span class="line">                例2</span><br><span class="line">                  1</span><br><span class="line">                 &#x2F;</span><br><span class="line">                2      这种情况确是允许的</span><br><span class="line">               &#x2F;</span><br><span class="line">              2  </span><br><span class="line">                </span><br><span class="line">为何会有这种神奇的效果呢？</span><br><span class="line">首先 i-1 &#x3D;&#x3D; i 是用于判定当前元素是否和之前元素相同的语句。这个语句就能砍掉例1。</span><br><span class="line">可是问题来了，如果把所有当前与之前一个元素相同的都砍掉，那么例二的情况也会消失。 </span><br><span class="line">因为当第二个2出现的时候，他就和前一个2相同了。</span><br><span class="line">                </span><br><span class="line">那么如何保留例2呢？</span><br><span class="line">那么就用i &gt; start 来避免这种情况，你发现例1中的两个2是处在同一个层级上的，</span><br><span class="line">例2的两个2是处在不同层级上的。</span><br><span class="line">在一个for循环中，所有被遍历到的数都是属于一个层级的。我们要让一个层级中，</span><br><span class="line">必须出现且只出现一个2，那么就放过第一个出现重复的2，但不放过后面出现的2。</span><br><span class="line">第一个出现的2的特点就是 i &#x3D;&#x3D; start. 第二个出现的2 特点是i &gt; start.</span><br><span class="line"></span><br><span class="line">再通俗点，就是有重复元素的话，比如测试用例中的第一个1和第二个1，都会有1,7组成8，这样就产生了重复的list。因为都是从当前数开始遍历，所以加这一层的意思就是过滤掉重复的数，但是第一个1依然能使用第二个1，而第二个1是失去了作用的。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def combinationSum2(self, candidates: List[int], target: int) -&gt; List[List[int]]:</span><br><span class="line">        if not candidates:</span><br><span class="line">            return []</span><br><span class="line">        candidates.sort()</span><br><span class="line">        res&#x3D;[]</span><br><span class="line"></span><br><span class="line">        def backtrace(candidates,start,path,target):</span><br><span class="line">            if target&#x3D;&#x3D;0:</span><br><span class="line">                return res.append(path[:])</span><br><span class="line">            for i in range(start,len(candidates)):</span><br><span class="line">                tmp&#x3D;target-candidates[i]</span><br><span class="line">                if tmp &lt; 0:</span><br><span class="line">                    continue</span><br><span class="line">                if i &gt; start and candidates[i] &#x3D;&#x3D; candidates[i-1]:</span><br><span class="line">                    continue</span><br><span class="line">                path.append(candidates[i])</span><br><span class="line">                backtrace(candidates,i+1,path,tmp) # 此处是i+1</span><br><span class="line">                path.pop()</span><br><span class="line">        </span><br><span class="line">        backtrace(candidates,0,[],target)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>
<h3 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46.全排列"></a>46.全排列</h3><pre><code>链接：https://leetcode-cn.com/problems/permutations/

给定一个没有重复数字的序列，返回其所有可能的全排列。

示例:

输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]</code></pre>
<p>题解一（回溯）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def permute(self, nums: List[int]) -&gt; List[List[int]]:</span><br><span class="line">        </span><br><span class="line">        def backtrack(first&#x3D;0):</span><br><span class="line">            if first&#x3D;&#x3D;lens:</span><br><span class="line">                output.append(nums[:])</span><br><span class="line">            for i in range(first,lens):</span><br><span class="line">                nums[first],nums[i]&#x3D;nums[i],nums[first]</span><br><span class="line">                backtrack(first+1) # 注意：不能使用i+1，否则会出现[[1,2,3],[1,3,2],[2,1,3],[3,2,1]]</span><br><span class="line">                nums[first],nums[i]&#x3D;nums[i],nums[first]</span><br><span class="line">        </span><br><span class="line">        lens&#x3D;len(nums)</span><br><span class="line">        output&#x3D;[]</span><br><span class="line">        backtrack()</span><br><span class="line">        return output</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def permute(self, nums):</span><br><span class="line">        def backtrack(first&#x3D;0):</span><br><span class="line">            # if all integers are used up</span><br><span class="line">            print(&#39;---------------first&#39;, first)</span><br><span class="line">            if first &#x3D;&#x3D; n:</span><br><span class="line">                output.append(nums[:])</span><br><span class="line">                print(&#39;output:&#39;,output)</span><br><span class="line">            for i in range(first, n):</span><br><span class="line">                # place i-th integer first</span><br><span class="line">                # in the current permutation</span><br><span class="line">                print(&#39;i,first:&#39;,i, first)</span><br><span class="line">                print(nums[i], nums[first])</span><br><span class="line">                nums[first], nums[i] &#x3D; nums[i], nums[first]</span><br><span class="line">                # use next integers to complete the permutations</span><br><span class="line">                backtrack(first + 1)</span><br><span class="line">                # backtrack</span><br><span class="line">                nums[first], nums[i] &#x3D; nums[i], nums[first]</span><br><span class="line">                print(&#39;2:i,first:&#39;, i, first)</span><br><span class="line">                print(&#39;2:&#39;, nums[i], nums[first])</span><br><span class="line"></span><br><span class="line">        n &#x3D; len(nums)</span><br><span class="line">        output &#x3D; []</span><br><span class="line">        backtrack()</span><br><span class="line">        return output</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">---------------first 0</span><br><span class="line">i,first: 0 0</span><br><span class="line">1 1</span><br><span class="line">---------------first 1</span><br><span class="line">i,first: 1 1</span><br><span class="line">2 2</span><br><span class="line">---------------first 2</span><br><span class="line">i,first: 2 2</span><br><span class="line">3 3</span><br><span class="line">---------------first 3</span><br><span class="line">output: [[1, 2, 3]]</span><br><span class="line">2:i,first: 2 2</span><br><span class="line">2: 3 3</span><br><span class="line">2:i,first: 1 1</span><br><span class="line">2: 2 2</span><br><span class="line">i,first: 2 1</span><br><span class="line">3 2</span><br><span class="line">---------------first 2</span><br><span class="line">i,first: 2 2</span><br><span class="line">2 2</span><br><span class="line">---------------first 3</span><br><span class="line">output: [[1, 2, 3], [1, 3, 2]]</span><br><span class="line">2:i,first: 2 2</span><br><span class="line">2: 2 2</span><br><span class="line">2:i,first: 2 1</span><br><span class="line">2: 3 2</span><br><span class="line">2:i,first: 0 0</span><br><span class="line">2: 1 1</span><br><span class="line">i,first: 1 0</span><br><span class="line">2 1</span><br><span class="line">---------------first 1</span><br><span class="line">i,first: 1 1</span><br><span class="line">1 1</span><br><span class="line">---------------first 2</span><br><span class="line">i,first: 2 2</span><br><span class="line">3 3</span><br><span class="line">---------------first 3</span><br><span class="line">output: [[1, 2, 3], [1, 3, 2], [2, 1, 3]]</span><br><span class="line">2:i,first: 2 2</span><br><span class="line">2: 3 3</span><br><span class="line">2:i,first: 1 1</span><br><span class="line">2: 1 1</span><br><span class="line">i,first: 2 1</span><br><span class="line">3 1</span><br><span class="line">---------------first 2</span><br><span class="line">i,first: 2 2</span><br><span class="line">1 1</span><br><span class="line">---------------first 3</span><br><span class="line">output: [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1]]</span><br><span class="line">2:i,first: 2 2</span><br><span class="line">2: 1 1</span><br><span class="line">2:i,first: 2 1</span><br><span class="line">2: 3 1</span><br><span class="line">2:i,first: 1 0</span><br><span class="line">2: 2 1</span><br><span class="line">i,first: 2 0</span><br><span class="line">3 1</span><br><span class="line">---------------first 1</span><br><span class="line">i,first: 1 1</span><br><span class="line">2 2</span><br><span class="line">---------------first 2</span><br><span class="line">i,first: 2 2</span><br><span class="line">1 1</span><br><span class="line">---------------first 3</span><br><span class="line">output: [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1]]</span><br><span class="line">2:i,first: 2 2</span><br><span class="line">2: 1 1</span><br><span class="line">2:i,first: 1 1</span><br><span class="line">2: 2 2</span><br><span class="line">i,first: 2 1</span><br><span class="line">1 2</span><br><span class="line">---------------first 2</span><br><span class="line">i,first: 2 2</span><br><span class="line">2 2</span><br><span class="line">---------------first 3</span><br><span class="line">output: [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]</span><br><span class="line">2:i,first: 2 2</span><br><span class="line">2: 2 2</span><br><span class="line">2:i,first: 2 1</span><br><span class="line">2: 1 2</span><br><span class="line">2:i,first: 2 0</span><br><span class="line">2: 3 1</span><br></pre></td></tr></table></figure>

<h3 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a>47. 全排列 II</h3><pre><code>链接：https://leetcode-cn.com/problems/permutations-ii/

给定一个可包含重复数字的序列，返回所有不重复的全排列。

示例:

输入: [1,1,2]
输出:
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]</code></pre>
<p>题解一（回溯）：<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations-ii/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2/">https://leetcode-cn.com/problems/permutations-ii/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2/</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def permuteUnique(self, nums: List[int]) -&gt; List[List[int]]:</span><br><span class="line">        </span><br><span class="line">        def backtrack(first&#x3D;0):</span><br><span class="line">            if first&#x3D;&#x3D;lens:</span><br><span class="line">                output.append(nums[:])</span><br><span class="line">            for i in range(first,lens):</span><br><span class="line">                if not duplicat(nums,first,i):</span><br><span class="line">                    continue</span><br><span class="line">                nums[first],nums[i]&#x3D;nums[i],nums[first]</span><br><span class="line">                backtrack(first+1) # 注意：不能使用i+1，否则会出现[[1,2,3],[1,3,2],[2,1,3],[3,2,1]]</span><br><span class="line">                nums[first],nums[i]&#x3D;nums[i],nums[first]</span><br><span class="line"></span><br><span class="line">        def duplicat(nums,begin,end):</span><br><span class="line">            i&#x3D;begin</span><br><span class="line">            while i&lt;end:</span><br><span class="line">                if nums[i]&#x3D;&#x3D;nums[end]:</span><br><span class="line">                    return False</span><br><span class="line">                i+&#x3D;1</span><br><span class="line">            return True</span><br><span class="line">    </span><br><span class="line">        lens&#x3D;len(nums)</span><br><span class="line">        output&#x3D;[]</span><br><span class="line">        backtrack()</span><br><span class="line">        return output</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def permuteUnique(self, nums: List[int]) -&gt; List[List[int]]:</span><br><span class="line">        </span><br><span class="line">        def backtrack(first&#x3D;0):</span><br><span class="line">            if first&#x3D;&#x3D;lens:</span><br><span class="line">                output.append(nums[:])</span><br><span class="line">            for i in range(first,lens):</span><br><span class="line">                </span><br><span class="line">                if nums[i] not in nums[first:i]:</span><br><span class="line">                    nums[first],nums[i]&#x3D;nums[i],nums[first]</span><br><span class="line">                    backtrack(first+1)</span><br><span class="line">                    nums[first],nums[i]&#x3D;nums[i],nums[first]</span><br><span class="line">        </span><br><span class="line">        lens&#x3D;len(nums)</span><br><span class="line">        output&#x3D;[]</span><br><span class="line">        nums.sort()</span><br><span class="line">        backtrack()</span><br><span class="line">        return output</span><br></pre></td></tr></table></figure>

<p>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations-ii/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2/">https://leetcode-cn.com/problems/permutations-ii/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2/</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def permuteUnique(self, nums: List[int]) -&gt; List[List[int]]:</span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        def backtrack(first,path,used):</span><br><span class="line">            if first &#x3D;&#x3D; len(nums):</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                return</span><br><span class="line">            for i in range(len(nums)):</span><br><span class="line">                if not used[i]:</span><br><span class="line">                    if i&gt;0 and nums[i] &#x3D;&#x3D; nums[i-1] and not used[i-1]:</span><br><span class="line">                        continue</span><br><span class="line">                    used[i]&#x3D;True</span><br><span class="line">                    path.append(nums[i])</span><br><span class="line">                    backtrack(first+1,path,used)</span><br><span class="line">                    used[i]&#x3D;False</span><br><span class="line">                    path.pop()</span><br><span class="line">        nums.sort()</span><br><span class="line">        used&#x3D;[False] * len(nums)</span><br><span class="line">        backtrack(0,[],used)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<h3 id="51-N皇后"><a href="#51-N皇后" class="headerlink" title="51. N皇后"></a>51. N皇后</h3><pre><code>链接：https://leetcode-cn.com/problems/n-queens/

n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。

上图为 8 皇后问题的一种解法。

给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。

每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 &#39;Q&#39; 和 &#39;.&#39; 分别代表了皇后和空位。

示例:

输入: 4
输出: [
 [&quot;.Q..&quot;,  // 解法 1
  &quot;...Q&quot;,
  &quot;Q...&quot;,
  &quot;..Q.&quot;],

 [&quot;..Q.&quot;,  // 解法 2
  &quot;Q...&quot;,
  &quot;...Q&quot;,
  &quot;.Q..&quot;]
]
解释: 4 皇后问题存在两个不同的解法。</code></pre>
<p>题解一（回溯法）:</p>
<p>问题是十九世纪著名的数学家高斯1850年提出：在8X8格的国际象棋上摆放八个皇后（棋子），使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上。</p>
<p>1、判断每次输入的皇后是否在同一行、同一列或者同一斜线上<br>2、核心算法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def solveNQueens(self, n: int) -&gt; List[List[str]]:</span><br><span class="line">        board,ret&#x3D;[[&#39;.&#39;]*n for _ in range(n)],[]</span><br><span class="line">        self.dfs(board,n,0,ret)</span><br><span class="line">        return ret</span><br><span class="line">    def dfs(self,board,n,row,ret):</span><br><span class="line">        if row&#x3D;&#x3D;n:</span><br><span class="line">            ret.append([&#39;&#39;.join(i) for i in board])</span><br><span class="line">            return</span><br><span class="line">        for i in range(n):</span><br><span class="line">            if not self.isVaild(row,i,n,board):</span><br><span class="line">                continue</span><br><span class="line">            board[row][i]&#x3D;&#39;Q&#39;</span><br><span class="line">            self.dfs(board,n,row+1,ret)</span><br><span class="line">            board[row][i]&#x3D;&#39;.&#39;</span><br><span class="line"></span><br><span class="line">    def isVaild(self,row,col,n,board):</span><br><span class="line">        for i in range(1, row + 1):</span><br><span class="line">            # 判断同一列上是否有Q</span><br><span class="line">            if board[row - i][col] &#x3D;&#x3D; &#39;Q&#39;:</span><br><span class="line">                return False</span><br><span class="line">            # 判断逆对角线是否有Q</span><br><span class="line">            if col - i &gt;&#x3D; 0 and board[row - i][col - i] &#x3D;&#x3D; &#39;Q&#39;:</span><br><span class="line">                return False</span><br><span class="line">            # 判断正对角线是否有Q</span><br><span class="line">            if col + i &lt; n and board[row - i][col + i] &#x3D;&#x3D; &#39;Q&#39;:</span><br><span class="line">                return False</span><br><span class="line">        return True</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>???### 60. 第k个排列<br>    给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。</p>
<pre><code>按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：

&quot;123&quot;
&quot;132&quot;
&quot;213&quot;
&quot;231&quot;
&quot;312&quot;
&quot;321&quot;
给定 n 和 k，返回第 k 个排列。

说明：

给定 n 的范围是 [1, 9]。
给定 k 的范围是[1,  n!]。
示例 1:

输入: n = 3, k = 3
输出: &quot;213&quot;
示例 2:

输入: n = 4, k = 9
输出: &quot;2314&quot;</code></pre>
<p>题解一|回溯|超时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def getPermutation(self, n: int, k: int) -&gt; str:</span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        used&#x3D;[False]*n # 使用used去重</span><br><span class="line">        def backtrace(path,first):</span><br><span class="line">            if len(path) &#x3D;&#x3D; n:</span><br><span class="line">                return res.append(path[:])</span><br><span class="line"></span><br><span class="line">            for i in range(1,n+1):</span><br><span class="line">                if used[i-1]: </span><br><span class="line">                    continue</span><br><span class="line">                used[i-1]&#x3D;True</span><br><span class="line">                path.append(i)</span><br><span class="line">                backtrace(path,i+1)</span><br><span class="line">                used[i-1]&#x3D;False</span><br><span class="line">                path.pop()</span><br><span class="line">        if not n or not k:</span><br><span class="line">            return &#39;&#39;</span><br><span class="line">        backtrace([],1)</span><br><span class="line">        print(res)</span><br><span class="line">        tmp&#x3D;[str(i) for i in res[k-1]]</span><br><span class="line">        return &#39;&#39;.join(tmp)</span><br></pre></td></tr></table></figure>

<p>优化|超时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def getPermutation(self, n: int, k: int) -&gt; str:</span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        used&#x3D;[False]*n # 使用used去重</span><br><span class="line">        def backtrace(path):</span><br><span class="line">            if len(res) &#x3D;&#x3D; k:</span><br><span class="line">                return</span><br><span class="line">            </span><br><span class="line">            if len(path) &#x3D;&#x3D; n:</span><br><span class="line">                return res.append(path[:])</span><br><span class="line"></span><br><span class="line">            for i in range(1,n+1):</span><br><span class="line">                if used[i-1]: </span><br><span class="line">                    continue</span><br><span class="line">                used[i-1]&#x3D;True</span><br><span class="line">                path.append(i)</span><br><span class="line">                backtrace(path)</span><br><span class="line">                used[i-1]&#x3D;False</span><br><span class="line">                path.pop()</span><br><span class="line">        if not n or not k:</span><br><span class="line">            return &#39;&#39;</span><br><span class="line">        backtrace([])</span><br><span class="line">        tmp&#x3D;[str(i) for i in res[-1]]</span><br><span class="line">        return &#39;&#39;.join(tmp)</span><br></pre></td></tr></table></figure>

<p>???</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def getPermutation(self, n: int, k: int) -&gt; str:</span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        def backtrack(k,first):</span><br><span class="line">            if first &#x3D;&#x3D; n:</span><br><span class="line">                return</span><br><span class="line">            cnt&#x3D;factorial[n-1-first]</span><br><span class="line">            for i in range(1,n+1):</span><br><span class="line">                if used[i]:</span><br><span class="line">                    continue</span><br><span class="line">                if cnt &lt; k:</span><br><span class="line">                    k-&#x3D;cnt</span><br><span class="line">                    continue</span><br><span class="line">                res.append(i)</span><br><span class="line">                used[i]&#x3D;True</span><br><span class="line">                backtrack(k,first+1)</span><br><span class="line"></span><br><span class="line">        used&#x3D;[False] * (n+1) # 使用used去重</span><br><span class="line">        factorial&#x3D;[ 1 for _ in range(n+1)]</span><br><span class="line">        for i in range(2,n+1):</span><br><span class="line">            factorial[i]&#x3D;factorial[i-1]*i</span><br><span class="line">        backtrack(k,0)</span><br><span class="line">        return &#39;&#39;.join([str(num) for num in res])</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="77-组合"><a href="#77-组合" class="headerlink" title="77.组合"></a>77.组合</h3><pre><code>链接：https://leetcode-cn.com/problems/combinations/

给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。

示例:

输入: n = 4, k = 2
输出:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]</code></pre>
<p>题解一|回溯：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def combine(self, n: int, k: int) -&gt; List[List[int]]:</span><br><span class="line">        if k &#x3D;&#x3D; 0 or n&#x3D;&#x3D;0:</span><br><span class="line">            return []</span><br><span class="line">    </span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        path&#x3D;[]</span><br><span class="line">        return self.helper(n,k,res,path,1)</span><br><span class="line">    def helper(self,n,k,res,path,first&#x3D;1):</span><br><span class="line">        if len(path)&#x3D;&#x3D;k:</span><br><span class="line">            res.append(path[:])</span><br><span class="line">        for i in range(first,n+1):</span><br><span class="line">            path.append(i)</span><br><span class="line"></span><br><span class="line">            self.helper(n,k,res,path,i+1) </span><br><span class="line">            # self.helper(n,k,res,path,first+1) </span><br><span class="line">            # [[1,2],[1,3],[1,4],[2,2],[2,3],[2,4],[3,2],[3,3],[3,4],[4,2],[4,3],[4,4]]</span><br><span class="line">            path.pop()</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def combine(self, n: int, k: int) -&gt; List[List[int]]:</span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        def backtrace(path,first):</span><br><span class="line">            if len(path) &#x3D;&#x3D; k:</span><br><span class="line">                return res.append(path[:])</span><br><span class="line">            for i in range(first,n+1):</span><br><span class="line">                path.append(i)</span><br><span class="line">                backtrace(path,i+1)</span><br><span class="line">                # backtrace(path,first+1)</span><br><span class="line">                path.pop()</span><br><span class="line">        if not n or not k:</span><br><span class="line">            return []</span><br><span class="line">        backtrace([],1)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def combine(self, n: int, k: int) -&gt; List[List[int]]:</span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        def backtrace(path,first):</span><br><span class="line">            if len(path) &#x3D;&#x3D; k:</span><br><span class="line">                return res.append(path[:])</span><br><span class="line">            for i in range(first,n+1):</span><br><span class="line">                path.append(i)</span><br><span class="line">                backtrace(path,i+1) # 输出：[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]</span><br><span class="line">                # backtrace(path,i) # 输出：[[1,1],[1,2],[1,3],[1,4],[2,2],[2,3],[2,4],[3,3],[3,4],[4,4]]</span><br><span class="line">                # backtrace(path,first+1) # 输出：[[1,2],[1,3],[1,4],[2,2],[2,3],[2,4],[3,2],[3,3],[3,4],[4,2],[4,3],[4,4]]</span><br><span class="line">                # backtrace(path,first) # 输出：[[1,1],[1,2],[1,3],[1,4],[2,1],[2,2],[2,3],[2,4],[3,1],[3,2],[3,3],[3,4],[4,1],[4,2],[4,3],[4,4]]</span><br><span class="line">                path.pop()</span><br><span class="line">        if not n or not k:</span><br><span class="line">            return []</span><br><span class="line">        backtrace([],1)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<h3 id="78-子集"><a href="#78-子集" class="headerlink" title="78.子集"></a>78.子集</h3><pre><code>链接：https://leetcode-cn.com/problems/subsets/submissions/

给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

说明：解集不能包含重复的子集。

示例:

输入: nums = [1,2,3]
输出:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]</code></pre>
<p>题解一（库函数）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def subsets(self, nums: List[int]) -&gt; List[List[int]]:</span><br><span class="line">        import itertools</span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        for i in range(len(nums)+1):</span><br><span class="line">            for j in itertools.combinations(nums,i):</span><br><span class="line">                res.append(j)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>
<p>题解二（迭代）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def subsets(self, nums: List[int]) -&gt; List[List[int]]:</span><br><span class="line">        res&#x3D;[[]]</span><br><span class="line">        for i in nums:</span><br><span class="line">            res+&#x3D;[[i]+j for j in res]</span><br><span class="line">            # print(res)</span><br><span class="line">        return res</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>题解三（回溯）:<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subsets/solution/hui-su-python-dai-ma-by-liweiwei1419/">https://leetcode-cn.com/problems/subsets/solution/hui-su-python-dai-ma-by-liweiwei1419/</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def subsets(self, nums: List[int]) -&gt; List[List[int]]:</span><br><span class="line">        length&#x3D;len(nums)</span><br><span class="line">        if length&#x3D;&#x3D;0:</span><br><span class="line">            return []</span><br><span class="line">        </span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        path&#x3D;[]</span><br><span class="line">        return self.helper(nums,res,path,0)</span><br><span class="line">    </span><br><span class="line">    def helper(self,nums,res,path,first&#x3D;1):</span><br><span class="line">        res.append(path[:])</span><br><span class="line">        for i in range(first,len(nums)):</span><br><span class="line">            path.append(nums[i])</span><br><span class="line">            self.helper(nums,res,path,i+1)</span><br><span class="line">            path.pop()</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def subsets(self, nums: List[int]) -&gt; List[List[int]]:</span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        def backtrace(path,first):</span><br><span class="line">            res.append(path[:])</span><br><span class="line">            for i in range(first,len(nums)):</span><br><span class="line">                path.append(nums[i])</span><br><span class="line">                backtrace(path,i+1)</span><br><span class="line">                path.pop()</span><br><span class="line">        backtrace([],0)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>
<h3 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a>90. 子集 II</h3><pre><code>链接：https://leetcode-cn.com/problems/subsets-ii/submissions/

给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

说明：解集不能包含重复的子集。

示例:

输入: [1,2,2]
输出:
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]</code></pre>
<p>题解一（回溯）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def subsetsWithDup(self, nums: List[int]) -&gt; List[List[int]]:</span><br><span class="line">        length&#x3D;len(nums)</span><br><span class="line">        if length&#x3D;&#x3D;0:</span><br><span class="line">            return []</span><br><span class="line">        </span><br><span class="line">        nums.sort() # 一定需要先排序，否则结果中有重复的。</span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        path&#x3D;[]</span><br><span class="line">        return self.helper(nums,res,path,0)</span><br><span class="line">    </span><br><span class="line">    def helper(self,nums,res,path,first&#x3D;1):</span><br><span class="line">        res.append(path[:])</span><br><span class="line">        for i in range(first,len(nums)):</span><br><span class="line">            if i&gt;first and nums[i]&#x3D;&#x3D;nums[i-1]:</span><br><span class="line">                continue</span><br><span class="line">            path.append(nums[i])</span><br><span class="line">            self.helper(nums,res,path,i+1)</span><br><span class="line">            path.pop()</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subsets-ii/solution/hui-su-de-duo-chong-xie-fa-duo-ti-yu-jing-by-zhang/">https://leetcode-cn.com/problems/subsets-ii/solution/hui-su-de-duo-chong-xie-fa-duo-ti-yu-jing-by-zhang/</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def subsetsWithDup(self, nums: List[int]) -&gt; List[List[int]]:</span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        nums.sort()</span><br><span class="line">        def backtrace(path,first):</span><br><span class="line">            res.append(path[:]) # ???没有return</span><br><span class="line">            for i in range(first,len(nums)):</span><br><span class="line">                if i&gt;first and nums[i]&#x3D;&#x3D;nums[i-1]: # 滤重</span><br><span class="line">                    continue</span><br><span class="line">                path.append(nums[i])</span><br><span class="line">                backtrace(path,i+1)</span><br><span class="line">                path.pop()</span><br><span class="line">        backtrace([],0)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>
<h3 id="93-复原IP地址"><a href="#93-复原IP地址" class="headerlink" title="93.复原IP地址"></a>93.复原IP地址</h3><pre><code>链接：https://leetcode-cn.com/problems/restore-ip-addresses/

给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。

示例:

输入: &quot;25525511135&quot;
输出: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]</code></pre>
<p>注意：<br>    IP的格式,每位是在0~255之间,<br>    不能出现以0开头的两位以上数字,比如012,08…</p>
<p>题解一(暴力):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def restoreIpAddresses(self, s: str) -&gt; List[str]:</span><br><span class="line">        n&#x3D;len(s)</span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        </span><br><span class="line">        def helper(tmp):</span><br><span class="line">            if tmp&#x3D;&#x3D;&#39;&#39; or (tmp[0]&#x3D;&#x3D;&#39;0&#39; and len(tmp)&gt;1) or int(tmp)&gt;255:</span><br><span class="line">            # if not tmp or (tmp[0]&#x3D;&#x3D;&#39;0&#39; and len(tmp)&gt;1) or int(tmp)&gt;255:</span><br><span class="line">                return False</span><br><span class="line">            return True</span><br><span class="line">        </span><br><span class="line">        for i in range(3):</span><br><span class="line">            for j in range(i+1,i+4):</span><br><span class="line">                for k in range(j+1,j+4):</span><br><span class="line">                    if i&lt;n and j&lt;n and k&lt;n:</span><br><span class="line">                        tmp1&#x3D;s[:i+1]</span><br><span class="line">                        tmp2&#x3D;s[i+1:j+1]</span><br><span class="line">                        tmp3&#x3D;s[j+1:k+1]</span><br><span class="line">                        tmp4&#x3D;s[k+1:]</span><br><span class="line"></span><br><span class="line">                        if all(map(helper,[tmp1,tmp2,tmp3,tmp4])):</span><br><span class="line">                            res.append(tmp1+&#39;.&#39;+tmp2+&#39;.&#39;+tmp3+&#39;.&#39;+tmp4)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>
<p>题解二（回溯）:</p>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/restore-ip-addresses/solution/shou-hua-tu-jie-huan-yuan-dfs-hui-su-de-xi-jie-by-/">https://leetcode-cn.com/problems/restore-ip-addresses/solution/shou-hua-tu-jie-huan-yuan-dfs-hui-su-de-xi-jie-by-/</a></p>
<p>思路:</p>
<pre><code>做第一步时我们有几种 选择 以 &quot;25525511135&quot; 为例：

    选 &quot;2&quot; 作为第一个片段
    选 &quot;25&quot; 作为第一个片段
    选 &quot;255&quot; 作为第一个片段

有三种选择，做了选择后，又面临三种选择：再切出一种长度的片段作为第二个片段。
这会像树一样向下分支，我们用 DFS 去遍历所有选择，并且是回溯，为什么是回溯？
因为某一步的选择可能来到一个错误的状态，得不到正确的结果，不要往下做了，要撤销最后一个选择，回到选择前的状态，去试另一个选择。
大概像是：选择、探索、撤销选择的过程。好，我们现在了解了回溯的要点1——选择。</code></pre>
<p>回溯的要点2——约束:</p>
<pre><code>约束限制了我们的搜索分支，这道题的约束条件是：

    一个片段的长度是 1~3
    片段的值范围是 0~255
    不能是 &quot;0x&quot;、&quot;0xx&quot; 形式（这个是测试用例告诉我们的）

我们要用这些约束在DFS中充分地剪枝，规避掉一些选择，避免去搜索一些不会产生正确答案的分支。</code></pre>
<p>回溯的要点3——目标:</p>
<pre><code>我们的目标决定了我们 DFS 什么时候捕捉答案，什么时候砍掉死支，不继续走了返回出来。
我们目标是生成 4 个有效片段，并且要用光 IP 字符串的字符。
当遍历的节点满足该条件时，说明已经生成了一个有效组合，推入结果数组。然后回溯，继续探索。
生成了4个有效片段，但没用光所有字符，不是有效的组合，不继续往下递归，直接返回，提前回溯。</code></pre>
<p>定义dfs函数:</p>
<pre><code>dfs函数传什么，用什么代表不同节点的状态？
选择切出一个长度的片段后，剩余的子串继续递归，可以传子串，也可以传指向起始位置的指针，加上当前已经生成的片段数组，作为状态，传入 dfs 函数。
dfs 函数做的是「按一定规则，切割从指针 start 开始的子串」。</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def restoreIpAddresses(self, s: str) -&gt; List[str]:</span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        def helper(path,first):</span><br><span class="line">            if len(path)&#x3D;&#x3D;4 and first&#x3D;&#x3D;len(s):</span><br><span class="line">                res.append(&#39;.&#39;.join(path))</span><br><span class="line">            if len(path)&#x3D;&#x3D;4 and first &lt; len(s):</span><br><span class="line">                return</span><br><span class="line">            for i in range(1,4):</span><br><span class="line">                if first+i-1 &gt;&#x3D; len(s):</span><br><span class="line">                    return</span><br><span class="line">                if i &gt;&#x3D; 2 and s[first]&#x3D;&#x3D;&#39;0&#39;:</span><br><span class="line">                    return</span><br><span class="line">                tmp&#x3D;s[first:first+i]                </span><br><span class="line">                if i&#x3D;&#x3D;3 and int(tmp)&gt;255:</span><br><span class="line">                    return</span><br><span class="line">                path.append(tmp)</span><br><span class="line">                helper(path,first+i)</span><br><span class="line">                path.pop()</span><br><span class="line">        helper([],0)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def restoreIpAddresses(self, s: str) -&gt; List[str]:</span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        def helper(path,first):</span><br><span class="line">            if len(path)&#x3D;&#x3D;4 and first&#x3D;&#x3D;len(s):</span><br><span class="line">                res.append(&#39;.&#39;.join(path))</span><br><span class="line">            if len(path)&#x3D;&#x3D;4 and first &lt; len(s):</span><br><span class="line">                return</span><br><span class="line">            for i in range(1,4):</span><br><span class="line">                if first+i-1 &gt;&#x3D; len(s):</span><br><span class="line">                    return</span><br><span class="line">                if i &gt;&#x3D; 2 and s[first]&#x3D;&#x3D;&#39;0&#39;:</span><br><span class="line">                    return</span><br><span class="line">                tmp&#x3D;s[first:first+i]                </span><br><span class="line">                if i&#x3D;&#x3D;3 and int(tmp)&gt;255:</span><br><span class="line">                    return</span><br><span class="line">                helper(path+[tmp],first+i)</span><br><span class="line">        helper([],0)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def restoreIpAddresses(self, s: str) -&gt; List[str]:</span><br><span class="line">        def __segment(s,left,right):</span><br><span class="line">            size&#x3D;right-left+1</span><br><span class="line"></span><br><span class="line">            if size &gt; 1 and s[left]&#x3D;&#39;0&#39;:</span><br><span class="line">                return -1</span><br><span class="line">            res&#x3D;0</span><br><span class="line">            for i in range(left,right+1):</span><br><span class="line">                res&#x3D;res*10 + ord(s[i])-ord(&#39;0&#39;)</span><br><span class="line"></span><br><span class="line">            if res &gt; 255:</span><br><span class="line">                return -1</span><br><span class="line">            return res</span><br><span class="line"></span><br><span class="line">        def backtrace(split,first,path):</span><br><span class="line">            if first &#x3D;&#x3D; len(s):</span><br><span class="line">                if split &#x3D;&#x3D; 4:</span><br><span class="line">                    res.append(&#39;&#39;.join(path))</span><br><span class="line">                return</span><br><span class="line">            if len(s) - first</span><br></pre></td></tr></table></figure>

<h3 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216. 组合总和 III"></a>216. 组合总和 III</h3><pre><code>链接：https://leetcode-cn.com/problems/combination-sum-iii/

找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。

说明：

所有数字都是正整数。
解集不能包含重复的组合。 
示例 1:

输入: k = 3, n = 7
输出: [[1,2,4]]
示例 2:

输入: k = 3, n = 9
输出: [[1,2,6], [1,3,5], [2,3,4]]</code></pre>
<p>题解一|回溯：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def combinationSum3(self, k: int, n: int) -&gt; List[List[int]]:</span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        def backtrace(path,first,n):</span><br><span class="line">            if len(path)&#x3D;&#x3D;k and n&#x3D;&#x3D;0:</span><br><span class="line">                return res.append(path[:])</span><br><span class="line">            for i in range(first,10):</span><br><span class="line">                tmp&#x3D;n-i</span><br><span class="line">                if tmp &lt; 0:</span><br><span class="line">                    continue</span><br><span class="line">                path.append(i)</span><br><span class="line">                backtrace(path,i+1,tmp)</span><br><span class="line">                path.pop()</span><br><span class="line">        if not k or not n:</span><br><span class="line">            return []</span><br><span class="line">        backtrace([],1,n)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<h3 id="357-计算各个位数不同的数字个数"><a href="#357-计算各个位数不同的数字个数" class="headerlink" title="357. 计算各个位数不同的数字个数"></a>357. 计算各个位数不同的数字个数</h3><pre><code>链接：https://leetcode-cn.com/problems/count-numbers-with-unique-digits/

给定一个非负整数 n，计算各位数字都不同的数字 x 的个数，其中 0 ≤ x &lt; 10n 。

示例:

输入: 2
输出: 91 
解释: 答案应为除去 11,22,33,44,55,66,77,88,99 外，在 [0,100) 区间内的所有数字。</code></pre>
<p>题解一|动态规划：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def countNumbersWithUniqueDigits(self, n: int) -&gt; int:</span><br><span class="line">        if n&#x3D;&#x3D;0:</span><br><span class="line">            return 1</span><br><span class="line">        dp1&#x3D;[0]*(n+1)</span><br><span class="line">        dp2&#x3D;[0]*(n+1)</span><br><span class="line">        dp1[1]&#x3D;10</span><br><span class="line">        dp2[1]&#x3D;9</span><br><span class="line">        for i in range(2,min(11,n+1)):</span><br><span class="line">            dp2[i]&#x3D;dp2[i-1]*(10-(i-1))</span><br><span class="line">            dp1[i]&#x3D;dp2[i]+dp1[i-1]</span><br><span class="line">        if n&gt;&#x3D;11:</span><br><span class="line">            return dp[10]</span><br><span class="line">        return dp1[n]</span><br></pre></td></tr></table></figure>

<p>题解二|数学：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">这是一道数学题，很容易发现规律：</span><br><span class="line"></span><br><span class="line">如果 n &#x3D; 1，ans &#x3D; 10；</span><br><span class="line">如果 n &#x3D; 2，考虑两位数都不相同，有 9 * 9 &#x3D; 81 种情况（第一个数字不能以 0 开头，第二个数字可以有 0），再加上 n &#x3D; 1 时的情况即可得到 ans &#x3D; 91；</span><br><span class="line">如果 n &#x3D; 3，考虑三位数都不相同，有 9 * 9 * 8 &#x3D; 648 种情况（第一个数字不能以 0 开头），再加上 n &#x3D; 2 时的情况即可得到 ans &#x3D; 739；</span><br><span class="line">以此类推即可。</span><br><span class="line"></span><br><span class="line">因此，我们从 i &#x3D; 1 开始，每次累加结果，一直计算到 i &#x3D; n 即可得到答案。注意：当 n &gt; 10 时，与 n &#x3D; 10 的结果相同。</span><br><span class="line"></span><br><span class="line">Python3 实现：</span><br><span class="line">class Solution:</span><br><span class="line">    def countNumbersWithUniqueDigits(self, n: int) -&gt; int:</span><br><span class="line">        def factorial(cnt):  # 从9阶乘cnt次</span><br><span class="line">            res &#x3D; 1</span><br><span class="line">            factor &#x3D; 9</span><br><span class="line">            for i in range(cnt):</span><br><span class="line">                res *&#x3D; factor</span><br><span class="line">                factor -&#x3D; 1</span><br><span class="line">            return res</span><br><span class="line">        </span><br><span class="line">        pre &#x3D; i &#x3D; 1</span><br><span class="line">        while i &lt;&#x3D; n and i &lt;&#x3D; 10:  # i要&lt;&#x3D;10</span><br><span class="line">            pre +&#x3D; 9 * factorial(i-1)  # i位不同的数字与前面结果累加</span><br><span class="line">            i +&#x3D; 1</span><br><span class="line">        return pre</span><br></pre></td></tr></table></figure>

<p>??题解三|回溯：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def countNumbersWithUniqueDigits(self, n: int) -&gt; int:</span><br><span class="line">        used&#x3D;[False]*10</span><br><span class="line">        def backtrace(first,used):</span><br><span class="line">            count&#x3D;0</span><br><span class="line">            if first !&#x3D; n:</span><br><span class="line">                for i in range(10):</span><br><span class="line">                    if i&#x3D;&#x3D;0 and n&gt;1 and first&#x3D;&#x3D;1:</span><br><span class="line">                        continue</span><br><span class="line">                    if used[i]:</span><br><span class="line">                        continue</span><br><span class="line">                    used[i]&#x3D;True</span><br><span class="line">                    count+&#x3D;backtrace(first+1,used)+1</span><br><span class="line">                    used[i]&#x3D;False</span><br><span class="line">            return count</span><br><span class="line">        if not n:</span><br><span class="line">            return 1</span><br><span class="line">        return backtrace(0,used)</span><br></pre></td></tr></table></figure>

<h3 id="401-二进制手表"><a href="#401-二进制手表" class="headerlink" title="401. 二进制手表"></a>401. 二进制手表</h3><pre><code>链接：https://leetcode-cn.com/problems/binary-watch/

二进制手表顶部有 4 个 LED 代表 小时（0-11），底部的 6 个 LED 代表 分钟（0-59）。

每个 LED 代表一个 0 或 1，最低位在右侧。


例如，上面的二进制手表读取 “3:25”。

给定一个非负整数 n 代表当前 LED 亮着的数量，返回所有可能的时间。

示例：

输入: n = 1
返回: [&quot;1:00&quot;, &quot;2:00&quot;, &quot;4:00&quot;, &quot;8:00&quot;, &quot;0:01&quot;, &quot;0:02&quot;, &quot;0:04&quot;, &quot;0:08&quot;, &quot;0:16&quot;, &quot;0:32&quot;]


提示：

输出的顺序没有要求。
小时不会以零开头，比如 “01:00” 是不允许的，应为 “1:00”。
分钟必须由两位数组成，可能会以零开头，比如 “10:2” 是无效的，应为 “10:02”。
超过表示范围（小时 0-11，分钟 0-59）的数据将会被舍弃，也就是说不会出现 &quot;13:00&quot;, &quot;0:61&quot; 等时间。</code></pre>
<p>题解一|暴力：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def readBinaryWatch(self, num: int) -&gt; List[str]:</span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        for i in range(12):</span><br><span class="line">            for j in range(60):</span><br><span class="line">                if (bin(i)+bin(j)).count(&#39;1&#39;) &#x3D;&#x3D; num:</span><br><span class="line">                    res.append(&#39;%d:%02d&#39;%(i,j))</span><br><span class="line">        return res     </span><br></pre></td></tr></table></figure>

<p>扩展：</p>
<pre><code>%d就是普通的输出了整形数
%2d是将数字按宽度为2，采用右对齐方式输出，若数据位数不到2位，则左边补空格。
%02d，和%2d差不多，只不过左边补0

%-2d将数字按宽度为2，采用左对齐方式输出，若数据位数不到2位，则右边补空格
%.2d 输出整形时最少输出2位，如不够前面以0占位。如输出2时变成02，200时只输出200；输出浮点型时（%.2f）小数点后强制2位输出</code></pre>
<p>比如：</p>
<pre><code>num = 1
print(&quot;%d&quot; % (num))结果为：   （1）
print(&quot;%2d&quot; % (num))结果为：  （ 1）
print(&quot;%02d&quot; % (num))结果为： （01）
print(&quot;%-2d&quot; % (num))结果为： （1 ）
print(&quot;%.2d&quot; % (num))结果为： （01）
print(&quot;%.2d&quot; % (200))结果为： （200）</code></pre>
<p>题解二|回溯</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def readBinaryWatch(self, num: int) -&gt; List[str]:</span><br><span class="line">        </span><br><span class="line">        def traceback(num,index,status):</span><br><span class="line">            if num&#x3D;&#x3D;0:</span><br><span class="line">                hour&#x3D;status[0]+2*status[1]+4*status[2]+8*status[3]</span><br><span class="line">                mintue&#x3D;status[4]+2*status[5]+4*status[6]+8*status[7]+16*status[8]+32*status[9]</span><br><span class="line">                if hour&lt;12 and mintue &lt;60:</span><br><span class="line">                    res.append(&#39;%d:%02d&#39;%(hour,mintue))</span><br><span class="line">                return</span><br><span class="line">            for i in range(index,10):</span><br><span class="line">                status[i]&#x3D;1</span><br><span class="line">                traceback(num-1,i+1,status)</span><br><span class="line">                status[i]&#x3D;0</span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        traceback(num,0,[0]*10)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">def readBinaryWatch(self, num: int) -&gt; List[str]:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    思路： 递归回溯法</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if num &lt; 0:</span><br><span class="line">        return []</span><br><span class="line">    # 一共只有10个灯</span><br><span class="line">    res, hour, minute &#x3D; [], [1, 2, 4, 8], [1, 2, 4, 8, 16, 32]</span><br><span class="line">    def traceback(num, index, status):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        num : 还剩下的可点亮的灯的数量</span><br><span class="line">        index: 是当前选择点亮哪一个灯</span><br><span class="line">        status: 记录是哪些位置的灯被点亮了</span><br><span class="line">        </span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if num &#x3D;&#x3D; 0: # 没有可以点亮的灯了，记录当前结果，并返回</span><br><span class="line">            h &#x3D; sum([i*j for i,j in zip(hour, status[:4])])</span><br><span class="line">            m &#x3D; sum([i*j for i,j in zip(minute, status[4:])])</span><br><span class="line">            if h &lt; 12 and m &lt; 60:</span><br><span class="line">                res.append(&#39;%d:%02d&#39; % (h, m))</span><br><span class="line">            return</span><br><span class="line">        for i in range(index, 10):</span><br><span class="line">            status[i] &#x3D; 1 # 做出下一步的选择</span><br><span class="line">            traceback(num-1, i+1, status) # 在剩下的灯里面去点亮num-1个灯</span><br><span class="line">            status[i] &#x3D; 0 # 返回到上一步选择时的状态            </span><br><span class="line">    </span><br><span class="line">    traceback(num, 0, [0] * 10)</span><br><span class="line">    return res</span><br></pre></td></tr></table></figure>

<h3 id="784-字母大小写全排列"><a href="#784-字母大小写全排列" class="headerlink" title="784. 字母大小写全排列"></a>784. 字母大小写全排列</h3><pre><code>链接：https://leetcode-cn.com/problems/letter-case-permutation/

给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。

示例:
输入: S = &quot;a1b2&quot;
输出: [&quot;a1b2&quot;, &quot;a1B2&quot;, &quot;A1b2&quot;, &quot;A1B2&quot;]

输入: S = &quot;3z4&quot;
输出: [&quot;3z4&quot;, &quot;3Z4&quot;]

输入: S = &quot;12345&quot;
输出: [&quot;12345&quot;]
注意：

S 的长度不超过12。
S 仅由数字和字母组成。</code></pre>
<p>题解一|递归：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def letterCasePermutation(self, S: str) -&gt; List[str]:</span><br><span class="line">        res&#x3D;[]</span><br><span class="line"></span><br><span class="line">        def dfs(s,tmp):</span><br><span class="line">            if not s:</span><br><span class="line">                res.append(&#39;&#39;.join(tmp))</span><br><span class="line">                return</span><br><span class="line">            if s[0].isalpha():</span><br><span class="line">                dfs(s[1:],tmp+[s[0].upper()])</span><br><span class="line">                dfs(s[1:],tmp+[s[0].lower()])</span><br><span class="line">            else:</span><br><span class="line">                dfs(s[1:],tmp+[s[0]])</span><br><span class="line">        dfs(S,[])</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<p>题解二|迭代</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def letterCasePermutation(self, S: str) -&gt; List[str]:</span><br><span class="line">        res&#x3D;[&#39;&#39;]</span><br><span class="line">        for i,c in enumerate(S):</span><br><span class="line">            if c.isdigit():</span><br><span class="line">                for j,r in enumerate(res):</span><br><span class="line">                    res[j]&#x3D;r+c</span><br><span class="line">            else:</span><br><span class="line">                tmp&#x3D;[]</span><br><span class="line">                for r in res:</span><br><span class="line">                    tmp.append(r+c.upper())</span><br><span class="line">                    tmp.append(r+c.lower())</span><br><span class="line">                res&#x3D;tmp[:]</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-38-字符串的排列"><a href="#剑指-Offer-38-字符串的排列" class="headerlink" title="剑指 Offer 38. 字符串的排列"></a>剑指 Offer 38. 字符串的排列</h3><pre><code>链接：https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/

输入一个字符串，打印出该字符串中字符的所有排列。

你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。

示例:

输入：s = &quot;abc&quot;
输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]


限制：

1 &lt;= s 的长度 &lt;= 8</code></pre>
<p>题解一|回溯：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def permutation(self, s: str) -&gt; List[str]:</span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        c&#x3D;list(s)</span><br><span class="line">        </span><br><span class="line">        def backtrace(first):</span><br><span class="line">            if len(s) &#x3D;&#x3D; first:  # 不能使用len(s)&#x3D;&#x3D;len(c)作为结束条件，因为c其实没变。</span><br><span class="line">                return res.append(&#39;&#39;.join(c))</span><br><span class="line">            isDup&#x3D;set()</span><br><span class="line">            for i in range(first,len(c)):</span><br><span class="line">                if c[i] in isDup: # 还有一种简单去重方法，直接把res定义为set()</span><br><span class="line">                    continue</span><br><span class="line">                isDup.add(c[i])</span><br><span class="line">                c[first],c[i]&#x3D;c[i],c[first]</span><br><span class="line">                backtrace(first+1)</span><br><span class="line">                c[first],c[i]&#x3D;c[i],c[first]</span><br><span class="line">        backtrace(0)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def permutation(self, s: str) -&gt; List[str]:</span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        list_s&#x3D;list(s)</span><br><span class="line">        list_s.sort()</span><br><span class="line">        self.sort_s&#x3D;&#39;&#39;.join(list_s)</span><br><span class="line">        used&#x3D;[False]*len(s)        </span><br><span class="line">        </span><br><span class="line">        def backtrace(path,first):</span><br><span class="line">            if len(self.sort_s) &#x3D;&#x3D; len(path): </span><br><span class="line">                return res.append(&#39;&#39;.join(path[:]))</span><br><span class="line">            for i in range(len(self.sort_s)):</span><br><span class="line">                if used[i]:</span><br><span class="line">                    continue</span><br><span class="line">                if i&gt;0 and self.sort_s[i]&#x3D;&#x3D;self.sort_s[i-1] and used[i-1] &#x3D;&#x3D; False: # ？？？？</span><br><span class="line">                    continue</span><br><span class="line">                used[i]&#x3D;True</span><br><span class="line">                path.append(self.sort_s[i])</span><br><span class="line">                backtrace(path,first+1)</span><br><span class="line">                path.pop()</span><br><span class="line">                used[i]&#x3D;False</span><br><span class="line">        backtrace([],0)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<h3 id="面试题-08-04-幂集"><a href="#面试题-08-04-幂集" class="headerlink" title="面试题 08.04. 幂集"></a>面试题 08.04. 幂集</h3><pre><code>幂集。编写一种方法，返回某集合的所有子集。集合中不包含重复的元素。

说明：解集不能包含重复的子集。

示例:

 输入： nums = [1,2,3]
 输出：
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]</code></pre>
<p>题解一|回溯：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def subsets(self, nums: List[int]) -&gt; List[List[int]]:</span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        def backtrace(path,first):</span><br><span class="line">            res.append(path[:])</span><br><span class="line">            for i in range(first,len(nums)):</span><br><span class="line">                path.append(nums[i])</span><br><span class="line">                backtrace(path,i+1)</span><br><span class="line">                path.pop()</span><br><span class="line">        backtrace([],0)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<h3 id="面试题-08-07-无重复字符串的排列组合"><a href="#面试题-08-07-无重复字符串的排列组合" class="headerlink" title="面试题 08.07. 无重复字符串的排列组合"></a>面试题 08.07. 无重复字符串的排列组合</h3><pre><code>无重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合，字符串每个字符均不相同。

示例1:

 输入：S = &quot;qwe&quot;
 输出：[&quot;qwe&quot;, &quot;qew&quot;, &quot;wqe&quot;, &quot;weq&quot;, &quot;ewq&quot;, &quot;eqw&quot;]
示例2:

 输入：S = &quot;ab&quot;
 输出：[&quot;ab&quot;, &quot;ba&quot;]
提示:

字符都是英文字母。
字符串长度在[1, 9]之间。</code></pre>
<p>题解一|回溯:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def permutation(self, S: str) -&gt; List[str]:</span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        c&#x3D;list(S)</span><br><span class="line">        </span><br><span class="line">        def backtrace(first):</span><br><span class="line">            if len(S) &#x3D;&#x3D; first:  # 不能使用len(s)&#x3D;&#x3D;len(c)作为结束条件，因为c其实没变。</span><br><span class="line">                return res.append(&#39;&#39;.join(c))</span><br><span class="line">            for i in range(first,len(c)):</span><br><span class="line">                c[first],c[i]&#x3D;c[i],c[first]</span><br><span class="line">                backtrace(first+1)</span><br><span class="line">                c[first],c[i]&#x3D;c[i],c[first]</span><br><span class="line">        backtrace(0)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<h3 id="面试题-08-09-括号"><a href="#面试题-08-09-括号" class="headerlink" title="面试题 08.09. 括号"></a>面试题 08.09. 括号</h3><pre><code>括号。设计一种算法，打印n对括号的所有合法的（例如，开闭一一对应）组合。

说明：解集不能包含重复的子集。

例如，给出 n = 3，生成结果为：

[
  &quot;((()))&quot;,
  &quot;(()())&quot;,
  &quot;(())()&quot;,
  &quot;()(())&quot;,
  &quot;()()()&quot;
]</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def generateParenthesis(self, n: int) -&gt; List[str]:</span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        def backtrace(path,first):</span><br><span class="line">            if len(path) &#x3D;&#x3D; 2*n:</span><br><span class="line">                if first&#x3D;&#x3D;0:</span><br><span class="line">                    res.append(&#39;&#39;.join(path))</span><br><span class="line">                return</span><br><span class="line">            if first &lt; n:</span><br><span class="line">                path.append(&#39;(&#39;)</span><br><span class="line">                backtrace(path,first+1)</span><br><span class="line">                path.pop()</span><br><span class="line">            if first &gt; 0:</span><br><span class="line">                path.append(&#39;)&#39;)</span><br><span class="line">                backtrace(path,first-1)</span><br><span class="line">                path.pop()</span><br><span class="line">            print(path)</span><br><span class="line">        backtrace([],0)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/LeetCode-4-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/LeetCode-4-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="post-title-link" itemprop="url">LeetCode-4-动态规划</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-19 11:28:41" itemprop="dateCreated datePublished" datetime="2020-01-19T11:28:41+08:00">2020-01-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-27 10:57:03" itemprop="dateModified" datetime="2020-08-27T10:57:03+08:00">2020-08-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="四、动态规划"><a href="#四、动态规划" class="headerlink" title="四、动态规划"></a>四、动态规划</h2><p>动态规划三大步骤：</p>
<p>动态规划，无非就是利用历史记录，来避免我们的重复计算。而这些历史记录，我们得需要一些变量来保存，一般是用一维数组或者二维数组来保存。</p>
<p>第一步骤：定义数组元素的含义，上面说了，我们会用一个数组，来保存历史数组，假设用一维数组 dp[] 吧。这个时候有一个非常非常重要的点，就是规定你这个数组元素的含义，例如你的 dp[i] 是代表什么意思？</p>
<p>第二步骤：找出数组元素之间的关系式，我觉得动态规划，还是有一点类似于我们高中学习时的归纳法的，当我们要计算 dp[n] 时，是可以利用 dp[n-1]，dp[n-2]…..dp[1]，来推出 dp[n] 的，也就是可以利用历史数据来推出新的元素值，所以我们要找出数组元素之间的关系式，例如 dp[n] = dp[n-1] + dp[n-2]，这个就是他们的关系式了。而这一步，也是最难的一步，后面我会讲几种类型的题来说。</p>
<p>第三步骤：找出初始值。学过数学归纳法的都知道，虽然我们知道了数组元素之间的关系式，例如 dp[n] = dp[n-1] + dp[n-2]，我们可以通过 dp[n-1] 和 dp[n-2] 来计算 dp[n]，但是，我们得知道初始值啊，例如一直推下去的话，会由 dp[3] = dp[2] + dp[1]。而 dp[2] 和 dp[1] 是不能再分解的了，所以我们必须要能够直接获得 dp[2] 和 dp[1]的值，而这，就是所谓的初始值。</p>
<p>由了初始值，并且有了数组元素之间的关系式，那么我们就可以得到 dp[n] 的值了，而 dp[n] 的含义是由你来定义的，你想求什么，就定义它是什么，这样，这道题也就解出来了。</p>
<p>原文：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/pg-IJ8rA1duIzt5hW1Cycw">https://mp.weixin.qq.com/s/pg-IJ8rA1duIzt5hW1Cycw</a></p>
<h3 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="?5.最长回文子串"></a>?5.最长回文子串</h3><pre><code>链接：https://leetcode-cn.com/problems/longest-palindromic-substring/

给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

示例 1：

输入: &quot;babad&quot;
输出: &quot;bab&quot;
注意: &quot;aba&quot; 也是一个有效答案。
示例 2：

输入: &quot;cbbd&quot;
输出: &quot;bb&quot;</code></pre>
<p>题解一|暴力破解：<br>    很明显，暴力法将选出所有子字符串可能的开始和结束位置，并检验它是不是回文。<br>    时间复杂度：O(n^2),往往利用python的切片可以很好的缩减复杂度<br>    如果不用切片，还需要遍历一次子字符串，时间复杂度就是O(n^3)<br>    空间复杂度：O(1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def longestPalindrome(self, s: str) -&gt; str:</span><br><span class="line">        if s&#x3D;&#x3D;s[::-1]:</span><br><span class="line">            return s</span><br><span class="line"></span><br><span class="line">        maxLen&#x3D;1</span><br><span class="line">        ans&#x3D;s[0]</span><br><span class="line">        for i in range(0,len(s)-1):</span><br><span class="line">            for j in range(i+1,len(s)):</span><br><span class="line">                if j-i+1 &gt; maxLen and self.isPalindrome(s[i:j+1]):</span><br><span class="line">                    maxLen&#x3D;j-i+1</span><br><span class="line">                    ans&#x3D;s[i:j+1]</span><br><span class="line">        return ans</span><br><span class="line"></span><br><span class="line">    def isPalindrome(self, s: str) -&gt; bool:</span><br><span class="line">        left,right&#x3D;0,len(s)-1</span><br><span class="line">        while left&lt;right:</span><br><span class="line">            while left&lt;len(s) and not s[left].isalnum():</span><br><span class="line">                left+&#x3D;1</span><br><span class="line">            while right &gt;-1 and not s[right].isalnum():</span><br><span class="line">                right-&#x3D;1</span><br><span class="line">            if left&gt;right:</span><br><span class="line">                return True</span><br><span class="line">            if s[left].upper() !&#x3D; s[right].upper():</span><br><span class="line">                return False</span><br><span class="line">            else:</span><br><span class="line">                left+&#x3D;1</span><br><span class="line">                right-&#x3D;1</span><br><span class="line">        return True</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(N^3)，这里 N 是字符串的长度，枚举字符串的左边界、右边界，然后继续验证子串是否是回文子串，这三种操作都与 N 相关；<br>空间复杂度：O(1)，只使用到常数个临时变量，与字符串长度无关。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # 暴力匹配（超时）</span><br><span class="line">    def longestPalindrome(self, s: str) -&gt; str:</span><br><span class="line">        # 特判</span><br><span class="line">        size &#x3D; len(s)</span><br><span class="line">        if size &lt; 2:</span><br><span class="line">            return s</span><br><span class="line"></span><br><span class="line">        max_len &#x3D; 1</span><br><span class="line">        res &#x3D; s[0]</span><br><span class="line"></span><br><span class="line">        # 枚举所有长度大于等于 2 的子串</span><br><span class="line">        for i in range(size - 1):</span><br><span class="line">            for j in range(i + 1, size):</span><br><span class="line">                if j - i + 1 &gt; max_len and self.__valid(s, i, j):</span><br><span class="line">                    max_len &#x3D; j - i + 1</span><br><span class="line">                    res &#x3D; s[i:j + 1]</span><br><span class="line">        return res</span><br><span class="line"></span><br><span class="line">    def __valid(self, s, left, right):</span><br><span class="line">        # 验证子串 s[left, right] 是否为回文串</span><br><span class="line">        while left &lt; right:</span><br><span class="line">            if s[left] !&#x3D; s[right]:</span><br><span class="line">                return False</span><br><span class="line">            left +&#x3D; 1</span><br><span class="line">            right -&#x3D; 1</span><br><span class="line">        return True</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def longestPalindrome(self, s: str) -&gt; str:</span><br><span class="line">        if s&#x3D;&#x3D;s[::-1]:</span><br><span class="line">            return s</span><br><span class="line"></span><br><span class="line">        maxLen&#x3D;1</span><br><span class="line">        ans&#x3D;s[0]</span><br><span class="line">        for i in range(0,len(s)-1):</span><br><span class="line">            for j in range(i+1,len(s)):</span><br><span class="line">                if j-i+1 &gt; maxLen and s[i:j+1]&#x3D;&#x3D;s[i:j+1][::-1]: # arr&#x3D;&#39;abb&#39;,arr[0:1]&#x3D;&#39;a&#39;,右边是开区间</span><br><span class="line">                    maxLen&#x3D;j-i+1</span><br><span class="line">                    ans&#x3D;s[i:j+1]</span><br><span class="line">        return ans</span><br></pre></td></tr></table></figure>

<p>题解二|每个字母当成回文串的中心：</p>
<pre><code>考虑两种情况:回文串的长度为奇数或者偶数情况。</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def longestPalindrome(self, s: str) -&gt; str:</span><br><span class="line">        n&#x3D;len(s)</span><br><span class="line">        self.res&#x3D;&#39;&#39;</span><br><span class="line">        def helper(i,j):</span><br><span class="line">            while i&gt;&#x3D; 0 and j&lt;n and s[i]&#x3D;&#x3D;s[j]:</span><br><span class="line">                i-&#x3D;1</span><br><span class="line">                j+&#x3D;1</span><br><span class="line">            if len(self.res) &lt; j-i-1:</span><br><span class="line">                self.res&#x3D;s[i+1:j]</span><br><span class="line">                # print(i,self.res)</span><br><span class="line">        </span><br><span class="line">        for i in range(n):</span><br><span class="line">            helper(i,i)</span><br><span class="line">            helper(i,i+1) # 解决case为&quot;cbbd&quot;,即解决回文串为偶数的情况</span><br><span class="line">        return self.res</span><br></pre></td></tr></table></figure>

<p>题解三|把每个字母当成回文串的结束：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def longestPalindrome(self, s: str) -&gt; str:</span><br><span class="line">        if not s:</span><br><span class="line">            return &quot;&quot;</span><br><span class="line">        max_len &#x3D; 1</span><br><span class="line">        n &#x3D; len(s)</span><br><span class="line">        start &#x3D; 0</span><br><span class="line">        for i in range(1,n):</span><br><span class="line">            even &#x3D; s[i-max_len:i+1]</span><br><span class="line">            odd &#x3D; s[i - max_len-1:i+1]</span><br><span class="line">            #print(even,odd)</span><br><span class="line">            if i - max_len - 1 &gt;&#x3D; 0 and odd &#x3D;&#x3D; odd[::-1]:</span><br><span class="line">                start &#x3D; i - max_len - 1</span><br><span class="line">                max_len +&#x3D; 2</span><br><span class="line">            elif i - max_len &gt;&#x3D;0 and even &#x3D;&#x3D; even[::-1]:</span><br><span class="line">                start &#x3D; i - max_len</span><br><span class="line">                max_len +&#x3D; 1</span><br><span class="line">                </span><br><span class="line">        #print(start,max_len)</span><br><span class="line">        return s[start: start+max_len]</span><br></pre></td></tr></table></figure>

<p>题解四|动态规划：<br><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/dp.png"></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/">https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/</a></p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/dp2.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/dp2.png"></p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/dp3.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/dp3.png"></p>
<pre><code>1、定义数组的定义
    dp[i][j] 表示子串 s[i,j] 是否为回文子串。
2、找出数组的关系式
    dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1]
3、找到初始值

    试想如果 dp[l][r]=true，我们要判断 dp[l-1][r+1] 是否为回文。
    只需要判断字符串在(l-1)和（r+1)两个位置是否为相同的字符，是不是减少了很多重复计算。

    初始状态，l=r 时，此时 dp[l][r]=true
    状态转移方程，dp[l][r]=true 并且(l-1)和（r+1)两个位置为相同的字符，此时 dp[l-1][r+1]=true。</code></pre>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/gao-hao-dong-tai-gui-hua-he-zhong-xin-tuo-zhan-zhu/">https://leetcode-cn.com/problems/longest-palindromic-substring/solution/gao-hao-dong-tai-gui-hua-he-zhong-xin-tuo-zhan-zhu/</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def longestPalindrome(self, s: str) -&gt; str:</span><br><span class="line">        if not s or len(s) &lt;2:</span><br><span class="line">            return s</span><br><span class="line"></span><br><span class="line">        length&#x3D;len(s)</span><br><span class="line">        start&#x3D;0</span><br><span class="line">        end&#x3D;0</span><br><span class="line">        count&#x3D;1</span><br><span class="line"></span><br><span class="line">        dp&#x3D;[[0]* length for i in range(length)]</span><br><span class="line">        for r in range(1,length):</span><br><span class="line">            for l in range(0,length):</span><br><span class="line">                if (s[l]&#x3D;&#x3D;s[r]) and (r-l&lt;&#x3D;2 or dp[l+1][r-1]):</span><br><span class="line">                    dp[l][r]&#x3D;True</span><br><span class="line">                    if r-l+1&gt; count:</span><br><span class="line">                        count&#x3D;r-l+1</span><br><span class="line">                        start&#x3D;l</span><br><span class="line">                        end&#x3D;r</span><br><span class="line">        return s[start:end+1]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def longestPalindrome(self, s: str) -&gt; str:</span><br><span class="line">        # 观察是否存在状态，例如 babab,可知aba是回文序列，那么可以看出babab也是回文序列，当b &#x3D; b的时候</span><br><span class="line">        # 因此我们可以用二维数组来i,j表示回文串的起始和结尾索引位置。</span><br><span class="line">        # 状态转移方程dp[i,j] &#x3D; dp[i+1][j-1] if s[i] &#x3D;&#x3D; s[j] else False</span><br><span class="line">        # 接下来看有没有特殊的边界情况存在，我们发现当0&lt;&#x3D;j-i&lt;3的时候，只要满足s[i] &#x3D;&#x3D; s[j]，无论里面是什么dp[i,j]都会是回文字串,将这种情况分开讨论，当j-i&gt;&#x3D;3的时候，进行状态转移</span><br><span class="line">        # 初始值</span><br><span class="line">        m &#x3D; len(s)</span><br><span class="line">        max_len &#x3D; 1</span><br><span class="line">        start_index &#x3D; 0</span><br><span class="line">        if m &lt; 2:</span><br><span class="line">            return s</span><br><span class="line">        dp &#x3D; [[False for _ in range(m)] for _ in range(m)]</span><br><span class="line">        for j in range(1,m):</span><br><span class="line">            for i in range(0,j):</span><br><span class="line">                if s[i]  &#x3D;&#x3D; s[j]:</span><br><span class="line">                    if j-i &lt; 3:</span><br><span class="line">                        dp[i][j] &#x3D; True</span><br><span class="line">                    else:</span><br><span class="line">                        dp[i][j] &#x3D; dp[i+1][j-1]</span><br><span class="line">                else:</span><br><span class="line">                    dp[i][j] &#x3D; False</span><br><span class="line">                if dp[i][j]:</span><br><span class="line">                    cur_len &#x3D; j-i+1</span><br><span class="line">                    if cur_len &gt; max_len:</span><br><span class="line">                        max_len &#x3D; cur_len</span><br><span class="line">                        start_index &#x3D; i</span><br><span class="line">        return s[start_index:start_index+max_len]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def longestPalindrome(self, s: str) -&gt; str:</span><br><span class="line">        if(not s or len(s)&#x3D;&#x3D;1):</span><br><span class="line">            return s</span><br><span class="line">        n&#x3D;len(s)</span><br><span class="line">        dp&#x3D;[[False]*n for _ in range(n)]</span><br><span class="line">        max_len&#x3D;1</span><br><span class="line">        start&#x3D;0</span><br><span class="line">        for i in range(n):</span><br><span class="line">            dp[i][i]&#x3D;True</span><br><span class="line">            if(i&lt;n-1 and s[i]&#x3D;&#x3D;s[i+1]):</span><br><span class="line">                dp[i][i+1]&#x3D;True</span><br><span class="line">                start&#x3D;i</span><br><span class="line">                max_len&#x3D;2</span><br><span class="line">        for l in range(3,n+1):</span><br><span class="line">            for i in range(n+1-l):</span><br><span class="line">                r&#x3D;i+l-1</span><br><span class="line">                if(s[i]&#x3D;&#x3D;s[r] and dp[i+1][r-1]):</span><br><span class="line">                    dp[i][r]&#x3D;True</span><br><span class="line">                    start&#x3D;i</span><br><span class="line">                    max_len&#x3D;l</span><br><span class="line">        return s[start:start+max_len]</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<h3 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53.最大子序和"></a>53.最大子序和</h3><pre><code>链接：https://leetcode-cn.com/problems/maximum-subarray/

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例:

输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
进阶:

如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</code></pre>
<p>暴力——动态规划——贪心——分治?<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-subarray/solution/zui-da-zi-xu-he-cshi-xian-si-chong-jie-fa-bao-li-f/">https://leetcode-cn.com/problems/maximum-subarray/solution/zui-da-zi-xu-he-cshi-xian-si-chong-jie-fa-bao-li-f/</a><br>题解一：</p>
<pre><code>遍历整个数组，在数组的每一个位置时，求出一个全局最大值L，代表以当前位置
为结尾的最大字串，而G是当前位置的L和上一个位置L相比较后，取数值更大的。
当遍历到i时，以i个为结尾的最大字串就是我们的L。
数组[-2,1,-3,4,-1,2,1,-5,4]
位置0：L=-2,G=-2
位置1：L=1,G=1
位置2：L=-2，G=1
位置3：L=4，G=4
位置4：L=3，G=4
位置5：L=5，G=5
位置6：L=6，G=6
位置7：L=-1，G=6
位置8：L=4，G=6
最后，全局最大值G就是我们的结果。</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxSubArray(self, nums):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        l&#x3D;g&#x3D;-10000000000</span><br><span class="line">        for n in nums:</span><br><span class="line">            l&#x3D;max(n,l+n)</span><br><span class="line">            g&#x3D;max(l,g)</span><br><span class="line">        return g</span><br></pre></td></tr></table></figure>
<p>题解二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxSubArray(self, nums: List[int]) -&gt; int:</span><br><span class="line">        for i in range(1,len(nums)):</span><br><span class="line">            nums[i]&#x3D;max(nums[i],nums[i]+nums[i-1])</span><br><span class="line">            </span><br><span class="line">        return max(nums) # 取子序和中最大值</span><br></pre></td></tr></table></figure>
<p>题解三|动态规划:<br>    1、定义数组元素的含义</p>
<pre><code>    dp[i]为以num[i]结尾的子段的最大子段和
    dp[1]为以num[1]结尾的最大子段和

2、寻找递推表达式

    只考虑第一个元素，则最大子段和为其本身 dp[0] = nums[0]

    考虑前两个元素，最大子段和为 nums[0],num[1]以及 nums[0] + num[1] 中最大值 设为dp[1]

    考虑前三个元素，如何求其最大子段和？还是分为两种情况讨论，第三个元素在最后的字串内吗？

    若第三个元素也包含在最后的字串内，则dp[2] = Max(dp[1]+nums[2] , nums[2])

    dp[i]=max(dp[i-1]+num[i],num[i])

3、找出初始值

    dp[0]=num[0]
    dp[1]=max(dp[0]+num[1],num[1])</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxSubArray(self, nums: List[int]) -&gt; int:</span><br><span class="line">        lens&#x3D;len(nums)</span><br><span class="line">        if lens&#x3D;&#x3D;0:</span><br><span class="line">            return 0</span><br><span class="line">        dp&#x3D;lens*[0]</span><br><span class="line">        dp[0]&#x3D;nums[0]</span><br><span class="line">        # dp[1]&#x3D;max(dp[0]+nums[1],nums[1])</span><br><span class="line">        res&#x3D;dp[0]</span><br><span class="line">        for i in range(1,lens):</span><br><span class="line">            dp[i]&#x3D;max(dp[i-1]+nums[i],nums[i])</span><br><span class="line">            if dp[i]&gt;res:</span><br><span class="line">                res&#x3D;dp[i]</span><br><span class="line">        return res</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：</span><br><span class="line">[-2, 1, 0, 0, 0, 0, 0, 0, 0]</span><br><span class="line">[-2, 1, -2, 0, 0, 0, 0, 0, 0]</span><br><span class="line">[-2, 1, -2, 4, 0, 0, 0, 0, 0]</span><br><span class="line">[-2, 1, -2, 4, 3, 0, 0, 0, 0]</span><br><span class="line">[-2, 1, -2, 4, 3, 5, 0, 0, 0]</span><br><span class="line">[-2, 1, -2, 4, 3, 5, 6, 0, 0]</span><br><span class="line">[-2, 1, -2, 4, 3, 5, 6, 1, 0]</span><br><span class="line">[-2, 1, -2, 4, 3, 5, 6, 1, 5]</span><br></pre></td></tr></table></figure>

<h3 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62.不同路径"></a>62.不同路径</h3><pre><code>链接：https://leetcode-cn.com/problems/unique-paths/

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

问总共有多少条不同的路径？</code></pre>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/unique-path.png" alt="tree1"></p>
<pre><code>例如，上图是一个7 x 3 的网格。有多少可能的路径？

说明：m 和 n 的值均不超过 100。

示例 1:

输入: m = 3, n = 2
输出: 3
解释:
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -&gt; 向右 -&gt; 向下
2. 向右 -&gt; 向下 -&gt; 向右
3. 向下 -&gt; 向右 -&gt; 向右
示例 2:

输入: m = 7, n = 3
输出: 28</code></pre>
<p>题解一|动态规划：</p>
<p>1、定义数组元素的含义<br>    目的：从左上角到右下角一共有多少种路径<br>    dp[i][j]含义：从左上角走到(i,j)这个位置时，一共有dp[i][j]种路径</p>
<p>2、找到数组的递推关系式</p>
<pre><code>如何才能到达 (i, j) 这个位置呢？可以向下走或者向右走，所以有两种方式到达：

    一种是从 (i-1, j) 这个位置走一步到达
    一种是从(i, j - 1) 这个位置走一步到达

所以：dp[i][j]=dp[i-1][j]+dp[i][j-1]</code></pre>
<p>3、找到初始值</p>
<pre><code>当 dp[i][j] 中，如果 i 或者 j 有一个为 0，那么还能使用关系式吗？答是不能的，因为这个时候把 i - 1 或者 j - 1，就变成负数了，数组就会出问题了。

图中的最上面一行和左边一列，因此初始值如下：

    dp[0][0….n-1] = 1; // 相当于最上面一行，只能一直往右走
    dp[0…m-1][0] = 1; // 相当于最左面一列，只能一直往下走</code></pre>
<p>时间复杂度：O(m<em>n)<br>空间复杂度：O(m</em>n)，使用dp数组保存结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def uniquePaths(self, m: int, n: int) -&gt; int:</span><br><span class="line">        if m&lt;&#x3D;0 or n&lt;&#x3D;0:</span><br><span class="line">            return 0</span><br><span class="line">        dp&#x3D;[ n*[_] for _ in range(m)] # 定义二维数组</span><br><span class="line">        # print(dp)</span><br><span class="line">        for i in range(m):</span><br><span class="line">            dp[i][0]&#x3D;1</span><br><span class="line">        for j in range(n):</span><br><span class="line">            dp[0][j]&#x3D;1</span><br><span class="line">            </span><br><span class="line">        for i in range(1,m):</span><br><span class="line">            for j in range(1,n):</span><br><span class="line">                dp[i][j]&#x3D;dp[i-1][j]+dp[i][j-1]</span><br><span class="line">        return dp[m-1][n-1]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def uniquePaths(self, m: int, n: int) -&gt; int:</span><br><span class="line">        if m&lt;&#x3D;0 or n&lt;&#x3D;0:</span><br><span class="line">            return 0</span><br><span class="line">        dp&#x3D;[ m*[_] for _ in range(n)]</span><br><span class="line">        # print(dp)</span><br><span class="line">        for i in range(n):</span><br><span class="line">            dp[i][0]&#x3D;1</span><br><span class="line">        for j in range(m):</span><br><span class="line">            dp[0][j]&#x3D;1</span><br><span class="line">            </span><br><span class="line">        for i in range(1,n):</span><br><span class="line">            for j in range(1,m):</span><br><span class="line">                dp[i][j]&#x3D;dp[i-1][j]+dp[i][j-1]</span><br><span class="line">        return dp[n-1][m-1]</span><br></pre></td></tr></table></figure>

<p>题解二|动态规划优化:</p>
<p>参考：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&amp;mid=2247486303&amp;idx=1&amp;sn=6034d1e6ca24253da64d6c539998f7c6&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&amp;mid=2247486303&amp;idx=1&amp;sn=6034d1e6ca24253da64d6c539998f7c6&amp;scene=21#wechat_redirect</a></p>
<p>转化成一维，关系式为 dp[i] = dp[i] + dp[i-1]</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def uniquePaths(self, m: int, n: int) -&gt; int:</span><br><span class="line">        if m&lt;&#x3D;0 or n&lt;&#x3D;0:</span><br><span class="line">            return 0</span><br><span class="line">        dp&#x3D;n*[0] # n是列</span><br><span class="line">        for i in range(n):</span><br><span class="line">            dp[i]&#x3D;1</span><br><span class="line">        </span><br><span class="line">        for i in range(1,m):</span><br><span class="line">            dp[0]&#x3D;1</span><br><span class="line">            for j in range(1,n):</span><br><span class="line">                dp[j]&#x3D;dp[j-1]+dp[j]</span><br><span class="line">        return dp[n-1]</span><br></pre></td></tr></table></figure>
<h3 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63.不同路径 II"></a>63.不同路径 II</h3><pre><code>链接：https://leetcode-cn.com/problems/unique-paths-ii/

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

如上图

网格中的障碍物和空位置分别用 1 和 0 来表示。

说明：m 和 n 的值均不超过 100。

示例 1:

输入:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
输出: 2
解释:
3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下
2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</code></pre>
<p>题解一|动态规划：</p>
<p>1、定义数组元素的含义<br>    机器人从左上角走到(i, j) 这个位置时，一共有 dp[i][j] 种路径<br>2、找出关系数组元素间的关系式<br>    想象以下，机器人要怎么样才能到达 (i, j)这个位置？由于机器人可以向下走或者向右走，所以有两种方式到达。当遇到障碍时</p>
<pre><code>一种是从 (i-1, j) 这个位置走一步到达

一种是从(i, j-1) 这个位置走一步到达

因为是计算所有可能的步骤，所以是把所有可能走的路径都加起来，所以关系式是 dp[i][j] = dp[i-1][j] + dp[i][j-1]。（当没有遇到障碍时，就用以上的方式进行）</code></pre>
<p>3、找出初始值<br>    dp[0][0]=1</p>
<pre><code>dp[0][i]=dp[0][i-1]; // 相当于最上面一行，机器人只能一直往右走（当没有遇到障碍时）
dp[i][0]=dp[i-1][0]; // 相当于最左面一列，机器人只能一直往下走（当没有遇到障碍时）</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -&gt; int:</span><br><span class="line">        if obstacleGrid is None:</span><br><span class="line">            return 0</span><br><span class="line">        if obstacleGrid[0][0]&#x3D;&#x3D;1 or obstacleGrid[-1][-1] &#x3D;&#x3D; 1:</span><br><span class="line">            return 0</span><br><span class="line"></span><br><span class="line">        m&#x3D;len(obstacleGrid)</span><br><span class="line">        n&#x3D;len(obstacleGrid[0])</span><br><span class="line"></span><br><span class="line">        dp&#x3D;[n*[0] for _ in range(m)]  # dp&#x3D;[n*[_] for _ in range(m)]时结果有误</span><br><span class="line"></span><br><span class="line">        dp[0][0]&#x3D;1</span><br><span class="line">        for i in range(1,m):</span><br><span class="line">            if obstacleGrid[i][0] !&#x3D;1:</span><br><span class="line">                dp[i][0]&#x3D;dp[i-1][0]</span><br><span class="line"></span><br><span class="line">        for i in range(1,n):</span><br><span class="line">            if obstacleGrid[0][i] !&#x3D;1:</span><br><span class="line">                dp[0][i]&#x3D;dp[0][i-1]</span><br><span class="line"></span><br><span class="line">        for i in range(1,m):</span><br><span class="line">            for j in range(1,n):</span><br><span class="line">                if obstacleGrid[i][j] !&#x3D; 1:</span><br><span class="line">                    dp[i][j]&#x3D;dp[i-1][j]+dp[i][j-1]</span><br><span class="line">        # print(dp[m-1][n-1])</span><br><span class="line">        return dp[-1][-1]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64.最小路径和"></a>64.最小路径和</h3><pre><code>链接：https://leetcode-cn.com/problems/minimum-path-sum/

给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。

示例:

输入:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 7
解释: 因为路径 1→3→1→1→1 的总和最小。</code></pre>
<p>题解一|动态规划：<br>1、定义数组元素的含义<br>    目的是从左上角到右下角，最小路径和是多少。<br>    dp[i][j]含义：当从左上角走到(i,j)位置时，最小路径和为dp[i][j]</p>
<pre><code>定义二维数据，数组是从下标 0 开始算起的，所以右下角的位置是 (m-1, n - 1)，所以 dp[m-1][n-1] 就是我们所求。</code></pre>
<p>2、找到数组的递推关系式</p>
<pre><code>如何才能到达 (i, j) 这个位置？由于可以向下走或者向右走，所以有两种方式到达：

    一种是从 (i-1, j) 这个位置走一步到达
    一种是从 (i, j-1) 这个位置走一步到达

不过本次计算不是所有可能路径，而是计算哪一个路径和最小。

所以：dp[i][j]=min(dp[i-1][j],dp[i][j-1])+arr[i][j]</code></pre>
<p>3、找到初始值</p>
<pre><code>当 dp[i][j] 中，如果 i 或者 j 有一个为 0，那么还能使用关系式吗？答是不能的，因为这个时候把 i - 1 或者 j - 1，就变成负数了，数组就会出问题了，所以我们的初始值是计算出所有的 dp[0][0….n-1] 和所有的 dp[0….m-1][0]

dp[0][j] = arr[0][j] + dp[0][j-1]; // 相当于最上面一行，只能一直往左走
dp[i][0] = arr[i][0] + dp[i][0];  // 相当于最左面一列，只能一直往下走</code></pre>
<p>时间复杂度：O(m<em>n)<br>空间复杂度：O(m</em>n)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def minPathSum(self, grid: List[List[int]]) -&gt; int:</span><br><span class="line">        # print(grid)</span><br><span class="line">        m&#x3D;len(grid) # 行</span><br><span class="line">        n&#x3D;len(grid[0]) # 列</span><br><span class="line">        if m&lt;&#x3D;0 or n&lt;&#x3D;0:</span><br><span class="line">            return 0</span><br><span class="line">        dp&#x3D;[ n*[_] for _ in range(m)]</span><br><span class="line">        # print(dp)</span><br><span class="line">        dp[0][0]&#x3D;grid[0][0] </span><br><span class="line">        </span><br><span class="line">        for i in range(1,m):</span><br><span class="line">            dp[i][0]&#x3D;dp[i-1][0]+grid[i][0]</span><br><span class="line"></span><br><span class="line">        for i in range(1,n):</span><br><span class="line">            dp[0][i]&#x3D;dp[0][i-1]+grid[0][i]</span><br><span class="line">        </span><br><span class="line">        for i in range(1,m):</span><br><span class="line">            for j in range(1,n):</span><br><span class="line">                dp[i][j]&#x3D;min(dp[i-1][j],dp[i][j-1])+grid[i][j]</span><br><span class="line">        # print(dp)</span><br><span class="line"></span><br><span class="line">        return dp[m-1][n-1]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a>70.爬楼梯</h3><pre><code>链接：https://leetcode-cn.com/problems/climbing-stairs/

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1：

输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
示例 2：

输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶</code></pre>
<p>题解一|递归：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def climbStairs(self, n: int) -&gt; int:</span><br><span class="line">        if n&lt;&#x3D;2:</span><br><span class="line">            return n</span><br><span class="line">        return self.climbStairs(n-1)+self.climbStairs(n-2)</span><br></pre></td></tr></table></figure>
<p>题解二|动态规划：<br>1、定义数组元素的含义</p>
<pre><code>dp[i]含义：跳上第i个台阶总共有dp[i]种跳法；
dp[n]即为我们所求结果。</code></pre>
<p>2、找出数组元素间的关系式</p>
<pre><code>把一个规模比较大的问题分成几个规模比较小的问题，然后由小的问题推导出大的问题。
到达第 n 级的台阶有两种方式：
    一种是从第 n-1 级跳上来
    一种是从第 n-2 级跳上来
所以：dp[n] = dp[n-1] + dp[n-2]。</code></pre>
<p>3、找出初始值</p>
<pre><code>n=1时，dp[1]=dp[0]+dp[-1]，不允许下标为-1，所以dp[1]=1
n=0时，dp[0]=0
n=2时，dp[2]=dp[1]+dp[0]=1，所以以上初始值定义不严谨，因为dp[2]=2</code></pre>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def climbStairs(self, n: int) -&gt; int:</span><br><span class="line">        if n&lt;&#x3D;2:</span><br><span class="line">            return n</span><br><span class="line">        dp&#x3D;(n+1)*[0] # 注意是n+1</span><br><span class="line">        dp[1]&#x3D;1</span><br><span class="line">        dp[2]&#x3D;2</span><br><span class="line">        for i in range(3,n+1):</span><br><span class="line">            dp[i]&#x3D;dp[i-1]+dp[i-2]</span><br><span class="line">        return dp[n] # 返回最后一个数</span><br></pre></td></tr></table></figure>
<h3 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72.编辑距离"></a>72.编辑距离</h3><pre><code>链接：https://leetcode-cn.com/problems/edit-distance/

给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

插入一个字符
删除一个字符
替换一个字符
示例 1:

输入: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;
输出: 3
解释: 
horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)
rorse -&gt; rose (删除 &#39;r&#39;)
rose -&gt; ros (删除 &#39;e&#39;)
示例 2:

输入: word1 = &quot;intention&quot;, word2 = &quot;execution&quot;
输出: 5
解释: 
intention -&gt; inention (删除 &#39;t&#39;)
inention -&gt; enention (将 &#39;i&#39; 替换为 &#39;e&#39;)
enention -&gt; exention (将 &#39;n&#39; 替换为 &#39;x&#39;)
exention -&gt; exection (将 &#39;n&#39; 替换为 &#39;c&#39;)
exection -&gt; execution (插入 &#39;u&#39;)</code></pre>
<p>思路：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if s1[i] &#x3D;&#x3D; s2[j]:</span><br><span class="line">    啥都别做（skip）</span><br><span class="line">    i, j 同时向前移动</span><br><span class="line">else:</span><br><span class="line">    三选一：</span><br><span class="line">        插入（insert）</span><br><span class="line">        删除（delete）</span><br><span class="line">        替换（replace）</span><br></pre></td></tr></table></figure>

<p>题解一|递归|自顶向下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def minDistance(self, word1: str, word2: str) -&gt; int:</span><br><span class="line">        def dp(i,j):</span><br><span class="line">            if i&#x3D;&#x3D;-1:</span><br><span class="line">                return j+1</span><br><span class="line">            if j&#x3D;&#x3D;-1:</span><br><span class="line">                return i+1</span><br><span class="line">            if word1[i]&#x3D;&#x3D;word2[j]:</span><br><span class="line">                return dp(i-1,j-1) # 什么都不做</span><br><span class="line">            else:</span><br><span class="line">                return min(</span><br><span class="line">                    dp(i,j-1)+1, # 插入</span><br><span class="line">                    dp(i-1,j)+1, # 删除</span><br><span class="line">                    dp(i-1,j-1)+1 # 替换</span><br><span class="line">                    )</span><br><span class="line">        return dp(len(word1)-1,len(word2)-1)</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">if s1[i] &#x3D;&#x3D; s2[j]:</span><br><span class="line">    return dp(i - 1, j - 1)  # 啥都不做</span><br><span class="line"># 解释：</span><br><span class="line"># 本来就相等，不需要任何操作</span><br><span class="line"># s1[0..i] 和 s2[0..j] 的最小编辑距离等于</span><br><span class="line"># s1[0..i-1] 和 s2[0..j-1] 的最小编辑距离</span><br><span class="line"># 也就是说 dp(i, j) 等于 dp(i-1, j-1)</span><br><span class="line"></span><br><span class="line">dp(i, j - 1) + 1,    # 插入</span><br><span class="line"># 解释：</span><br><span class="line"># 我直接在 s1[i] 插入一个和 s2[j] 一样的字符</span><br><span class="line"># 那么 s2[j] 就被匹配了，前移 j，继续跟 i 对比</span><br><span class="line"># 别忘了操作数加一</span><br><span class="line"></span><br><span class="line">dp(i - 1, j) + 1,    # 删除</span><br><span class="line"># 解释：</span><br><span class="line"># 我直接把 s[i] 这个字符删掉</span><br><span class="line"># 前移 i，继续跟 j 对比</span><br><span class="line"># 操作数加一</span><br><span class="line"></span><br><span class="line">dp(i - 1, j - 1) + 1 # 替换</span><br><span class="line"># 解释：</span><br><span class="line"># 我直接把 s1[i] 替换成 s2[j]，这样它俩就匹配了</span><br><span class="line"># 同时前移 i，j 继续对比</span><br><span class="line"># 操作数加一</span><br></pre></td></tr></table></figure>

<p>优化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def minDistance(self, word1: str, word2: str) -&gt; int:</span><br><span class="line">        memo&#x3D;dict()</span><br><span class="line"></span><br><span class="line">        def dp(i,j):</span><br><span class="line">            if (i,j) in memo:</span><br><span class="line">                return memo[(i,j)]</span><br><span class="line">            if i&#x3D;&#x3D;-1:</span><br><span class="line">                return j+1</span><br><span class="line">            if j&#x3D;&#x3D;-1:</span><br><span class="line">                return i+1</span><br><span class="line">            if word1[i]&#x3D;&#x3D;word2[j]:</span><br><span class="line">                memo[(i,j)] &#x3D; dp(i-1,j-1) # 什么都不做</span><br><span class="line">            else:</span><br><span class="line">                memo[(i,j)]&#x3D; min(</span><br><span class="line">                    dp(i,j-1)+1, # 插入</span><br><span class="line">                    dp(i-1,j)+1, # 删除</span><br><span class="line">                    dp(i-1,j-1)+1 # 替换</span><br><span class="line">                    )</span><br><span class="line">            return memo[(i,j)]</span><br><span class="line">        return dp(len(word1)-1,len(word2)-1)</span><br></pre></td></tr></table></figure>


<p>题解二|动态规划：</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/dp4.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/dp4.png"></p>
<p>思路：</p>
<pre><code>理解 word1 上的删除等价 word2 上的增加, word1 上的增加等价于 word2 上的删除
2维的 dp array 中某一点 dp[i][j] 的意义: word1[ : i] 到 word[ : j] 转换所需要的最小的数目
不太需要关注具体进行了删除、增加还是替换操作，而是专注于 a 状态到 b 状态所需要的步数</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def minDistance(self, word1: str, word2: str) -&gt; int:</span><br><span class="line">        m &#x3D; len(word1)</span><br><span class="line">        n &#x3D; len(word2)</span><br><span class="line">        dp &#x3D; [[float(&#39;inf&#39;) for _ in range(n + 1)] for _ in range(m + 1)]</span><br><span class="line">        # 初始化</span><br><span class="line">        for i in range(m + 1):</span><br><span class="line">            dp[i][0] &#x3D; i</span><br><span class="line">        for i in range(n + 1):</span><br><span class="line">            dp[0][i] &#x3D; i</span><br><span class="line">        # 状态转移</span><br><span class="line">        # i , j 代表 word1, word2 对应位置的 index</span><br><span class="line">        for i in range(1, m + 1):</span><br><span class="line">            for j in range(1, n + 1):</span><br><span class="line">                # 如果word1[:i][-1]&#x3D;&#x3D;word2[:j][-1]</span><br><span class="line">                if word1[i - 1] &#x3D;&#x3D; word2[j - 1]:</span><br><span class="line">                    dp[i][j] &#x3D; dp[i - 1][j - 1]</span><br><span class="line">                # 否则从三种状态中选一个最小的然后 +1</span><br><span class="line">                else:</span><br><span class="line">                    dp[i][j] &#x3D; min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1</span><br><span class="line">        return dp[m][n]</span><br></pre></td></tr></table></figure>

<p>题解三|动态规划：</p>
<pre><code>参考：https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&amp;mid=2247486294&amp;idx=1&amp;sn=dd8968700d19ea8b1db29065dc2f7b01&amp;scene=21#wechat_redirect</code></pre>
<p>1、定义数组元素的含义</p>
<pre><code>目的：求将 word1 转换成 word2 所使用的最少操作数 。

dp[i][j]的含义为：当字符串 word1 的长度为 i，字符串 word2 的长度为 j 时，将 word1 转化为 word2 所使用的最少操作次数为 dp[i][j]。</code></pre>
<p>2、找出关系数组元素间的关系式</p>
<pre><code>第一种：如果我们 word1[i] 与 word2 [j] 相等，这个时候不需要进行任何操作，所以 dp[i][j] = dp[i-1][j-1]。

第二种：如果我们 word1[i] 与 word2 [j] 不相等，这个时候我们就必须进行调整，而调整的操作有 3 种，我们要选择一种。
三种操作对应的关系式如下（注意字符串与字符的区别）：

（1）、如果把字符 word1[i] 替换成与 word2[j] 相等，则有 dp[i][j] = dp[i-1][j-1] + 1;

（2）、如果在字符串 word1末尾插入一个与 word2[j] 相等的字符，则有 dp[i][j] = dp[i][j-1] + 1;

（3）、如果把字符 word1[i] 删除，则有 dp[i][j] = dp[i-1][j] + 1;

所以应该选择一种操作，使得 dp[i][j] 的值最小，显然关系式有：dp[i][j] = min(dp[i-1] [j-1]，dp[i][j-1]，dp[i-1][j]) + 1;</code></pre>
<p>3、找出初始值</p>
<pre><code>当 dp[i][j] 中，如果 i 或者 j 有一个为 0，那么还能使用关系式吗？答是不能的，因为这个时候把 i - 1 或者 j - 1，就变成负数了，数组就会出问题了，所以我们的初始值是计算出所有的 dp[0][0….n] 和所有的 dp[0….m][0]。

这个还是非常容易计算的，因为当有一个字符串的长度为 0 时，转化为另外一个字符串，那就只能一直进行插入或者删除操作了。</code></pre>
<p>时间复杂度：O(m<em>n)<br>空间复杂度：O(m</em>n)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def minDistance(self, word1: str, word2: str) -&gt; int:</span><br><span class="line">        m&#x3D;len(word1)+1</span><br><span class="line">        n&#x3D;len(word2)+1</span><br><span class="line">        dp &#x3D; [ n*[_] for _ in range(m) ]</span><br><span class="line">        for i in range(1,m):</span><br><span class="line">            dp[i][0]&#x3D;dp[i-1][0]+1</span><br><span class="line">        </span><br><span class="line">        for i in range(1,n):</span><br><span class="line">            dp[0][i]&#x3D;dp[0][i-1]+1</span><br><span class="line">        </span><br><span class="line">        for i in range(1,m):</span><br><span class="line">            for j in range(1,n):</span><br><span class="line">                if word1[i-1]&#x3D;&#x3D;word2[j-1]:</span><br><span class="line">                    dp[i][j]&#x3D;dp[i-1][j-1]</span><br><span class="line">                else:</span><br><span class="line">                    dp[i][j]&#x3D;min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])+1</span><br><span class="line">        # print(dp)</span><br><span class="line">        # print(dp[-1][-1])</span><br><span class="line">        return dp[m-1][n-1]</span><br></pre></td></tr></table></figure>

<p>???题解四|动态规划优化：</p>
<p>定义额外变量 pre = (i-1,j-1) 的值<br>二维的dp[i][j]=min(dp[i-1][j],dp[i-1][j-1],dp[i][j-1])+1<br>转换为一维的dp[i]=min(dp[i-1],pre,dp[i])+1</p>
<p>空间复杂度：O(n)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def minDistance(self, word1: str, word2: str) -&gt; int:</span><br><span class="line">        m&#x3D;len(word1)+1</span><br><span class="line">        n&#x3D;len(word2)+1</span><br><span class="line">        dp &#x3D; n*[0]</span><br><span class="line"></span><br><span class="line">        for i in range(0,n):</span><br><span class="line">            dp[i]&#x3D;i</span><br><span class="line">        </span><br><span class="line">        for i in range(1,m):</span><br><span class="line">            tmp&#x3D;dp[0]</span><br><span class="line">            dp[0]&#x3D;i</span><br><span class="line">            for j in range(1,n):</span><br><span class="line">                pre&#x3D;tmp</span><br><span class="line">                tmp&#x3D;dp[j]</span><br><span class="line">                if word1[i-1]&#x3D;&#x3D;word2[j-1]:</span><br><span class="line">                    dp[j]&#x3D;pre</span><br><span class="line">                else:</span><br><span class="line">                    dp[j]&#x3D;min(dp[j-1],pre,dp[j])+1</span><br><span class="line">        return dp[n-1]</span><br></pre></td></tr></table></figure>

<h3 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91.解码方法"></a>91.解码方法</h3><pre><code>链接：https://leetcode-cn.com/problems/decode-ways/

一条包含字母 A-Z 的消息通过以下方式进行了编码：

&#39;A&#39; -&gt; 1
&#39;B&#39; -&gt; 2
...
&#39;Z&#39; -&gt; 26
给定一个只包含数字的非空字符串，请计算解码方法的总数。

示例 1:

输入: &quot;12&quot;
输出: 2
解释: 它可以解码为 &quot;AB&quot;（1 2）或者 &quot;L&quot;（12）。
示例 2:

输入: &quot;226&quot;
输出: 3
解释: 它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。</code></pre>
<p>题解一|动态规划：<br>    此题类似于青蛙跳台阶问题，不同的只是多了很多限制条件。</p>
<pre><code>青蛙跳台阶时，可以选择跳一级，也可以选择跳两级，所以青蛙到达第 n 级的台阶有两种方式：
一种是从第 n-1 级跳上来；
一种是从第 n-2 级跳上来；

解码也同理，最大编码为26，所以第 n 个位置编码的总数也有两种方式：
一种是从第 n-1 编码位置的总数；
一种是从第 n-2 编码位置的总数；

1、定义数组元素的含义
第 i 位置的编码总数有 dp[i] 个
d[i]代表第i个位置解码方法的总数

2、找出关系数组元素间的关系式
d[i]=d[i-1]+d[i-2]
d[i+1]=d[i]+d[i-1]

3、找出初始值
dp[0]=1
dp[1]=1
dp[2]=2(此题限制2不好，因为‘10’返回1，’27‘返回0)

4、限制条件
字符串以‘0’开头时返回0
字符串含有‘00’时返回0
字符串中s[i]=&#39;0&#39;但是int(s[i-1])&gt;2时返回0
字符串s[i-1:i]&gt;26时，此时应该分开计算。dp[i]+=dp[i-1]</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def numDecodings(self, s: str) -&gt; int:</span><br><span class="line">    </span><br><span class="line">        if s[0]&#x3D;&#x3D;&#39;0&#39; or s is None:</span><br><span class="line">            return 0</span><br><span class="line">        if len(s)&#x3D;&#x3D;1:</span><br><span class="line">            return 1</span><br><span class="line">        if len(s)&#x3D;&#x3D;2:</span><br><span class="line">            return 2</span><br><span class="line"></span><br><span class="line">        dp&#x3D;[0]*(len(s))</span><br><span class="line">        dp[0]&#x3D;1</span><br><span class="line">        dp[1]&#x3D;1</span><br><span class="line">        dp[2]&#x3D;2</span><br><span class="line">        for i in range(2,len(s)):</span><br><span class="line">            if s[i] !&#x3D; &#39;0&#39;:</span><br><span class="line">                print(i)</span><br><span class="line">                dp[i]+&#x3D;dp[i-1]</span><br><span class="line">            if s[i-1] &#x3D;&#x3D;&#39;1&#39; and (s[i-1]&#x3D;&#x3D;&#39;2&#39; or s[i]&lt;&#x3D;6):</span><br><span class="line">                dp[i]+&#x3D;dp[i-2]</span><br><span class="line">            if s[i]&#x3D;&#x3D;&#39;0&#39; and s[i-1]&#x3D;&#x3D;&#39;0&#39;:</span><br><span class="line">                return 0</span><br><span class="line">        return dp[-1]</span><br><span class="line">                </span><br><span class="line">用例‘10’这个例子预期输出应该是1,但是实际输出为2，所以for循环从2开始有问题。</span><br><span class="line">即使改成如下也有问题：</span><br><span class="line">        if s&#x3D;&#x3D;&#39;10&#39; or s&#x3D;&#x3D;&#39;20&#39;:</span><br><span class="line">            return 1</span><br><span class="line">        elif int(s)&gt;26:</span><br><span class="line">            return 0</span><br><span class="line">        elif len(s)&#x3D;&#x3D;2:</span><br><span class="line">            return 2</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def numDecodings(self, s: str) -&gt; int:</span><br><span class="line">    </span><br><span class="line">        if s[0]&#x3D;&#x3D;&#39;0&#39; or s is None:</span><br><span class="line">            return 0</span><br><span class="line">        if len(s)&#x3D;&#x3D;1:</span><br><span class="line">            return 1</span><br><span class="line">    </span><br><span class="line">        length&#x3D;len(s)</span><br><span class="line">        dp&#x3D;[0]*(length+1)</span><br><span class="line">        dp[0]&#x3D;1</span><br><span class="line">        dp[1]&#x3D;1</span><br><span class="line"></span><br><span class="line">        for i in range(1,len(s)):</span><br><span class="line">            if s[i] !&#x3D; &#39;0&#39;:</span><br><span class="line">                dp[i+1]+&#x3D;dp[i]</span><br><span class="line">            if s[i-1] &#x3D;&#x3D;&#39;1&#39; or (s[i-1]&#x3D;&#x3D;&#39;2&#39; and int(s[i])&lt;&#x3D;6):</span><br><span class="line">                dp[i+1]+&#x3D;dp[i-1]</span><br><span class="line">            if s[i]&#x3D;&#x3D;&#39;0&#39; and s[i-1]&#x3D;&#x3D;&#39;0&#39;:</span><br><span class="line">                return 0</span><br><span class="line">        # print(dp[-1])</span><br><span class="line">        return dp[length]</span><br></pre></td></tr></table></figure>
<h3 id="95-不同的二叉搜索树-II"><a href="#95-不同的二叉搜索树-II" class="headerlink" title="?95. 不同的二叉搜索树 II"></a>?95. 不同的二叉搜索树 II</h3><pre><code>链接：https://leetcode-cn.com/problems/unique-binary-search-trees-ii/

给定一个整数 n，生成所有由 1 ... n 为节点所组成的二叉搜索树。

示例:

输入: 3
输出:
[
  [1,null,3,2],
  [3,2,null,1],
  [3,1,null,null,2],
  [2,1,3],
  [1,null,2,null,3]
]
解释:
以上的输出对应以下 5 种不同结构的二叉搜索树：

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3</code></pre>
<p>题解一|递归：<br><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/tree3.png" alt="tree3"><br><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/tree4.png" alt="tree4"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># Definition for a binary tree node.</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.left &#x3D; None</span><br><span class="line">#         self.right &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def generateTrees(self, n: int) -&gt; List[TreeNode]:</span><br><span class="line">        if n:</span><br><span class="line">            return self.build(1,n)</span><br><span class="line">        else:</span><br><span class="line">            []</span><br><span class="line">    def build(self,start,end):</span><br><span class="line">        # 结束条件</span><br><span class="line">        if start&gt;end:</span><br><span class="line">            return [None,]</span><br><span class="line">        </span><br><span class="line">        trees&#x3D;[]</span><br><span class="line">        for i in range(start,end+1):</span><br><span class="line">            leftTrees&#x3D;self.build(start,i-1)</span><br><span class="line">            rightTrees&#x3D;self.build(i+1,end)</span><br><span class="line">            for l in leftTrees:</span><br><span class="line">                for r in rightTrees:</span><br><span class="line">                    currentTree&#x3D;TreeNode(i)</span><br><span class="line">                    currentTree.left&#x3D;l</span><br><span class="line">                    currentTree.right&#x3D;r</span><br><span class="line">                    trees.append(currentTree)</span><br><span class="line">        # print(trees)</span><br><span class="line">        return trees</span><br></pre></td></tr></table></figure>
<h3 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96.不同的二叉搜索树"></a>96.不同的二叉搜索树</h3><pre><code>链接：https://leetcode-cn.com/problems/unique-binary-search-trees/

给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

示例:

输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3</code></pre>
<p>题解一|动态规划:</p>
<p>二叉树定义：</p>
<p>二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-binary-search-trees/solution/bu-tong-de-er-cha-sou-suo-shu-by-leetcode/">https://leetcode-cn.com/problems/unique-binary-search-trees/solution/bu-tong-de-er-cha-sou-suo-shu-by-leetcode/</a><br>方法：</p>
<pre><code>给定一个有序序列 1 ... n，为了根据序列构建一棵二叉搜索树。我们可以遍历每个数字 i，将该数字作为树根，1 ... (i-1) 序列将成为左子树，(i+1) ... n 序列将成为右子树。于是，我们可以递归地从子序列构建子树。
在上述方法中，由于根各自不同，每棵二叉树都保证是独特的。

可见，问题可以分解成规模较小的子问题。因此，我们可以存储并复用子问题的解，而不是递归的（也重复的）解决这些子问题，这就是动态规划法。</code></pre>
<p>函数定义：</p>
<pre><code>令G(n)的从1到n可以形成二叉搜索树个数
令f(i)为以i为根的二叉搜索树的个数

所以G(n)是解决问题的函数：G(n) = f(1) + f(2) + f(3) + f(4) + ... + f(n)</code></pre>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/tree.png" alt="tree"></p>
<p>1、定义数组元素的含义<br>    G[i]代表二叉搜索树的个数<br>2、找出数组之间的的关系式<br>    以i为根，[0,i-1]为左节点，[i+1,n]为右节点<br>    之后再对[0,i-1]和[i+1,n]递归求解</p>
<pre><code>f(i)=G(i-1)+G(n-i)
G(n)=f(1) + f(2) + f(3) + f(4) + ... + f(n)
    =G(0)G(n-1)+G(1)G(n-2)+...+G(n-1)G(0)</code></pre>
<p>3、找出初始值<br>    G[0]=1<br>    G[1]=1<br>    G[2]=2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def numTrees(self, n: int) -&gt; int:</span><br><span class="line">        dp&#x3D;[0]*(n+1)</span><br><span class="line">        dp[0]&#x3D;1</span><br><span class="line">        dp[1]&#x3D;1</span><br><span class="line"></span><br><span class="line">        for i in range(2,n+1):</span><br><span class="line">            for j in range(1,i+1):</span><br><span class="line">                dp[i]+&#x3D;dp[j-1]*dp[i-j]</span><br><span class="line">        # print(dp)</span><br><span class="line">        return dp[n]</span><br></pre></td></tr></table></figure>

<h3 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118.杨辉三角"></a>118.杨辉三角</h3><pre><code>链接：https://leetcode-cn.com/problems/pascals-triangle/

给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。

在杨辉三角中，每个数是它左上方和右上方的数的和。

示例:

输入: 5
输出:
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]</code></pre>
<p>题解一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def generate(self, numRows: int) -&gt; List[List[int]]:</span><br><span class="line">        triangle&#x3D;[]</span><br><span class="line">        for i in range(numRows):</span><br><span class="line">            row&#x3D;[None for _ in range(i+1)]</span><br><span class="line">            row[0],row[-1]&#x3D;1,1</span><br><span class="line">            for j in range(1,len(row)-1):</span><br><span class="line">                row[j]&#x3D;triangle[i-1][j-1]+triangle[i-1][j]</span><br><span class="line">            triangle.append(row)</span><br><span class="line">        return triangle</span><br></pre></td></tr></table></figure>
<p>题解二|动态规划：</p>
<pre><code>1、定义数组元素的含义
    dp存储每个数

2、找出数组之间的的关系式
    遍历dp，将为0的位置使用动态规划填入，公式：dp[i][j]=dp[i-1][j-1]+dp[i-1][j]

3、找出初始值
    初始化结果数组，numRows表示结果数组dp的行数，每一行的元素个数等于所处第几行。全部初始化为0；
    将边界全部初始化为1；</code></pre>
<p>时间复杂度：O(n^2)，等差数列求和。<br>空间复杂度：O(n^2)，等差数列求和。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def generate(self, numRows: int) -&gt; List[List[int]]:</span><br><span class="line">        dp&#x3D;[[0]*i for i in range(1,numRows+1)]</span><br><span class="line">        for i in range(numRows):</span><br><span class="line">            dp[i][0]&#x3D;dp[i][-1]&#x3D;1</span><br><span class="line">        for i in range(0,numRows):</span><br><span class="line">            for j in range(i+1):</span><br><span class="line">                if dp[i][j]&#x3D;&#x3D;0:</span><br><span class="line">                    dp[i][j]&#x3D;dp[i-1][j-1]+dp[i-1][j]</span><br><span class="line">        return dp</span><br></pre></td></tr></table></figure>
<h3 id="119-杨辉三角-II"><a href="#119-杨辉三角-II" class="headerlink" title="119. 杨辉三角 II"></a>119. 杨辉三角 II</h3><pre><code>链接：https://leetcode-cn.com/problems/pascals-triangle-ii/

给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。

在杨辉三角中，每个数是它左上方和右上方的数的和。

示例:

输入: 3
输出: [1,3,3,1]
进阶：你可以优化你的算法到 O(k) 空间复杂度吗？</code></pre>
<p>题解一|动态规划：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def getRow(self, rowIndex: int) -&gt; List[int]:</span><br><span class="line">        dp&#x3D;[[0]* i for i in range(1,rowIndex+2)]</span><br><span class="line">        for i in range(rowIndex+1):</span><br><span class="line">            dp[i][0]&#x3D;dp[i][-1]&#x3D;1</span><br><span class="line">        for i in range(rowIndex+1):</span><br><span class="line">            for j in range(i+1):</span><br><span class="line">                if dp[i][j]&#x3D;&#x3D;0:</span><br><span class="line">                    dp[i][j]&#x3D;dp[i-1][j-1]+dp[i-1][j]</span><br><span class="line">        return dp[rowIndex]</span><br></pre></td></tr></table></figure>

<h3 id="120-三角形最小路径和"><a href="#120-三角形最小路径和" class="headerlink" title="120.三角形最小路径和"></a>120.三角形最小路径和</h3><pre><code>链接：https://leetcode-cn.com/problems/triangle/

给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。

例如，给定三角形：

[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。

说明：

如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。</code></pre>
<p>题解一|动态规划：</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/dp1.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/dp1.png"></p>
<p>1、定义数组的含义</p>
<pre><code>dp[i][j]为最小路径和</code></pre>
<p>2、找出递推关系式</p>
<pre><code>从第二行开始，遍历区间[1,n):
    对每一层的元素进行遍历，遍历区间[0,len(triangle[i])，存在3种情况：
        首位；
        末位；
        其他元素；</code></pre>
<p>3、找到初始值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def minimumTotal(self, triangle: List[List[int]]) -&gt; int:</span><br><span class="line">        if triangle is None:</span><br><span class="line">            return 0</span><br><span class="line">        m&#x3D;len(triangle)</span><br><span class="line">        # print(triangle,m,triangle[0]) # m&#x3D;4,triangle[0]&#x3D;[2]</span><br><span class="line">        if m&#x3D;&#x3D;1:</span><br><span class="line">            return triangle[0][0]</span><br><span class="line">        dp&#x3D;triangle</span><br><span class="line">        for i in range(1,m):</span><br><span class="line">            for j in range(len(triangle[i])):</span><br><span class="line">                if j&#x3D;&#x3D;0:</span><br><span class="line">                    dp[i][j]&#x3D;triangle[i-1][j]+triangle[i][j]</span><br><span class="line">                elif j&#x3D;&#x3D; len(triangle[i])-1:</span><br><span class="line">                    dp[i][j]&#x3D;triangle[i-1][j-1]+triangle[i][j]</span><br><span class="line">                else:</span><br><span class="line">                    dp[i][j]&#x3D;min(triangle[i-1][j],triangle[i-1][j-1])+triangle[i][j]</span><br><span class="line">        return min(dp[-1])</span><br></pre></td></tr></table></figure>

<p>优化一下，空间复杂度变为O(n).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def minimumTotal(self, triangle: List[List[int]]) -&gt; int:</span><br><span class="line">        if triangle is None:</span><br><span class="line">            return 0</span><br><span class="line">        m&#x3D;len(triangle)</span><br><span class="line">        if m&#x3D;&#x3D;1:</span><br><span class="line">            return triangle[0][0]</span><br><span class="line">        for i in range(1,m):</span><br><span class="line">            for j in range(len(triangle[i])):</span><br><span class="line">                if j&#x3D;&#x3D;0:</span><br><span class="line">                    triangle[i][j]+&#x3D;triangle[i-1][j]</span><br><span class="line">                elif j&#x3D;&#x3D; len(triangle[i])-1:</span><br><span class="line">                    triangle[i][j]+&#x3D;triangle[i-1][j-1]</span><br><span class="line">                else:</span><br><span class="line">                    triangle[i][j]+&#x3D;min(triangle[i-1][j],triangle[i-1][j-1])</span><br><span class="line">        return min(triangle[-1]) # 返回最后一行的最小值</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139.单词拆分"></a>139.单词拆分</h3><pre><code>链接：https://leetcode-cn.com/problems/word-break/

给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。

说明：

拆分时可以重复使用字典中的单词。
你可以假设字典中没有重复的单词。
示例 1：

输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]
输出: true
解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。
示例 2：

输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]
输出: true
解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。
     注意你可以重复使用字典中的单词。
示例 3：

输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]
输出: false</code></pre>
<p>题解一|动态规划：</p>
<p>1、定义数组的含义</p>
<pre><code>dp=[False,...,false],长度为n+1，n为字符串长度。
dp[i]表示s的前i位是否可以用wordDict中的单词表示。</code></pre>
<p>2、找出递推关系式</p>
<pre><code>遍历字符串的所有子串，遍历开始索引i，遍历区间[0,n)：
    遍历结束索引j，遍历区间[i+1,n+1)：
        若dp[i]=True且s[i,⋯,j)在wordlist中：dp[j]=True

        解释：dp[i]=True说明s的前i位可以用wordDict表示，则s[i,⋯,j)出现在wordDict中，说明s的前j位可以表示。

返回dp[n]</code></pre>
<p>3、找到初始值</p>
<pre><code>初始化dp[0]=True，空字符可以被表示。</code></pre>
<p>时间复杂度：O(n^2)<br>空间复杂度：O(n)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def wordBreak(self, s: str, wordDict: List[str]) -&gt; bool:</span><br><span class="line">        n&#x3D;len(s)</span><br><span class="line">        dp&#x3D;(n+1)*[False]</span><br><span class="line">        dp[0]&#x3D;True</span><br><span class="line">        for i in range(n):</span><br><span class="line">            for j in range(i+1,n+1):</span><br><span class="line">                if dp[i] and s[i:j] in wordDict:</span><br><span class="line">                    dp[j]&#x3D;True</span><br><span class="line">        # return dp[n]</span><br><span class="line">        return dp[-1]</span><br></pre></td></tr></table></figure>

<p>题解二|DFS|记忆化递归：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def wordBreak(self, s: str, wordDict: List[str]) -&gt; bool:</span><br><span class="line">        memo&#x3D;[None] * len(s)</span><br><span class="line">        def dfs(first):</span><br><span class="line">            if first &gt;&#x3D; len(s):</span><br><span class="line">                return True</span><br><span class="line">            if memo[first] !&#x3D; None:</span><br><span class="line">                return memo[first]</span><br><span class="line"></span><br><span class="line">            for i in range(first,len(s)):</span><br><span class="line">                if s[first:i+1] in wordDict and dfs(i+1):</span><br><span class="line">                    memo[first]&#x3D;True</span><br><span class="line">                    return True</span><br><span class="line">            memo[first]&#x3D;False</span><br><span class="line">            return False</span><br><span class="line"></span><br><span class="line">        return dfs(0)</span><br></pre></td></tr></table></figure>

<p>??题解三|记忆化回溯）:</p>
<pre><code>1、使用记忆化函数，保存出现过的backtrack(s)，避免重复计算。

2、定义回溯函数backtrack(s)

    若s长度为0，则返回True，表示已经使用wordDict中的单词分割完。
    初试化当前字符串是否可以被分割res=False
    遍历结束索引i，遍历区间[1,n+1)：
        若s[0,⋯,i−1]在wordDict中：res=backtrack(s[i,...,n-1]) or  res。
        解释：保存遍历结束索引中，可以使字符串切割完成的情况。
    返回res

3、返回backtrack(s)</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def wordBreak(self, s: str, wordDict: List[str]) -&gt; bool:</span><br><span class="line">        import functools</span><br><span class="line">        @functools.lru_cache(None)</span><br><span class="line">        def back_track(s):</span><br><span class="line">            if (not s):</span><br><span class="line">                return True</span><br><span class="line">            res&#x3D;False</span><br><span class="line">            for i in range(1,len(s)+1):</span><br><span class="line">                if(s[:i] in wordDict):</span><br><span class="line">                    res&#x3D;back_track(s[i:]) or res</span><br><span class="line">            return res</span><br><span class="line">        return back_track(s)</span><br></pre></td></tr></table></figure>

<p>题解四|BFS|超时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import collections</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def wordBreak(self, s: str, wordDict: List[str]) -&gt; bool:</span><br><span class="line">        visited&#x3D;[False]*len(s)</span><br><span class="line">        queue&#x3D;collections.deque()</span><br><span class="line">        queue.append(0)</span><br><span class="line"></span><br><span class="line">        while queue:</span><br><span class="line">            i&#x3D;queue.popleft()</span><br><span class="line">            if visited[i]:</span><br><span class="line">                continue</span><br><span class="line">            else:</span><br><span class="line">                visited[i]&#x3D;False</span><br><span class="line"></span><br><span class="line">            for j in range(i,len(s)):</span><br><span class="line">                if s[i:j+1] in wordDict:</span><br><span class="line">                    if j &#x3D;&#x3D; len(s)-1:</span><br><span class="line">                        return True</span><br><span class="line">                    else:</span><br><span class="line">                        queue.append(j+1)</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure>

<h3 id="152-乘积最大的连续子序列"><a href="#152-乘积最大的连续子序列" class="headerlink" title="152.乘积最大的连续子序列"></a>152.乘积最大的连续子序列</h3><pre><code>链接：https://leetcode-cn.com/problems/maximum-product-subarray/

给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。

示例 1:

输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
示例 2:

输入: [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</code></pre>
<p>题解一|动态规划:</p>
<p>此题类似于52题最大子序和，唯一的区别是：由于存在负数，那么会导致最大的变最小的，最小的变最大的，因此还需要维护当前最小值minTmp，minTmp = min(minTmp * nums[i], nums[i])</p>
<p>1、定义数组元素的含义</p>
<pre><code>dp[i]为以num[i]结尾的子段的最大子段乘积
dp[1]为以num[1]结尾的最大子段乘积</code></pre>
<p>2、寻找递推表达式</p>
<pre><code>只考虑第一个元素，则最大子段和为其本身 dp[0] = nums[0]

考虑前两个元素，最大子段和为 nums[0],num[1]以及 nums[0]*num[1] 中最大值 设为dp[1]

考虑前三个元素，如何求其最大子段乘积？还是分为两种情况讨论，第三个元素在最后的字串内吗？

若第三个元素也包含在最后的字串内，则dp[2] = Max(dp[1]*nums[2] , nums[2])

dp[i]=max(dp[i-1]*num[i],num[i])
由于存在负数：
dp_[i]=min(dp_[i-1]*num[i],num[i])</code></pre>
<p>3、找出初始值</p>
<pre><code>dp[0]=num[0]
dp[1]=max(dp[0]* num[1],num[1])</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxProduct(self, nums: List[int]) -&gt; int:</span><br><span class="line">        lens&#x3D;len(nums)</span><br><span class="line">        if lens&#x3D;&#x3D;0:</span><br><span class="line">            return 0</span><br><span class="line">        dp&#x3D;lens*[0]</span><br><span class="line">        mindp&#x3D;lens*[0]</span><br><span class="line">        dp[0]&#x3D;nums[0]</span><br><span class="line">        mindp[0]&#x3D;nums[0]</span><br><span class="line">        res&#x3D;nums[0]</span><br><span class="line">        for i in range(1,lens):</span><br><span class="line">            dp[i]&#x3D;max(dp[i-1]*nums[i],nums[i],mindp[i-1]*nums[i])</span><br><span class="line">            mindp[i]&#x3D;min(dp[i-1]*nums[i],nums[i],mindp[i-1]*nums[i])</span><br><span class="line">            res&#x3D;max(res,dp[i])</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxProduct(self, nums: List[int]) -&gt; int:</span><br><span class="line">        lens&#x3D;len(nums)</span><br><span class="line">        if lens&#x3D;&#x3D;0:</span><br><span class="line">            return 0</span><br><span class="line">        res&#x3D;float(&#39;-inf&#39;)</span><br><span class="line">        maxTmp&#x3D;1</span><br><span class="line">        minTmp&#x3D;1</span><br><span class="line">        for i in range(lens):</span><br><span class="line">            if nums[i]&lt;0:</span><br><span class="line">                maxTmp,minTmp&#x3D;minTmp,maxTmp</span><br><span class="line">            maxTmp&#x3D;max(maxTmp*nums[i],nums[i])</span><br><span class="line">            minTmp&#x3D;min(minTmp*nums[i],nums[i])</span><br><span class="line"></span><br><span class="line">            res&#x3D;max(res,maxTmp)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<h3 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221.最大正方形"></a>221.最大正方形</h3><pre><code>链接：https://leetcode-cn.com/problems/maximal-square/

在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。

示例:

输入: 

1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0

输出: 4</code></pre>
<p>题解一|动态规划：</p>
<p>1、定义数组元素的含义</p>
<pre><code>dp[i][j]表示以(i,j)为右下角，且只包含1的正方形边长最大值;
计算出所有 dp(i,j) 的值，那么其中的最大值即为矩阵中只包含 1 的正方形的边长最大值，其平方即为最大正方形的面积。</code></pre>
<p>2、寻找递推表达式</p>
<pre><code>如果该位置的值是 0，则 dp(i,j)=0，因为当前位置不可能在由 1 组成的正方形中；

如果该位置的值是 1，则 dp(i,j) 的值由其上方、左方和左上方的三个相邻位置的 dp值决定。具体而言，当前位置的元素值等于三个相邻位置的元素中的最小值加 1，状态转移方程如下：

dp(i,j)=min(dp(i−1,j),dp(i−1,j−1),dp(i,j−1))+1</code></pre>
<p>3、找出初始值</p>
<pre><code>if matrix[i][j]==&#39;1&#39;:
    if i==0 or j==0:
        dp[i][j]=1</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maximalSquare(self, matrix: List[List[str]]) -&gt; int:</span><br><span class="line">        if len(matrix)&#x3D;&#x3D;0 or len(matrix[0])&#x3D;&#x3D;0:</span><br><span class="line">            return 0</span><br><span class="line">        maxSide&#x3D;0</span><br><span class="line">        rows,columns&#x3D;len(matrix),len(matrix[0])</span><br><span class="line">        dp&#x3D;[[0]*columns for _ in range(rows)]</span><br><span class="line">        for i in range(rows):</span><br><span class="line">            for j in range(columns):</span><br><span class="line">                if matrix[i][j]&#x3D;&#x3D;&#39;1&#39;:</span><br><span class="line">                    if i&#x3D;&#x3D;0 or j&#x3D;&#x3D;0:</span><br><span class="line">                        dp[i][j]&#x3D;1</span><br><span class="line">                    else:</span><br><span class="line">                        dp[i][j]&#x3D;min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1</span><br><span class="line">                    maxSide&#x3D;max(maxSide,dp[i][j])</span><br><span class="line">        maxSquare&#x3D;maxSide*maxSide</span><br><span class="line">        return maxSquare</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="264-丑数-II"><a href="#264-丑数-II" class="headerlink" title="264. 丑数 II"></a>264. 丑数 II</h3><pre><code>链接：https://leetcode-cn.com/problems/ugly-number-ii/

编写一个程序，找出第 n 个丑数。

丑数就是质因数只包含 2, 3, 5 的正整数。

示例:

输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。
说明:  

1 是丑数。
n 不超过1690。</code></pre>
<p>题解一|动态规划+3个指针:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def nthUglyNumber(self, n: int) -&gt; int:</span><br><span class="line">        nums&#x3D;[1]</span><br><span class="line">        i2&#x3D;i3&#x3D;i5&#x3D;0</span><br><span class="line">        for i in range(1,n):</span><br><span class="line">            ugly&#x3D;min(nums[i2]*2,nums[i3]*3,nums[i5]*5)</span><br><span class="line">            nums.append(ugly)</span><br><span class="line">            if ugly &#x3D;&#x3D; nums[i2]*2:</span><br><span class="line">                i2+&#x3D;1</span><br><span class="line">            if ugly &#x3D;&#x3D; nums[i3]*3:</span><br><span class="line">                i3+&#x3D;1</span><br><span class="line">            if ugly&#x3D;&#x3D; nums[i5]*5:</span><br><span class="line">                i5+&#x3D;1</span><br><span class="line">        return nums[n-1]</span><br></pre></td></tr></table></figure>

<h3 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a>279. 完全平方数</h3><pre><code>链接：https://leetcode-cn.com/problems/perfect-squares/

给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。

示例 1:

输入: n = 12
输出: 3 
解释: 12 = 4 + 4 + 4.
示例 2:

输入: n = 13
输出: 2
解释: 13 = 4 + 9.</code></pre>
<p>题解一|动态规划：</p>
<p>1、定义数组元素的含义</p>
<pre><code>dp[i]表示i最少可以由几个平方数构成</code></pre>
<p>2、寻找递推表达式</p>
<pre><code>遍历dp，对于i，遍历区间[2,n+1)：
    遍历所有平方数小于i的数j，遍历区间[1,int(\sqrt&#123;i&#125;)+1):
        dp[i]=min(dp[i],dp[i-j*j]+1)
        始终保存所有可能情况中的最小值
返回dp[n]</code></pre>
<p>3、找出初始值<br>    dp=[0,1,2,…,n]，长度为n+1，最多次数就是全由1构成。</p>
<p>时间复杂度：O(n\sqrt{n})<br>空间复杂度：O(n)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import math</span><br><span class="line">class Solution:</span><br><span class="line">    def numSquares(self, n: int) -&gt; int:</span><br><span class="line">        dp&#x3D;[i for i in range(n+1)]</span><br><span class="line">        for i in range(2,n+1):</span><br><span class="line">            for j in range(1,int(math.sqrt(i))+1): # 开方也可使用i**0.5</span><br><span class="line">                dp[i]&#x3D;min(dp[i],dp[i-j*j]+1)</span><br><span class="line">        return dp[n]</span><br></pre></td></tr></table></figure>

<p>题解二|广度优先遍历bfs：</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/bfs.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/bfs.png"></p>
<p>借助队列实现广度优先遍历（层次遍历）:</p>
<pre><code>1、初始化队列queue=[n]，访问元组visited=&#123;&#125;，初试化路径长度step=0
2、特判，若n==0，返回0。
3、循环条件，队列不为空：

    step+=1，因为循环一次，意味着一层中的节点已经遍历完，所以路径长度需要加一。
    定义当前层中的节点数length=len(queue)，遍历当前层的所有节点：
        令tmp为队首元素。
        遍历所有可能数i的平方数，遍历区间[1,int(\sqrt&#123;tmp&#125;)+1)：
            定义x=tmp-i^2
            若x==0，返回当前的路径长度。
            若x not in visited，表示当前节点未出现过：将该节点入队并在访问数组中加入。
4、返回step</code></pre>
<p>时间复杂度：O(n*\sqrt{n})，并不准确<br>空间复杂度：O(n)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from collections import deque</span><br><span class="line">class Solution:</span><br><span class="line">    def numSquares(self, n: int) -&gt; int:</span><br><span class="line">        if n&#x3D;&#x3D;0:</span><br><span class="line">            return 0</span><br><span class="line">        queue&#x3D;deque([n])</span><br><span class="line">        visited&#x3D;set()</span><br><span class="line">        step&#x3D;0</span><br><span class="line">        while queue:</span><br><span class="line">            step+&#x3D;1</span><br><span class="line">            length&#x3D;len(queue)</span><br><span class="line">            for _ in range(length):</span><br><span class="line">                tmp&#x3D;queue.pop()</span><br><span class="line">                for j in range(1,int(tmp**0.5)+1):</span><br><span class="line">                    node&#x3D;tmp-j**2</span><br><span class="line">                    if node&#x3D;&#x3D;0:</span><br><span class="line">                        return step</span><br><span class="line">                    if node not in visited:</span><br><span class="line">                        queue.appendleft(node)</span><br><span class="line">                        visited.add(node)</span><br><span class="line">        return step</span><br></pre></td></tr></table></figure>
<h3 id="继续理解-300-最长上升子序列"><a href="#继续理解-300-最长上升子序列" class="headerlink" title="继续理解 300. 最长上升子序列"></a>继续理解 300. 最长上升子序列</h3><pre><code>链接：https://leetcode-cn.com/problems/longest-increasing-subsequence/

给定一个无序的整数数组，找到其中最长上升子序列的长度。

示例:

输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
说明:

可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
你算法的时间复杂度应该为 O(n^2) 。
进阶: 你能将算法的时间复杂度降低到 O(n*logn) 吗?</code></pre>
<p>题解一|动态规划：</p>
<p>1、定义数组元素的含义</p>
<pre><code>定义 dp[i] 为考虑前 i 个元素，以第 i 个数字结尾的最长上升子序列的长度，注意 nums[i] 必须被选取。</code></pre>
<p>2、寻找递推表达式</p>
<pre><code>从小到大计算 dp[] 数组的值，在计算 dp[i] 之前，我们已经计算出 dp[0…i−1] 的值:
dp[i]=max(dp[j])+1,其中0≤j&lt;i且num[j]&lt;num[i]</code></pre>
<p>3、找出初始值<br>    dp[i]=1，1 个字符显然是长度为 1 的上升子序列。</p>
<p>时间复杂度：O(n^2)，其中 n 为数组 nums 的长度。动态规划的状态数为 n，计算状态 dp[i] 时，需要 O(n) 的时间遍历 dp[0…i−1] 的所有状态，所以总时间复杂度为 O(n^2)<br>空间复杂度：O(n)，需要额外使用长度为 n 的 dp 数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def lengthOfLIS(self, nums: List[int]) -&gt; int:</span><br><span class="line">        if not nums:</span><br><span class="line">            return 0</span><br><span class="line">        dp&#x3D;[]</span><br><span class="line">        for i in range(len(nums)):</span><br><span class="line">            dp.append(1)</span><br><span class="line">            for j in range(i):</span><br><span class="line">                if nums[i]&gt;nums[j]:</span><br><span class="line">                    dp[i]&#x3D;max(dp[i],dp[j]+1)</span><br><span class="line">        return max(dp)</span><br></pre></td></tr></table></figure>

<p>题解二|动态规划+二分查找：</p>
<p>1、定义数组元素的含义</p>
<pre><code>tails[k] 的值代表 长度为 k+1 子序列 的尾部元素值。</code></pre>
<p>2、寻找递推表达式</p>
<pre><code>设 res 为 tails 当前长度，代表直到当前的最长上升子序列长度。设 j∈[0,res)，考虑每轮遍历 nums[k] 时，通过二分法遍历 [0,res) 列表区间，找出 nums[k]的大小分界点，会出现两种情况：

    区间中存在 tails[i] &gt; nums[k] ： 将第一个满足 tails[i] &gt; nums[k]执行 tails[i] = nums[k] ；因为更小的 nums[k]后更可能接一个比它大的数字。

    区间中不存在 tails[i] &gt; nums[k] ： 意味着 nums[k]可以接在前面所有长度的子序列之后，因此肯定是接到最长的后面（长度为 res），新子序列长度为 res + 1。</code></pre>
<p>3、找出初始值<br>    tails[i]=0，tails 列表所有值 =0。</p>
<p>4、返回 res ，即最长上升子子序列长度。</p>
<p>时间复杂度 O(NlogN) ： 遍历 nums 列表需 O(N)，在每个 nums[i] 二分法需 O(logN)<br>空间复杂度 O(N) ： tails 列表占用线性大小额外空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def lengthOfLIS(self, nums: List[int]) -&gt; int:</span><br><span class="line">        if not nums:</span><br><span class="line">            return 0</span><br><span class="line">        tails,res&#x3D;[0]*len(nums),0</span><br><span class="line">        for num in nums:</span><br><span class="line">            i,j&#x3D;0,res</span><br><span class="line">            while i&lt;j:</span><br><span class="line">                m&#x3D;(i+j)&#x2F;&#x2F;2</span><br><span class="line">                if tails[m]&lt;num:</span><br><span class="line">                    i&#x3D;m+1</span><br><span class="line">                else:</span><br><span class="line">                    j&#x3D;m</span><br><span class="line">            tails[i]&#x3D;num</span><br><span class="line">            if j&#x3D;&#x3D;res:</span><br><span class="line">                res+&#x3D;1</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/02o_OPgePjaz3dXnw9TA1w">https://mp.weixin.qq.com/s/02o_OPgePjaz3dXnw9TA1w</a></p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/search.jpg" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/search.jpg"></p>
<h3 id="303-区域和检索-数组不可变"><a href="#303-区域和检索-数组不可变" class="headerlink" title="303. 区域和检索 - 数组不可变"></a>303. 区域和检索 - 数组不可变</h3><pre><code>链接：https://leetcode-cn.com/problems/range-sum-query-immutable/

给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。

示例：

给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()

sumRange(0, 2) -&gt; 1
sumRange(2, 5) -&gt; -1
sumRange(0, 5) -&gt; -3
说明:

你可以假设数组不可变。
会多次调用 sumRange 方法。</code></pre>
<p>题解一|暴力：</p>
<pre><code>缺点：每次调用sumRange都要重新进行计算</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class NumArray:</span><br><span class="line"></span><br><span class="line">    def __init__(self, nums: List[int]):</span><br><span class="line">        self.nums&#x3D;nums</span><br><span class="line"></span><br><span class="line">    def sumRange(self, i: int, j: int) -&gt; int:</span><br><span class="line">        sum&#x3D;0</span><br><span class="line">        for each in range(i,j+1):</span><br><span class="line">            sum+&#x3D;self.nums[each]</span><br><span class="line">        return sum</span><br><span class="line"></span><br><span class="line"># Your NumArray object will be instantiated and called as such:</span><br><span class="line"># obj &#x3D; NumArray(nums)</span><br><span class="line"># param_1 &#x3D; obj.sumRange(i,j)</span><br></pre></td></tr></table></figure>

<p>题解二|缓存+动态规划：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class NumArray:</span><br><span class="line"></span><br><span class="line">    def __init__(self, nums: List[int]):</span><br><span class="line">        self.nums&#x3D;nums</span><br><span class="line">        if not nums:</span><br><span class="line">            return</span><br><span class="line">        n&#x3D;len(nums)</span><br><span class="line">        self.dp&#x3D;[0]*(n+1)</span><br><span class="line">        self.dp[1]&#x3D;nums[0]</span><br><span class="line">        for i in range(2,n+1):</span><br><span class="line">            self.dp[i]&#x3D;self.dp[i-1]+nums[i-1]</span><br><span class="line"></span><br><span class="line">    def sumRange(self, i: int, j: int) -&gt; int:</span><br><span class="line">        return self.dp[j+1]-self.dp[i]</span><br><span class="line"></span><br><span class="line"># Your NumArray object will be instantiated and called as such:</span><br><span class="line"># obj &#x3D; NumArray(nums)</span><br><span class="line"># param_1 &#x3D; obj.sumRange(i,j)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class NumArray:</span><br><span class="line"></span><br><span class="line">    def __init__(self, nums: List[int]):</span><br><span class="line">        self.nums&#x3D;nums</span><br><span class="line">        if not nums:</span><br><span class="line">            return</span><br><span class="line">        n&#x3D;len(nums)</span><br><span class="line">        self.dp&#x3D;[0]*(n+1)</span><br><span class="line">        for i in range(0,n):</span><br><span class="line">            self.dp[i+1]&#x3D;self.dp[i]+nums[i]</span><br><span class="line">        # print(self.dp)</span><br><span class="line"></span><br><span class="line">    def sumRange(self, i: int, j: int) -&gt; int:</span><br><span class="line">        return self.dp[j+1]-self.dp[i]</span><br><span class="line"></span><br><span class="line"># Your NumArray object will be instantiated and called as such:</span><br><span class="line"># obj &#x3D; NumArray(nums)</span><br><span class="line"># param_1 &#x3D; obj.sumRange(i,j)</span><br></pre></td></tr></table></figure>

<h3 id="304-二维区域和检索-矩阵不可变"><a href="#304-二维区域和检索-矩阵不可变" class="headerlink" title="304. 二维区域和检索 - 矩阵不可变"></a>304. 二维区域和检索 - 矩阵不可变</h3><pre><code>链接：https://leetcode-cn.com/problems/range-sum-query-2d-immutable/

给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2)。

Range Sum Query 2D
上图子矩阵左上角 (row1, col1) = (2, 1) ，右下角(row2, col2) = (4, 3)，该子矩形内元素的总和为 8。

示例:

给定 matrix = [
  [3, 0, 1, 4, 2],
  [5, 6, 3, 2, 1],
  [1, 2, 0, 1, 5],
  [4, 1, 0, 1, 7],
  [1, 0, 3, 0, 5]
]

sumRegion(2, 1, 4, 3) -&gt; 8
sumRegion(1, 1, 2, 2) -&gt; 11
sumRegion(1, 2, 2, 4) -&gt; 12
说明:

你可以假设矩阵不可变。
会多次调用 sumRegion 方法。
你可以假设 row1 ≤ row2 且 col1 ≤ col2。</code></pre>
<p>题解一|动态规划：</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/dp22.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/dp22.png"></p>
<pre><code>sum(abcd)=sum(od)−sum(ob)−sum(oc)+sum(oa)</code></pre>
<p>1、定义数组的含义</p>
<pre><code>dp[i][j]表示矩阵左上角到matrix[i][j]的累加和</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class NumMatrix:</span><br><span class="line"></span><br><span class="line">    def __init__(self, matrix: List[List[int]]):</span><br><span class="line">        </span><br><span class="line">        if not matrix or not matrix[0]:pass</span><br><span class="line">        else:</span><br><span class="line">            row &#x3D; len(matrix)</span><br><span class="line">            col &#x3D; len(matrix[0])</span><br><span class="line">            self.dp &#x3D; [[ 0 ] * (col + 1) for _ in range(row + 1)]</span><br><span class="line">            # 求行的前缀和</span><br><span class="line">            for i in range(1, row + 1):</span><br><span class="line">                for j in range(1 ,col + 1):</span><br><span class="line">                    self.dp[i][j] &#x3D; self.dp[i][j - 1] + matrix[i - 1][j - 1] </span><br><span class="line">            # 求列的前缀和</span><br><span class="line">            for j in range(1, col + 1):</span><br><span class="line">                for i in range(1, row + 1):</span><br><span class="line">                    self.dp[i][j] +&#x3D; self.dp[i - 1][j]</span><br><span class="line">            # print(self.dp)</span><br><span class="line"></span><br><span class="line">    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -&gt; int:</span><br><span class="line">        return self.dp[row2 + 1][col2 + 1] - self.dp[row1][col2 + 1] - self.dp[row2 + 1][col1] + self.dp[row1][col1]</span><br><span class="line"></span><br><span class="line"># Your NumMatrix object will be instantiated and called as such:</span><br><span class="line"># obj &#x3D; NumMatrix(matrix)</span><br><span class="line"># param_1 &#x3D; obj.sumRegion(row1,col1,row2,col2)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class NumMatrix:</span><br><span class="line"></span><br><span class="line">    def __init__(self, matrix: List[List[int]]):</span><br><span class="line">        </span><br><span class="line">        if not matrix or not matrix[0]:pass</span><br><span class="line">        else:</span><br><span class="line">            row &#x3D; len(matrix)</span><br><span class="line">            col &#x3D; len(matrix[0])</span><br><span class="line">            self.dp &#x3D; [[ 0 ] * (col + 1) for _ in range(row + 1)]</span><br><span class="line">        </span><br><span class="line">            for i in range(1, row + 1):</span><br><span class="line">                for j in range(1, col + 1):</span><br><span class="line">                    self.dp[i][j] &#x3D; matrix[i - 1][j - 1] + self.dp[i - 1][j] + self.dp[i][j - 1] - self.dp[i-1][j-1] # [i-1, j-1]重复计算了, 所以需要减去.</span><br><span class="line"></span><br><span class="line">    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -&gt; int:</span><br><span class="line">        return self.dp[row2 + 1][col2 + 1] - self.dp[row1][col2 + 1] - self.dp[row2 + 1][col1] + self.dp[row1][col1]</span><br><span class="line"></span><br><span class="line"># Your NumMatrix object will be instantiated and called as such:</span><br><span class="line"># obj &#x3D; NumMatrix(matrix)</span><br><span class="line"># param_1 &#x3D; obj.sumRegion(row1,col1,row2,col2)</span><br></pre></td></tr></table></figure>


<h3 id="338-比特位计数"><a href="#338-比特位计数" class="headerlink" title="338. 比特位计数"></a>338. 比特位计数</h3><pre><code>链接：https://leetcode-cn.com/problems/counting-bits/

给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。

示例 1:

输入: 2
输出: [0,1,1]
示例 2:

输入: 5
输出: [0,1,1,2,1,2]
进阶:

给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？
要求算法的空间复杂度为O(n)。
你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount）来执行此操作。</code></pre>
<p>题解一（动态规划）：</p>
<p>1、定义数组含义</p>
<pre><code>dp[i]表示数字i计算其二进制数中的 1 的数目。</code></pre>
<p>2、找出数组递推关系式</p>
<pre><code>当i为奇数时：
    奇数一定比前面那个偶数多一个 1，因为多的就是最低位的 1。
当i为偶数时：
    二进制是逢2开始进位的，也就是在偶数的时候，一个偶数相当一另一个数成以2得到，在二进制运算中，就是左移一位，也就是在低位多加1个0，故遇到偶数的时候就是dp[i] = dp[i/2]。</code></pre>
<p>3、找到初始值</p>
<pre><code>dp[0]=0
dp[1]=1</code></pre>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def countBits(self, num: int) -&gt; List[int]:</span><br><span class="line">        if num&#x3D;&#x3D;0:</span><br><span class="line">            return [0]</span><br><span class="line">        dp&#x3D;[0]*(num+1)</span><br><span class="line">        dp[0]&#x3D;0</span><br><span class="line">        dp[1]&#x3D;1</span><br><span class="line">        for i in range(2,num+1):</span><br><span class="line">            if i%2&#x3D;&#x3D;0:</span><br><span class="line">                dp[i]&#x3D;dp[i&#x2F;&#x2F;2]</span><br><span class="line">            else:</span><br><span class="line">                dp[i]&#x3D;dp[i-1]+1</span><br><span class="line">        return dp</span><br></pre></td></tr></table></figure>

<h3 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343. 整数拆分"></a>343. 整数拆分</h3><pre><code>链接：https://leetcode-cn.com/problems/integer-break/

给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

示例 1:

输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
示例 2:

输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
说明: 你可以假设 n 不小于 2 且不大于 58。</code></pre>
<p>题解一|动态规划</p>
<p>1、定义数组</p>
<pre><code>dp[i]代表i拆分后的最大乘积</code></pre>
<p>2、递推表达式</p>
<pre><code>dp[i]=max(dp[i],j*(i-j),j*dp[i-j])

(i - j) * j 代表的是整数 i 拆分成 2 部分, 分别为 (i - j) * j；

j * dp[i - j]代表的是整数 i 拆 2 部分以上， dp[i - j] 就是代表在之前的动态规划求得的整数 i - j 的分割最大的乘积</code></pre>
<p>3、初始值<br>    dp[i]=1，从3开始。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def integerBreak(self, n: int) -&gt; int:</span><br><span class="line">        dp&#x3D;[1 for i in range(n+1)]</span><br><span class="line">        for i in range(3,n+1):</span><br><span class="line">            for j in range(1,i):</span><br><span class="line">                dp[i]&#x3D;max(dp[i],j*(i-j),j*dp[i-j])</span><br><span class="line">        return dp[n]</span><br></pre></td></tr></table></figure>

<h3 id="354-俄罗斯套娃信封问题"><a href="#354-俄罗斯套娃信封问题" class="headerlink" title="354. 俄罗斯套娃信封问题"></a>354. 俄罗斯套娃信封问题</h3><pre><code>链接：https://leetcode-cn.com/problems/russian-doll-envelopes/

给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 (w, h) 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。

请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。

说明:
不允许旋转信封。

示例:

输入: envelopes = [[5,4],[6,4],[6,7],[2,3]]
输出: 3 
解释: 最多信封的个数为 3, 组合为: [2,3] =&gt; [5,4] =&gt; [6,7]。</code></pre>
<p>题解一|动态规划|超时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxEnvelopes(self, envelopes: List[List[int]]) -&gt; int:</span><br><span class="line">        if not envelopes:</span><br><span class="line">            return 0</span><br><span class="line">        envelopes&#x3D;sorted(envelopes,key&#x3D;lambda x:(x[0],-x[1]))</span><br><span class="line">        dp&#x3D;[1]*len(envelopes)</span><br><span class="line">        count&#x3D;1</span><br><span class="line">        for i in range(len(envelopes)):</span><br><span class="line">            for j in range(i):</span><br><span class="line">                if envelopes[i][1] &gt; envelopes[j][1] and dp[j]+1 &gt; dp[i]:</span><br><span class="line">                    dp[i]&#x3D;dp[j]+1</span><br><span class="line">                count&#x3D;max(count,dp[i])</span><br><span class="line">        return count</span><br></pre></td></tr></table></figure>

<p>稍微修改下，通过：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxEnvelopes(self, envelopes: List[List[int]]) -&gt; int:</span><br><span class="line">        if not envelopes:</span><br><span class="line">            return 0</span><br><span class="line">        envelopes&#x3D;sorted(envelopes,key&#x3D;lambda x:(x[0],-x[1]))</span><br><span class="line">        dp&#x3D;[1]*len(envelopes)</span><br><span class="line">        for i in range(len(envelopes)):</span><br><span class="line">            for j in range(i):</span><br><span class="line">                if envelopes[i][1] &gt; envelopes[j][1] and dp[j]+1 &gt; dp[i]:</span><br><span class="line">                    dp[i]&#x3D;max(dp[i],dp[j]+1)</span><br><span class="line">        return max(dp)</span><br></pre></td></tr></table></figure>

<h3 id="357-计算各个位数不同的数字个数"><a href="#357-计算各个位数不同的数字个数" class="headerlink" title="357. 计算各个位数不同的数字个数"></a>357. 计算各个位数不同的数字个数</h3><pre><code>链接：https://leetcode-cn.com/problems/count-numbers-with-unique-digits/

给定一个非负整数 n，计算各位数字都不同的数字 x 的个数，其中 0 ≤ x &lt; 10^n 。

示例:

输入: 2
输出: 91 
解释: 答案应为除去 11,22,33,44,55,66,77,88,99 外，在 [0,100) 区间内的所有数字。</code></pre>
<p>题解一|动态规划:</p>
<pre><code>数字一共有0~9十个，所以n超过十位一定会重复。

1位 10
2位 9*9+10 （第一位不能0）
3位 9*9*8+9*9+10
4位 9*9*8*7+9*9*8+9*9+10
...
i位 dp1[i] = dp2[i-1]*(10-(i-1))+dp1[i-1]  （i从2开始，dp1[1] = 10, dp2[1] = 9）</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def countNumbersWithUniqueDigits(self, n: int) -&gt; int:</span><br><span class="line">        if n&#x3D;&#x3D;0:</span><br><span class="line">            return 1</span><br><span class="line">        dp1&#x3D;[0]*(n+1)</span><br><span class="line">        dp2&#x3D;[0]*(n+1)</span><br><span class="line">        dp1[1]&#x3D;10</span><br><span class="line">        dp2[1]&#x3D;9</span><br><span class="line">        for i in range(2,min(11,n+1)):</span><br><span class="line">            dp2[i]&#x3D;dp2[i-1]*(10-(i-1))</span><br><span class="line">            dp1[i]&#x3D;dp2[i]+dp1[i-1]</span><br><span class="line">        if n&gt;&#x3D;11:</span><br><span class="line">            return dp[10]</span><br><span class="line">        return dp1[n]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def countNumbersWithUniqueDigits(self, n: int) -&gt; int:</span><br><span class="line">        if n&#x3D;&#x3D;0:</span><br><span class="line">            return 1</span><br><span class="line">        fisrt,second&#x3D;10,9*9</span><br><span class="line">        size&#x3D;min(n,10)</span><br><span class="line">        for i in range(2,size+1):</span><br><span class="line">            fisrt+&#x3D;second</span><br><span class="line">            second*&#x3D;(10-i)</span><br><span class="line">        return fisrt</span><br></pre></td></tr></table></figure>

<p>??题解二|回溯：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def countNumbersWithUniqueDigits(self, n: int) -&gt; int:</span><br><span class="line">        used&#x3D;[False]*10</span><br><span class="line">        def backtrace(first,used):</span><br><span class="line">            count&#x3D;0</span><br><span class="line">            if first !&#x3D; n:</span><br><span class="line">                for i in range(10):</span><br><span class="line">                    # 剪枝：多位数时，第一个数字不能为0</span><br><span class="line">                    if i&#x3D;&#x3D;0 and n&gt;1 and first&#x3D;&#x3D;1:</span><br><span class="line">                        continue</span><br><span class="line">                    if used[i]:</span><br><span class="line">                        continue</span><br><span class="line">                    used[i]&#x3D;True</span><br><span class="line">                    count+&#x3D;backtrace(first+1,used)+1</span><br><span class="line">                    used[i]&#x3D;False</span><br><span class="line">            return count</span><br><span class="line">        if not n:</span><br><span class="line">            return 1</span><br><span class="line">        return backtrace(0,used)</span><br></pre></td></tr></table></figure>

<h3 id="368-最大整除子集"><a href="#368-最大整除子集" class="headerlink" title="368. 最大整除子集"></a>368. 最大整除子集</h3><pre><code>链接：https://leetcode-cn.com/problems/largest-divisible-subset/

给出一个由无重复的正整数组成的集合，找出其中最大的整除子集，子集中任意一对 (Si，Sj) 都要满足：Si % Sj = 0 或 Sj % Si = 0。

如果有多个目标子集，返回其中任何一个均可。

示例 1:

输入: [1,2,3]
输出: [1,2] (当然, [1,3] 也正确)
示例 2:

输入: [1,2,4,8]
输出: [1,2,4,8]</code></pre>
<p>题解一|动态规划：</p>
<p>1、sorted()排序；<br>2、dp[i]表示以下标i位置元素结尾得最长序列。<br>3、遍历0-(i-1)，如果nums[i]整除nums[j]，则判断dp[i]和dp[j] + 1哪个大</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def largestDivisibleSubset(self, nums: List[int]) -&gt; List[int]:</span><br><span class="line">        if not nums:</span><br><span class="line">            return []</span><br><span class="line">        nums&#x3D;sorted(nums)</span><br><span class="line">        dp&#x3D;[[i] for i in nums]</span><br><span class="line">        res&#x3D;[]</span><br><span class="line">        for i in range(0,len(nums)):</span><br><span class="line">            for j in range(0,i):</span><br><span class="line">                if nums[i]%nums[j]&#x3D;&#x3D;0:</span><br><span class="line">                    if len(dp[i])&lt;len(dp[j]+[nums[i]]):</span><br><span class="line">                        dp[i]&#x3D;dp[j]+[nums[i]]</span><br><span class="line">            if len(dp[i])&gt;len(res):</span><br><span class="line">                res&#x3D;dp[i]</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<h3 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392. 判断子序列"></a>392. 判断子序列</h3><pre><code>链接：https://leetcode-cn.com/problems/is-subsequence/

给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 &lt;=100）。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，&quot;ace&quot;是&quot;abcde&quot;的一个子序列，而&quot;aec&quot;不是）。

示例 1:
s = &quot;abc&quot;, t = &quot;ahbgdc&quot;

返回 true.

示例 2:
s = &quot;axc&quot;, t = &quot;ahbgdc&quot;

返回 false.

后续挑战 :

如果有大量输入的 S，称作S1, S2, ... , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</code></pre>
<p>题解一|双指针：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isSubsequence(self, s: str, t: str) -&gt; bool:</span><br><span class="line">        p,q&#x3D;0,0</span><br><span class="line">        count&#x3D;0</span><br><span class="line">        while p&lt;len(s) and q&lt;len(t):</span><br><span class="line">            if s[p]&#x3D;&#x3D;t[q]:</span><br><span class="line">                count+&#x3D;1</span><br><span class="line">                p+&#x3D;1</span><br><span class="line">            q+&#x3D;1</span><br><span class="line">        return p&#x3D;&#x3D;len(s)</span><br></pre></td></tr></table></figure>

<p>题解二|二分+哈希：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isSubsequence(self, s: str, t: str) -&gt; bool:</span><br><span class="line">        hash&#x3D;&#123;&#125;</span><br><span class="line">        for i,word in enumerate(t):</span><br><span class="line">            if word not in hash:</span><br><span class="line">                hash[word]&#x3D;[i] # 注意这里是列表</span><br><span class="line">            else:</span><br><span class="line">                hash[word].append(i)</span><br><span class="line"></span><br><span class="line">        index &#x3D; -1</span><br><span class="line">        for word in s:</span><br><span class="line">            if word not in hash:</span><br><span class="line">                return False</span><br><span class="line">            # 字母s出现的索引 用二分法找到其中大于index的第一个</span><br><span class="line">            indexes &#x3D; hash[word]</span><br><span class="line">            left &#x3D; 0</span><br><span class="line">            right &#x3D; len(indexes)</span><br><span class="line">            while left &lt; right:</span><br><span class="line">                mid &#x3D; left + (right - left) &#x2F;&#x2F; 2</span><br><span class="line">                if indexes[mid] &gt; index:</span><br><span class="line">                    right &#x3D; mid</span><br><span class="line">                else:</span><br><span class="line">                    left &#x3D; mid + 1</span><br><span class="line">            if left &#x3D;&#x3D; len(indexes):</span><br><span class="line">                return False</span><br><span class="line">            index &#x3D; indexes[left]</span><br><span class="line">            </span><br><span class="line">        return True</span><br></pre></td></tr></table></figure>

<h3 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a>516. 最长回文子序列</h3><pre><code>给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。

示例 1:
输入:

&quot;bbbab&quot;
输出:

4
一个可能的最长回文子序列为 &quot;bbbb&quot;。

示例 2:
输入:

&quot;cbbd&quot;
输出:

2
一个可能的最长回文子序列为 &quot;bb&quot;。

提示：

1 &lt;= s.length &lt;= 1000
s 只包含小写英文字母</code></pre>
<p>题解一|动态规划：</p>
<p>1、dp 数组的定义是：在子串s[i..j]中，最长回文子序列的长度为dp[i][j]</p>
<p>2、状态转移方程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (s[i] &#x3D;&#x3D; s[j])</span><br><span class="line">    &#x2F;&#x2F; 它俩一定在最长回文子序列中</span><br><span class="line">    dp[i][j] &#x3D; dp[i + 1][j - 1] + 2;</span><br><span class="line">else</span><br><span class="line">    &#x2F;&#x2F; s[i+1..j] 和 s[i..j-1] 谁的回文子序列更长？</span><br><span class="line">    dp[i][j] &#x3D; max(dp[i + 1][j], dp[i][j - 1]);</span><br></pre></td></tr></table></figure>

<p>答案：dp[0][n - 1]，也就是整个s的最长回文子序列的长度。</p>
<p>3、bad case</p>
<p>如果只有一个字符，显然最长回文子序列长度是 1，也就是dp[i][j] = 1,(i == j)。</p>
<p>因为i肯定小于等于j，所以对于那些i &gt; j的位置，根本不存在什么子序列，应该初始化为 0。</p>
<p>为了保证每次计算dp[i][j]，左、下、左下三个方向的位置已经被计算出来，只能斜着遍历或者反着遍历：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def longestPalindromeSubseq(self, s: str) -&gt; int:</span><br><span class="line">        n&#x3D;len(s)</span><br><span class="line">        dp&#x3D;[[0]*n for i in range(n)]</span><br><span class="line"></span><br><span class="line">        for i in range(n):</span><br><span class="line">            dp[i][i]&#x3D;1</span><br><span class="line"></span><br><span class="line">        # 反着遍历保证正确的状态转移</span><br><span class="line">        for i in range(n-1,-1,-1):</span><br><span class="line">            for j in range(i+1,n):</span><br><span class="line">                if s[i] &#x3D;&#x3D; s[j]:</span><br><span class="line">                    dp[i][j]&#x3D;dp[i+1][j-1]+2</span><br><span class="line">                else:</span><br><span class="line">                    dp[i][j]&#x3D;max(dp[i+1][j],dp[i][j-1])</span><br><span class="line">        return dp[0][n-1]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="651-4键键盘"><a href="#651-4键键盘" class="headerlink" title="???651.4键键盘"></a>???651.4键键盘</h3><p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/keyborad.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/keyborad.png"></p>
<p>如何在 N 次敲击按钮后得到最多的 A？</p>
<p>对 dp 数组的不同定义需要完全不同的逻辑，从而产生完全不同的解法。</p>
<p>题解一：</p>
<p>流程：对于动态规划问题，首先要明白有哪些「状态」，有哪些「选择」。</p>
<p>有哪些「选择」是很明显的：</p>
<pre><code>4 种，就是题目中提到的四个按键，分别是A、C-A、C-C、C-V（Ctrl简写为C）。</code></pre>
<p>有哪些「状态」？或者换句话说，我们需要知道什么信息，才能将原问题分解为规模更小的子问题？</p>
<p>定义三个状态行不行：</p>
<pre><code>第一个状态是剩余的按键次数，用n表示；
第二个状态是当前屏幕上字符 A 的数量，用a_num表示；
第三个状态是剪切板中字符 A 的数量，用copy表示。</code></pre>
<p>如此定义「状态」，就可以知道 base case：当剩余次数n为 0 时，a_num就是我们想要的答案。</p>
<p>结合刚才说的 4 种「选择」，我们可以把这几种选择通过状态转移表示出来：</p>
<pre><code>dp(n - 1, a_num + 1, copy),    # A
解释：按下 A 键，屏幕上加一个字符
同时消耗 1 个操作数

dp(n - 1, a_num + copy, copy), # C-V
解释：按下 C-V 粘贴，剪切板中的字符加入屏幕
同时消耗 1 个操作数

dp(n - 2, a_num, a_num)        # C-A C-C
解释：全选和复制必然是联合使用的，
剪切板中 A 的数量变为屏幕上 A 的数量
同时消耗 2 个操作数</code></pre>
<p>问题的规模n在不断减小，肯定可以到达n = 0的 base case，所以这个思路是正确的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def maxA(n):</span><br><span class="line">    def dp(n,a_num,copy):</span><br><span class="line">        # 初始值</span><br><span class="line">        if n&lt;&#x3D;0:</span><br><span class="line">            return a_num</span><br><span class="line">        # 所有选择全部试一遍，选择最大结果</span><br><span class="line">        return max(</span><br><span class="line">            dp(n-1,a_num+1,copy),</span><br><span class="line">            dp(n-1,a_num+copy,copy),</span><br><span class="line">            dp(n-2,a_num,a_num)</span><br><span class="line">            )</span><br><span class="line">    return dp(n,0,0) # 可以按n次按键，屏幕和剪切板种还没有A</span><br></pre></td></tr></table></figure>

<p>优化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def maxA(n):</span><br><span class="line">    memo&#x3D;dict()</span><br><span class="line">    def dp(n,a_num,copy):</span><br><span class="line">        # 初始值</span><br><span class="line">        if n&lt;&#x3D;0:</span><br><span class="line">            return a_num</span><br><span class="line">        # 避免计算重叠子问题</span><br><span class="line">        if (n,a_num,copy) in demo:</span><br><span class="line">            return memo[(n,a_num,copy)]</span><br><span class="line"></span><br><span class="line">        memo[(n,a_num,copy)]&#x3D; max(</span><br><span class="line">            dp(n-1,a_num+1,copy),</span><br><span class="line">            dp(n-1,a_num+copy,copy),</span><br><span class="line">            dp(n-2,a_num,a_num)</span><br><span class="line">            )</span><br><span class="line">        return memo[(n,a_num,copy)]</span><br><span class="line">    return dp(n,0,0) # 可以按n次按键，屏幕和剪切板种还没有A</span><br></pre></td></tr></table></figure>

<p>可以把这个 dp 函数写成 dp 数组：</p>
<pre><code>dp[n][a_num][copy] #状态的总数（时空复杂度）就是这个三维数组的体积</code></pre>
<p>我们知道变量n最多为N，但是a_num和copy最多为多少我们很难计算，复杂度起码也有 O(N^3) 吧。</p>
<p>题解二：</p>
<p>「选择」还是那 4 个，但是这次我们只定义一个「状态」，也就是剩余的敲击次数n。</p>
<p>最优按键序列一定只有两种情况：</p>
<pre><code>要么一直按A：A,A,…A（当 N 比较小时）。

要么是这么一个形式：A,A,…C-A,C-C,C-V,C-V,…C-V（当 N 比较大时）。</code></pre>
<p>因为字符数量少（N 比较小）时，C-A C-C C-V这一套操作的代价相对比较高，可能不如一个个按A；而当 N 比较大时，后期C-V的收获肯定很大。这种情况下整个操作序列大致是：开头连按几个A，然后C-A C-C组合再接若干C-V，然后再C-A C-C接着若干C-V，循环下去。</p>
<p>换句话说，最后一次按键要么是A要么是C-V。明确了这一点，可以通过这两种情况来设计算法：</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&amp;mid=2247486045&amp;idx=2&amp;sn=c270733b9ea06403ab9851bbc5d935db&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&amp;mid=2247486045&amp;idx=2&amp;sn=c270733b9ea06403ab9851bbc5d935db&amp;scene=21#wechat_redirect</a></p>
<h3 id="673-最长递增子序列的个数"><a href="#673-最长递增子序列的个数" class="headerlink" title="673. 最长递增子序列的个数"></a>673. 最长递增子序列的个数</h3><pre><code>链接：https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/

给定一个未排序的整数数组，找到最长递增子序列的个数。

示例 1:

输入: [1,3,5,4,7]
输出: 2
解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。
示例 2:

输入: [2,2,2,2,2]
输出: 5
解释: 最长递增子序列的长度是1，并且存在5个子序列的长度为1，因此输出5。</code></pre>
<p>题解一|动态规划：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findNumberOfLIS(self, nums: List[int]) -&gt; int:</span><br><span class="line">        if not nums:</span><br><span class="line">            return 0</span><br><span class="line">        dp&#x3D;[1]*len(nums)</span><br><span class="line">        count&#x3D;[1]*len(nums)</span><br><span class="line">        MAX&#x3D;0</span><br><span class="line">        for i in range(len(nums)):</span><br><span class="line">            for j in range(i):</span><br><span class="line">                if nums[i] &gt; nums[j]:</span><br><span class="line">                    if dp[j]+1 &gt; dp[i]: # 代表第一次遇到最长子序列</span><br><span class="line">                        dp[i]&#x3D;max(dp[i],dp[j]+1)</span><br><span class="line">                        count[i]&#x3D;count[j]</span><br><span class="line">                    elif dp[j]+1 &#x3D;&#x3D; dp[i]: # 代表已经遇到最长子序列</span><br><span class="line">                        count[i]+&#x3D;count[j]</span><br><span class="line">            MAX &#x3D; max(MAX, dp[i])</span><br><span class="line">        res&#x3D;0</span><br><span class="line">        for i in range(len(nums)):</span><br><span class="line">            if dp[i]&#x3D;&#x3D;MAX:</span><br><span class="line">                res+&#x3D;count[i]</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<h3 id="674-最长连续递增序列"><a href="#674-最长连续递增序列" class="headerlink" title="674. 最长连续递增序列"></a>674. 最长连续递增序列</h3><pre><code>链接：https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/

给定一个未经排序的整数数组，找到最长且连续的的递增序列，并返回该序列的长度。

示例 1:

输入: [1,3,5,4,7]
输出: 3
解释: 最长连续递增序列是 [1,3,5], 长度为3。
尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。 
示例 2:

输入: [2,2,2,2,2]
输出: 1
解释: 最长连续递增序列是 [2], 长度为1。</code></pre>
<p>题解一|动态规划：</p>
<p>1、数组定义：dp[i]代表nums[i]值结尾的最长连续递增序列的长度<br>2、状态转移方程</p>
<pre><code>nums[i]＞nums[i−1]，i至少可以与i-1形成一个连续递增序列，因为它们俩挨着，并且是递增的，长度上是dp[i-1]+1

nums[i]＜=nums[i-1],这时候，不能形成连续递增序列，后一个数要比前一个数小，呈下降的趋势，注意=不认为是递增的</code></pre>
<p>3、初始值dp[i]=1</p>
<p>时间复杂度：o(n)<br>空间复杂度：o(n)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findLengthOfLCIS(self, nums: List[int]) -&gt; int:</span><br><span class="line">        if not nums:</span><br><span class="line">            return 0</span><br><span class="line">        dp&#x3D;[1]*len(nums)</span><br><span class="line">        for i in range(1,len(nums)):</span><br><span class="line">                if nums[i] &gt; nums[i-1]:</span><br><span class="line">                    dp[i]&#x3D;max(dp[i],dp[i-1]+1)</span><br><span class="line">        return max(dp)                    </span><br></pre></td></tr></table></figure>

<p>o(1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int findLengthOfLCIS(int[] nums) &#123;</span><br><span class="line">        if (nums &#x3D;&#x3D; null || nums.length &#x3D;&#x3D; 0) return 0;</span><br><span class="line">        int n &#x3D; nums.length;</span><br><span class="line">        int max &#x3D; 1;</span><br><span class="line">        int[] dp &#x3D; new int[2];</span><br><span class="line">        dp[0] &#x3D; 1;</span><br><span class="line">        for (int i &#x3D; 1; i ＜ n; i++) &#123;</span><br><span class="line">            dp[i % 2] &#x3D; 1;&#x2F;&#x2F;前一个状态值都会被覆盖，需要重新初始化</span><br><span class="line">            if (nums[i] ＞ nums[i - 1]) &#123;</span><br><span class="line">                dp[i % 2] +&#x3D; dp[(i - 1) % 2];&#x2F;&#x2F;当前状态依赖前一状态，需要再前一状态上累加</span><br><span class="line">            &#125;</span><br><span class="line">            max &#x3D; Math.max(max, dp[i % 2]);</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">           </span><br></pre></td></tr></table></figure>

<h3 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a>746. 使用最小花费爬楼梯</h3><pre><code>链接：https://leetcode-cn.com/problems/min-cost-climbing-stairs/

数组的每个索引作为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost[i](索引从0开始)。

每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。

您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。

示例 1:

输入: cost = [10, 15, 20]
输出: 15
解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。
 示例 2:

输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
输出: 6
解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。
注意：

cost 的长度将会在 [2, 1000]。
每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。</code></pre>
<p>题解一|动态规划：<br>1、定义<br>    dp[i]为踏上第i级台阶的最小花费<br>2、状态转移<br>踏上第i级台阶有两种方法：</p>
<pre><code>先踏上第i-2级台阶（最小总花费dp[i-2]），再直接迈两步踏上第i级台阶（花费cost[i]），最小总花费dp[i-2] + cost[i]；

先踏上第i-1级台阶（最小总花费dp[i-1]），再迈一步踏上第i级台阶（花费cost[i]），最小总花费dp[i-1] + cost[i]；

则dp[i]是上面这两个最小总花费中的最小值。</code></pre>
<p>因此状态转移方程是：dp[i] = min(dp[i-2], dp[i-1]) + cost[i]。</p>
<p>3、初始条件：</p>
<pre><code>最后一步踏上第0级台阶，最小花费dp[0] = cost[0]。

最后一步踏上第1级台阶有两个选择：

可以分别踏上第0级与第1级台阶，花费cost[0] + cost[1]；
也可以从地面开始迈两步直接踏上第1级台阶，花费cost[1]。
最小值dp[1] = min(cost[0] + cost[1], cost[1]) = cost[1]。</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def minCostClimbingStairs(self, cost: List[int]) -&gt; int:</span><br><span class="line">        if not cost:</span><br><span class="line">            return 0</span><br><span class="line">        dp&#x3D;[0]*len(cost)</span><br><span class="line">        dp[0]&#x3D;cost[0]</span><br><span class="line">        dp[1]&#x3D;cost[1]</span><br><span class="line">        for i in range(2,len(cost)):</span><br><span class="line">            dp[i]&#x3D;min(dp[i-1]+cost[i],dp[i-2]+cost[i])</span><br><span class="line">        return min(dp[-1],dp[-2])</span><br></pre></td></tr></table></figure>

<h3 id="1025-除数博弈"><a href="#1025-除数博弈" class="headerlink" title="1025. 除数博弈"></a>1025. 除数博弈</h3><pre><code>链接：https://leetcode-cn.com/problems/divisor-game/

爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。

最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：

选出任一 x，满足 0 &lt; x &lt; N 且 N % x == 0 。
用 N - x 替换黑板上的数字 N 。
如果玩家无法执行这些操作，就会输掉游戏。

只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。

示例 1：

输入：2
输出：true
解释：爱丽丝选择 1，鲍勃无法进行操作。
示例 2：

输入：3
输出：false
解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。


提示：

1 &lt;= N &lt;= 1000</code></pre>
<p>题解一|归纳</p>
<p>思路：最后轮到谁时 N=1，那么谁就是输家。</p>
<p>假设N为奇数，即 N%2=1:</p>
<pre><code>那么 N 的约数x一定都是奇数，N-x 一定是偶数；</code></pre>
<p>假设N为偶数，即 N%2=0:</p>
<pre><code>那么 N 的约数x可能是奇数，也可能是偶数。x为奇数时，N-x为奇数；x为偶数时，N-x为偶数。</code></pre>
<p>题目中说“两个玩家都以最佳状态参与游戏”，并且爱丽丝先手，那她一定会努力让自己得胜。</p>
<p>结论：</p>
<pre><code>若N是偶数，爱丽丝一定会选x为奇数，让轮到鲍勃的(N-x)为奇数，这样她每次都会轮到偶数直至胜利；

若N是奇数，爱丽丝没得选，只能让鲍勃轮到的（N-x)为偶数，此时主动权就在鲍勃手中，他会让爱丽丝每次轮到奇数，直至鲍勃获胜。</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def divisorGame(self, N: int) -&gt; bool:</span><br><span class="line">        return N%2&#x3D;&#x3D;0</span><br></pre></td></tr></table></figure>
<p>题解二|动态规划</p>
<p>定义：dp[i]为当N=i时，Alice的输赢</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def divisorGame(self, N: int) -&gt; bool:</span><br><span class="line">        if N&lt;&#x3D;1:</span><br><span class="line">            return False</span><br><span class="line">        dp&#x3D;[False]* (N+1)</span><br><span class="line">        dp[1]&#x3D; False</span><br><span class="line">        dp[2]&#x3D; True</span><br><span class="line">        for i in range(3,N+1):</span><br><span class="line">            for j in range(1,i):</span><br><span class="line">                if dp[i-j] &#x3D;&#x3D; False and i%j &#x3D;&#x3D; 0: # 当dp[i-j]为奇数时，dp[i]为偶数</span><br><span class="line">                    dp[i]&#x3D;True</span><br><span class="line">                    break</span><br><span class="line">        return dp[N]</span><br></pre></td></tr></table></figure>

<h3 id="面试题-08-01-三步问题"><a href="#面试题-08-01-三步问题" class="headerlink" title="面试题 08.01. 三步问题"></a>面试题 08.01. 三步问题</h3><pre><code>链接：https://leetcode-cn.com/problems/three-steps-problem-lcci/

三步问题。有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶或3阶。实现一种方法，计算小孩有多少种上楼梯的方式。结果可能很大，你需要对结果模1000000007。

示例1:

 输入：n = 3 
 输出：4
 说明: 有四种走法
示例2:

 输入：n = 5
 输出：13
提示:

n范围在[1, 1000000]之间</code></pre>
<p>题解一|动态规划</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def watiaosToStep(self, n: int) -&gt; int:</span><br><span class="line">        if n &lt; 3:</span><br><span class="line">            return n</span><br><span class="line">        dp&#x3D;[0]*(n+1)</span><br><span class="line">        dp[1]&#x3D;1</span><br><span class="line">        dp[2]&#x3D;2</span><br><span class="line">        dp[3]&#x3D;4</span><br><span class="line">        for i in range(4,n+1):</span><br><span class="line">            dp[i]&#x3D;(dp[i-1]+dp[i-2]+dp[i-3]) % 1000000007</span><br><span class="line">        return dp[n]</span><br></pre></td></tr></table></figure>

<h3 id="面试题-16-17-连续数列"><a href="#面试题-16-17-连续数列" class="headerlink" title="面试题 16.17. 连续数列"></a>面试题 16.17. 连续数列</h3><pre><code>链接：https://leetcode-cn.com/problems/contiguous-sequence-lcci/

给定一个整数数组，找出总和最大的连续数列，并返回总和。

示例：

输入： [-2,1,-3,4,-1,2,1,-5,4]
输出： 6
解释： 连续子数组 [4,-1,2,1] 的和最大，为 6。
进阶：

如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxSubArray(self, nums: List[int]) -&gt; int:</span><br><span class="line">        if not nums:</span><br><span class="line">            return 0</span><br><span class="line">        if len(nums)&#x3D;&#x3D;1:</span><br><span class="line">            return nums[0]</span><br><span class="line">        dp&#x3D;[0]*len(nums)</span><br><span class="line">        dp[0]&#x3D;nums[0]</span><br><span class="line">        dp[1]&#x3D;max(dp[0]+nums[1],nums[1])</span><br><span class="line">        for i in range(2,len(nums)):</span><br><span class="line">            dp[i]&#x3D;max(dp[i-1]+nums[i],nums[i])</span><br><span class="line">        return max(dp)</span><br></pre></td></tr></table></figure>

<h3 id="面试题42-连续子数组的最大和"><a href="#面试题42-连续子数组的最大和" class="headerlink" title="面试题42. 连续子数组的最大和"></a>面试题42. 连续子数组的最大和</h3><pre><code>链接：https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/

输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。

要求时间复杂度为O(n)。

示例1:

输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。


提示：

1 &lt;= arr.length &lt;= 10^5
-100 &lt;= arr[i] &lt;= 100</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxSubArray(self, nums: List[int]) -&gt; int:</span><br><span class="line">        if not nums:</span><br><span class="line">            return 0</span><br><span class="line">        if len(nums)&#x3D;&#x3D;1:</span><br><span class="line">            return nums[0]</span><br><span class="line">        dp&#x3D;[0]*len(nums)</span><br><span class="line">        dp[0]&#x3D;nums[0]</span><br><span class="line">        dp[1]&#x3D;max(dp[0]+nums[1],nums[1])</span><br><span class="line">        for i in range(2,len(nums)):</span><br><span class="line">            dp[i]&#x3D;max(dp[i-1]+nums[i],nums[i])</span><br><span class="line">        return max(dp)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/LeetCode-7-%E9%80%92%E5%BD%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/LeetCode-7-%E9%80%92%E5%BD%92/" class="post-title-link" itemprop="url">LeetCode-7-递归</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-16 18:30:44" itemprop="dateCreated datePublished" datetime="2020-01-16T18:30:44+08:00">2020-01-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-18 22:37:06" itemprop="dateModified" datetime="2020-08-18T22:37:06+08:00">2020-08-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="七-递归"><a href="#七-递归" class="headerlink" title="七.递归"></a>七.递归</h2><p>参考文章：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&amp;mid=2247485092&amp;idx=1&amp;sn=ff44f169aa57cac8a8e6595b7ff49ab8&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&amp;mid=2247485092&amp;idx=1&amp;sn=ff44f169aa57cac8a8e6595b7ff49ab8&amp;scene=21#wechat_redirect</a></p>
<p>递归的三大要素:</p>
<pre><code>第一要素：明确你这个函数想要干什么
第二要素：寻找递归结束条件
第三要素：找出函数的等价关系式,不断缩小参数的范围</code></pre>
<p>递归优化（建议看完一题再看优化）：</p>
<pre><code>1.考虑是否重复计算
比如说f(n-1),f(n-2)等就是 f(n) 的子问题了，这些子问题会被重复计算。

一般我们可以把我们计算的结果保证起来，例如把 f(4) 的计算结果保证起来，当再次要计算 f(4) 的时候，我们先判断一下，之前是否计算过，如果计算过，直接把 f(4) 的结果取出来就可以了，没有计算过的话，再递归计算。</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def fib(n):</span><br><span class="line">        if n&lt;&#x3D;2:</span><br><span class="line">            return n</span><br><span class="line"></span><br><span class="line">        # 判断是否计算过</span><br><span class="line">        if arr[n] !&#x3D; -1:</span><br><span class="line">            return arr[n]</span><br><span class="line">        else:</span><br><span class="line">            # 没有计算过，递归计算,并且把结果保存到 arr数组里</span><br><span class="line">            arr[n]&#x3D;f(n-1)+f(n-2)</span><br><span class="line">            return arr[n]</span><br></pre></td></tr></table></figure>

<pre><code>2.考虑是否可以自底向上,这种方法也被称为递推。

对于递归的问题，我们一般都是从上往下递归的，直到递归到最底，再一层一层着把值返回。
不过，有时候当 n 比较大的时候，例如当 n = 10000 时，那么必须要往下递归10000层直到 n &lt;=1 才将结果慢慢返回，如果n太大的话，可能栈空间会不够用。</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def f(n):</span><br><span class="line">        if n&lt;&#x3D;2:</span><br><span class="line">            return n</span><br><span class="line">        f1&#x3D;1</span><br><span class="line">        f2&#x3D;2</span><br><span class="line">        sum&#x3D;0</span><br><span class="line">        for i in range(3,n+1):</span><br><span class="line">            sum&#x3D;f1+f2</span><br><span class="line">            f1&#x3D;f2</span><br><span class="line">            f2&#x3D;sum</span><br><span class="line">        return  sum</span><br></pre></td></tr></table></figure>

<h3 id="在两个长度相等的排序数组中找到上中位数"><a href="#在两个长度相等的排序数组中找到上中位数" class="headerlink" title="在两个长度相等的排序数组中找到上中位数"></a>在两个长度相等的排序数组中找到上中位数</h3><pre><code>给定两个有序数组arr1和arr2，已知两个数组的长度都为N，求两个数组中所有数的上中位数。要求时间复杂度O(logN)，空间复杂度O(1）

例如 arr1 = [1, 2,3,4]，arr2 = [3,4,5,6]。

总共8个数，则中位数就是第 4 小的数，为 3.

例如 arr1 = [0,1,2]，arr2 = [3,4,5]。

总共6个数，则中位数就是第 3 小的数，为 2.</code></pre>
<p>参考文章：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&amp;mid=2247485087&amp;idx=3&amp;sn=9db76b899a0ed1c9274211a0218c2e8e&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&amp;mid=2247485087&amp;idx=3&amp;sn=9db76b899a0ed1c9274211a0218c2e8e&amp;scene=21#wechat_redirect</a></p>
<p>题解一（递归）：</p>
<pre><code>(1)、当 两个数组的长度为偶数时：

mid1 = (n-1)/2 = 1。
mid2 = (n - 1)/2 = 1。</code></pre>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/median1.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/median1.png"></p>
<pre><code>(2)、当两个数组的长度为奇数时：

mid1 = (n-1)/2 = 2。
mid2 = (n - 1)/2 = 2。

如果 arr2[mid2] &gt; arr1[mid1] 时，则和上面那个情况有点小差别，这时候目标数只存在于 arr1[mid1…n] 和 arr2[0…mid2]中。注意他们的差别，从arr1[mid1+1…n] =&gt; arr1[mid1…n]。

(3)、总结

当数组长度为奇数时：
    arr2[mid1] &lt; arr1[mid2]：mid1+1~n和0～mid2
    arr2[mid1] &gt; arr1[mid2]：0～mid1和mid2+1～n
当数组长度为偶数时:
    arr2[mid1] &lt; arr1[mid2]：mid1~n和0～mid2
    arr2[mid1] &gt; arr1[mid2]：0～mid1和mid2～n</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">def getUpMedian(arr1, arr2):</span><br><span class="line">    if arr1 is None or arr2 is None:</span><br><span class="line">        return -1</span><br><span class="line"></span><br><span class="line">    return helper(arr1, 0, len(arr1) - 1, arr2, 0, len(arr2) - 1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def helper(arr1, l1, r1, arr2, l2, r2):</span><br><span class="line">    # mid1 &#x3D; (r1 + l1) &#x2F;&#x2F; 2</span><br><span class="line">    # mid2 &#x3D; (r2 + l2) &#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">    mid1 &#x3D; l1+(r1 - l1) &#x2F;&#x2F; 2 # 不明白为何这样求中位数？</span><br><span class="line">    mid2 &#x3D; l2+(r2 - l2) &#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">    if l1 &gt;&#x3D; r1:</span><br><span class="line">        return min(arr1[l1], arr2[l2])</span><br><span class="line"></span><br><span class="line">    offset &#x3D; ((r1 - l1 + 1) &amp; 1) ^ 1</span><br><span class="line"></span><br><span class="line">    if arr1[mid1] &lt; arr2[mid2]:</span><br><span class="line">        return helper(arr1, mid1 + offset, r1, arr2, l2, mid2)</span><br><span class="line">    elif arr1[mid1] &gt; arr2[mid2]:</span><br><span class="line">        return helper(arr1, l1, mid1, arr2, mid2 + offset, r2)</span><br><span class="line">    else:</span><br><span class="line">        return arr1[mid1]</span><br><span class="line"></span><br><span class="line">print(getUpMedian([1, 2, 4, 6,9], [2, 2, 7, 9,10]))</span><br></pre></td></tr></table></figure>

<p>题解二（迭代）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">def getUpMedian(arr1, arr2):</span><br><span class="line">    if arr1 is None or arr2 is None:</span><br><span class="line">        return -1</span><br><span class="line"></span><br><span class="line">    l1 &#x3D; 0</span><br><span class="line">    r1 &#x3D; len(arr1) - 1</span><br><span class="line">    l2 &#x3D; 0</span><br><span class="line">    r2 &#x3D; len(arr2) - 1</span><br><span class="line">    mid1, mid2 &#x3D; 0, 0</span><br><span class="line">    offset &#x3D; 0</span><br><span class="line"></span><br><span class="line">    while l1 &lt; r1:</span><br><span class="line">        # mid1 &#x3D; (r1 - l1) &#x2F;&#x2F; 2</span><br><span class="line">        # mid2 &#x3D; (r2 - l2) &#x2F;&#x2F; 2</span><br><span class="line">        mid1 &#x3D; l1 + (r1 - l1) &#x2F;&#x2F; 2</span><br><span class="line">        mid2 &#x3D; l2 + (r2 - l2) &#x2F;&#x2F; 2</span><br><span class="line">        offset &#x3D; ((r1 - l1 + 1) &amp; 1) ^ 1</span><br><span class="line"></span><br><span class="line">        if arr1[mid1] &lt; arr2[mid2]:</span><br><span class="line">            l1 &#x3D; mid1 + offset</span><br><span class="line">            r2 &#x3D; mid2</span><br><span class="line">        elif arr1[mid1] &gt; arr2[mid2]:</span><br><span class="line">            r1 &#x3D; mid1</span><br><span class="line">            l2 &#x3D; mid2 + offset</span><br><span class="line">        else:</span><br><span class="line">            return arr1[mid1]</span><br><span class="line">    return min(arr1[l1], arr2[l2])</span><br><span class="line"></span><br><span class="line">print(getUpMedian([1, 2, 4, 6, 9], [2, 2, 7, 9, 10]))</span><br></pre></td></tr></table></figure>

<h3 id="？？？求两个有序数组的第K小数"><a href="#？？？求两个有序数组的第K小数" class="headerlink" title="？？？求两个有序数组的第K小数"></a>？？？求两个有序数组的第K小数</h3><pre><code>给定两个有序数组arr1和arr2，已知两个数组的长度分别为 m1 和 m2，求两个数组中的第 K 小数。要求时间复杂度O(log(m1 + m2))。

【举例】
例如 arr1 = [1, 2,3]，arr2 = [3,4,5,6]，K = 4。

则第 K 小数为 3.

例如 arr1 = [0,1,2]，arr2 = [3,4,5，7，8]， K = 3;

则第 K 小数为 2.</code></pre>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&amp;mid=2247485084&amp;idx=3&amp;sn=2cd46fef0f9e80bfe5a47043afc8ccbb&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&amp;mid=2247485084&amp;idx=3&amp;sn=2cd46fef0f9e80bfe5a47043afc8ccbb&amp;scene=21#wechat_redirect</a></p>
<p>题解一（递归）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">def findKth(arr1, arr2, k):</span><br><span class="line">    if arr1 is None or len(arr1) &lt; 1:</span><br><span class="line">        return arr2[k - 1]</span><br><span class="line">    if arr2 is None or len(arr2) &lt; 1:</span><br><span class="line">        return arr1[k - 1]</span><br><span class="line">    return helper(arr1, 0, len(arr1) - 1, arr2, 0, len(arr2) - 1, k)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def helper(arr1, l1, r1, arr2, l2, r2, k):</span><br><span class="line">    if l1 &gt; r1:</span><br><span class="line">        return arr2[l2 + k]</span><br><span class="line">    if l2 &gt; r2:</span><br><span class="line">        return arr1[l1 + k]</span><br><span class="line">    if k &#x3D;&#x3D; 0:</span><br><span class="line">        return min(arr1[l1], arr2[l2])</span><br><span class="line"></span><br><span class="line">    mid1 &#x3D; l1 + k &#x2F;&#x2F; 2 if (l1 + k &#x2F;&#x2F; 2) &lt; (r1) else r1</span><br><span class="line">    mid2 &#x3D; l2 + k &#x2F;&#x2F; 2 if (l1 + k &#x2F;&#x2F; 2) &lt; (r2 - l1) else r2</span><br><span class="line"></span><br><span class="line">    if arr1[mid1] &lt; arr2[mid2]:</span><br><span class="line">        return helper(arr1, mid1 + 1, r1, arr2, l2, r2, k - k &#x2F;&#x2F; 2 - 1)</span><br><span class="line">    elif arr1[mid1] &gt; arr2[mid2]:</span><br><span class="line">        return helper(arr1, l1, r1, arr2, mid2 + 1, r2, k - k &#x2F;&#x2F; 2 - 1)</span><br><span class="line">    else:</span><br><span class="line">        return arr1[mid1]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a>70.爬楼梯</h3><pre><code>链接：https://leetcode-cn.com/problems/climbing-stairs/

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1：

输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
示例 2：

输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶</code></pre>
<p>题解一(递归):</p>
<pre><code>第一要素：明确你这个函数想要干什么</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(n) 的功能是跳上一个n级的台阶总共有多少种跳法.</span><br><span class="line">def f(n):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<pre><code>第二要素：寻找递归结束条件</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n&#x3D;1,f(1) &#x3D; 1</span><br><span class="line">n&#x3D;2,f(2) &#x3D; 2</span><br><span class="line"></span><br><span class="line">def f(n):</span><br><span class="line">    if n&lt;&#x3D; 2:</span><br><span class="line">        return n</span><br></pre></td></tr></table></figure>
<pre><code>第三要素：找出函数的等价关系式,不断缩小参数的范围</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">每次跳的时候，小青蛙可以跳一个台阶，也可以跳两个台阶，也就是说，每次跳的时候，小青蛙有两种跳法。</span><br><span class="line"></span><br><span class="line">跳上n个台阶时，可以从n-1台阶跳上来，或者从n-2台阶跳上来。</span><br><span class="line"></span><br><span class="line">第一种跳法：第一次我跳了一个台阶，那么还剩下n-1个台阶还没跳，剩下的n-1个台阶的跳法有f(n-1)种。</span><br><span class="line"></span><br><span class="line">第二种跳法：第一次跳了两个台阶，那么还剩下n-2个台阶还没，剩下的n-2个台阶的跳法有f(n-2)种。</span><br><span class="line"></span><br><span class="line">f(n) &#x3D; f(n-1) + f(n-2)</span><br><span class="line"></span><br><span class="line">def f(n):</span><br><span class="line">    # 递归结束条件</span><br><span class="line">    if n&lt;&#x3D;2:</span><br><span class="line">        return n</span><br><span class="line">    # 等价关系式</span><br><span class="line">    return  fib(n-1)+fib(n-2)</span><br></pre></td></tr></table></figure>
<h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h3><pre><code>链接：https://leetcode-cn.com/problems/reverse-linked-list/

反转一个单链表。

示例:

输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL
进阶:
你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</code></pre>
<p>题解一（递归）:</p>
<pre><code>第一要素：明确你这个函数想要干什么</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reverseList(head) 的功能是反转单链表，head表示头节点</span><br><span class="line">def reverseList(head):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<pre><code>第二要素：寻找递归结束条件
当链表只有一个节点，或者链表为空时，递归结束。</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def reverseList(head):</span><br><span class="line">    if head is None or head.next is None:</span><br><span class="line">        return head</span><br></pre></td></tr></table></figure>

<pre><code>第三要素：找出函数的等价关系式,不断缩小参数的范围

等价条件中，一定是范围不断在缩小，对于链表来说，就是链表的节点个数不断在变小.
head -&gt; 1 -&gt; 2 -&gt;3 -&gt;4

newList -&gt; 4 -&gt; 3 -&gt; 2 &lt;- 1 &lt;- head

接下来只需要把节点 2 的 next 指向 1，然后把 1 的 next 指向 null,不就行了.

newList -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; null</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def reverseList(head):</span><br><span class="line">    def helper(head):</span><br><span class="line">        if head is None or head.next is None:</span><br><span class="line">            return head</span><br><span class="line">        pre,last&#x3D;helper(head.next)</span><br><span class="line">        last.next&#x3D;head</span><br><span class="line">        head.next&#x3D;None</span><br><span class="line">        return pre,head</span><br><span class="line">    rt,_&#x3D;helper(head)</span><br><span class="line">    return rt</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">不理解？？？</span><br><span class="line">class Solution(object):</span><br><span class="line">    def reverseList(self, head):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 递归终止条件是当前为空，或者下一个节点为空</span><br><span class="line">        if(head&#x3D;&#x3D;None or head.next&#x3D;&#x3D;None):</span><br><span class="line">            return head</span><br><span class="line">        # 这里的cur就是最后一个节点</span><br><span class="line">        cur &#x3D; self.reverseList(head.next)</span><br><span class="line">        # 这里请配合动画演示理解</span><br><span class="line">        # 如果链表是 1-&gt;2-&gt;3-&gt;4-&gt;5，那么此时的cur就是5</span><br><span class="line">        # 而head是4，head的下一个是5，下下一个是空</span><br><span class="line">        # 所以head.next.next 就是5-&gt;4</span><br><span class="line">        head.next.next &#x3D; head</span><br><span class="line">        # 防止链表循环，需要将head.next设置为空</span><br><span class="line">        head.next &#x3D; None</span><br><span class="line">        # 每层递归函数都返回cur，也就是最后一个节点</span><br><span class="line">        return cur</span><br></pre></td></tr></table></figure>
<h3 id="509-斐波那契数列"><a href="#509-斐波那契数列" class="headerlink" title="509.斐波那契数列"></a>509.斐波那契数列</h3><pre><code>链接：https://leetcode-cn.com/problems/fibonacci-number/

斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：

F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.
给定 N，计算 F(N)。

 

示例 1：

输入：2
输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1.
示例 2：

输入：3
输出：2
解释：F(3) = F(2) + F(1) = 1 + 1 = 2.
示例 3：

输入：4
输出：3
解释：F(4) = F(3) + F(2) = 2 + 1 = 3.
 

提示：

0 ≤ N ≤ 30</code></pre>
<p>题解一（递归）:</p>
<pre><code>第一要素：明确你这个函数想要干什么</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f(n) 的功能是求第 n 项的值.</span><br><span class="line"></span><br><span class="line">def fib(n):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<pre><code>第二要素：寻找递归结束条件</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f(1) &#x3D; f(2) &#x3D; 1。所以递归结束条件可以为  n &lt;&#x3D; 2。</span><br><span class="line"></span><br><span class="line">def fib(n):</span><br><span class="line">    if n&lt;2:</span><br><span class="line">        return 1</span><br></pre></td></tr></table></figure>
<pre><code>第三要素：找出函数的等价关系式,不断缩小参数的范围</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">f(n) &#x3D; f(n-1) + f(n-2)</span><br><span class="line"></span><br><span class="line">def fib(n):</span><br><span class="line">    # 递归结束条件</span><br><span class="line">    if n&lt;2:</span><br><span class="line">        return 1</span><br><span class="line">    # 等价关系式</span><br><span class="line">    return  fib(n-1)+fib(n-2)</span><br></pre></td></tr></table></figure>

<h3 id="969-煎饼排序"><a href="#969-煎饼排序" class="headerlink" title="969. 煎饼排序"></a>969. 煎饼排序</h3><pre><code>链接：https://leetcode-cn.com/problems/pancake-sorting/

给定数组 A，我们可以对其进行煎饼翻转：我们选择一些正整数 k &lt;= A.length，然后反转 A 的前 k 个元素的顺序。我们要执行零次或多次煎饼翻转（按顺序一次接一次地进行）以完成对数组 A 的排序。

返回能使 A 排序的煎饼翻转操作所对应的 k 值序列。任何将数组排序且翻转次数在 10 * A.length 范围内的有效答案都将被判断为正确。

示例 1：

输入：[3,2,4,1]
输出：[4,2,4,3]
解释：
我们执行 4 次煎饼翻转，k 值分别为 4，2，4，和 3。
初始状态 A = [3, 2, 4, 1]
第一次翻转后 (k=4): A = [1, 4, 2, 3]
第二次翻转后 (k=2): A = [4, 1, 2, 3]
第三次翻转后 (k=4): A = [3, 2, 1, 4]
第四次翻转后 (k=3): A = [1, 2, 3, 4]，此时已完成排序。 
示例 2：

输入：[1,2,3]
输出：[]
解释：
输入已经排序，因此不需要翻转任何内容。
请注意，其他可能的答案，如[3，3]，也将被接受。

提示：

1 &lt;= A.length &lt;= 100
A[i] 是 [1, 2, ..., A.length] 的排列</code></pre>
<p>题解一|递归</p>
<p>思路：</p>
<pre><code>1、找到n个饼中最大的那个。

2、把这个最大的饼移到最底下。

3、递归调用pancakeSort(A, n - 1)。

base case：n == 1时，排序 1 个饼时不需要翻转。</code></pre>
<p>操作：</p>
<p>1、用锅铲将前 3 块饼翻转一下，这样最大的饼就翻到了最上面。</p>
<p>2、用锅铲将前n块饼全部翻转，这样最大的饼就翻到了第n块，也就是最后一块。</p>
<p>时间复杂度：因为递归调用的次数是n，每次递归调用都需要一次 for 循环，时间复杂度是 O(n)，所以总的复杂度是 O(n^2)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def pancakeSort(self, A: List[int]) -&gt; List[int]:</span><br><span class="line">        self.res&#x3D;[]</span><br><span class="line">        self.sort(A,len(A))</span><br><span class="line">        return self.res</span><br><span class="line">    </span><br><span class="line">    def sort(self,arr,n):</span><br><span class="line">        if n&#x3D;&#x3D;1:</span><br><span class="line">            return</span><br><span class="line">        maxCake&#x3D;0</span><br><span class="line">        maxCakeIndex&#x3D;0</span><br><span class="line">        # 寻找最大饼的索引</span><br><span class="line">        for i in range(n):</span><br><span class="line">            if arr[i]&gt;maxCake:</span><br><span class="line">                maxCake&#x3D;arr[i]</span><br><span class="line">                maxCakeIndex&#x3D;i</span><br><span class="line">        self.reverse(arr,0,maxCakeIndex) # 第一次翻转，将最大饼翻到最上面</span><br><span class="line">        self.res.append(maxCakeIndex+1)</span><br><span class="line">        self.reverse(arr,0,n-1) # 第二次翻转，将最大饼翻到最下面</span><br><span class="line">        self.res.append(n)</span><br><span class="line"></span><br><span class="line">        self.sort(arr,n-1) # 递归调用</span><br><span class="line"></span><br><span class="line">    def reverse(self,arr,i,j):</span><br><span class="line">        while i&lt;j:</span><br><span class="line">            arr[i],arr[j]&#x3D;arr[j],arr[i]</span><br><span class="line">            i+&#x3D;1</span><br><span class="line">            j-&#x3D;1</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/LeetCode-5-%E9%93%BE%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/LeetCode-5-%E9%93%BE%E8%A1%A8/" class="post-title-link" itemprop="url">LeetCode-5-链表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-15 22:01:02" itemprop="dateCreated datePublished" datetime="2020-01-15T22:01:02+08:00">2020-01-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-16 15:40:06" itemprop="dateModified" datetime="2020-09-16T15:40:06+08:00">2020-09-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="五、链表"><a href="#五、链表" class="headerlink" title="五、链表"></a>五、链表</h2><h3 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h3><pre><code>链接：https://leetcode-cn.com/problems/add-two-numbers/

给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。

如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

您可以假设除了数字 0 之外，这两个数都不会以 0 开头。

示例：

输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
输出：7 -&gt; 0 -&gt; 8
原因：342 + 465 = 807</code></pre>
<p>题解一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:</span><br><span class="line">        if not l1:</span><br><span class="line">            return l2</span><br><span class="line">        if not l2:</span><br><span class="line">            return l1</span><br><span class="line">        dummy&#x3D;res&#x3D;ListNode(0)</span><br><span class="line">        flag&#x3D;0</span><br><span class="line"></span><br><span class="line">        while l1 or l2:</span><br><span class="line">            sum&#x3D;0</span><br><span class="line">            if l1:</span><br><span class="line">                sum&#x3D;l1.val</span><br><span class="line">                l1&#x3D;l1.next</span><br><span class="line">            if l2:</span><br><span class="line">                sum+&#x3D;l2.val</span><br><span class="line">                l2&#x3D;l2.next</span><br><span class="line">            tmp&#x3D;(sum+flag)%10 # 余数</span><br><span class="line">            flag&#x3D;(sum+flag)&#x2F;&#x2F;10 # 进位</span><br><span class="line"></span><br><span class="line">            res.next&#x3D;ListNode(tmp)</span><br><span class="line">            res&#x3D;res.next</span><br><span class="line"></span><br><span class="line">            if flag: # 这里虽然创建了一个节点，但是并没有res&#x3D;res.next,并没有右移。所以插入8时没有问题。同时case输入为[5]和[5]时，可以得到结果[0,1]，而非[0]</span><br><span class="line">                res.next&#x3D;ListNode(1)</span><br><span class="line">        return dummy.next</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:</span><br><span class="line">        res&#x3D;dummy&#x3D;ListNode(-1)</span><br><span class="line">        flag&#x3D;0</span><br><span class="line">        while l1 and l2:</span><br><span class="line">            res.next&#x3D;ListNode(l1.val+l2.val+flag)</span><br><span class="line">            flag&#x3D;res.next.val &#x2F;&#x2F; 10</span><br><span class="line">            res.next.val %&#x3D; 10</span><br><span class="line">            res&#x3D;res.next</span><br><span class="line">            l1&#x3D;l1.next</span><br><span class="line">            l2&#x3D;l2.next</span><br><span class="line">        </span><br><span class="line">        p&#x3D; l1 or l2</span><br><span class="line">        while p:</span><br><span class="line">            res.next&#x3D;ListNode(p.val+flag)</span><br><span class="line">            flag&#x3D;res.next.val &#x2F;&#x2F; 10</span><br><span class="line">            res.next.val %&#x3D; 10</span><br><span class="line">            p&#x3D;p.next</span><br><span class="line">            res&#x3D;res.next</span><br><span class="line">        if flag:</span><br><span class="line">            res.next&#x3D;ListNode(1)</span><br><span class="line">        return dummy.next</span><br></pre></td></tr></table></figure>

<h3 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19. 删除链表的倒数第N个节点"></a>19. 删除链表的倒数第N个节点</h3><pre><code>链接：https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/

给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。

示例：

给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.
说明：

给定的 n 保证是有效的。

进阶：你能尝试使用一趟扫描实现吗？</code></pre>
<p>题解一|两次遍历：</p>
<p>分析：<br>    删除从列表开头数起的第 (L−n+1) 个结点，其中 L 是列表的长度。只要我们找到列表的长度 L，这个问题就很容易解决。</p>
<pre><code>在第一次遍历中，我们找出列表的长度 L。
设置一个指向哑结点的指针，并移动它遍历列表，直至它到达第 (L−n) 个结点那里。我们把第 (L−n) 个结点的 next 指针重新链接至第 (L−n+2) 个结点，完成这个算法。</code></pre>
<p>时间复杂度：O(L)，该算法对列表进行了两次遍历，首先计算了列表的长度 L 其次找到第 (L−n) 个结点。 操作执行了 2L-n 步，时间复杂度为 O(L)。</p>
<p>空间复杂度：O(1)，我们只用了常量级的额外空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode:</span><br><span class="line">        dummy&#x3D;ListNode(-1)</span><br><span class="line">        dummy.next&#x3D;head # 注意case:[1]和1</span><br><span class="line">        p&#x3D;dummy</span><br><span class="line">        length&#x3D;0</span><br><span class="line">        while p:</span><br><span class="line">            p&#x3D;p.next</span><br><span class="line">            length+&#x3D;1 # 注意：这里length&#x3D;6，而不是5，因为有一个头节点。</span><br><span class="line">        length-&#x3D;(n+1)</span><br><span class="line">        p&#x3D;dummy</span><br><span class="line">        while length&gt;0:</span><br><span class="line">            p&#x3D;p.next</span><br><span class="line">            length-&#x3D;1</span><br><span class="line">        p.next&#x3D;p.next.next</span><br><span class="line">        return dummy.next</span><br></pre></td></tr></table></figure>
<p>题解二|一次遍历：</p>
<p>分析：<br>    第一个指针从列表的开头向前移动 n+1 步，而第二个指针将从列表的开头出发。</p>
<pre><code>通过同时移动两个指针向前来保持这个恒定的间隔，直到第一个指针到达最后一个结点。

此时第二个指针将指向从最后一个结点数起的第 n 个结点。我们重新链接第二个指针所引用的结点的 next 指针指向该结点的下下个结点。</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode:</span><br><span class="line">        dummy&#x3D;ListNode(-1)</span><br><span class="line">        dummy.next&#x3D;head # 如果dummy&#x3D;head,case为[1],1不能通过。</span><br><span class="line">        fast&#x3D;slow&#x3D;dummy</span><br><span class="line">        while fast and n:</span><br><span class="line">            fast&#x3D;fast.next</span><br><span class="line">            n-&#x3D;1</span><br><span class="line">        while fast.next and slow.next: # 注意不是while fast and slow：</span><br><span class="line">            fast&#x3D;fast.next</span><br><span class="line">            slow&#x3D;slow.next</span><br><span class="line"></span><br><span class="line">        # print( fast.val,slow.val)</span><br><span class="line">        slow.next&#x3D;slow.next.next</span><br><span class="line">        return dummy.next</span><br></pre></td></tr></table></figure>

<h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a>21. 合并两个有序链表</h3><pre><code>链接：https://leetcode-cn.com/problems/merge-two-sorted-lists/

将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

示例：

输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4
输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</code></pre>
<p>题解一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode:</span><br><span class="line">        # if not l1:</span><br><span class="line">        #     return l2</span><br><span class="line">        # if not l2:</span><br><span class="line">        #     return l1</span><br><span class="line">        head&#x3D;dummy&#x3D;ListNode(-1)</span><br><span class="line">        while l1 and l2:</span><br><span class="line">            if l1.val &lt; l2.val:</span><br><span class="line">                head.next&#x3D;l1</span><br><span class="line">                l1&#x3D;l1.next</span><br><span class="line">            else:</span><br><span class="line">                head.next&#x3D;l2</span><br><span class="line">                l2&#x3D;l2.next</span><br><span class="line">            head&#x3D;head.next</span><br><span class="line">        if l1:</span><br><span class="line">            head.next&#x3D;l1</span><br><span class="line">        if l2:</span><br><span class="line">            head.next&#x3D;l2</span><br><span class="line">        return dummy.next</span><br></pre></td></tr></table></figure>

<h3 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h3><pre><code>链接：https://leetcode-cn.com/problems/swap-nodes-in-pairs/

给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

示例:

给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</code></pre>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/dong-hua-yan-shi-24-liang-liang-jiao-huan-lian-bia/">https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/dong-hua-yan-shi-24-liang-liang-jiao-huan-lian-bia/</a></p>
<p>题解一|递归：<br>分析：</p>
<pre><code>从链表的头节点 head 开始递归。
每次递归都负责交换一对节点。由 firstNode 和 secondNode 表示要交换的两个节点。
下一次递归则是传递的是下一对需要交换的节点。若链表中还有节点，则继续递归。
交换了两个节点以后，返回 secondNode，因为它是交换后的新头。
在所有节点交换完成以后，我们返回交换后的头，实际上是原始链表的第二个节点。</code></pre>
<p>时间复杂度：O(N)，其中 N 指的是链表的节点数量。<br>空间复杂度：O(N)，递归过程使用的堆栈空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def swapPairs(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        if not head or not head.next:</span><br><span class="line">            return head</span><br><span class="line"></span><br><span class="line">        first&#x3D;head</span><br><span class="line">        second&#x3D;head.next</span><br><span class="line"></span><br><span class="line">        # swap</span><br><span class="line">        first.next&#x3D;self.swapPairs(second.next)</span><br><span class="line">        second.next&#x3D;first</span><br><span class="line"></span><br><span class="line">        return second</span><br></pre></td></tr></table></figure>
<p>题解二|迭代：</p>
<p>我们把链表分为两部分，即奇数节点为一部分，偶数节点为一部分，A 指的是交换节点中的前面的节点，B 指的是要交换节点中的后面的节点。在完成它们的交换，我们还得用 prevNode 记录 A 的前驱节点。</p>
<p>思路：</p>
<pre><code>1、firstNode（即 A） 和 secondNode（即 B） 分别遍历偶数节点和奇数节点，即两步看作一步。

2、交换两个节点：
    firstNode.next = secondNode.next
    secondNode.next = firstNode

3、还需要更新 prevNode.next 指向交换后的头。
    prevNode.next = secondNode

4、迭代完成后得到最终的交换结果。</code></pre>
<p>时间复杂度：O(N)，其中 N 指的是链表的节点数量。<br>空间复杂度：O(1)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def swapPairs(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        dummy&#x3D;ListNode(-1)</span><br><span class="line">        dummy.next&#x3D;head</span><br><span class="line">        pre&#x3D;dummy</span><br><span class="line"></span><br><span class="line">        while head and head.next:</span><br><span class="line">            first&#x3D;head</span><br><span class="line">            second&#x3D;head.next</span><br><span class="line"></span><br><span class="line">            # swap</span><br><span class="line">            pre.next&#x3D;second</span><br><span class="line">            first.next&#x3D;second.next</span><br><span class="line">            second.next&#x3D;first</span><br><span class="line"></span><br><span class="line">            # Reinitializing the head and prev_node for next swap</span><br><span class="line">            pre&#x3D;first # 通过pre来构成新的链表</span><br><span class="line">            # print(pre.val)</span><br><span class="line">            head&#x3D;first.next</span><br><span class="line"></span><br><span class="line">        return dummy.next</span><br></pre></td></tr></table></figure>

<h3 id="61-旋转链表"><a href="#61-旋转链表" class="headerlink" title="61. 旋转链表"></a>61. 旋转链表</h3><pre><code>链接：https://leetcode-cn.com/problems/rotate-list/

给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。

示例 1:

输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2
输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL
解释:
向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL
向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL
示例 2:

输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4
输出: 2-&gt;0-&gt;1-&gt;NULL
解释:
向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL
向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL
向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL
向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL</code></pre>
<p>题解一|暴力法：</p>
<p>分析：</p>
<pre><code>首先遍历获得链表的长度以及链表尾部的指针（引用）；
之后头尾拼接起来；
随后我们只要从头遍历k - k % length步就能够找到旋转后链表的头指针，断开尾指针和头指针，返回头指针。</code></pre>
<p>关键点就是k，如果移动一次就相当于将倒数第一个元素1移到链表开头，如果移动两次就相当于将倒数第二和倒数第一个元素2和1移动到链表开头。</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode1.jpg" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode1.jpg"></p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode2.jpg" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode2.jpg"></p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode3.jpg" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode3.jpg"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def rotateRight(self, head: ListNode, k: int) -&gt; ListNode:</span><br><span class="line">        if not head:</span><br><span class="line">            return None</span><br><span class="line">        cur&#x3D;head</span><br><span class="line">        length&#x3D;1</span><br><span class="line">        while cur.next:</span><br><span class="line">            cur&#x3D;cur.next</span><br><span class="line">            length+&#x3D;1</span><br><span class="line">        cur.next&#x3D;head # 头尾拼接</span><br><span class="line">        k&#x3D;length-k%length                                          </span><br><span class="line">        while k:</span><br><span class="line">            k-&#x3D;1</span><br><span class="line">            cur&#x3D;cur.next</span><br><span class="line">        head&#x3D;cur.next # 找到头指针</span><br><span class="line">        cur.next&#x3D;None  # 断开尾节点             </span><br><span class="line">        return head</span><br></pre></td></tr></table></figure>

<h3 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="??82.删除排序链表中的重复元素 II"></a>??82.删除排序链表中的重复元素 II</h3><pre><code>链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/

给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。

示例 1:

输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5
输出: 1-&gt;2-&gt;5
示例 2:

输入: 1-&gt;1-&gt;1-&gt;2-&gt;3
输出: 2-&gt;3</code></pre>
<p>题解一：</p>
<p>建立哑结点dummy，当前处理节点为curr，它的值为anchor，它的前序节点为prev。</p>
<p>思路：</p>
<p>如果curr的后序节点的值等于anchor，那么标注flag为True，curr一直后移下去，总之，curr移到连续的最后一个值为anchor的节点，停下来。如果经历了上述步骤，那么prev和curr.next相连，prev按兵不动，curr后移一位；如果没有经历，curr的值是独一无二的，那么prev和curr同时右移一位。继续循环直到curr移到最后一位。</p>
<p>时间复杂度: O(n), 空间复杂度: O(1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        dummy&#x3D;ListNode(-1)</span><br><span class="line">        dummy.next&#x3D;head</span><br><span class="line">        pre,curr&#x3D;dummy,head</span><br><span class="line"></span><br><span class="line">        while curr:</span><br><span class="line">            anchor&#x3D;curr.val</span><br><span class="line">            flag&#x3D;False</span><br><span class="line">            while curr.next:</span><br><span class="line">                if curr.next.val &#x3D;&#x3D; anchor:</span><br><span class="line">                    curr&#x3D;curr.next</span><br><span class="line">                    flag&#x3D;True</span><br><span class="line">                else:</span><br><span class="line">                    break</span><br><span class="line">            if flag:</span><br><span class="line">                pre.next&#x3D;curr.next # pre并未向前移动</span><br><span class="line">            else:</span><br><span class="line">                pre&#x3D;curr</span><br><span class="line">            curr&#x3D;curr.next</span><br><span class="line">        return dummy.next</span><br></pre></td></tr></table></figure>

<p>题解二（快慢指针）：</p>
<pre><code>// 3.1 fast 遍历链表,让fast 去嗅探不相等元素
// 3.2 slow.next == fast --&gt; slow 与 fast 之间没有重复元素，slow 动。
// 3.3 slow.next != fast --&gt; slow 与 fast 之间存在重复元素，让slow指向的元素跳过这些重复元素，slow 不动。</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        dummy&#x3D;ListNode(-1)</span><br><span class="line">        dummy.next&#x3D;head</span><br><span class="line">        slow&#x3D;dummy</span><br><span class="line">        fast&#x3D;head</span><br><span class="line"></span><br><span class="line">        while fast and fast.next:</span><br><span class="line">            if fast.val !&#x3D; fast.next.val:</span><br><span class="line">                if slow.next &#x3D;&#x3D; fast: # 注意此处判断的是内存地址，而非节点的值</span><br><span class="line">                    slow&#x3D;fast</span><br><span class="line">                    # print(&#39;111&#39;,slow)</span><br><span class="line">                else:</span><br><span class="line">                    # print(&#39;222&#39;,fast.next)</span><br><span class="line">                    slow.next&#x3D;fast.next # slow并未向前移动</span><br><span class="line">            fast&#x3D;fast.next</span><br><span class="line">        if slow.next !&#x3D; fast: # 解决case:[1,1]</span><br><span class="line">            slow.next&#x3D;fast.next</span><br><span class="line">        return dummy.next</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        if head &#x3D;&#x3D; None or head.next &#x3D;&#x3D; None:</span><br><span class="line">            return head</span><br><span class="line">        dummy &#x3D; ListNode(-1000)</span><br><span class="line">        dummy.next &#x3D; head</span><br><span class="line">        slow &#x3D; dummy</span><br><span class="line">        fast &#x3D; dummy.next</span><br><span class="line">        while fast:</span><br><span class="line">            if  fast.next and fast.next.val &#x3D;&#x3D; fast.val:</span><br><span class="line">                tmp &#x3D; fast.val</span><br><span class="line">                while fast and tmp &#x3D;&#x3D; fast.val:</span><br><span class="line">                    fast &#x3D; fast.next</span><br><span class="line">            else:</span><br><span class="line">                slow.next &#x3D; fast</span><br><span class="line">                slow &#x3D; fast</span><br><span class="line">                fast &#x3D; fast.next</span><br><span class="line">        slow.next &#x3D; fast</span><br><span class="line">        return dummy.next</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        if head &#x3D;&#x3D; None or head.next &#x3D;&#x3D; None:</span><br><span class="line">            return head</span><br><span class="line">        dummy &#x3D; ListNode(-1)</span><br><span class="line">        dummy.next &#x3D; head</span><br><span class="line">        slow &#x3D; dummy</span><br><span class="line">        fast &#x3D; dummy.next</span><br><span class="line">        while fast:</span><br><span class="line">            while fast.next and slow.next.val &#x3D;&#x3D; fast.next.val:</span><br><span class="line">                fast &#x3D; fast.next</span><br><span class="line">            if slow.next &#x3D;&#x3D; fast:</span><br><span class="line">                slow &#x3D; fast</span><br><span class="line">            else:</span><br><span class="line">                slow.next &#x3D; fast.next</span><br><span class="line">            fast &#x3D; fast.next</span><br><span class="line">        return dummy.next</span><br></pre></td></tr></table></figure>

<p>题解三（递归）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        if not head:</span><br><span class="line">            return head</span><br><span class="line">        if head.next and head.val &#x3D;&#x3D; head.next.val:</span><br><span class="line">            while head.next and head.val &#x3D;&#x3D; head.next.val:</span><br><span class="line">                head&#x3D;head.next</span><br><span class="line">            return self.deleteDuplicates(head.next)</span><br><span class="line">        else:</span><br><span class="line">            head.next&#x3D;self.deleteDuplicates(head.next)</span><br><span class="line">        return head</span><br></pre></td></tr></table></figure>

<h3 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a>83. 删除排序链表中的重复元素</h3><pre><code>链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/

给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。

示例 1:

输入: 1-&gt;1-&gt;2
输出: 1-&gt;2
示例 2:

输入: 1-&gt;1-&gt;2-&gt;3-&gt;3
输出: 1-&gt;2-&gt;3</code></pre>
<p>思路：因为是排序列表，通过将结点的值与它之后的结点进行比较来确定它是否为重复结点。如果它是重复的，我们更改当前结点的 next 指针，以便它跳过下一个结点并直接指向下一个结点之后的结点。</p>
<p>时间复杂度：O(n)，因为列表中的每个结点都检查一次以确定它是否重复，所以总运行时间为 O(n)，其中 n 是列表中的结点数。<br>空间复杂度：O(1)，没有使用额外的空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        dummy&#x3D;ListNode(-1)</span><br><span class="line">        dummy.next&#x3D;head</span><br><span class="line">        while head and head.next:</span><br><span class="line">            if head.val &#x3D;&#x3D; head.next.val:</span><br><span class="line">                head.next&#x3D;head.next.next</span><br><span class="line">            else:</span><br><span class="line">                head&#x3D;head.next</span><br><span class="line">        return dummy.next</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        dummy&#x3D;head</span><br><span class="line">        while head and head.next:</span><br><span class="line">            if head.val &#x3D;&#x3D; head.next.val:</span><br><span class="line">                head.next&#x3D;head.next.next</span><br><span class="line">            else:</span><br><span class="line">                head&#x3D;head.next</span><br><span class="line">        return dummy</span><br></pre></td></tr></table></figure>

<h3 id="86-分隔链表"><a href="#86-分隔链表" class="headerlink" title="86. 分隔链表"></a>86. 分隔链表</h3><pre><code>链接：https://leetcode-cn.com/problems/partition-list/

给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。

你应当保留两个分区中每个节点的初始相对位置。

示例:

输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3
输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</code></pre>
<p>分析：</p>
<pre><code>哈哈，差点没看懂题。</code></pre>
<p>这道题要求我们划分链表，把所有小于给定值的节点都移到前面，大于该值的节点顺序不变，相当于一个局部排序的问题。那么可以想到的一种解法是首先找到第一个大于或等于给定值的节点，用题目中给的例子来说就是先找到4，然后再找小于3的值，每找到一个就将其取出置于4之前即可</p>
<p>题解一（双指针法）：</p>
<p>用两个指针before 和 after 来追踪上述的两个链表。两个指针可以用于分别创建两个链表，然后将这两个链表连接即可获得所需的链表。</p>
<p>时间复杂度: O(N)，其中N是原链表的长度，我们对该链表进行了遍历。<br>空间复杂度: O(1)，我们没有申请任何新空间。值得注意的是，我们只移动了原有的结点，因此没有使用任何额外空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def partition(self, head: ListNode, x: int) -&gt; ListNode:</span><br><span class="line">        before&#x3D;bf&#x3D;ListNode(-1)</span><br><span class="line">        after&#x3D;af&#x3D;ListNode(-1)</span><br><span class="line"></span><br><span class="line">        while head:</span><br><span class="line">            if head.val &lt; x:</span><br><span class="line">                before.next&#x3D;head</span><br><span class="line">                before&#x3D;before.next</span><br><span class="line">            else:</span><br><span class="line">                after.next&#x3D;head</span><br><span class="line">                after&#x3D;after.next</span><br><span class="line">            head&#x3D;head.next</span><br><span class="line">        </span><br><span class="line">        after.next&#x3D;None</span><br><span class="line">        before.next&#x3D;af.next</span><br><span class="line">        return bf.next</span><br></pre></td></tr></table></figure>

<h3 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a>92. 反转链表 II</h3><pre><code>链接：https://leetcode-cn.com/problems/reverse-linked-list-ii/

反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。

说明:
1 ≤ m ≤ n ≤ 链表长度。

示例:

输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4
输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</code></pre>
<p>题解一（迭代）：</p>
<p>时间复杂度: O(N)。考虑包含 N 个结点的链表。对每个节点最多会处理<br>（第 n 个结点之后的结点不处理）。</p>
<p>空间复杂度: O(1)。我们仅仅在原有链表的基础上调整了一些指针，只使用了 O(1)的额外存储空间来获得结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def reverseBetween(self, head: ListNode, m: int, n: int) -&gt; ListNode:</span><br><span class="line">        if not head:</span><br><span class="line">            return None</span><br><span class="line">        prev,cur&#x3D;None,head</span><br><span class="line">        while m&gt;1:</span><br><span class="line">            prev&#x3D;cur</span><br><span class="line">            cur&#x3D;cur.next</span><br><span class="line">            m,n&#x3D;m-1,n-1</span><br><span class="line">        # print(cur.val,prev.val)</span><br><span class="line">        # tail 指针指向从链表头起的第m个结点，此结点是反转后链表的尾部，故称为 tail。</span><br><span class="line">        # con 指针指向第 m 个结点的前一个结点，此结点是新链表的头部。</span><br><span class="line">        con,tail&#x3D;prev,cur</span><br><span class="line">        while n:</span><br><span class="line">            next&#x3D;cur.next</span><br><span class="line">            cur.next&#x3D;prev</span><br><span class="line">            prev&#x3D;cur</span><br><span class="line">            cur&#x3D;next</span><br><span class="line">            n-&#x3D;1</span><br><span class="line">        if con:</span><br><span class="line">            con.next&#x3D;prev # 头节点链接反转后链表的头节点</span><br><span class="line">        else:</span><br><span class="line">            # head.next&#x3D;prev</span><br><span class="line">            head&#x3D;prev</span><br><span class="line">        tail.next&#x3D;cur # 反转后的链表链接尾节点</span><br><span class="line">        return head</span><br></pre></td></tr></table></figure>

<h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141.环形链表"></a>141.环形链表</h3><pre><code>链表：https://leetcode-cn.com/problems/linked-list-cycle

给定一个链表，判断链表中是否有环。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。

示例 1：

输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。


示例 2：

输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。


示例 3：

输入：head = [1], pos = -1
输出：false
解释：链表中没有环。

进阶：你能用 O(1)（即，常量）内存解决此问题吗？</code></pre>
<p>题解一|hash:</p>
<pre><code>时间复杂度：O(n)，对于含有 n个元素的链表，我们访问每个元素最多一次。添加一个结点到哈希表中只需要花费 O(1) 的时间。

空间复杂度：O(n)，空间取决于添加到哈希表中的元素数目，最多可以添加 n 个元素。</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class ListNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def hasCycle(self, head: ListNode) -&gt; bool:</span><br><span class="line">        hash&#x3D;&#123;&#125;</span><br><span class="line">        while head :</span><br><span class="line">            if head not in hash:</span><br><span class="line">                hash[head]&#x3D;0</span><br><span class="line">                head&#x3D;head.next</span><br><span class="line">            else:</span><br><span class="line">                return True</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure>
<p>题解二|快慢指针:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def hasCycle(self, head: ListNode) -&gt; bool:</span><br><span class="line">        if not head or not head.next: </span><br><span class="line">            return False</span><br><span class="line">        i,j&#x3D;head,head.next</span><br><span class="line">        while j and j.next: # 如果没有j.next，无法通过case ([1,2] -1).</span><br><span class="line">            if i&#x3D;&#x3D;j:</span><br><span class="line">                return True</span><br><span class="line">            i,j&#x3D;i.next,j.next.next</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def hasCycle(self, head: ListNode) -&gt; bool:</span><br><span class="line">        slow&#x3D;fast&#x3D;head</span><br><span class="line">        while fast and fast.next: # 如果没有fast.next，无法通过case ([1] -1).</span><br><span class="line">            fast&#x3D;fast.next.next</span><br><span class="line">            slow&#x3D;slow.next</span><br><span class="line">            # print(fast.val,slow.val)</span><br><span class="line">            if fast &#x3D;&#x3D; slow:</span><br><span class="line">                # print(fast.val)</span><br><span class="line">                return True # 返回True的节点并不一定就是环的入口节点。</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure>
<h3 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142.环形链表 II"></a>142.环形链表 II</h3><pre><code>链接：https://leetcode-cn.com/problems/linked-list-cycle-ii/

给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。

说明：不允许修改给定的链表。

示例 1：

输入：head = [3,2,0,-4], pos = 1
输出：tail connects to node index 1
解释：链表中有一个环，其尾部连接到第二个节点。


示例 2：

输入：head = [1,2], pos = 0
输出：tail connects to node index 0
解释：链表中有一个环，其尾部连接到第一个节点。


示例 3：

输入：head = [1], pos = -1
输出：no cycle
解释：链表中没有环。

进阶：你是否可以不用额外空间解决此题？</code></pre>
<p>题解一(hash)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def detectCycle(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        hash&#x3D;&#123;&#125;</span><br><span class="line">        while head:</span><br><span class="line">            if head not in hash:</span><br><span class="line">                hash[head]&#x3D;0</span><br><span class="line">                head&#x3D;head.next</span><br><span class="line">            else:</span><br><span class="line">                return head</span><br><span class="line">        return None</span><br></pre></td></tr></table></figure>
<p>题解二(快慢指针):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def detectCycle(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        if not head or not head.next:</span><br><span class="line">            return None</span><br><span class="line">        slow,fast&#x3D;head,head</span><br><span class="line">        while fast and fast.next:</span><br><span class="line">            slow&#x3D;slow.next</span><br><span class="line">            fast&#x3D;fast.next.next</span><br><span class="line">            if slow &#x3D;&#x3D; fast:</span><br><span class="line">                slow&#x3D;head</span><br><span class="line">                while slow !&#x3D; fast:</span><br><span class="line">                    slow&#x3D;slow.next</span><br><span class="line">                    fast&#x3D;fast.next</span><br><span class="line">                return slow</span><br><span class="line">        return None</span><br></pre></td></tr></table></figure>

<h3 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143. 重排链表"></a>143. 重排链表</h3><pre><code>链接：https://leetcode-cn.com/problems/reorder-list

给定一个单链表 L：L0→L1→…→Ln-1→Ln ，
将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

示例 1:

给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.
示例 2:

给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3.</code></pre>
<p>题解一（反转链表）:</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode4.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode4.png"></p>
<p>分析：</p>
<pre><code>找中点
翻转中点之后的链表
依次拼接</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def reorderList(self, head: ListNode) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Do not return anything, modify head in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 1、找中点, 偶数个时找上界</span><br><span class="line">        if not head or not head.next:</span><br><span class="line">            return head</span><br><span class="line">        slow,fast&#x3D;head,head</span><br><span class="line">        while fast and fast.next:</span><br><span class="line">            slow&#x3D;slow.next</span><br><span class="line">            fast&#x3D;fast.next.next</span><br><span class="line">        mid&#x3D;slow        </span><br><span class="line">        # 2、翻转中点之后的链表,采用是pre, slow双指针方法</span><br><span class="line">        pre&#x3D;None</span><br><span class="line">        while slow:</span><br><span class="line">            next&#x3D;slow.next</span><br><span class="line">            slow.next&#x3D;pre</span><br><span class="line">            pre&#x3D;slow</span><br><span class="line">            slow&#x3D;next</span><br><span class="line">        # 3、翻转链表和前面链表拼接</span><br><span class="line">        p1&#x3D;head # 链表头</span><br><span class="line">        p2&#x3D;pre # 翻转头</span><br><span class="line"></span><br><span class="line">        # print(mid.val,p2.val)</span><br><span class="line">        while p2 !&#x3D; mid:</span><br><span class="line">            next1,next2&#x3D;p1.next,p2.next</span><br><span class="line">            p1.next&#x3D;p2               </span><br><span class="line">            p2.next&#x3D;next1</span><br><span class="line">            p1,p2&#x3D;next1,next2</span><br><span class="line">        return head</span><br></pre></td></tr></table></figure>

<p>题解二（栈）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def reorderList(self, head: ListNode) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Do not return anything, modify head in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not head:</span><br><span class="line">            return head</span><br><span class="line">        dummy&#x3D;head</span><br><span class="line">        stack&#x3D;[]</span><br><span class="line">        while dummy:</span><br><span class="line">            stack.append(dummy)</span><br><span class="line">            dummy&#x3D;dummy.next</span><br><span class="line">        n&#x3D;len(stack)</span><br><span class="line">        mid&#x3D;(n-1)&#x2F;&#x2F;2</span><br><span class="line">        </span><br><span class="line">        dummy&#x3D;head</span><br><span class="line">        while mid:</span><br><span class="line">            tmp&#x3D;stack.pop() # 弹出链表最后一个节点</span><br><span class="line">            tmp.next&#x3D;dummy.next</span><br><span class="line">            dummy.next&#x3D;tmp</span><br><span class="line">            dummy&#x3D;tmp.next # 移动2个位置，使用dummy&#x3D;dummy.next.next也可以。</span><br><span class="line">            mid-&#x3D;1</span><br><span class="line">        stack.pop().next&#x3D;None</span><br><span class="line">        return head</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def reorderList(self, head: ListNode) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Do not return anything, modify head in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not head:</span><br><span class="line">            return head</span><br><span class="line">        fast,slow&#x3D;head,head</span><br><span class="line">        stack&#x3D;[]</span><br><span class="line">        while fast.next and fast.next.next:</span><br><span class="line">            fast&#x3D;fast.next.next</span><br><span class="line">            slow&#x3D;slow.next</span><br><span class="line">        while slow.next:</span><br><span class="line">            stack.append(slow.next)</span><br><span class="line">            slow.next&#x3D;slow.next.next</span><br><span class="line">        dummy&#x3D;head</span><br><span class="line">        while stack:</span><br><span class="line">            tmp&#x3D;stack.pop()</span><br><span class="line">            tmp.next&#x3D;dummy.next</span><br><span class="line">            dummy.next&#x3D;tmp</span><br><span class="line">            dummy&#x3D;dummy.next.next</span><br><span class="line">        return head</span><br></pre></td></tr></table></figure>

<h3 id="147-对链表进行插入排序"><a href="#147-对链表进行插入排序" class="headerlink" title="???147. 对链表进行插入排序"></a>???147. 对链表进行插入排序</h3><pre><code>链接：https://leetcode-cn.com/problems/insertion-sort-list

对链表进行插入排序。


插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。
每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。


插入排序算法：

插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。
每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。
重复直到所有输入数据插入完为止。
 

示例 1：

输入: 4-&gt;2-&gt;1-&gt;3
输出: 1-&gt;2-&gt;3-&gt;4
示例 2：

输入: -1-&gt;5-&gt;3-&gt;4-&gt;0
输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</code></pre>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_17550379/article/details/80708238">https://blog.csdn.net/qq_17550379/article/details/80708238</a></p>
<p>插入排序（数组）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def insertSort(lists):</span><br><span class="line">    count&#x3D;len(lists)</span><br><span class="line">    for i in range(1,count):</span><br><span class="line">        key&#x3D;lists[i]</span><br><span class="line">        j&#x3D;i-1</span><br><span class="line">        while j&gt;&#x3D;0:</span><br><span class="line">            if lists[j]&gt;key:</span><br><span class="line">                lists[j+1]&#x3D;lists[j]</span><br><span class="line">                lists[j]&#x3D;key</span><br><span class="line">            j-&#x3D;1</span><br><span class="line">    return lists</span><br></pre></td></tr></table></figure>

<p>题解一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def insertionSortList(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        if head &#x3D;&#x3D; None or head.next &#x3D;&#x3D; None:</span><br><span class="line">            return head</span><br><span class="line"></span><br><span class="line">        dummy &#x3D; ListNode(-1)</span><br><span class="line">        dummy.next &#x3D; head</span><br><span class="line">        pre &#x3D; dummy</span><br><span class="line">        cur &#x3D; head</span><br><span class="line">        while cur:</span><br><span class="line">            lat &#x3D; cur.next</span><br><span class="line">            if lat and lat.val &lt; cur.val:  # 只有cur.next比cur小的时候我们才寻找插入点</span><br><span class="line">                while pre.next and pre.next.val &lt; lat.val:</span><br><span class="line">                    pre &#x3D; pre.next</span><br><span class="line">                tmp &#x3D; pre.next</span><br><span class="line">                pre.next &#x3D; lat</span><br><span class="line">                cur.next &#x3D; lat.next</span><br><span class="line">                lat.next &#x3D; tmp</span><br><span class="line">                pre &#x3D; dummy</span><br><span class="line">            else:</span><br><span class="line">                cur &#x3D; lat</span><br><span class="line"></span><br><span class="line">        return dummy.next</span><br></pre></td></tr></table></figure>

<p>？？题解二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def insertionSortList(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        p&#x3D;dummy&#x3D;ListNode(-1)</span><br><span class="line">        curr&#x3D;dummy.next&#x3D;head</span><br><span class="line">        while curr and curr.next:</span><br><span class="line">            val &#x3D; curr.next.val</span><br><span class="line">            if curr.val &lt; val:</span><br><span class="line">                curr&#x3D;curr.next</span><br><span class="line">                continue</span><br><span class="line">            if p.next.val &gt; val:</span><br><span class="line">                p&#x3D;dummy</span><br><span class="line">            while p.next.val &lt; val:</span><br><span class="line">                p&#x3D;p.next</span><br><span class="line">            new&#x3D;curr.next</span><br><span class="line">            curr.next&#x3D;new.next</span><br><span class="line">            new.next&#x3D;p.next</span><br><span class="line">            p.next&#x3D;new</span><br><span class="line">        return dummy.next</span><br></pre></td></tr></table></figure>

<h3 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a>160. 相交链表</h3><pre><code>链接：https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</code></pre>
<p>题解一|暴力:</p>
<p>对链表A中的每一个结点 ai，遍历整个链表 B 并检查链表 B 中是否存在结点和 a<br>i相同。</p>
<p>时间复杂度 : (mn)<br>空间复杂度 : O(1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode:</span><br><span class="line">        p,q&#x3D;headA,headB</span><br><span class="line">        while p:</span><br><span class="line">            while q:</span><br><span class="line">                if p &#x3D;&#x3D; q:</span><br><span class="line">                    return q</span><br><span class="line">            q&#x3D;q.next</span><br><span class="line">        p&#x3D;p.next</span><br><span class="line">        return None</span><br></pre></td></tr></table></figure>

<p>题解二|hash：</p>
<p>分析：</p>
<pre><code>遍历链表 A 并将每个结点的地址/引用存储在哈希表中。然后检查链表 B 中的每一个结点 bi 是否在哈希表中。若在，则 bi为相交结点。</code></pre>
<p>时间复杂度 : O(m+n)。<br>空间复杂度 : O(m) 或 O(n)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode:</span><br><span class="line">        p,q&#x3D;headA,headB</span><br><span class="line">        hash&#x3D;&#123;&#125;</span><br><span class="line">        while p:</span><br><span class="line">            if p not in hash:</span><br><span class="line">                hash[p]&#x3D;1</span><br><span class="line">            p&#x3D;p.next</span><br><span class="line">        while q:</span><br><span class="line">            if q in hash:</span><br><span class="line">                return q</span><br><span class="line">            q&#x3D;q.next</span><br></pre></td></tr></table></figure>

<p>题解三|双指针：</p>
<p>分析：<br>    两个指针分别从链表头开始扫描，每次分别走一步<br>    若指针走到null，则从另一个链表头部开始走<br>    两指针相同时:<br>        (利用此时两个指针移动步数一致)<br>        指针不为null：指针位置为相遇点<br>        指针为null：两个链表不相交</p>
<pre><code>创建两个指针 pA 和 pB，分别初始化为链表 A 和 B 的头结点。然后让它们向后逐结点遍历。

当 pA 到达链表的尾部时，将它重定位到链表 B 的头结点 (你没看错，就是链表 B); 类似的，当 pB 到达链表的尾部时，将它重定位到链表 A 的头结点。

若在某一时刻 pA 和 pB 相遇，则 pA/pB 为相交结点。

想弄清楚为什么这样可行, 可以考虑以下两个链表: A=&#123;1,3,5,7,9,11&#125; 和 B=&#123;2,4,9,11&#125;，相交于结点 9。 由于 B.length (=4) &lt; A.length (=6)，pB 比 pA少经过 2 个结点，会先到达尾部。将 pB 重定向到 A 的头结点，pA 重定向到 B 的头结点后，pB 要比 pA 多走 2 个结点。因此，它们会同时到达交点。

如果两个链表存在相交，它们末尾的结点必然相同。因此当 pA/pB 到达链表结尾时，记录下链表 A/B 对应的元素。若最后元素不相同，则两个链表不相交。</code></pre>
<p>时间复杂度 : O(m+n)<br>空间复杂度 : O(1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode:</span><br><span class="line">        p,q&#x3D;headA,headB</span><br><span class="line">        while p !&#x3D; q:</span><br><span class="line">            if p:</span><br><span class="line">                p&#x3D;p.next</span><br><span class="line">            else:</span><br><span class="line">                p&#x3D;headB</span><br><span class="line">            if q:</span><br><span class="line">                q&#x3D;q.next</span><br><span class="line">            else:</span><br><span class="line">                q&#x3D;headA</span><br><span class="line">        return p</span><br></pre></td></tr></table></figure>

<p>扩展：链表有环，如何判断相交？</p>
<p>分析：如果有环且两个链表相交，则两个链表都有共同一个环，即环上的任意一个节点都存在于两个链表上。因此，就可以判断一链表上俩指针相遇的那个节点，在不在另一条链表上。</p>
<pre><code>无环链表和有环链表是不可能相交的;

两个有环链表若相交，其“整个环上”的所有node一定都重合;

有环链表的相交，情况只有2种：相交于”环上”或相交于”不是环的部分”,即下图所示;</code></pre>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/link.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/link.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;cloud.tencent.com&#x2F;developer&#x2F;article&#x2F;1045468</span><br></pre></td></tr></table></figure>

<h3 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a>203. 移除链表元素</h3><pre><code>链接：https://leetcode-cn.com/problems/remove-linked-list-elements/

删除链表中等于给定值 val 的所有节点。

示例:

输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6
输出: 1-&gt;2-&gt;3-&gt;4-&gt;5</code></pre>
<p>题解一|删除头结点时另做考虑：</p>
<p>思路：删除头结点时另做考虑（由于头结点没有前一个结点）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def removeElements(self, head: ListNode, val: int) -&gt; ListNode:</span><br><span class="line">        if not head:</span><br><span class="line">            return head</span><br><span class="line">        # 如果不对头结点单独考虑，无法解决case：[1]和1</span><br><span class="line">        while head and head.val &#x3D;&#x3D; val:</span><br><span class="line">            head&#x3D;head.next</span><br><span class="line">        dummy&#x3D;head</span><br><span class="line">        while head and head.next:</span><br><span class="line">            if head.next.val &#x3D;&#x3D; val:</span><br><span class="line">                # print(val)</span><br><span class="line">                # head&#x3D;head.next.next</span><br><span class="line">                head.next&#x3D;head.next.next</span><br><span class="line">            else:</span><br><span class="line">                head&#x3D;head.next</span><br><span class="line">        return dummy</span><br></pre></td></tr></table></figure>

<p>题解二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">时间复杂度：O(N)，只遍历了一次</span><br><span class="line">空间复杂度：O(1)</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def removeElements(self, head: ListNode, val: int) -&gt; ListNode:</span><br><span class="line">        dummy&#x3D;ListNode(0)</span><br><span class="line">        dummy.next&#x3D;head</span><br><span class="line"></span><br><span class="line">        pre,curr&#x3D;dummy,head</span><br><span class="line">        # print(pre.val,curr.val) 0和1</span><br><span class="line">        while curr:</span><br><span class="line">            if curr.val &#x3D;&#x3D; val:</span><br><span class="line">                pre.next&#x3D;curr.next</span><br><span class="line">            else:</span><br><span class="line">                pre&#x3D;curr</span><br><span class="line">            curr&#x3D;curr.next</span><br><span class="line">            </span><br><span class="line">        return dummy.next</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def removeElements(self, head: ListNode, val: int) -&gt; ListNode:</span><br><span class="line">        dummy&#x3D;ListNode(0)</span><br><span class="line">        dummy.next&#x3D;head</span><br><span class="line">        pre&#x3D;dummy</span><br><span class="line">        while pre.next:</span><br><span class="line">            if pre.next.val &#x3D;&#x3D; val:</span><br><span class="line">                pre.next&#x3D;pre.next.next</span><br><span class="line">            else:</span><br><span class="line">                pre&#x3D;pre.next</span><br><span class="line">            </span><br><span class="line">        return dummy.next</span><br></pre></td></tr></table></figure>

<p>???题解三（递归）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def removeElements(self, head: ListNode, val: int) -&gt; ListNode:</span><br><span class="line">        if not head:</span><br><span class="line">            return head</span><br><span class="line">        head.next&#x3D;self.removeElements(head.next,val)        </span><br><span class="line">        if head.val&#x3D;&#x3D;val:</span><br><span class="line">            return head.next</span><br><span class="line">        else:</span><br><span class="line">            return head</span><br></pre></td></tr></table></figure>

<h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h3><pre><code>链接：https://leetcode-cn.com/problems/reverse-linked-list/

反转一个单链表。

示例:

输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL
进阶:
你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</code></pre>
<p>题解一：</p>
<p>参考：<br>    <a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-linked-list/solution/">https://leetcode.com/problems/reverse-linked-list/solution/</a><br>     <a target="_blank" rel="noopener" href="http://baijiahao.baidu.com/s?id=1574261186522385&wfr=spider&for=pc">http://baijiahao.baidu.com/s?id=1574261186522385&amp;wfr=spider&amp;for=pc</a><br>     <a target="_blank" rel="noopener" href="https://blog.csdn.net/autumn20080101/article/details/7607148">https://blog.csdn.net/autumn20080101/article/details/7607148</a><br>     <a target="_blank" rel="noopener" href="https://www.cnblogs.com/scud001/p/4423324.html">https://www.cnblogs.com/scud001/p/4423324.html</a></p>
<pre><code>初始状态，prev是NULL，head指向当前的头节点A，next指向A节点的下一个节点B。
首先从A节点开始逆序，将A节点的next指针指向prev，因为prev的当前值是NULL，所以A节点就从链表中脱离出来了，然后移动
head和next指针，使它们分别指向B节点和B的下一个节点C（因为当前的next已经指向B节点了，因此修改A节点的next指针不会
导致链表丢失）。逆向节点A之后，链表的状态如图（2）所示：

 从图（1）的初始状态到图（2）状态共做了四个操作，这四个操作的伪代码如下：

head-&gt;next = prev;

prev = head;

head = next;

next = head-&gt;next;

这四行伪代码就是循环算法的迭代体了，现在用这个迭代体对图（2）的状态再进行一轮迭代，就得到了图（3）的状态：

那么循环终止条件呢？现在对图（3）的状态再迭代一次得到图（4）的状态：

此时可以看出，在图（4）的基础上再进行一次迭代就可以完成链表的逆序，因此循环迭代的终止条件就是当前的head指针是NULL。

现在来总结一下，循环的初始条件是：

prev = NULL;

循环迭代体是：

//在头节点改变之前，先获取下一个节点的指针
next = head-&gt;Next;
//头节点的下一个节点要改成它的上一个节点，是一个逆转的过程
head-&gt;Next = prev;
//上一个节点前移指向头节点
prev = head;
//头节点前移指向下一个节点
head = next;

循环终止条件是：

head == NULL</code></pre>
<p><img src="http://p2lakvkq0.bkt.clouddn.com/linkedlist.jpg"></p>
<p>题解一(指针迭代)：</p>
<p>反转一个节点的时候，把一个节点的后驱改为指向它前驱就可以了。这里需要注意的点就是，当你把当前节点的后驱指向前驱的时候，这个时候链表会被截断，也就是说后面的节点和当前节点分开了，所以我们需要一个变量来保存当前节点的后驱，以访丢失。</p>
<p>第一个指针叫 pre，最初是指向 null 的。<br>第二个指针 cur 指向 head，然后不断遍历 cur。<br>每次迭代到 cur，都将 cur 的 next 指向 pre，然后 pre 和 cur 前进一位。<br>都迭代完了(cur 变成 null 了)，pre 就是最后一个节点了。</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode5.JPG" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode5.JPG"></p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/baidu_31657889/article/details/91552141">https://blog.csdn.net/baidu_31657889/article/details/91552141</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def reverseList(self, head):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        prve &#x3D; None</span><br><span class="line">        while head:</span><br><span class="line">            next &#x3D; head.next # 记录当前节点的下一个节点</span><br><span class="line">            head.next &#x3D; prve # 将当前节点指向pre</span><br><span class="line">            prve &#x3D; head # pre节点和head节点前进一位</span><br><span class="line">            head &#x3D; next</span><br><span class="line">        return prve</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reverseList(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        pre&#x3D;None</span><br><span class="line">        while head:</span><br><span class="line">            pre, pre.next, head &#x3D; head, pre, head.next</span><br><span class="line">        return pre</span><br></pre></td></tr></table></figure>

<p>???题解二(递归):</p>
<p>递归的两个条件：</p>
<pre><code>终止条件是当前节点或者下一个节点==null
在函数内部，改变节点的指向，也就是 head 的下一个节点指向 head 递归函数那句

很不好理解，其实就是 head 的下一个节点指向head。</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def reverseList(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        if head is None or head.next is None:  </span><br><span class="line">            return head  # 递归终止条件是当前为空，或者下一个节点为空</span><br><span class="line">        cur&#x3D;self.reverseList(head.next) # cur是最后一个节点5</span><br><span class="line">        head.next.next&#x3D;head </span><br><span class="line">        head.next&#x3D;None</span><br><span class="line">        return cur</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def reverseList(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        def helper(head):</span><br><span class="line">            if head is None or head.next is None:</span><br><span class="line">                return head,head</span><br><span class="line">            pre,last&#x3D;helper(head.next)</span><br><span class="line">            last.next&#x3D;head</span><br><span class="line">            head.next&#x3D;None</span><br><span class="line">            return pre,head</span><br><span class="line">        res,_&#x3D;helper(head)</span><br><span class="line">        return res,_</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>问题扩展：部分节点进行反转</p>
<h3 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234.回文链表"></a>234.回文链表</h3><pre><code>链接：https://leetcode-cn.com/problems/palindrome-linked-list/

请判断一个链表是否为回文链表。

示例 1:

输入: 1-&gt;2
输出: false
示例 2:

输入: 1-&gt;2-&gt;2-&gt;1
输出: true
进阶：
你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</code></pre>
<p>数组列表底层是使用数组存储值，我们可以通过索引在 O(1)的时间访问列表任何位置的值，这是由于内存寻址的方式。</p>
<p>链表存储的是称为节点的对象，每个节点保存一个值和指向下一个节点的指针。访问某个特定索引的节点需要 O(n) 的时间，因为要通过指针获取到下一个位置的节点。</p>
<p>题解一|数组：</p>
<p>分析：</p>
<p>确定数组列表是否为回文很简单，我们可以使用双指针法来比较两端的元素，并向中间移动。一个指针从起点向中间移动，另一个指针从终点向中间移动。这需要 O(n)的时间，因为访问每个元素的时间是 O(1)，而有 n 个元素要访问。</p>
<p>然后，直接在链表上操作并不简单，因为不论是正向访问还是反向访问都不是 O(1)。而将链表的值复制到数组列表中是 O(n)，因此最简单的方法就是将链表的值复制到数组列表中，再使用双指针法判断。</p>
<p>算法：</p>
<pre><code>复制链表值到数组列表中。
使用双指针法判断是否为回文。</code></pre>
<p>第一步，我们需要遍历链表将值复制到数组列表中。我们用 currentNode 指向当前节点。每次迭代向数组添加 currentNode.val，并更新 currentNode = currentNode.next，当 currentNode = null 则停止循环。</p>
<p>执行第二部的最佳方法取决于你使用的编程语言。在 Python 中，很容易构造一个列表的反向副本，也很容易比较两个列表。在其他语言中，就没有那么简单。因此最好使用双指针法来检查是否为回文。我们在起点放置一个指针，在结尾放置一个指针，每一次迭代判断两个指针指向的元素是否相同，若不同，返回 false；相同则将两个指针向内移动，并继续判断，直到相遇。</p>
<p>在编码的过程中，注意我们比较的是节点值的大小，而不是节点本身。正确的比较方式是：node_1.val==node_2.val，node_1==node_2 是错误的。</p>
<p>复杂度：</p>
<p>时间复杂度：O(n)，其中 n 指的是链表的元素个数。</p>
<pre><code>第一步： 遍历链表并将值复制到数组中，O(n)。
第二步：双指针判断是否为回文，执行了 O(n/2) 次的判断，即 O(n)。
总的时间复杂度：O(2n) = O(n)</code></pre>
<p>空间复杂度：O(n)，其中 n 指的是链表的元素个数，我们使用了一个数组列表存放链表的元素值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def isPalindrome(self, head: ListNode) -&gt; bool:</span><br><span class="line">        arr&#x3D;[]</span><br><span class="line">        while head:</span><br><span class="line">            arr.append(head.val)</span><br><span class="line">            head&#x3D;head.next</span><br><span class="line">        return arr&#x3D;&#x3D;arr[::-1]</span><br></pre></td></tr></table></figure>

<p>快慢指针：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">l &#x3D; 0</span><br><span class="line">r &#x3D; len(tmp)-1</span><br><span class="line">while l&lt;r:</span><br><span class="line">    if tmp[l] !&#x3D; tmp[r]:</span><br><span class="line">        return False</span><br><span class="line">    l +&#x3D; 1</span><br><span class="line">    r -&#x3D; 1</span><br><span class="line">return True</span><br></pre></td></tr></table></figure>

<p>题解二|快慢指针+反转链表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def isPalindrome(self, head: ListNode) -&gt; bool:</span><br><span class="line">        def reverseList(head):</span><br><span class="line">            pre&#x3D;None</span><br><span class="line">            while head:</span><br><span class="line">                next&#x3D;head.next</span><br><span class="line">                head.next&#x3D;pre</span><br><span class="line">                pre&#x3D;head</span><br><span class="line">                head&#x3D;next</span><br><span class="line">            return pre</span><br><span class="line"></span><br><span class="line">        # 快慢指针，快指针到达尾部，慢指针到达中间</span><br><span class="line">        slow&#x3D;fast&#x3D;head</span><br><span class="line">        while fast and fast.next:</span><br><span class="line">            slow&#x3D;slow.next</span><br><span class="line">            fast&#x3D;fast.next.next</span><br><span class="line">        </span><br><span class="line">        newHead&#x3D;reverseList(slow)</span><br><span class="line">        p1&#x3D;head</span><br><span class="line">        p2&#x3D;newHead</span><br><span class="line">        while p1 and p2:</span><br><span class="line">            if p1.val !&#x3D; p2.val:</span><br><span class="line">                return False</span><br><span class="line">            p1&#x3D;p1.next</span><br><span class="line">            p2&#x3D;p2.next</span><br><span class="line">        return True</span><br></pre></td></tr></table></figure>
<h3 id="237-删除链表中的节点"><a href="#237-删除链表中的节点" class="headerlink" title="237.删除链表中的节点"></a>237.删除链表中的节点</h3><pre><code>链接：https://leetcode-cn.com/problems/delete-node-in-a-linked-list/

请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。

现有一个链表 -- head = [4,5,1,9]，它可以表示为:

示例 1:

输入: head = [4,5,1,9], node = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.
示例 2:

输入: head = [4,5,1,9], node = 1
输出: [4,5,9]
解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.
 

说明:

链表至少包含两个节点。
链表中所有节点的值都是唯一的。
给定的节点为非末尾节点并且一定是链表中的一个有效节点。
不要从你的函数中返回任何结果。</code></pre>
<p>时间复杂度 O(1)<br>空间复杂度 O(1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def deleteNode(self, node):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type node: ListNode</span><br><span class="line">        :rtype: void Do not return anything, modify node in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        node.val&#x3D;node.next.val</span><br><span class="line">        node.next&#x3D;node.next.next</span><br></pre></td></tr></table></figure>
<h3 id="876-链表的中间节点"><a href="#876-链表的中间节点" class="headerlink" title="876.链表的中间节点"></a>876.链表的中间节点</h3><pre><code>链接：https://leetcode-cn.com/problems/middle-of-the-linked-list/

给定一个带有头结点 head 的非空单链表，返回链表的中间结点。

如果有两个中间结点，则返回第二个中间结点。

示例 1：

输入：[1,2,3,4,5]
输出：此列表中的结点 3 (序列化形式：[3,4,5])
返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。
注意，我们返回了一个 ListNode 类型的对象 ans，这样：
ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.
示例 2：

输入：[1,2,3,4,5,6]
输出：此列表中的结点 4 (序列化形式：[4,5,6])
由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。
 

提示：给定链表的结点数介于 1 和 100 之间。</code></pre>
<p>题解一|数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def middleNode(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        arr&#x3D;[]</span><br><span class="line">        dummy&#x3D;head</span><br><span class="line">        while head:</span><br><span class="line">            arr.append(head.val)</span><br><span class="line">            head&#x3D;head.next</span><br><span class="line">        mid&#x3D;len(arr)&#x2F;&#x2F;2</span><br><span class="line">        i&#x3D;0</span><br><span class="line">        while dummy:</span><br><span class="line">            if i&#x3D;&#x3D;mid:</span><br><span class="line">                return dummy</span><br><span class="line">            dummy&#x3D;dummy.next</span><br><span class="line">            i+&#x3D;1</span><br></pre></td></tr></table></figure>

<p>题解二|快慢指针：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def middleNode(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        slow&#x3D;fast&#x3D;head</span><br><span class="line">        while fast and fast.next:</span><br><span class="line">            slow&#x3D;slow.next</span><br><span class="line">            fast&#x3D;fast.next.next</span><br><span class="line">        return slow</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a>剑指 Offer 06. 从尾到头打印链表</h3><pre><code>链接：https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/

输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。

示例 1：

输入：head = [1,3,2]
输出：[2,3,1]

限制：

0 &lt;= 链表长度 &lt;= 10000</code></pre>
<p>题解一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def reversePrint(self, head: ListNode) -&gt; List[int]:</span><br><span class="line">        arr&#x3D;[]</span><br><span class="line">        while head:</span><br><span class="line">            arr.append(head.val)</span><br><span class="line">            head&#x3D;head.next</span><br><span class="line">        return arr[::-1]</span><br></pre></td></tr></table></figure>

<h3 id="面试题-02-01-移除重复节点"><a href="#面试题-02-01-移除重复节点" class="headerlink" title="面试题 02.01. 移除重复节点"></a>面试题 02.01. 移除重复节点</h3><pre><code>链接：https://leetcode-cn.com/problems/remove-duplicate-node-lcci/

编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。

示例1:

 输入：[1, 2, 3, 3, 2, 1]
 输出：[1, 2, 3]
示例2:

 输入：[1, 1, 1, 1, 2]
 输出：[1, 2]
提示：

链表长度在[0, 20000]范围内。
链表元素在[0, 20000]范围内。
进阶：

如果不得使用临时缓冲区，该怎么解决？</code></pre>
<p>题解一（hash）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def removeDuplicateNodes(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        dummy&#x3D;res&#x3D;ListNode(-1)</span><br><span class="line">        dummy.next&#x3D;head</span><br><span class="line">        hash&#x3D;&#123;&#125;</span><br><span class="line">        while head:</span><br><span class="line">            if head.val not in hash:</span><br><span class="line">                hash[head.val]&#x3D;1</span><br><span class="line">                res&#x3D;head</span><br><span class="line">            else:</span><br><span class="line">                res.next&#x3D;head.next</span><br><span class="line">            head&#x3D;head.next</span><br><span class="line">        return dummy.next</span><br></pre></td></tr></table></figure>
<p>???题解二（快慢指针)：</p>
<p>思路：</p>
<pre><code>1.快慢双指针，第一层大循环为slow非空的循环，
2.第二层循环为fast循环，prev的下一个始终指向fast，保证出现fast.val==slow.val时，可以有效的删除相同结点，只需要fast和prev即可完美做到
3.slow和fast双层循环依次进行，slow和fast以及以后的依次比较，直到结束</code></pre>
<p>运行超时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def removeDuplicateNodes(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        fast&#x3D;slow&#x3D;head</span><br><span class="line">        while slow:</span><br><span class="line">            fast&#x3D;slow.next</span><br><span class="line">            pre&#x3D;slow</span><br><span class="line">            while fast:</span><br><span class="line">                if fast.val &#x3D;&#x3D; slow.val:</span><br><span class="line">                    pre.next&#x3D;fast.next</span><br><span class="line">                else:</span><br><span class="line">                    pre&#x3D;pre.next</span><br><span class="line">                fast&#x3D;fast.next</span><br><span class="line">            slow&#x3D;slow.next</span><br><span class="line">        return head</span><br></pre></td></tr></table></figure>

<h3 id="面试题-02-02-返回倒数第-k-个节点"><a href="#面试题-02-02-返回倒数第-k-个节点" class="headerlink" title="面试题 02.02. 返回倒数第 k 个节点"></a>面试题 02.02. 返回倒数第 k 个节点</h3><pre><code>链接：https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/

实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。

注意：本题相对原题稍作改动

示例：

输入： 1-&gt;2-&gt;3-&gt;4-&gt;5 和 k = 2
输出： 4
说明：

给定的 k 保证是有效的。</code></pre>
<p>题解一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def kthToLast(self, head: ListNode, k: int) -&gt; int:</span><br><span class="line">        res&#x3D;head</span><br><span class="line">        n&#x3D;1</span><br><span class="line">        while head.next:</span><br><span class="line">            n+&#x3D;1</span><br><span class="line">            head&#x3D;head.next</span><br><span class="line">        k&#x3D;n-k</span><br><span class="line">        while k&gt;0:</span><br><span class="line">            k-&#x3D;1</span><br><span class="line">            res&#x3D;res.next</span><br><span class="line">        return res.val</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def kthToLast(self, head: ListNode, k: int) -&gt; int:</span><br><span class="line">        tmp&#x3D;head</span><br><span class="line">        n&#x3D;0</span><br><span class="line">        while head:</span><br><span class="line">            head&#x3D;head.next</span><br><span class="line">            n+&#x3D;1</span><br><span class="line">        k&#x3D;n-k</span><br><span class="line">        while k&gt;0:</span><br><span class="line">            k-&#x3D;1</span><br><span class="line">            tmp&#x3D;tmp.next</span><br><span class="line">        return tmp.val</span><br></pre></td></tr></table></figure>
<p>题解二（快慢指针）:</p>
<pre><code>定义两个指针，快指针 fast， 慢指针 low .
让 fast 先向前移动 k 个位置，然后 low 和 fast 再一起向前移动 .
当 fast 到达链表尾部，返回 low .</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def kthToLast(self, head: ListNode, k: int) -&gt; int:</span><br><span class="line">        fast&#x3D;slow&#x3D;head</span><br><span class="line">        while fast:</span><br><span class="line">            fast&#x3D;fast.next</span><br><span class="line">            if k&#x3D;&#x3D;0:</span><br><span class="line">                slow&#x3D;slow.next</span><br><span class="line">            else:</span><br><span class="line">                k-&#x3D;1</span><br><span class="line">        return slow.val</span><br><span class="line">                  </span><br></pre></td></tr></table></figure>

<h3 id="面试题-02-03-删除中间节点"><a href="#面试题-02-03-删除中间节点" class="headerlink" title="面试题 02.03. 删除中间节点"></a>面试题 02.03. 删除中间节点</h3><pre><code>链接：https://leetcode-cn.com/problems/delete-middle-node-lcci/

实现一种算法，删除单向链表中间的某个节点（除了第一个和最后一个节点，不一定是中间节点），假定你只能访问该节点。

示例：

输入：单向链表a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f中的节点c
结果：不返回任何数据，但该链表变为a-&gt;b-&gt;d-&gt;e-&gt;f</code></pre>
<p>题解一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def deleteNode(self, node):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type node: ListNode</span><br><span class="line">        :rtype: void Do not return anything, modify node in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        node.val&#x3D;node.next.val</span><br><span class="line">        node.next&#x3D;node.next.next</span><br></pre></td></tr></table></figure>

<h3 id="面试题-02-04-分割链表"><a href="#面试题-02-04-分割链表" class="headerlink" title="面试题 02.04. 分割链表"></a>面试题 02.04. 分割链表</h3><pre><code>链接：https://leetcode-cn.com/problems/partition-list-lcci/

编写程序以 x 为基准分割链表，使得所有小于 x 的节点排在大于或等于 x 的节点之前。如果链表中包含 x，x 只需出现在小于 x 的元素之后(如下所示)。分割元素 x 只需处于“右半部分”即可，其不需要被置于左右两部分之间。

示例:

输入: head = 3-&gt;5-&gt;8-&gt;5-&gt;10-&gt;2-&gt;1, x = 5
输出: 3-&gt;1-&gt;2-&gt;10-&gt;5-&gt;5-&gt;8</code></pre>
<p>题解一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def partition(self, head: ListNode, x: int) -&gt; ListNode:</span><br><span class="line">        before&#x3D;bf&#x3D;ListNode(-1)</span><br><span class="line">        after&#x3D;af&#x3D;ListNode(-1)</span><br><span class="line">        while head:</span><br><span class="line">            if head.val&lt;x:</span><br><span class="line">                before.next&#x3D;head</span><br><span class="line">                before&#x3D;before.next</span><br><span class="line">            else:</span><br><span class="line">                after.next&#x3D;head</span><br><span class="line">                after&#x3D;after.next</span><br><span class="line">            head&#x3D;head.next</span><br><span class="line">        after.next&#x3D;None</span><br><span class="line">        before.next&#x3D;af.next</span><br><span class="line">        return bf.next</span><br></pre></td></tr></table></figure>

<h3 id="面试题-02-05-链表求和"><a href="#面试题-02-05-链表求和" class="headerlink" title="面试题 02.05. 链表求和"></a>面试题 02.05. 链表求和</h3><pre><code>链接：https://leetcode-cn.com/problems/sum-lists-lcci/

给定两个用链表表示的整数，每个节点包含一个数位。

这些数位是反向存放的，也就是个位排在链表首部。

编写函数对这两个整数求和，并用链表形式返回结果。

 

示例：

输入：(7 -&gt; 1 -&gt; 6) + (5 -&gt; 9 -&gt; 2)，即617 + 295
输出：2 -&gt; 1 -&gt; 9，即912
进阶：假设这些数位是正向存放的，请再做一遍。

示例：

输入：(6 -&gt; 1 -&gt; 7) + (2 -&gt; 9 -&gt; 5)，即617 + 295
输出：9 -&gt; 1 -&gt; 2，即912</code></pre>
<p>题解一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:</span><br><span class="line">        if not l1:</span><br><span class="line">            return l2</span><br><span class="line">        if not l2:</span><br><span class="line">            return l1</span><br><span class="line">        dummy&#x3D;res&#x3D;ListNode(0)</span><br><span class="line">        flag&#x3D;0</span><br><span class="line">        while l1 or l2:</span><br><span class="line">            sum&#x3D;0</span><br><span class="line">            if l1:</span><br><span class="line">                sum+&#x3D;l1.val</span><br><span class="line">                l1&#x3D;l1.next</span><br><span class="line">            if l2:</span><br><span class="line">                sum+&#x3D;l2.val</span><br><span class="line">                l2&#x3D;l2.next</span><br><span class="line">            tmp&#x3D;(sum+flag)%10</span><br><span class="line">            flag&#x3D;(sum+flag)&#x2F;&#x2F;10</span><br><span class="line">            res.next&#x3D;ListNode(tmp)</span><br><span class="line">            res&#x3D;res.next</span><br><span class="line">        if flag:</span><br><span class="line">            res.next&#x3D;ListNode(flag)</span><br><span class="line">            # res.next&#x3D;ListNode(1)</span><br><span class="line">        return dummy.next</span><br></pre></td></tr></table></figure>

<h3 id="面试题-02-06-回文链表"><a href="#面试题-02-06-回文链表" class="headerlink" title="面试题 02.06. 回文链表"></a>面试题 02.06. 回文链表</h3><pre><code>链接：https://leetcode-cn.com/problems/palindrome-linked-list-lcci/

编写一个函数，检查输入的链表是否是回文的。

示例 1：

输入： 1-&gt;2
输出： false 
示例 2：

输入： 1-&gt;2-&gt;2-&gt;1
输出： true 


进阶：
你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</code></pre>
<p>题解一（数组）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isPalindrome(self, head: ListNode) -&gt; bool:</span><br><span class="line">        arr&#x3D;[]</span><br><span class="line">        while head:</span><br><span class="line">            arr.append(head.val)</span><br><span class="line">            head&#x3D;head.next</span><br><span class="line">        return arr&#x3D;&#x3D;arr[::-1]</span><br></pre></td></tr></table></figure>
<p>题解二（快慢指针）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def isPalindrome(self, head: ListNode) -&gt; bool:</span><br><span class="line">        if not head:</span><br><span class="line">            return True</span><br><span class="line">        slow&#x3D;fast&#x3D;head</span><br><span class="line">        while fast and fast.next:</span><br><span class="line">            slow&#x3D;slow.next</span><br><span class="line">            fast&#x3D;fast.next.next</span><br><span class="line">        pre&#x3D;slow</span><br><span class="line">        while slow and slow.next:</span><br><span class="line">            next&#x3D;slow.next.next</span><br><span class="line">            slow.next.next&#x3D;pre</span><br><span class="line">            pre&#x3D;slow.next</span><br><span class="line">            slow.next&#x3D;next</span><br><span class="line">        while head and pre:</span><br><span class="line">            if head.val !&#x3D; pre.val:</span><br><span class="line">                return False</span><br><span class="line">            head&#x3D;head.next</span><br><span class="line">            pre&#x3D;pre.next</span><br><span class="line">        return True</span><br></pre></td></tr></table></figure>

<h3 id="面试题-02-07-链表相交"><a href="#面试题-02-07-链表相交" class="headerlink" title="面试题 02.07. 链表相交"></a>面试题 02.07. 链表相交</h3><pre><code>链接：https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/

给定两个（单向）链表，判定它们是否相交并返回交点。请注意相交的定义基于节点的引用，而不是基于节点的值。换句话说，如果一个链表的第k个节点与另一个链表的第j个节点是同一节点（引用完全相同），则这两个链表相交。


示例 1：

输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。

示例 2：

输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Reference of the node with value = 2
输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。

示例 3：

输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
解释：这两个链表不相交，因此返回 null。

注意：

如果两个链表没有交点，返回 null 。
在返回结果后，两个链表仍须保持原有的结构。
可假定整个链表结构中没有循环。
程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</code></pre>
<p>题解一（循环）：<br>超时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode:</span><br><span class="line">        p,q&#x3D;headA.next,headB.next</span><br><span class="line">        while p:</span><br><span class="line">            while q:</span><br><span class="line">                if p&#x3D;&#x3D;q:</span><br><span class="line">                    return q</span><br><span class="line">            q&#x3D;q.next</span><br><span class="line">        p&#x3D;p.next</span><br><span class="line">        return None</span><br></pre></td></tr></table></figure>
<p>题解二（双指针）：</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/link10.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/link10.png"></p>
<p>算法让两个指针分别从A和B点往C点走，两个指针分别走到C后，又各自从另外一个指针的起点，也就是A指针第二次走从B点开始走，B指针同理，这样，A指针走的路径长度 AO + OC + BO 必定等于B指针走的路径长度 BO + OC + AO，这也就意味着这两个指针第二轮走必定会在O点相遇，相遇后也即到达了退出循环的条件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode:</span><br><span class="line">        p,q&#x3D;headA,headB</span><br><span class="line">        while p !&#x3D; q:</span><br><span class="line">            if p:</span><br><span class="line">                p&#x3D;p.next</span><br><span class="line">            else:</span><br><span class="line">                p&#x3D;headB</span><br><span class="line">            if q:</span><br><span class="line">                q&#x3D;q.next</span><br><span class="line">            else:</span><br><span class="line">                q&#x3D;headA</span><br><span class="line">        return p</span><br></pre></td></tr></table></figure>

<h3 id="面试题-02-08-环路检测"><a href="#面试题-02-08-环路检测" class="headerlink" title="面试题 02.08. 环路检测"></a>面试题 02.08. 环路检测</h3><pre><code>链接：https://leetcode-cn.com/problems/linked-list-cycle-lcci/

给定一个有环链表，实现一个算法返回环路的开头节点。
有环链表的定义：在链表中某个节点的next元素指向在它前面出现过的节点，则表明该链表存在环路。

示例 1：

输入：head = [3,2,0,-4], pos = 1
输出：tail connects to node index 1
解释：链表中有一个环，其尾部连接到第二个节点。

示例 2：

输入：head = [1,2], pos = 0
输出：tail connects to node index 0
解释：链表中有一个环，其尾部连接到第一个节点。

示例 3：

输入：head = [1], pos = -1
输出：no cycle
解释：链表中没有环。

进阶：你是否可以不用额外空间解决此题？</code></pre>
<p>题解一（双指针）：</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode6.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode6.png"></p>
<p>z=n*环的大小+z</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def detectCycle(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        if not head:</span><br><span class="line">            return None</span><br><span class="line">        slow&#x3D;fast&#x3D;head</span><br><span class="line">        while  fast and fast.next:</span><br><span class="line">            slow&#x3D;slow.next</span><br><span class="line">            fast&#x3D;fast.next.next</span><br><span class="line">            if slow&#x3D;&#x3D;fast:</span><br><span class="line">                slow&#x3D;head</span><br><span class="line">                while slow!&#x3D;fast:</span><br><span class="line">                    slow&#x3D;slow.next</span><br><span class="line">                    fast&#x3D;fast.next</span><br><span class="line">                return slow</span><br><span class="line">        return None</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def detectCycle(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        if not head:</span><br><span class="line">            return None</span><br><span class="line">        slow&#x3D;fast&#x3D;head</span><br><span class="line">        while True:</span><br><span class="line">            if not (fast and fast.next):</span><br><span class="line">                return</span><br><span class="line">            slow&#x3D;slow.next</span><br><span class="line">            fast&#x3D;fast.next.next</span><br><span class="line">            if slow &#x3D;&#x3D; fast:</span><br><span class="line">                break</span><br><span class="line">        slow&#x3D;head</span><br><span class="line">        while slow !&#x3D; fast:</span><br><span class="line">            slow&#x3D;slow.next</span><br><span class="line">            fast&#x3D;fast.next</span><br><span class="line">        return slow  </span><br></pre></td></tr></table></figure>

<h3 id="面试题18-删除链表的节点"><a href="#面试题18-删除链表的节点" class="headerlink" title="面试题18. 删除链表的节点"></a>面试题18. 删除链表的节点</h3><pre><code>链接：https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/

给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。

返回删除后的链表的头节点。

注意：此题对比原题有改动

示例 1:

输入: head = [4,5,1,9], val = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.
示例 2:

输入: head = [4,5,1,9], val = 1
输出: [4,5,9]
解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.


说明：

题目保证链表中节点的值互不相同
若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点</code></pre>
<p>题解一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def deleteNode(self, head: ListNode, val: int) -&gt; ListNode:</span><br><span class="line">        dummy&#x3D;ListNode(-1)</span><br><span class="line">        dummy.next&#x3D;head</span><br><span class="line">        res&#x3D;dummy</span><br><span class="line">        while res.next:</span><br><span class="line">            if res.next.val&#x3D;&#x3D;val:</span><br><span class="line">                res.next&#x3D;res.next.next</span><br><span class="line">            else:</span><br><span class="line">                res&#x3D;res.next</span><br><span class="line">        return dummy.next</span><br></pre></td></tr></table></figure>

<h3 id="面试题22-链表中倒数第k个节点"><a href="#面试题22-链表中倒数第k个节点" class="headerlink" title="面试题22. 链表中倒数第k个节点"></a>面试题22. 链表中倒数第k个节点</h3><pre><code>链接：https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/

个链表的倒数第3个节点是值为4的节点。

示例：

给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.

返回链表 4-&gt;5.</code></pre>
<p>题解一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def getKthFromEnd(self, head: ListNode, k: int) -&gt; ListNode:</span><br><span class="line">        fast&#x3D;slow&#x3D;head</span><br><span class="line">        while fast:</span><br><span class="line">            fast&#x3D;fast.next</span><br><span class="line">            if k&#x3D;&#x3D;0:</span><br><span class="line">                slow&#x3D;slow.next</span><br><span class="line">            else:</span><br><span class="line">                k-&#x3D;1</span><br><span class="line">        return slow</span><br></pre></td></tr></table></figure>

<h3 id="面试题24-反转链表"><a href="#面试题24-反转链表" class="headerlink" title="面试题24. 反转链表"></a>面试题24. 反转链表</h3><pre><code>链接：https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/

定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

示例:

输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL


限制：

0 &lt;= 节点个数 &lt;= 5000</code></pre>
<p>题解一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reverseList(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        pre&#x3D;None</span><br><span class="line">        while head:</span><br><span class="line">            next&#x3D;head.next</span><br><span class="line">            head.next&#x3D;pre</span><br><span class="line">            pre&#x3D;head</span><br><span class="line">            head&#x3D;next</span><br><span class="line">        return pre</span><br></pre></td></tr></table></figure>

<h3 id><a href="#" class="headerlink" title></a></h3><p>题解一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def copyRandomList(self, head: &#39;Node&#39;) -&gt; &#39;Node&#39;:</span><br><span class="line">        return copy.deepcopy(head)</span><br></pre></td></tr></table></figure>

<p>题解二（深度优先遍历）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line"># Definition for a Node.</span><br><span class="line">class Node:</span><br><span class="line">    def __init__(self, x: int, next: &#39;Node&#39; &#x3D; None, random: &#39;Node&#39; &#x3D; None):</span><br><span class="line">        self.val &#x3D; int(x)</span><br><span class="line">        self.next &#x3D; next</span><br><span class="line">        self.random &#x3D; random</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">class Solution:</span><br><span class="line">    def copyRandomList(self, head: &#39;Node&#39;) -&gt; &#39;Node&#39;:</span><br><span class="line">        def dfs(head):</span><br><span class="line">            if not head:</span><br><span class="line">                return None</span><br><span class="line">            if head in visited:</span><br><span class="line">                return visited[head]</span><br><span class="line">            copy&#x3D;Node(head.val,None,None)</span><br><span class="line">            visited[head]&#x3D;copy</span><br><span class="line">            copy.next&#x3D;dfs(head.next)</span><br><span class="line">            copy.random&#x3D;dfs(head.random)</span><br><span class="line">            return copy</span><br><span class="line">        visited&#x3D;&#123;&#125;</span><br><span class="line">        return dfs(head)</span><br></pre></td></tr></table></figure>

<p>题解三（bfs）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line"># Definition for a Node.</span><br><span class="line">class Node:</span><br><span class="line">    def __init__(self, x: int, next: &#39;Node&#39; &#x3D; None, random: &#39;Node&#39; &#x3D; None):</span><br><span class="line">        self.val &#x3D; int(x)</span><br><span class="line">        self.next &#x3D; next</span><br><span class="line">        self.random &#x3D; random</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import collections</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def copyRandomList(self, head: &#39;Node&#39;) -&gt; &#39;Node&#39;:</span><br><span class="line">        visited&#x3D;&#123;&#125;</span><br><span class="line">        def bfs(head):</span><br><span class="line">            if not head:</span><br><span class="line">                return None</span><br><span class="line">            clone&#x3D;Node(head.val,None,None)</span><br><span class="line">            queue&#x3D;collections.deque()</span><br><span class="line">            queue.append(head)</span><br><span class="line">            visited[head]&#x3D;clone</span><br><span class="line">            while queue:</span><br><span class="line">                tmp&#x3D;queue.pop()</span><br><span class="line">                if tmp.next and tmp.next not in visited:</span><br><span class="line">                    visited[tmp.next]&#x3D;None(tmp.next.val,[],[])</span><br><span class="line">                    queue.append(tmp.next)</span><br><span class="line">                if tmp.random and tmp.random not in visited:</span><br><span class="line">                    visited[tmp.random] &#x3D; Node(tmp.random.val, [], [])</span><br><span class="line">                    queue.append(tmp.random)</span><br><span class="line">                visited[tmp].next&#x3D;visited.get(tmp.next)</span><br><span class="line">                visited[tmp].random&#x3D;visited.get(tmp.random)</span><br><span class="line">            return clone</span><br><span class="line">        return bfs(head)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="面试题52-两个链表的第一个公共节点"><a href="#面试题52-两个链表的第一个公共节点" class="headerlink" title="面试题52. 两个链表的第一个公共节点"></a>面试题52. 两个链表的第一个公共节点</h3><pre><code>链接：https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/

输入两个链表，找出它们的第一个公共节点。

如下面的两个链表：

在节点 c1 开始相交。

示例 1：

输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。

示例 2：

输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Reference of the node with value = 2
输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。

示例 3：

输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
解释：这两个链表不相交，因此返回 null。

注意：

如果两个链表没有交点，返回 null.
在返回结果后，两个链表仍须保持原有的结构。
可假定整个链表结构中没有循环。
程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</code></pre>
<p>题解一（hash）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode:</span><br><span class="line">        p&#x3D;headA</span><br><span class="line">        q&#x3D;headB</span><br><span class="line">        hash&#x3D;&#123;&#125;</span><br><span class="line">        while headA:</span><br><span class="line">            if headA not in hash:</span><br><span class="line">                hash[headA]&#x3D;1</span><br><span class="line">                headA&#x3D;headA.next</span><br><span class="line">        while headB:</span><br><span class="line">            if headB in hash:</span><br><span class="line">                return headB</span><br><span class="line">            else:</span><br><span class="line">                headB&#x3D;headB.next</span><br><span class="line">        return None</span><br></pre></td></tr></table></figure>

<p>题解二（双指针）：</p>
<p>时间复杂度：O(M+N)<br>空间复杂度：O(1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode:</span><br><span class="line">        node1, node2 &#x3D; headA, headB</span><br><span class="line">        </span><br><span class="line">        while node1 !&#x3D; node2:</span><br><span class="line">            node1 &#x3D; node1.next if node1 else headB</span><br><span class="line">            node2 &#x3D; node2.next if node2 else headA</span><br><span class="line"></span><br><span class="line">        return node1</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Lilly</p>
  <div class="site-description" itemprop="description">Up in the wind!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">128</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lilly</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
