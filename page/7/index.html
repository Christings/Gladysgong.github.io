<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"gongyanli.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Up in the wind!">
<meta property="og:type" content="website">
<meta property="og:title" content="茉莉Python">
<meta property="og:url" content="http://gongyanli.com/page/7/index.html">
<meta property="og:site_name" content="茉莉Python">
<meta property="og:description" content="Up in the wind!">
<meta property="og:locale">
<meta property="article:author" content="Lilly">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://gongyanli.com/page/7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>茉莉Python</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">茉莉Python</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">voidqueens@hotmail.com</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/LeetCode-8-%E4%B8%AD%E4%BD%8D%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/LeetCode-8-%E4%B8%AD%E4%BD%8D%E6%95%B0/" class="post-title-link" itemprop="url">LeetCode-8-中位数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-02 15:28:41" itemprop="dateCreated datePublished" datetime="2020-02-02T15:28:41+08:00">2020-02-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-18 22:37:05" itemprop="dateModified" datetime="2020-08-18T22:37:05+08:00">2020-08-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="八、中位数"><a href="#八、中位数" class="headerlink" title="八、中位数"></a>八、中位数</h2><p>首先假设我们的变量都是 int 值，二分查找中我们需要根据 start 和 end 求中点，正常情况下加起来除以 2 即可。</p>
<pre><code>int mid = (start + end) / 2</code></pre>
<p>但这样有一个缺点，我们知道int的最大值是 Integer.MAX_VALUE ，也就是2147483647（2^31-1）。那么有一个问题，如果 start = 2147483645，end = 2147483645，虽然 start 和 end都没有超出最大值，但是如果利用上边的公式，加起来的话就会造成溢出，从而导致mid计算错误。</p>
<p>解决的一个方案就是利用数学上的技巧，我们可以加一个 start 再减一个 start 将公式变形：</p>
<pre><code>(start + end) / 2 = (start + end + start - start) / 2 = start + (end - start) / 2</code></pre>
<p>然后当时和同学看到jdk源码中，求mid的方法如下，通过移位实现了除以2：</p>
<pre><code>int mid = (start + end) &gt;&gt;&gt; 1</code></pre>
<p>补码：</p>
<p>其实问题的关键就是这里了&gt;&gt;&gt; ，我们知道还有一种右移是&gt;&gt;。区别在于&gt;&gt;为有符号右移，右移以后最高位保持原来的最高位。而&gt;&gt;&gt;这个右移的话最高位补 0。</p>
<p>所以这里其实利用到了整数的补码形式，最高位其实是符号位，所以当 start + end 溢出的时候，其实本质上只是符号位收到了进位，而&gt;&gt;&gt;这个右移不仅可以把符号位右移，同时最高位只是补零，不会对数字的大小造成影响。</p>
<p>但&gt;&gt;有符号右移就会出现问题了，事实上 JDK6 之前都用的&gt;&gt;，这个 BUG 在 java 里竟然隐藏了十年之久。</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/median2.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/median2.png"><br><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/median3.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/median3.png"><br><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/median4.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/median4.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/LeetCode-6-%E8%B4%AA%E5%BF%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/LeetCode-6-%E8%B4%AA%E5%BF%83/" class="post-title-link" itemprop="url">LeetCode-6-贪心</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-31 12:09:27" itemprop="dateCreated datePublished" datetime="2020-01-31T12:09:27+08:00">2020-01-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-26 19:54:18" itemprop="dateModified" datetime="2020-08-26T19:54:18+08:00">2020-08-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="六、贪心"><a href="#六、贪心" class="headerlink" title="六、贪心"></a>六、贪心</h2><p>贪心和动态规划一样，考验的是对问题分析的能力，贪心算法解题的关键在于如何找到每次的局部最优解，动态规划则是如何找到状态转移方程。</p>
<p>什么是贪心算法呢？贪心算法可以认为是动态规划算法的一个特例，相比动态规划，使用贪心算法需要满足更多的条件（贪心选择性质），但是效率比动态规划要高。</p>
<p>比如说一个算法问题使用暴力解法需要指数级时间，如果能使用动态规划消除重叠子问题，就可以降到多项式级别的时间，如果满足贪心选择性质，那么可以进一步降低时间复杂度，达到线性级别的。</p>
<p>什么是贪心选择性质呢，简单说就是：每一步都做出一个局部最优的选择，最终的结果就是全局最优。注意哦，这是一种特殊性质，其实只有一小部分问题拥有这个性质。</p>
<p>问题：Interval Scheduling（区间调度问题）。给你很多形如[start,end]的闭区间，请你设计一个算法，算出这些区间中最多有几个互不相交的区间。</p>
<p>举个例子，intvs=[[1,3],[2,4],[3,6]]，这些区间最多有两个区间互不相交，即[[1,3],[3,6]]，你的算法应该返回 2。注意边界相同并不算相交。比如你今天有好几个活动，每个活动都可以用区间[start,end]表示开始和结束的时间，请问你今天最多能参加几个活动呢？</p>
<p>思路：</p>
<pre><code>1、从区间集合 intvs 中选择一个区间 x，这个 x 是在当前所有区间中结束最早的（end 最小）。
2、把所有与 x 区间相交的区间从区间集合 intvs 中删除。
3、重复步骤 1 和 2，直到 intvs 为空为止。之前选出的那些 x 就是最大不相交子集。</code></pre>
<p>实现：按每个区间的end数值升序排序</p>
<pre><code>步骤 1：由于我们预先按照end排了序，所以选择 x 是很容易的。关键在于，如何去除与 x 相交的区间，选择下一轮循环的 x 呢？

由于我们事先排了序，不难发现所有与 x 相交的区间必然会与 x 的end相交；如果一个区间不想与 x 的end相交，它的start必须要大于（或等于）x 的end</code></pre>
<pre><code>def intervalSchedule(intvs):
    if not intvs:
        return 0
    intvs.sort(key=lambda x:x[1]) # 升序排序
    count=1 # 至少应该有1个区间不相交
    x_end=intvs[0][1] # 排序后，第一个区间就是x
    for interval in intvs:
        start=interval[0]
        if start &gt;= x_end:
            count+=1
            x_end=interval[1] # 更新x
    return count</code></pre>
<h3 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45.跳跃游戏 II"></a>45.跳跃游戏 II</h3><pre><code>链接：https://leetcode-cn.com/problems/jump-game-ii/

给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

你的目标是使用最少的跳跃次数到达数组的最后一个位置。

示例:

输入: [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
说明:

假设你总是可以到达数组的最后一个位置。</code></pre>
<p>参考：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&amp;mid=2247486128&amp;idx=2&amp;sn=bcec6b9eb7374169d823963bb7ca8415&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&amp;mid=2247486128&amp;idx=2&amp;sn=bcec6b9eb7374169d823963bb7ca8415&amp;scene=21#wechat_redirect</a></p>
<p>问题是：保证你一定可以跳到最后一格，请问你最少要跳多少次，才能跳过去？</p>
<p>题解一|从右向左搜索：</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/greepy2.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/greepy2.png"></p>
<p>时间复杂度为 O(n^2)，空间复杂度为 O(1)</p>
<pre><code>class Solution:
    def jump(self, nums: List[int]) -&gt; int:
        right=len(nums)-1
        sum=0
        while right&gt;0:
            cur=right-1
            for i in range(right-2,-1,-1):
                if (i+nums[i]) &gt;= right:
                    cur=i
            right=cur
            sum+=1
        return sum</code></pre>
<p>题解二|自顶向下的动态规划：</p>
<pre><code>vector&lt;int&gt; memo;
// 主函数
int jump(vector&lt;int&gt;&amp; nums) &#123;
    int n = nums.size();
    // 备忘录都初始化为 n，相当于 INT_MAX
    // 因为从 0 调到 n - 1 最多 n - 1 步
    memo = vector&lt;int&gt;(n, n);
    return dp(nums, 0);
&#125;

int dp(vector&lt;int&gt;&amp; nums, int p) &#123;
    int n = nums.size();
    // base case
    if (p &gt;= n - 1) &#123;
        return 0;
    &#125;
    // 子问题已经计算过
    if (memo[p] != n) &#123;
        return memo[p];
    &#125;
    int steps = nums[p];
    // 你可以选择跳 1 步，2 步...
    for (int i = 1; i &lt;= steps; i++) &#123;
        // 穷举每一个选择
        // 计算每一个子问题的结果
        int subProblem = dp(nums, p + i);
        // 取其中最小的作为最终结果
        memo[p] = min(memo[p], subProblem + 1);
    &#125;
    return memo[p];
&#125;</code></pre>
<p>题解三|贪心:</p>
<p>贪心选择性质，我们不需要「递归地」计算出所有选择的具体结果然后比较求最值，而只需要做出那个最有「潜力」，看起来最优的选择即可。</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/greepy1.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/greepy1.png"></p>
<p>时间复杂度是 O(n)，空间复杂度是 O(1)。</p>
<pre><code>class Solution:
    def jump(self, nums: List[int]) -&gt; int:
        if len(nums)&lt;2:
            return 0
        sum,end,maxDistance=0,0,0
        # end代表能跳到的最远距离，maxDistance代表下一步能跳到的最远距离。
        for i in range(len(nums)-1):
            maxDistance=max(maxDistance,i+nums[i])
            if i==end:
                end=maxDistance
                sum+=1
        return sum</code></pre>
<h3 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55.跳跃游戏"></a>55.跳跃游戏</h3><pre><code>链接：https://leetcode-cn.com/problems/jump-game/

给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个位置。

示例 1:

输入: [2,3,1,1,4]
输出: true
解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。
示例 2:

输入: [3,2,1,0,4]
输出: false
解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</code></pre>
<p>题解一：</p>
<pre><code>class Solution:
    def canJump(self, nums: List[int]) -&gt; bool:
        right=len(nums)-1
        for i in range(len(nums)-2,-1,-1):
            if (i+nums[i]) &gt;= right:
                right=i
        if right==0:
            return True
        return False</code></pre>
<p>题解二|贪心：</p>
<p>思考：<br>    通过题目中的跳跃规则，最多能跳多远？如果能够越过最后一格，返回 true，否则返回 false。</p>
<pre><code>class Solution:
    def canJump(self, nums: List[int]) -&gt; bool:
        n=len(nums)
        maxDistance=0
        for i in range(n-1):
            maxDistance=max(maxDistance,i+nums[i])
            if maxDistance &lt;= i:
                return False
        return maxDistance &gt;= n-1</code></pre>
<pre><code>class Solution:
    def canJump(self, nums: List[int]) -&gt; bool:
        if len(nums)&lt;2:
            return True
        end,maxDistance=0,0
        # end代表能跳到的最远距离，maxDistance代表下一步能跳到的最远距离。
        for i in range(len(nums)-1): # for i in range(len(nums)):
            maxDistance=max(maxDistance,i+nums[i])
            if i==end:
                end=maxDistance
            if end &gt;= len(nums)-1:
                return True
        return False</code></pre>
<h3 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135.分发糖果"></a>135.分发糖果</h3><pre><code>链接：https://leetcode-cn.com/problems/candy/

老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。

你需要按照以下要求，帮助老师给这些孩子分发糖果：

每个孩子至少分配到 1 个糖果。
相邻的孩子中，评分高的孩子必须获得更多的糖果。
那么这样下来，老师至少需要准备多少颗糖果呢？

示例 1:

输入: [1,0,2]
输出: 5
解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。
示例 2:

输入: [1,2,2]
输出: 4
解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。
     第三个孩子只得到 1 颗糖果，这已满足上述两个条件。</code></pre>
<p>题解一：<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/candy/solution/candy-cong-zuo-zhi-you-cong-you-zhi-zuo-qu-zui-da-/">https://leetcode-cn.com/problems/candy/solution/candy-cong-zuo-zhi-you-cong-you-zhi-zuo-qu-zui-da-/</a></p>
<pre><code>class Solution:
    def candy(self, ratings: List[int]) -&gt; int:
        left=[1 for _ in range(len(ratings))]
        right=left[:]
        for i in range(1,len(ratings)):
            if ratings[i]&gt;ratings[i-1]:
                left[i]=left[i-1]+1
        count=left[-1] # 从右向左遍历时，最后一个元素没有比较大小，所以此处计算count。
        for i in range(len(ratings)-2,-1,-1):
            if ratings[i]&gt;ratings[i+1]:
                right[i]=right[i+1]+1
            count+=max(left[i],right[i])
        return count</code></pre>
<p>题解二：<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/candy/solution/fen-fa-tang-guo-by-powcai/">https://leetcode-cn.com/problems/candy/solution/fen-fa-tang-guo-by-powcai/</a></p>
<h3 id="316-去除重复字母"><a href="#316-去除重复字母" class="headerlink" title="316.去除重复字母"></a>316.去除重复字母</h3><pre><code>链接：https://leetcode-cn.com/problems/remove-duplicate-letters/

给定一个仅包含小写字母的字符串，去除字符串中重复的字母，使得每个字母只出现一次。需保证返回结果的字典序最小（要求不能打乱其他字符的相对位置）。

示例 1:

输入: &quot;bcabc&quot;
输出: &quot;abc&quot;
示例 2:

输入: &quot;cbacdcbc&quot;
输出: &quot;acdb&quot;</code></pre>
<p>名词解释：</p>
<pre><code>字典序：对于字符而言，按 ascii 码值进行比较，小的排在前，大的排在后。对于字符串，从第 0 位字符开始比较，ascii 码数值小的排在前面，如果相同，就延后一位比较 ascii 码值大小。

子序列：子序列不同于子串，子串要求它们在原串中连续，而子序列则不要求连续。例如acd是abcd的子序列，但不是子串。</code></pre>
<p>?题解一（递归）：</p>
<pre><code>class Solution:
    def removeDuplicateLetters(self, s: str) -&gt; str:
        for i in sorted(set(s)):
            tmp=s[s.index(i):]
            if len(set(tmp)) == len(set(s)):
                return i+self.removeDuplicateLetters(tmp.replace(i,&#39;&#39;))
        return &#39;&#39;</code></pre>
<p>?题解二（迭代）：</p>
<pre><code>class Solution:
    def removeDuplicateLetters(self, s: str) -&gt; str:
        res = &quot;&quot;
        while s:
            # 从右往左找，找到最小位置的索引号
            loc = min(map(s.rindex, s))
            # 找该索引前面最小的字母
            a = min(s[:loc + 1])
            res += a
            s = s[s.index(a):].replace(a, &quot;&quot;)
        return res</code></pre>
<p>题解三(栈):<br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&amp;mid=2247486367&amp;idx=2&amp;sn=b25c0701241325f644acda12599ec06a&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&amp;mid=2247486367&amp;idx=2&amp;sn=b25c0701241325f644acda12599ec06a&amp;scene=21#wechat_redirect</a></p>
<pre><code>class Solution:
    def removeDuplicateLetters(self, s: str) -&gt; str:
        from collections import Counter
        count=Counter(s)
        stack=[]
        existed=set()
        for i in s:
            if i not in existed:
                while stack and stack[-1]&gt;i and count[stack[-1]]&gt;0:
                    existed.remove(stack.pop())
                stack.append(i)
                existed.add(i)
            count[i]-=1
        return &#39;&#39;.join(stack)</code></pre>
<h3 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435.无重叠区间"></a>435.无重叠区间</h3><pre><code>链接:https://leetcode-cn.com/problems/non-overlapping-intervals/

给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。

注意:

可以认为区间的终点总是大于它的起点。
区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。
示例 1:

输入: [ [1,2], [2,3], [3,4], [1,3] ]

输出: 1

解释: 移除 [1,3] 后，剩下的区间没有重叠。
示例 2:

输入: [ [1,2], [1,2], [1,2] ]

输出: 2

解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。
示例 3:

输入: [ [1,2], [2,3] ]

输出: 0

解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</code></pre>
<p>已经会求最多有几个区间不会重叠了，那么剩下的不就是至少需要去除的区间吗？</p>
<pre><code>def eraseOverlapIntervals(intervals) &#123;
    n=len(intervals)
    return n - intervalSchedule(intervals);
&#125;</code></pre>
<p>题解一（贪心）:</p>
<pre><code>先计算能组成不重叠最多区间个数： 
（1）按区间结尾排序
（2）每次选择结尾最小，且与前一个区间不重叠</code></pre>
<pre><code>class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -&gt; int:
        if not intervals:
            return 0
        intervals.sort(key=lambda x:x[1])

        curr=0
        count=1
        for i in range(1,len(intervals)):
            if intervals[i][0]&gt;=intervals[curr][1]:
                curr=i
                count+=1
        return len(intervals)-count</code></pre>
<h3 id="452-用最少数量的箭引爆气球"><a href="#452-用最少数量的箭引爆气球" class="headerlink" title="452. 用最少数量的箭引爆气球"></a>452. 用最少数量的箭引爆气球</h3><pre><code>链接：https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/

在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以y坐标并不重要，因此只要知道开始和结束的x坐标就足够了。开始坐标总是小于结束坐标。平面内最多存在104个气球。

一支弓箭可以沿着x轴从不同点完全垂直地射出。在坐标x处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。

Example:

输入:
[[10,16], [2,8], [1,6], [7,12]]

输出:
2

解释:
对于该样例，我们可以在x = 6（射爆[2,8],[1,6]两个气球）和 x = 11（射爆另外两个气球）。</code></pre>
<p>思考：</p>
<p>只是有一点不一样，在intervalSchedule算法中，如果两个区间的边界触碰，不算重叠；而按照这道题目的描述，箭头如果碰到气球的边界气球也会爆炸，所以说相当于区间的边界触碰也算重叠。</p>
<pre><code>class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -&gt; int:
        if not points:
            return 0
        points.sort(key=lambda x:x[1])
        n=len(points)
        count=1
        x_end=points[0][1]
        for point in points:
            start=point[0]
            if start &gt; x_end:
                count+=1
                x_end=point[1]
        return count</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/LeetCode-9-%E5%9B%9E%E6%BA%AF%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/LeetCode-9-%E5%9B%9E%E6%BA%AF%E6%B3%95/" class="post-title-link" itemprop="url">LeetCode-9-回溯法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-21 17:20:06" itemprop="dateCreated datePublished" datetime="2020-01-21T17:20:06+08:00">2020-01-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-13 14:46:13" itemprop="dateModified" datetime="2020-11-13T14:46:13+08:00">2020-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>参考文章：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaomangxie/p/10208441.html">https://www.cnblogs.com/xiaomangxie/p/10208441.html</a><br>参考文章：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-xiang-jie-by-labuladong-2/">https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-xiang-jie-by-labuladong-2/</a></p>
<h2 id="九、回溯法"><a href="#九、回溯法" class="headerlink" title="九、回溯法"></a>九、回溯法</h2><p>回溯法（back tracking）（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</p>
<p>解决一个回溯问题，实际上就是一个决策树的遍历过程。你只需要思考 3 个问题：</p>
<pre><code>1、路径：也就是已经做出的选择。

2、选择列表：也就是你当前可以做的选择。

3、结束条件：也就是到达决策树底层，无法再做选择的条件。</code></pre>
<p>回溯算法的框架: 其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」。</p>
<pre><code>result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择</code></pre>
<pre><code>「路径」，记录你已经做过的选择；
「选择列表」，表示你当前可以做出的选择；
「结束条件」就是遍历到树的底层，在这里就是选择列表为空的时候。</code></pre>
<pre><code>for 选择 in 选择列表:
    # 做选择
    将该选择从选择列表移除
    路径.add(选择)
    backtrack(路径, 选择列表)
    # 撤销选择
    路径.remove(选择)
    将该选择再加入选择列表</code></pre>
<h3 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a>17. 电话号码的字母组合</h3><pre><code>链接：https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/

给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

示例:

输入：&quot;23&quot;
输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].
说明:
尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</code></pre>
<p>题解一|暴力：</p>
<pre><code>class Solution:
    def letterCombinations(self, digits: str) -&gt; List[str]:
        key_all=&#123;
            &#39;2&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;],
            &#39;3&#39;: [&#39;d&#39;, &#39;e&#39;, &#39;f&#39;],
            &#39;4&#39;: [&#39;g&#39;, &#39;h&#39;, &#39;i&#39;],
            &#39;5&#39;: [&#39;j&#39;, &#39;k&#39;, &#39;l&#39;],
            &#39;6&#39;: [&#39;m&#39;, &#39;n&#39;, &#39;o&#39;],
            &#39;7&#39;: [&#39;p&#39;, &#39;q&#39;, &#39;r&#39;, &#39;s&#39;],
            &#39;8&#39;: [&#39;t&#39;, &#39;u&#39;, &#39;v&#39;],
            &#39;9&#39;: [&#39;w&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;]
        &#125;
        if digits==&#39;&#39;:
            return &#39;&#39;
        ans=[&#39;&#39;]
        for num in digits:
            ans=[pre+suf for pre in ans for suf in key_all[num]]
        return ans</code></pre>
<pre><code>class Solution:
    def letterCombinations(self, digits):
        key_all=&#123;
            &#39;2&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;],
            &#39;3&#39;: [&#39;d&#39;, &#39;e&#39;, &#39;f&#39;],
            &#39;4&#39;: [&#39;g&#39;, &#39;h&#39;, &#39;i&#39;],
            &#39;5&#39;: [&#39;j&#39;, &#39;k&#39;, &#39;l&#39;],
            &#39;6&#39;: [&#39;m&#39;, &#39;n&#39;, &#39;o&#39;],
            &#39;7&#39;: [&#39;p&#39;, &#39;q&#39;, &#39;r&#39;, &#39;s&#39;],
            &#39;8&#39;: [&#39;t&#39;, &#39;u&#39;, &#39;v&#39;],
            &#39;9&#39;: [&#39;w&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;]
        &#125;
        if digits==&#39;&#39;:
            return &#39;&#39;
        ans=[&#39;&#39;]
        for num in digits:
            tmp=[]
            for pre in ans:
                for suf in key_all[num]:
                    tmp.append(pre+suf)
            ans=tmp[:]
        return ans</code></pre>
<p>题解二|回溯：</p>
<pre><code>class Solution:
    def letterCombinations(self, digits: str) -&gt; List[str]:
        if not digits:
            return []
        res=[]
        hash=&#123;
            1:&#39;&#39;,
            2:&#39;abc&#39;,
            3:&#39;def&#39;,
            4:&#39;ghi&#39;,
            5:&#39;jkl&#39;,
            6:&#39;mno&#39;,
            7:&#39;pqrs&#39;,
            8:&#39;tuv&#39;,
            9:&#39;wxyz&#39;
        &#125;

        def traceback(digits,index,path):
            if index == len(digits):
                res.append(&#39;&#39;.join(path))
                return

            digit=int(digits[index])
            for i in hash.get(digit,[]):
                path.append(i)
                traceback(digits,index+1,path)
                path.pop()
        traceback(digits,0,[])
        return res</code></pre>
<pre><code>class Solution:
    def letterCombinations(self, digits: str) -&gt; List[str]:
        if not digits:
            return []
        res=[]
        hash=&#123;
            &#39;1&#39;:&#39;&#39;,
            &#39;2&#39;:&#39;abc&#39;,
            &#39;3&#39;:&#39;def&#39;,
            &#39;4&#39;:&#39;ghi&#39;,
            &#39;5&#39;:&#39;jkl&#39;,
            &#39;6&#39;:&#39;mno&#39;,
            &#39;7&#39;:&#39;pqrs&#39;,
            &#39;8&#39;:&#39;tuv&#39;,
            &#39;9&#39;:&#39;wxyz&#39;
        &#125;
        def traceback(digits,first,path):
            if first==len(digits):
                res.append(&#39;&#39;.join(path))
                return
            # digit=int(digits[first])
            digit=digits[first]
            for i in hash.get(digit,[]):
                path.append(i)
                traceback(digits,first+1,path)
                path.pop()
        traceback(digits,0,[])
        return res</code></pre>
<h3 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a>22. 括号生成</h3><pre><code>链接：https://leetcode-cn.com/problems/generate-parentheses/

数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且有效的 括号组合。

示例：

输入：n = 3
输出：[
       &quot;((()))&quot;,
       &quot;(()())&quot;,
       &quot;(())()&quot;,
       &quot;()(())&quot;,
       &quot;()()()&quot;
     ]</code></pre>
<p>题解一|暴力：</p>
<pre><code>class Solution:
    def generateParenthesis(self, n: int) -&gt; List[str]:
        def generate(A):
            if len(A) == 2*n:
                if valid(A):
                    ans.append(&quot;&quot;.join(A))
            else:
                A.append(&#39;(&#39;)
                generate(A)
                A.pop()
                A.append(&#39;)&#39;)
                generate(A)
                A.pop()

        def valid(A):
            bal = 0
            for c in A:
                if c == &#39;(&#39;: bal += 1
                else: bal -= 1
                if bal &lt; 0: return False
            return bal == 0

        ans = []
        generate([])
        return ans</code></pre>
<p>题解二|回溯：</p>
<p>可以只在序列仍然保持有效时才添加 ‘(‘ or ‘)’，而不是像 方法一 那样每次添加。</p>
<p>我们可以通过跟踪到目前为止放置的左括号和右括号的数目来做到这一点，</p>
<p>如果左括号数量不大于 n，我们可以放一个左括号。如果右括号数量小于左括号的数量，我们可以放一个右括号。</p>
<pre><code>class Solution:
    def generateParenthesis(self, n: int) -&gt; List[str]:

        def backtrace(S,left,right):
            if len(S) == 2*n:
                res.append(&#39;&#39;.join(S))
                return

            if left &lt; n:
                S.append(&#39;(&#39;)
                backtrace(S,left+1,right)
                S.pop()
            if right &lt; left:
                S.append(&#39;)&#39;)
                backtrace(S,left,right+1)
                S.pop()

        res = []
        backtrace([],0,0)
        return res</code></pre>
<pre><code>class Solution:
    def generateParenthesis(self, n: int) -&gt; List[str]:

        def backtrace(S,index):
            if len(S) == 2*n:
                if index == 0:
                    res.append(&#39;&#39;.join(S))
                return

            if index &lt; n:
                S.append(&#39;(&#39;)
                backtrace(S,index+1)
                S.pop()
            if index &gt; 0:
                S.append(&#39;)&#39;)
                backtrace(S,index-1)
                S.pop()

        res = []
        backtrace([],0)
        return res</code></pre>
<p>题解三|递归：</p>
<pre><code>class Solution:
    def generateParenthesis(self, n: int) -&gt; List[str]:
        res=[]
        def helper(left,right,n,s):
            if left==n and right==n:
                res.append(s)
                return
            if left &lt; n:
                helper(left+1,right,n,s+&#39;(&#39;)
            if left &gt; right:
            # if left &gt; right and right &lt; n:
                helper(left,right+1,n,s+&#39;)&#39;)

        helper(0,0,n,&#39;&#39;)
        return res</code></pre>
<h3 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37. 解数独"></a>37. 解数独</h3><pre><code>链接：https://leetcode-cn.com/problems/sudoku-solver/

编写一个程序，通过已填充的空格来解决数独问题。

一个数独的解法需遵循如下规则：

数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。
空白格用 &#39;.&#39; 表示。

一个数独。

答案被标成红色。

Note:

给定的数独序列只包含数字 1-9 和字符 &#39;.&#39; 。
你可以假设给定的数独只有唯一解。
给定数独永远是 9x9 形式的。</code></pre>
<p>题解一|回溯：</p>
<pre><code>class Solution:
    def solveSudoku(self, board: List[List[str]]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify board in-place instead.
        &quot;&quot;&quot;
        def backtrace(board,i,j):
            m,n=9,9
            if j==n: # 走到9越界，进入下一行
                return backtrace(board,i+1,0)
            if i==m: # 走到最后一行，找到一个可行解
                return True
            if board[i][j] != &#39;.&#39;: # 当前是预设数字，直接跳到下一个
                return backtrace(board,i,j+1)
            chars=[str(i) for i in range(1,10)]
            for char in chars:
                if not isValid(board,i,j,char): # 遇到不合法的数字，跳过
                    continue

                board[i][j]=char # 做选择
                if backtrace(board,i,j+1): # 如果找到一个可行解，立即结束
                    return True
                board[i][j]=&#39;.&#39; # 撤销选择
            return False

        def isValid(board,r,c,char):
            for i in range(9):
                # 判断行是否存在重复
                if board[r][i] == char:
                    return False
                # 判断列是否存在重复
                if board[i][c] == char:
                    return False
                # 判断 3 * 3 方框是否存在重复
                if board[(r//3)*3+i//3][(c//3)*3+i%3] == char:
                    return False
            return True
        backtrace(board,0,0)</code></pre>
<h3 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a>39. 组合总和</h3><pre><code>链接：https://leetcode-cn.com/problems/combination-sum/

给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的数字可以无限制重复被选取。

说明：

所有数字（包括 target）都是正整数。
解集不能包含重复的组合。 
示例 1:

输入: candidates = [2,3,6,7], target = 7,
所求解集为:
[
  [7],
  [2,2,3]
]
示例 2:

输入: candidates = [2,3,5], target = 8,
所求解集为:
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]</code></pre>
<p>题解一|回溯:<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/">https://leetcode-cn.com/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/</a></p>
<pre><code>class Solution:
    def combinationSum(self, candidates: List[int], target: int) -&gt; List[List[int]]:
        size=len(candidates)
        if size==0:
            return []

        candidates.sort()
        res=[]
        path=[]
        return self.helper(candidates,0,size,target,res,path)
    def helper(self,candidates,begin,size,target,res,path):
        if target==0:
            res.append(path[:])
        for i in range(begin,size):
            residue=target-candidates[i]
            if residue &lt; 0:
                break
            path.append(candidates[i])
            self.helper(candidates,i,size,residue,res,path)
            path.pop()
        return res</code></pre>
<pre><code>class Solution:
    def combinationSum(self, candidates: List[int], target: int) -&gt; List[List[int]]:
        res=[]
        def backtrace(candidates,start,path,target):
            if target==0:
                # res.append(path[:])
                res.append(path+[])
                return

            for i in range(start,len(candidates)):
                tmp=target-candidates[i]
                if tmp &lt; 0:
                    continue
                path.append(candidates[i])
                backtrace(candidates,i,path,tmp) # 注意此处i的取值
                path.pop()

        backtrace(candidates,0,[],target)
        return res</code></pre>
<h3 id="40-组合总和-II"><a href="#40-组合总和-II" class="headerlink" title="40.组合总和 II"></a>40.组合总和 II</h3><pre><code>链接：https://leetcode-cn.com/problems/combination-sum-ii/

给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的每个数字在每个组合中只能使用一次。

说明：

所有数字（包括目标数）都是正整数。
解集不能包含重复的组合。 
示例 1:

输入: candidates = [10,1,2,7,6,1,5], target = 8,
所求解集为:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
示例 2:

输入: candidates = [2,5,2,1,2], target = 5,
所求解集为:
[
  [1,2,2],
  [5]
]</code></pre>
<p>这道题与上一问的区别在于：</p>
<p>第 39 题：candidates 中的数字可以无限制重复被选取。<br>第 40 题：candidates 中的每个数字在每个组合中只能使用一次。<br>编码的不同在于下一层递归的起始索引不一样。</p>
<p>第 39 题：还从候选数组的当前索引值开始。<br>第 40 题：从候选数组的当前索引值的下一位开始。<br>相同之处：解集不能包含重复的组合。</p>
<p>题解一|回溯:<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum-ii/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-3/">https://leetcode-cn.com/problems/combination-sum-ii/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-3/</a></p>
<pre><code>class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -&gt; List[List[int]]:
        size=len(candidates)
        if size==0:
            return []

        candidates.sort()
        res=[]
        path=[]
        return self.helper(candidates,0,size,target,res,path)
    def helper(self,candidates,begin,size,target,res,path):
        if target==0:
            res.append(path[:])
        for i in range(begin,size):
            residue=target-candidates[i]
            if residue &lt; 0:
                break

            if i &gt; begin and candidates[i-1] == candidates[i]:
                continue

            path.append(candidates[i])
            self.helper(candidates,i+1,size,residue,res,path)
            path.pop()
        return res</code></pre>
<p>去重：无论是求组合/子集/排列，只要原数组中含有重复元素，通用一个去重方法：</p>
<pre><code>1.先排序，使相同元素相邻；
2.在backtrack的for循环里：
    if(i&gt;start &amp;&amp; candidates[i]==candidates[i-1]) continue;</code></pre>
<pre><code>这个避免重复当思想是在是太重要了。
这个方法最重要的作用是，可以让同一层级，不出现相同的元素。即
                  1
                 / \
                2   2  这种情况不会发生 但是却允许了不同层级之间的重复即：
               /     \
              5       5
                例2
                  1
                 /
                2      这种情况确是允许的
               /
              2  

为何会有这种神奇的效果呢？
首先 i-1 == i 是用于判定当前元素是否和之前元素相同的语句。这个语句就能砍掉例1。
可是问题来了，如果把所有当前与之前一个元素相同的都砍掉，那么例二的情况也会消失。 
因为当第二个2出现的时候，他就和前一个2相同了。

那么如何保留例2呢？
那么就用i &gt; start 来避免这种情况，你发现例1中的两个2是处在同一个层级上的，
例2的两个2是处在不同层级上的。
在一个for循环中，所有被遍历到的数都是属于一个层级的。我们要让一个层级中，
必须出现且只出现一个2，那么就放过第一个出现重复的2，但不放过后面出现的2。
第一个出现的2的特点就是 i == start. 第二个出现的2 特点是i &gt; start.

再通俗点，就是有重复元素的话，比如测试用例中的第一个1和第二个1，都会有1,7组成8，这样就产生了重复的list。因为都是从当前数开始遍历，所以加这一层的意思就是过滤掉重复的数，但是第一个1依然能使用第二个1，而第二个1是失去了作用的。
</code></pre>
<pre><code>class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -&gt; List[List[int]]:
        if not candidates:
            return []
        candidates.sort()
        res=[]

        def backtrace(candidates,start,path,target):
            if target==0:
                return res.append(path[:])
            for i in range(start,len(candidates)):
                tmp=target-candidates[i]
                if tmp &lt; 0:
                    continue
                if i &gt; start and candidates[i] == candidates[i-1]:
                    continue
                path.append(candidates[i])
                backtrace(candidates,i+1,path,tmp) # 此处是i+1
                path.pop()

        backtrace(candidates,0,[],target)
        return res</code></pre>
<h3 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46.全排列"></a>46.全排列</h3><pre><code>链接：https://leetcode-cn.com/problems/permutations/

给定一个没有重复数字的序列，返回其所有可能的全排列。

示例:

输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]</code></pre>
<p>题解一|回溯:</p>
<pre><code>class Solution:
    def permute(self, nums: List[int]) -&gt; List[List[int]]:

        def backtrack(first=0):
            if first==lens:
                output.append(nums[:]) # 可以加上return
            for i in range(first,lens):
                nums[first],nums[i]=nums[i],nums[first]
                backtrack(first+1) # 注意：不能使用i+1，否则会出现[[1,2,3],[1,3,2],[2,1,3],[3,2,1]]
                nums[first],nums[i]=nums[i],nums[first]

        lens=len(nums)
        output=[]
        backtrack()
        return output</code></pre>
<pre><code>class Solution:
    def permute(self, nums):
        def backtrack(first=0):
            # if all integers are used up
            print(&#39;---------------first&#39;, first)
            if first == n:
                output.append(nums[:])
                print(&#39;output:&#39;,output)
            for i in range(first, n):
                # place i-th integer first
                # in the current permutation
                print(&#39;i,first:&#39;,i, first)
                print(nums[i], nums[first])
                nums[first], nums[i] = nums[i], nums[first]
                # use next integers to complete the permutations
                backtrack(first + 1)
                # backtrack
                nums[first], nums[i] = nums[i], nums[first]
                print(&#39;2:i,first:&#39;, i, first)
                print(&#39;2:&#39;, nums[i], nums[first])

        n = len(nums)
        output = []
        backtrack()
        return output

输出：
---------------first 0
i,first: 0 0
1 1
---------------first 1
i,first: 1 1
2 2
---------------first 2
i,first: 2 2
3 3
---------------first 3
output: [[1, 2, 3]]
2:i,first: 2 2
2: 3 3
2:i,first: 1 1
2: 2 2
i,first: 2 1
3 2
---------------first 2
i,first: 2 2
2 2
---------------first 3
output: [[1, 2, 3], [1, 3, 2]]
2:i,first: 2 2
2: 2 2
2:i,first: 2 1
2: 3 2
2:i,first: 0 0
2: 1 1
i,first: 1 0
2 1
---------------first 1
i,first: 1 1
1 1
---------------first 2
i,first: 2 2
3 3
---------------first 3
output: [[1, 2, 3], [1, 3, 2], [2, 1, 3]]
2:i,first: 2 2
2: 3 3
2:i,first: 1 1
2: 1 1
i,first: 2 1
3 1
---------------first 2
i,first: 2 2
1 1
---------------first 3
output: [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1]]
2:i,first: 2 2
2: 1 1
2:i,first: 2 1
2: 3 1
2:i,first: 1 0
2: 2 1
i,first: 2 0
3 1
---------------first 1
i,first: 1 1
2 2
---------------first 2
i,first: 2 2
1 1
---------------first 3
output: [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1]]
2:i,first: 2 2
2: 1 1
2:i,first: 1 1
2: 2 2
i,first: 2 1
1 2
---------------first 2
i,first: 2 2
2 2
---------------first 3
output: [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 2, 1], [3, 1, 2]]
2:i,first: 2 2
2: 2 2
2:i,first: 2 1
2: 1 2
2:i,first: 2 0
2: 3 1</code></pre>
<h3 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a>47. 全排列 II</h3><pre><code>链接：https://leetcode-cn.com/problems/permutations-ii/

给定一个可包含重复数字的序列，返回所有不重复的全排列。

示例:

输入: [1,1,2]
输出:
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]</code></pre>
<p>题解一|回溯：<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations-ii/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2/">https://leetcode-cn.com/problems/permutations-ii/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2/</a></p>
<pre><code>class Solution:
    def permuteUnie(self, nums: List[int]) -&gt; List[List[int]]:

        def backtrack(first=0):
            if first==lens:
                output.append(nums[:])
            for i in range(first,lens):
                if not duplicat(nums,first,i):
                    continue
                nums[first],nums[i]=nums[i],nums[first]
                backtrack(first+1) # 注意：不能使用i+1，否则会出现[[1,2,3],[1,3,2],[2,1,3],[3,2,1]]
                nums[first],nums[i]=nums[i],nums[first]

        def duplicat(nums,begin,end):
            i=begin
            while i&lt;end:
                if nums[i]==nums[end]:
                    return False
                i+=1
            return True

        lens=len(nums)
        output=[]
        backtrack()
        return output</code></pre>
<pre><code>class Solution:
    def permuteUnique(self, nums: List[int]) -&gt; List[List[int]]:

        def backtrack(first=0):
            if first==lens:
                output.append(nums[:])
            for i in range(first,lens):

                if nums[i] not in nums[first:i]:
                    nums[first],nums[i]=nums[i],nums[first]
                    backtrack(first+1)
                    nums[first],nums[i]=nums[i],nums[first]

        lens=len(nums)
        output=[]
        nums.sort()
        backtrack()
        return output</code></pre>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations-ii/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2/">https://leetcode-cn.com/problems/permutations-ii/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liwe-2/</a></p>
<pre><code>class Solution:
    def permuteUnique(self, nums: List[int]) -&gt; List[List[int]]:
        res=[]
        def backtrack(first,path,used):
            if first == len(nums):
                res.append(path[:])
                return
            for i in range(len(nums)):
                if not used[i]:
                    if i&gt;0 and nums[i] == nums[i-1] and not used[i-1]:
                        continue
                    used[i]=True
                    path.append(nums[i])
                    backtrack(first+1,path,used)
                    used[i]=False
                    path.pop()
        nums.sort()
        used=[False] * len(nums)
        backtrack(0,[],used)
        return res</code></pre>
<h3 id="51-N皇后"><a href="#51-N皇后" class="headerlink" title="51. N皇后"></a>51. N皇后</h3><pre><code>链接：https://leetcode-cn.com/problems/n-queens/

n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。

上图为 8 皇后问题的一种解法。

给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。

每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 &#39;Q&#39; 和 &#39;.&#39; 分别代表了皇后和空位。

示例:

输入: 4
输出: [
 [&quot;.Q..&quot;,  // 解法 1
  &quot;...Q&quot;,
  &quot;Q...&quot;,
  &quot;..Q.&quot;],

 [&quot;..Q.&quot;,  // 解法 2
  &quot;Q...&quot;,
  &quot;...Q&quot;,
  &quot;.Q..&quot;]
]
解释: 4 皇后问题存在两个不同的解法。</code></pre>
<p>题解一|回溯法:</p>
<p>问题是十九世纪著名的数学家高斯1850年提出：在8X8格的国际象棋上摆放八个皇后（棋子），使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上。</p>
<p>1、判断每次输入的皇后是否在同一行、同一列或者同一斜线上<br>2、核心算法</p>
<pre><code>class Solution:
    def solveNQueens(self, n: int) -&gt; List[List[str]]:
        board,ret=[[&#39;.&#39;]*n for _ in range(n)],[]
        self.dfs(board,n,0,ret)
        return ret
    def dfs(self,board,n,row,ret):
        if row==n:
            ret.append([&#39;&#39;.join(i) for i in board])
            return
        for i in range(n):
            if not self.isVaild(row,i,n,board):
                continue
            board[row][i]=&#39;Q&#39;
            self.dfs(board,n,row+1,ret)
            board[row][i]=&#39;.&#39;

    def isVaild(self,row,col,n,board):
        for i in range(1, row + 1):
            # 判断同一列上是否有Q
            if board[row - i][col] == &#39;Q&#39;:
                return False
            # 判断逆对角线是否有Q
            if col - i &gt;= 0 and board[row - i][col - i] == &#39;Q&#39;:
                return False
            # 判断正对角线是否有Q
            if col + i &lt; n and board[row - i][col + i] == &#39;Q&#39;:
                return False
        return True
</code></pre>
<h3 id="60-第k个排列"><a href="#60-第k个排列" class="headerlink" title="60. 第k个排列"></a>60. 第k个排列</h3><pre><code>链接：https://leetcode-cn.com/problems/permutation-sequence/

给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。

按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：

&quot;123&quot;
&quot;132&quot;
&quot;213&quot;
&quot;231&quot;
&quot;312&quot;
&quot;321&quot;
给定 n 和 k，返回第 k 个排列。

说明：

给定 n 的范围是 [1, 9]。
给定 k 的范围是[1,  n!]。
示例 1:

输入: n = 3, k = 3
输出: &quot;213&quot;
示例 2:

输入: n = 4, k = 9
输出: &quot;2314&quot;</code></pre>
<p>题解一|回溯|超时：</p>
<pre><code>class Solution:
    def getPermutation(self, n: int, k: int) -&gt; str:
        res=[]
        used=[False]*n # 使用used去重
        def backtrace(path,first):
            if len(path) == n:
                return res.append(path[:])

            for i in range(1,n+1):
                if used[i-1]: 
                    continue
                used[i-1]=True
                path.append(i)
                backtrace(path,i+1)
                used[i-1]=False
                path.pop()
        if not n or not k:
            return &#39;&#39;
        backtrace([],1)
        # print(res)
        tmp=[str(i) for i in res[k-1]]
        return &#39;&#39;.join(tmp)</code></pre>
<p>优化|超时：</p>
<pre><code>class Solution:
    def getPermutation(self, n: int, k: int) -&gt; str:
        res=[]
        used=[False]*n # 使用used去重
        def backtrace(path):
            if len(res) == k:
                return

            if len(path) == n:
                return res.append(path[:])

            for i in range(1,n+1):
                if used[i-1]: 
                    continue
                used[i-1]=True
                path.append(i)
                backtrace(path)
                used[i-1]=False
                path.pop()
        if not n or not k:
            return &#39;&#39;
        backtrace([])
        tmp=[str(i) for i in res[-1]]
        return &#39;&#39;.join(tmp)</code></pre>
<p>???</p>
<pre><code>class Solution:
    def getPermutation(self, n: int, k: int) -&gt; str:
        res=[]
        def backtrack(k,first):
            if first == n:
                return
            cnt=factorial[n-1-first]
            for i in range(1,n+1):
                if used[i]:
                    continue
                if cnt &lt; k:
                    k-=cnt
                    continue
                res.append(i)
                used[i]=True
                backtrack(k,first+1)

        used=[False] * (n+1) # 使用used去重
        factorial=[ 1 for _ in range(n+1)]
        for i in range(2,n+1):
            factorial[i]=factorial[i-1]*i
        backtrack(k,0)
        return &#39;&#39;.join([str(num) for num in res])
</code></pre>
<h3 id="77-组合"><a href="#77-组合" class="headerlink" title="77.组合"></a>77.组合</h3><pre><code>链接：https://leetcode-cn.com/problems/combinations/

给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。

示例:

输入: n = 4, k = 2
输出:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]</code></pre>
<p>题解一|回溯：</p>
<pre><code>class Solution:
    def combine(self, n: int, k: int) -&gt; List[List[int]]:
        if k == 0 or n==0:
            return []

        res=[]
        path=[]
        return self.helper(n,k,res,path,1)
    def helper(self,n,k,res,path,first=1):
        if len(path)==k:
            res.append(path[:])
        for i in range(first,n+1):
            path.append(i)

            self.helper(n,k,res,path,i+1) 
            # self.helper(n,k,res,path,first+1) 
            # [[1,2],[1,3],[1,4],[2,2],[2,3],[2,4],[3,2],[3,3],[3,4],[4,2],[4,3],[4,4]]
            path.pop()
        return res</code></pre>
<pre><code>class Solution:
    def combine(self, n: int, k: int) -&gt; List[List[int]]:
        res=[]
        def backtrace(path,first):
            if len(path) == k:
                return res.append(path[:])
            for i in range(first,n+1):
                path.append(i)
                backtrace(path,i+1)
                # backtrace(path,first+1)
                path.pop()
        if not n or not k:
            return []
        backtrace([],1)
        return res</code></pre>
<pre><code>class Solution:
    def combine(self, n: int, k: int) -&gt; List[List[int]]:
        res=[]
        def backtrace(path,first):
            if len(path) == k:
                return res.append(path[:])
            for i in range(first,n+1):
                path.append(i)
                backtrace(path,i+1) # 输出：[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
                # backtrace(path,i) # 输出：[[1,1],[1,2],[1,3],[1,4],[2,2],[2,3],[2,4],[3,3],[3,4],[4,4]]
                # backtrace(path,first+1) # 输出：[[1,2],[1,3],[1,4],[2,2],[2,3],[2,4],[3,2],[3,3],[3,4],[4,2],[4,3],[4,4]]
                # backtrace(path,first) # 输出：[[1,1],[1,2],[1,3],[1,4],[2,1],[2,2],[2,3],[2,4],[3,1],[3,2],[3,3],[3,4],[4,1],[4,2],[4,3],[4,4]]
                path.pop()
        if not n or not k:
            return []
        backtrace([],1)
        return res</code></pre>
<h3 id="78-子集"><a href="#78-子集" class="headerlink" title="78.子集"></a>78.子集</h3><pre><code>链接：https://leetcode-cn.com/problems/subsets/submissions/

给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

说明：解集不能包含重复的子集。

示例:

输入: nums = [1,2,3]
输出:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]</code></pre>
<p>题解一|库函数:</p>
<pre><code>class Solution:
    def subsets(self, nums: List[int]) -&gt; List[List[int]]:
        import itertools
        res=[]
        for i in range(len(nums)+1):
            for j in itertools.combinations(nums,i):
                res.append(j)
        return res</code></pre>
<p>题解二|迭代:</p>
<pre><code>class Solution:
    def subsets(self, nums: List[int]) -&gt; List[List[int]]:
        res=[[]]
        for i in nums:
            res+=[[i]+j for j in res]
            # print(res)
        return res
</code></pre>
<p>题解三|回溯:<br><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subsets/solution/hui-su-python-dai-ma-by-liweiwei1419/">https://leetcode-cn.com/problems/subsets/solution/hui-su-python-dai-ma-by-liweiwei1419/</a></p>
<pre><code>class Solution:
    def subsets(self, nums: List[int]) -&gt; List[List[int]]:
        length=len(nums)
        if length==0:
            return []

        res=[]
        path=[]
        return self.helper(nums,res,path,0)

    def helper(self,nums,res,path,first=1):
        res.append(path[:])
        for i in range(first,len(nums)):
            path.append(nums[i])
            self.helper(nums,res,path,i+1)
            path.pop()
        return res</code></pre>
<pre><code>class Solution:
    def subsets(self, nums: List[int]) -&gt; List[List[int]]:
        res=[]
        def backtrace(path,first):
            res.append(path[:])
            for i in range(first,len(nums)):
                path.append(nums[i])
                backtrace(path,i+1)
                path.pop()
        backtrace([],0)
        return res</code></pre>
<h3 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a>79. 单词搜索</h3><pre><code>链接：https://leetcode-cn.com/problems/word-search/

给定一个二维网格和一个单词，找出该单词是否存在于网格中。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

示例:

board =
[
  [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;],
  [&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;],
  [&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;]
]

给定 word = &quot;ABCCED&quot;, 返回 true
给定 word = &quot;SEE&quot;, 返回 true
给定 word = &quot;ABCB&quot;, 返回 false


提示：

board 和 word 中只包含大写和小写英文字母。
1 &lt;= board.length &lt;= 200
1 &lt;= board[i].length &lt;= 200
1 &lt;= word.length &lt;= 10^3</code></pre>
<p>题解一|DFS：</p>
<pre><code>class Solution:
    def exist(self, board: List[List[str]], word: str) -&gt; bool:
        def dfs(board,word,i,j,index):
            if i&lt;0 or i&gt;=m or j&lt;0 or j&gt;=n or board[i][j]!=word[index]:
                return False
            if index==len(word)-1:
                return True
            tmp=board[i][j]
            board[i][j]=&#39;.&#39;
            res=dfs(board,word,i+1,j,index+1) or dfs(board,word,i-1,j,index+1) or dfs(board,word,i,j+1,index+1) or dfs(board,word,i,j-1,index+1)
            board[i][j]=tmp
            return res

        m=len(board)
        n=len(board[0])
        for i in range(m):
            for j in range(n):
                if dfs(board,word,i,j,0):
                    return True
        return False</code></pre>
<h3 id="90-子集-II"><a href="#90-子集-II" class="headerlink" title="90. 子集 II"></a>90. 子集 II</h3><pre><code>链接：https://leetcode-cn.com/problems/subsets-ii/submissions/

给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

说明：解集不能包含重复的子集。

示例:

输入: [1,2,2]
输出:
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]</code></pre>
<p>题解一|回溯:</p>
<pre><code>class Solution:
    def subsetsWithDup(self, nums: List[int]) -&gt; List[List[int]]:
        length=len(nums)
        if length==0:
            return []

        nums.sort() # 一定需要先排序，否则结果中有重复的。
        res=[]
        path=[]
        return self.helper(nums,res,path,0)

    def helper(self,nums,res,path,first=1):
        res.append(path[:])
        for i in range(first,len(nums)):
            if i&gt;first and nums[i]==nums[i-1]:
                continue
            path.append(nums[i])
            self.helper(nums,res,path,i+1)
            path.pop()
        return res</code></pre>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subsets-ii/solution/hui-su-de-duo-chong-xie-fa-duo-ti-yu-jing-by-zhang/">https://leetcode-cn.com/problems/subsets-ii/solution/hui-su-de-duo-chong-xie-fa-duo-ti-yu-jing-by-zhang/</a></p>
<pre><code>class Solution:
    def subsetsWithDup(self, nums: List[int]) -&gt; List[List[int]]:
        res=[]
        nums.sort()
        def backtrace(path,first):
            res.append(path[:]) # ???没有return
            for i in range(first,len(nums)):
                if i&gt;first and nums[i]==nums[i-1]: # 滤重
                    continue
                path.append(nums[i])
                backtrace(path,i+1)
                path.pop()
        backtrace([],0)
        return res</code></pre>
<h3 id="93-复原IP地址"><a href="#93-复原IP地址" class="headerlink" title="93.复原IP地址"></a>93.复原IP地址</h3><pre><code>链接：https://leetcode-cn.com/problems/restore-ip-addresses/

给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。

示例:

输入: &quot;25525511135&quot;
输出: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;]</code></pre>
<p>注意：<br>    IP的格式,每位是在0~255之间,<br>    不能出现以0开头的两位以上数字,比如012,08…</p>
<p>题解一|暴力:</p>
<pre><code>class Solution:
    def restoreIpAddresses(self, s: str) -&gt; List[str]:
        n=len(s)
        res=[]

        def helper(tmp):
            if tmp==&#39;&#39; or (tmp[0]==&#39;0&#39; and len(tmp)&gt;1) or int(tmp)&gt;255:
            # if not tmp or (tmp[0]==&#39;0&#39; and len(tmp)&gt;1) or int(tmp)&gt;255:
                return False
            return True

        for i in range(3):
            for j in range(i+1,i+4):
                for k in range(j+1,j+4):
                    if i&lt;n and j&lt;n and k&lt;n:
                        tmp1=s[:i+1]
                        tmp2=s[i+1:j+1]
                        tmp3=s[j+1:k+1]
                        tmp4=s[k+1:]

                        if all(map(helper,[tmp1,tmp2,tmp3,tmp4])):
                            res.append(tmp1+&#39;.&#39;+tmp2+&#39;.&#39;+tmp3+&#39;.&#39;+tmp4)
        return res</code></pre>
<p>题解二|回溯:</p>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/restore-ip-addresses/solution/shou-hua-tu-jie-huan-yuan-dfs-hui-su-de-xi-jie-by-/">https://leetcode-cn.com/problems/restore-ip-addresses/solution/shou-hua-tu-jie-huan-yuan-dfs-hui-su-de-xi-jie-by-/</a></p>
<p>思路:</p>
<pre><code>做第一步时我们有几种 选择 以 &quot;25525511135&quot; 为例：

    选 &quot;2&quot; 作为第一个片段
    选 &quot;25&quot; 作为第一个片段
    选 &quot;255&quot; 作为第一个片段

有三种选择，做了选择后，又面临三种选择：再切出一种长度的片段作为第二个片段。
这会像树一样向下分支，我们用 DFS 去遍历所有选择，并且是回溯，为什么是回溯？
因为某一步的选择可能来到一个错误的状态，得不到正确的结果，不要往下做了，要撤销最后一个选择，回到选择前的状态，去试另一个选择。
大概像是：选择、探索、撤销选择的过程。好，我们现在了解了回溯的要点1——选择。</code></pre>
<p>回溯的要点2——约束:</p>
<pre><code>约束限制了我们的搜索分支，这道题的约束条件是：

    一个片段的长度是 1~3
    片段的值范围是 0~255
    不能是 &quot;0x&quot;、&quot;0xx&quot; 形式（这个是测试用例告诉我们的）

我们要用这些约束在DFS中充分地剪枝，规避掉一些选择，避免去搜索一些不会产生正确答案的分支。</code></pre>
<p>回溯的要点3——目标:</p>
<pre><code>我们的目标决定了我们 DFS 什么时候捕捉答案，什么时候砍掉死支，不继续走了返回出来。
我们目标是生成 4 个有效片段，并且要用光 IP 字符串的字符。
当遍历的节点满足该条件时，说明已经生成了一个有效组合，推入结果数组。然后回溯，继续探索。
生成了4个有效片段，但没用光所有字符，不是有效的组合，不继续往下递归，直接返回，提前回溯。</code></pre>
<p>定义dfs函数:</p>
<pre><code>dfs函数传什么，用什么代表不同节点的状态？
选择切出一个长度的片段后，剩余的子串继续递归，可以传子串，也可以传指向起始位置的指针，加上当前已经生成的片段数组，作为状态，传入 dfs 函数。
dfs 函数做的是「按一定规则，切割从指针 start 开始的子串」。</code></pre>
<pre><code>class Solution:
    def restoreIpAddresses(self, s: str) -&gt; List[str]:
        res=[]
        def helper(path,first):
            if len(path)==4 and first==len(s):
                res.append(&#39;.&#39;.join(path))
            if len(path)==4 and first &lt; len(s):
                return
            for i in range(1,4):
                if first+i-1 &gt;= len(s):
                    return
                if i &gt;= 2 and s[first]==&#39;0&#39;:
                    return
                tmp=s[first:first+i]                
                if i==3 and int(tmp)&gt;255:
                    return
                path.append(tmp)
                helper(path,first+i)
                path.pop()
        helper([],0)
        return res</code></pre>
<pre><code>class Solution:
    def restoreIpAddresses(self, s: str) -&gt; List[str]:
        res=[]
        def helper(path,first):
            if len(path)==4 and first==len(s):
                res.append(&#39;.&#39;.join(path))
            if len(path)==4 and first &lt; len(s):
                return
            for i in range(1,4):
                if first+i-1 &gt;= len(s):
                    return
                if i &gt;= 2 and s[first]==&#39;0&#39;:
                    return
                tmp=s[first:first+i]                
                if i==3 and int(tmp)&gt;255:
                    return
                helper(path+[tmp],first+i)
        helper([],0)
        return res</code></pre>
<pre><code>class Solution:
    def restoreIpAddresses(self, s: str) -&gt; List[str]:
        def __segment(s,left,right):
            size=right-left+1

            if size &gt; 1 and s[left]=&#39;0&#39;:
                return -1
            res=0
            for i in range(left,right+1):
                res=res*10 + ord(s[i])-ord(&#39;0&#39;)

            if res &gt; 255:
                return -1
            return res

        def backtrace(split,first,path):
            if first == len(s):
                if split == 4:
                    res.append(&#39;&#39;.join(path))
                return
            if len(s) - first</code></pre>
<h3 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216. 组合总和 III"></a>216. 组合总和 III</h3><pre><code>链接：https://leetcode-cn.com/problems/combination-sum-iii/

找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。

说明：

所有数字都是正整数。
解集不能包含重复的组合。 
示例 1:

输入: k = 3, n = 7
输出: [[1,2,4]]
示例 2:

输入: k = 3, n = 9
输出: [[1,2,6], [1,3,5], [2,3,4]]</code></pre>
<p>题解一|回溯：</p>
<pre><code>class Solution:
    def combinationSum3(self, k: int, n: int) -&gt; List[List[int]]:
        res=[]
        def backtrace(path,first,n):
            if len(path)==k and n==0:
                return res.append(path[:])
            for i in range(first,10):
                tmp=n-i
                if tmp &lt; 0:
                    continue
                path.append(i)
                backtrace(path,i+1,tmp)
                path.pop()
        if not k or not n:
            return []
        backtrace([],1,n)
        return res</code></pre>
<h3 id="357-计算各个位数不同的数字个数"><a href="#357-计算各个位数不同的数字个数" class="headerlink" title="357. 计算各个位数不同的数字个数"></a>357. 计算各个位数不同的数字个数</h3><pre><code>链接：https://leetcode-cn.com/problems/count-numbers-with-unique-digits/

给定一个非负整数 n，计算各位数字都不同的数字 x 的个数，其中 0 ≤ x &lt; 10n 。

示例:

输入: 2
输出: 91 
解释: 答案应为除去 11,22,33,44,55,66,77,88,99 外，在 [0,100) 区间内的所有数字。</code></pre>
<p>题解一|动态规划：</p>
<pre><code>class Solution:
    def countNumbersWithUniqueDigits(self, n: int) -&gt; int:
        if n==0:
            return 1
        dp1=[0]*(n+1)
        dp2=[0]*(n+1)
        dp1[1]=10
        dp2[1]=9
        for i in range(2,min(11,n+1)):
            dp2[i]=dp2[i-1]*(10-(i-1))
            dp1[i]=dp2[i]+dp1[i-1]
        if n&gt;=11:
            return dp[10]
        return dp1[n]</code></pre>
<p>题解二|数学：</p>
<p>这是一道数学题，很容易发现规律：</p>
<p>如果 n = 1，ans = 10；<br>如果 n = 2，考虑两位数都不相同，有 9 * 9 = 81 种情况（第一个数字不能以 0 开头，第二个数字可以有 0），再加上 n = 1 时的情况即可得到 ans = 91；<br>如果 n = 3，考虑三位数都不相同，有 9 * 9 * 8 = 648 种情况（第一个数字不能以 0 开头），再加上 n = 2 时的情况即可得到 ans = 739；<br>以此类推即可。</p>
<p>因此，我们从 i = 1 开始，每次累加结果，一直计算到 i = n 即可得到答案。注意：当 n &gt; 10 时，与 n = 10 的结果相同。</p>
<pre><code>class Solution:
    def countNumbersWithUniqueDigits(self, n: int) -&gt; int:
        def factorial(cnt):  # 从9阶乘cnt次
            res = 1
            factor = 9
            for i in range(cnt):
                res *= factor
                factor -= 1
            return res

        pre = i = 1
        while i &lt;= n and i &lt;= 10:  # i要&lt;=10
            pre += 9 * factorial(i-1)  # i位不同的数字与前面结果累加
            i += 1
        return pre</code></pre>
<p>??题解三|回溯：</p>
<pre><code>class Solution:
    def countNumbersWithUniqueDigits(self, n: int) -&gt; int:
        used=[False]*10
        def backtrace(first,used):
            count=0
            if first != n:
                for i in range(10):
                    if i==0 and n&gt;1 and first==1:
                        continue
                    if used[i]:
                        continue
                    used[i]=True
                    count+=backtrace(first+1,used)+1
                    used[i]=False
            return count
        if not n:
            return 1
        return backtrace(0,used)</code></pre>
<h3 id="401-二进制手表"><a href="#401-二进制手表" class="headerlink" title="401. 二进制手表"></a>401. 二进制手表</h3><pre><code>链接：https://leetcode-cn.com/problems/binary-watch/

二进制手表顶部有 4 个 LED 代表 小时（0-11），底部的 6 个 LED 代表 分钟（0-59）。

每个 LED 代表一个 0 或 1，最低位在右侧。


例如，上面的二进制手表读取 “3:25”。

给定一个非负整数 n 代表当前 LED 亮着的数量，返回所有可能的时间。

示例：

输入: n = 1
返回: [&quot;1:00&quot;, &quot;2:00&quot;, &quot;4:00&quot;, &quot;8:00&quot;, &quot;0:01&quot;, &quot;0:02&quot;, &quot;0:04&quot;, &quot;0:08&quot;, &quot;0:16&quot;, &quot;0:32&quot;]


提示：

输出的顺序没有要求。
小时不会以零开头，比如 “01:00” 是不允许的，应为 “1:00”。
分钟必须由两位数组成，可能会以零开头，比如 “10:2” 是无效的，应为 “10:02”。
超过表示范围（小时 0-11，分钟 0-59）的数据将会被舍弃，也就是说不会出现 &quot;13:00&quot;, &quot;0:61&quot; 等时间。</code></pre>
<p>题解一|暴力：</p>
<pre><code>class Solution:
    def readBinaryWatch(self, num: int) -&gt; List[str]:
        res=[]
        for i in range(12):
            for j in range(60):
                if (bin(i)+bin(j)).count(&#39;1&#39;) == num:
                    res.append(&#39;%d:%02d&#39;%(i,j))
        return res     </code></pre>
<p>扩展：</p>
<pre><code>%d就是普通的输出了整形数
%2d是将数字按宽度为2，采用右对齐方式输出，若数据位数不到2位，则左边补空格。
%02d，和%2d差不多，只不过左边补0

%-2d将数字按宽度为2，采用左对齐方式输出，若数据位数不到2位，则右边补空格
%.2d 输出整形时最少输出2位，如不够前面以0占位。如输出2时变成02，200时只输出200；输出浮点型时（%.2f）小数点后强制2位输出</code></pre>
<p>比如：</p>
<pre><code>num = 1
print(&quot;%d&quot; % (num))结果为：   （1）
print(&quot;%2d&quot; % (num))结果为：  （ 1）
print(&quot;%02d&quot; % (num))结果为： （01）
print(&quot;%-2d&quot; % (num))结果为： （1 ）
print(&quot;%.2d&quot; % (num))结果为： （01）
print(&quot;%.2d&quot; % (200))结果为： （200）</code></pre>
<p>题解二|回溯</p>
<pre><code>class Solution:
    def readBinaryWatch(self, num: int) -&gt; List[str]:

        def traceback(num,index,status):
            if num==0:
                hour=status[0]+2*status[1]+4*status[2]+8*status[3]
                mintue=status[4]+2*status[5]+4*status[6]+8*status[7]+16*status[8]+32*status[9]
                if hour&lt;12 and mintue &lt;60:
                    res.append(&#39;%d:%02d&#39;%(hour,mintue))
                return
            for i in range(index,10):
                status[i]=1
                traceback(num-1,i+1,status)
                status[i]=0
        res=[]
        traceback(num,0,[0]*10)
        return res</code></pre>
<pre><code>    def readBinaryWatch(self, num: int) -&gt; List[str]:
        &quot;&quot;&quot;
        思路： 递归回溯法
        &quot;&quot;&quot;
        if num &lt; 0:
            return []
        # 一共只有10个灯
        res, hour, minute = [], [1, 2, 4, 8], [1, 2, 4, 8, 16, 32]
        def traceback(num, index, status):
            &quot;&quot;&quot;
            num : 还剩下的可点亮的灯的数量
            index: 是当前选择点亮哪一个灯
            status: 记录是哪些位置的灯被点亮了

            &quot;&quot;&quot;
            if num == 0: # 没有可以点亮的灯了，记录当前结果，并返回
                h = sum([i*j for i,j in zip(hour, status[:4])])
                m = sum([i*j for i,j in zip(minute, status[4:])])
                if h &lt; 12 and m &lt; 60:
                    res.append(&#39;%d:%02d&#39; % (h, m))
                return
            for i in range(index, 10):
                status[i] = 1 # 做出下一步的选择
                traceback(num-1, i+1, status) # 在剩下的灯里面去点亮num-1个灯
                status[i] = 0 # 返回到上一步选择时的状态            

        traceback(num, 0, [0] * 10)
        return res</code></pre>
<h3 id="784-字母大小写全排列"><a href="#784-字母大小写全排列" class="headerlink" title="784. 字母大小写全排列"></a>784. 字母大小写全排列</h3><pre><code>链接：https://leetcode-cn.com/problems/letter-case-permutation/

给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。

示例:
输入: S = &quot;a1b2&quot;
输出: [&quot;a1b2&quot;, &quot;a1B2&quot;, &quot;A1b2&quot;, &quot;A1B2&quot;]

输入: S = &quot;3z4&quot;
输出: [&quot;3z4&quot;, &quot;3Z4&quot;]

输入: S = &quot;12345&quot;
输出: [&quot;12345&quot;]
注意：

S 的长度不超过12。
S 仅由数字和字母组成。</code></pre>
<p>题解一|递归：</p>
<pre><code>class Solution:
    def letterCasePermutation(self, S: str) -&gt; List[str]:
        res=[]

        def dfs(s,tmp):
            if not s:
                res.append(&#39;&#39;.join(tmp))
                return
            if s[0].isalpha():
                dfs(s[1:],tmp+[s[0].upper()])
                dfs(s[1:],tmp+[s[0].lower()])
            else:
                dfs(s[1:],tmp+[s[0]])
        dfs(S,[])
        return res</code></pre>
<p>题解二|迭代</p>
<pre><code>class Solution:
    def letterCasePermutation(self, S: str) -&gt; List[str]:
        res=[&#39;&#39;]
        for i,c in enumerate(S):
            if c.isdigit():
                for j,r in enumerate(res):
                    res[j]=r+c
            else:
                tmp=[]
                for r in res:
                    tmp.append(r+c.upper())
                    tmp.append(r+c.lower())
                res=tmp[:]
        return res</code></pre>
<h3 id="剑指-Offer-38-字符串的排列"><a href="#剑指-Offer-38-字符串的排列" class="headerlink" title="剑指 Offer 38. 字符串的排列"></a>剑指 Offer 38. 字符串的排列</h3><pre><code>链接：https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/

输入一个字符串，打印出该字符串中字符的所有排列。

你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。

示例:

输入：s = &quot;abc&quot;
输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]


限制：

1 &lt;= s 的长度 &lt;= 8</code></pre>
<p>题解一|回溯：</p>
<pre><code>class Solution:
    def permutation(self, s: str) -&gt; List[str]:
        res=[]
        c=list(s)

        def backtrace(first):
            if len(s) == first:  # 不能使用len(s)==len(c)作为结束条件，因为c其实没变。
                return res.append(&#39;&#39;.join(c))
            isDup=set()
            for i in range(first,len(c)):
                if c[i] in isDup: # 还有一种简单去重方法，直接把res定义为set()
                    continue
                isDup.add(c[i])
                c[first],c[i]=c[i],c[first]
                backtrace(first+1)
                c[first],c[i]=c[i],c[first]
        backtrace(0)
        return res</code></pre>
<pre><code>class Solution:
    def permutation(self, s: str) -&gt; List[str]:
        res=[]
        list_s=list(s)
        list_s.sort()
        self.sort_s=&#39;&#39;.join(list_s)
        used=[False]*len(s)        

        def backtrace(path,first):
            if len(self.sort_s) == len(path): 
                return res.append(&#39;&#39;.join(path[:]))
            for i in range(len(self.sort_s)):
                if used[i]:
                    continue
                if i&gt;0 and self.sort_s[i]==self.sort_s[i-1] and used[i-1] == False: # ？？？？
                    continue
                used[i]=True
                path.append(self.sort_s[i])
                backtrace(path,first+1)
                path.pop()
                used[i]=False
        backtrace([],0)
        return res</code></pre>
<h3 id="面试题-08-04-幂集"><a href="#面试题-08-04-幂集" class="headerlink" title="面试题 08.04. 幂集"></a>面试题 08.04. 幂集</h3><pre><code>幂集。编写一种方法，返回某集合的所有子集。集合中不包含重复的元素。

说明：解集不能包含重复的子集。

示例:

 输入： nums = [1,2,3]
 输出：
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]</code></pre>
<p>题解一|回溯：</p>
<pre><code>class Solution:
    def subsets(self, nums: List[int]) -&gt; List[List[int]]:
        res=[]
        def backtrace(path,first):
            res.append(path[:])
            for i in range(first,len(nums)):
                path.append(nums[i])
                backtrace(path,i+1)
                path.pop()
        backtrace([],0)
        return res</code></pre>
<h3 id="面试题-08-07-无重复字符串的排列组合"><a href="#面试题-08-07-无重复字符串的排列组合" class="headerlink" title="面试题 08.07. 无重复字符串的排列组合"></a>面试题 08.07. 无重复字符串的排列组合</h3><pre><code>无重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合，字符串每个字符均不相同。

示例1:

 输入：S = &quot;qwe&quot;
 输出：[&quot;qwe&quot;, &quot;qew&quot;, &quot;wqe&quot;, &quot;weq&quot;, &quot;ewq&quot;, &quot;eqw&quot;]
示例2:

 输入：S = &quot;ab&quot;
 输出：[&quot;ab&quot;, &quot;ba&quot;]
提示:

字符都是英文字母。
字符串长度在[1, 9]之间。</code></pre>
<p>题解一|回溯:</p>
<pre><code>class Solution:
    def permutation(self, S: str) -&gt; List[str]:
        res=[]
        c=list(S)

        def backtrace(first):
            if len(S) == first:  # 不能使用len(s)==len(c)作为结束条件，因为c其实没变。
                return res.append(&#39;&#39;.join(c))
            for i in range(first,len(c)):
                c[first],c[i]=c[i],c[first]
                backtrace(first+1)
                c[first],c[i]=c[i],c[first]
        backtrace(0)
        return res</code></pre>
<h3 id="面试题-08-09-括号"><a href="#面试题-08-09-括号" class="headerlink" title="面试题 08.09. 括号"></a>面试题 08.09. 括号</h3><pre><code>括号。设计一种算法，打印n对括号的所有合法的（例如，开闭一一对应）组合。

说明：解集不能包含重复的子集。

例如，给出 n = 3，生成结果为：

[
  &quot;((()))&quot;,
  &quot;(()())&quot;,
  &quot;(())()&quot;,
  &quot;()(())&quot;,
  &quot;()()()&quot;
]</code></pre>
<pre><code>class Solution:
    def generateParenthesis(self, n: int) -&gt; List[str]:
        res=[]
        def backtrace(path,first):
            if len(path) == 2*n:
                if first==0:
                    res.append(&#39;&#39;.join(path))
                return
            if first &lt; n:
                path.append(&#39;(&#39;)
                backtrace(path,first+1)
                path.pop()
            if first &gt; 0:
                path.append(&#39;)&#39;)
                backtrace(path,first-1)
                path.pop()
            print(path)
        backtrace([],0)
        return res</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/LeetCode-4-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/LeetCode-4-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="post-title-link" itemprop="url">LeetCode-4-动态规划</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-19 11:28:41" itemprop="dateCreated datePublished" datetime="2020-01-19T11:28:41+08:00">2020-01-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-09 20:52:05" itemprop="dateModified" datetime="2020-11-09T20:52:05+08:00">2020-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="四、动态规划"><a href="#四、动态规划" class="headerlink" title="四、动态规划"></a>四、动态规划</h2><p>动态规划三大步骤：</p>
<p>动态规划，无非就是利用历史记录，来避免我们的重复计算。而这些历史记录，我们得需要一些变量来保存，一般是用一维数组或者二维数组来保存。</p>
<p>第一步骤：定义数组元素的含义，上面说了，我们会用一个数组，来保存历史数组，假设用一维数组 dp[] 吧。这个时候有一个非常非常重要的点，就是规定你这个数组元素的含义，例如你的 dp[i] 是代表什么意思？</p>
<p>第二步骤：找出数组元素之间的关系式，我觉得动态规划，还是有一点类似于我们高中学习时的归纳法的，当我们要计算 dp[n] 时，是可以利用 dp[n-1]，dp[n-2]…..dp[1]，来推出 dp[n] 的，也就是可以利用历史数据来推出新的元素值，所以我们要找出数组元素之间的关系式，例如 dp[n] = dp[n-1] + dp[n-2]，这个就是他们的关系式了。而这一步，也是最难的一步，后面我会讲几种类型的题来说。</p>
<p>第三步骤：找出初始值。学过数学归纳法的都知道，虽然我们知道了数组元素之间的关系式，例如 dp[n] = dp[n-1] + dp[n-2]，我们可以通过 dp[n-1] 和 dp[n-2] 来计算 dp[n]，但是，我们得知道初始值啊，例如一直推下去的话，会由 dp[3] = dp[2] + dp[1]。而 dp[2] 和 dp[1] 是不能再分解的了，所以我们必须要能够直接获得 dp[2] 和 dp[1]的值，而这，就是所谓的初始值。</p>
<p>由了初始值，并且有了数组元素之间的关系式，那么我们就可以得到 dp[n] 的值了，而 dp[n] 的含义是由你来定义的，你想求什么，就定义它是什么，这样，这道题也就解出来了。</p>
<p>原文：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/pg-IJ8rA1duIzt5hW1Cycw">https://mp.weixin.qq.com/s/pg-IJ8rA1duIzt5hW1Cycw</a></p>
<h3 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="?5.最长回文子串"></a>?5.最长回文子串</h3><pre><code>链接：https://leetcode-cn.com/problems/longest-palindromic-substring/

给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

示例 1：

输入: &quot;babad&quot;
输出: &quot;bab&quot;
注意: &quot;aba&quot; 也是一个有效答案。
示例 2：

输入: &quot;cbbd&quot;
输出: &quot;bb&quot;</code></pre>
<p>题解一|暴力破解：<br>    很明显，暴力法将选出所有子字符串可能的开始和结束位置，并检验它是不是回文。<br>    时间复杂度：O(n^2),往往利用python的切片可以很好的缩减复杂度<br>    如果不用切片，还需要遍历一次子字符串，时间复杂度就是O(n^3)<br>    空间复杂度：O(1)</p>
<pre><code>class Solution:
    def longestPalindrome(self, s: str) -&gt; str:
        if s==s[::-1]:
            return s

        maxLen=1
        ans=s[0]
        for i in range(0,len(s)-1):
            for j in range(i+1,len(s)):
                if j-i+1 &gt; maxLen and self.isPalindrome(s[i:j+1]):
                    maxLen=j-i+1
                    ans=s[i:j+1]
        return ans

    def isPalindrome(self, s: str) -&gt; bool:
        left,right=0,len(s)-1
        while left&lt;right:
            while left&lt;len(s) and not s[left].isalnum():
                left+=1
            while right &gt;-1 and not s[right].isalnum():
                right-=1
            if left&gt;right:
                return True
            if s[left].upper() != s[right].upper():
                return False
            else:
                left+=1
                right-=1
        return True</code></pre>
<p>时间复杂度：O(N^3)，这里 N 是字符串的长度，枚举字符串的左边界、右边界，然后继续验证子串是否是回文子串，这三种操作都与 N 相关；<br>空间复杂度：O(1)，只使用到常数个临时变量，与字符串长度无关。</p>
<pre><code>class Solution:
    # 暴力匹配（超时）
    def longestPalindrome(self, s: str) -&gt; str:
        # 特判
        size = len(s)
        if size &lt; 2:
            return s

        max_len = 1
        res = s[0]

        # 枚举所有长度大于等于 2 的子串
        for i in range(size - 1):
            for j in range(i + 1, size):
                if j - i + 1 &gt; max_len and self.__valid(s, i, j):
                    max_len = j - i + 1
                    res = s[i:j + 1]
        return res

    def __valid(self, s, left, right):
        # 验证子串 s[left, right] 是否为回文串
        while left &lt; right:
            if s[left] != s[right]:
                return False
            left += 1
            right -= 1
        return True</code></pre>
<pre><code>class Solution:
    def longestPalindrome(self, s: str) -&gt; str:
        if s==s[::-1]:
            return s

        maxLen=1
        ans=s[0]
        for i in range(0,len(s)-1):
            for j in range(i+1,len(s)):
                if j-i+1 &gt; maxLen and s[i:j+1]==s[i:j+1][::-1]: # arr=&#39;abb&#39;,arr[0:1]=&#39;a&#39;,右边是开区间
                    maxLen=j-i+1
                    ans=s[i:j+1]
        return ans</code></pre>
<p>题解二|每个字母当成回文串的中心：</p>
<pre><code>考虑两种情况:回文串的长度为奇数或者偶数情况。</code></pre>
<pre><code>class Solution:
    def longestPalindrome(self, s: str) -&gt; str:
        n=len(s)
        self.res=&#39;&#39;
        def helper(i,j):
            while i&gt;= 0 and j&lt;n and s[i]==s[j]:
                i-=1
                j+=1
            if len(self.res) &lt; j-i-1:
                self.res=s[i+1:j]
                # print(i,self.res)

        for i in range(n):
            helper(i,i)
            helper(i,i+1) # 解决case为&quot;cbbd&quot;,即解决回文串为偶数的情况
        return self.res</code></pre>
<p>题解三|把每个字母当成回文串的结束：</p>
<pre><code>class Solution:
    def longestPalindrome(self, s: str) -&gt; str:
        if not s:
            return &quot;&quot;
        max_len = 1
        n = len(s)
        start = 0
        for i in range(1,n):
            even = s[i-max_len:i+1] # 偶数
            odd = s[i - max_len-1:i+1] # 奇数
            #print(even,odd)
            if i - max_len - 1 &gt;= 0 and odd == odd[::-1]:
                start = i - max_len - 1
                max_len += 2
            elif i - max_len &gt;=0 and even == even[::-1]:
                start = i - max_len
                max_len += 1

        #print(start,max_len)
        return s[start: start+max_len]</code></pre>
<p>题解四|动态规划：<br><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/dp.png"></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/">https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/</a></p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/dp2.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/dp2.png"></p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/dp3.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/dp3.png"></p>
<pre><code>1、定义数组的定义
    dp[i][j] 表示子串 s[i,j] 是否为回文子串。
2、找出数组的关系式
    dp[i][j] = (s[i] == s[j]) and dp[i + 1][j - 1]
3、找到初始值

    试想如果 dp[l][r]=true，我们要判断 dp[l-1][r+1] 是否为回文。
    只需要判断字符串在(l-1)和（r+1)两个位置是否为相同的字符，是不是减少了很多重复计算。

    初始状态，l=r 时，此时 dp[l][r]=true
    状态转移方程，dp[l][r]=true 并且(l-1)和（r+1)两个位置为相同的字符，此时 dp[l-1][r+1]=true。</code></pre>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/gao-hao-dong-tai-gui-hua-he-zhong-xin-tuo-zhan-zhu/">https://leetcode-cn.com/problems/longest-palindromic-substring/solution/gao-hao-dong-tai-gui-hua-he-zhong-xin-tuo-zhan-zhu/</a></p>
<pre><code>class Solution:
    def longestPalindrome(self, s: str) -&gt; str:
        if not s or len(s) &lt;2:
            return s

        length=len(s)
        start=0
        end=0
        count=1

        dp=[[0]* length for i in range(length)]
        for r in range(1,length):
            for l in range(0,length):
                if (s[l]==s[r]) and (r-l&lt;=2 or dp[l+1][r-1]):
                    dp[l][r]=True
                    if r-l+1&gt; count:
                        count=r-l+1
                        start=l
                        end=r
        return s[start:end+1]</code></pre>
<pre><code>class Solution:
    def longestPalindrome(self, s: str) -&gt; str:
        # 观察是否存在状态，例如 babab,可知aba是回文序列，那么可以看出babab也是回文序列，当b = b的时候
        # 因此我们可以用二维数组来i,j表示回文串的起始和结尾索引位置。
        # 状态转移方程dp[i,j] = dp[i+1][j-1] if s[i] == s[j] else False
        # 接下来看有没有特殊的边界情况存在，我们发现当0&lt;=j-i&lt;3的时候，只要满足s[i] == s[j]，无论里面是什么dp[i,j]都会是回文字串,将这种情况分开讨论，当j-i&gt;=3的时候，进行状态转移
        # 初始值
        m = len(s)
        max_len = 1
        start_index = 0
        if m &lt; 2:
            return s
        dp = [[False for _ in range(m)] for _ in range(m)]
        for j in range(1,m):
            for i in range(0,j):
                if s[i]  == s[j]:
                    if j-i &lt; 3:
                        dp[i][j] = True
                    else:
                        dp[i][j] = dp[i+1][j-1]
                else:
                    dp[i][j] = False
                if dp[i][j]:
                    cur_len = j-i+1
                    if cur_len &gt; max_len:
                        max_len = cur_len
                        start_index = i
        return s[start_index:start_index+max_len]</code></pre>
<pre><code>class Solution:
    def longestPalindrome(self, s: str) -&gt; str:
        if(not s or len(s)==1):
            return s
        n=len(s)
        dp=[[False]*n for _ in range(n)]
        max_len=1
        start=0
        for i in range(n):
            dp[i][i]=True
            if(i&lt;n-1 and s[i]==s[i+1]):
                dp[i][i+1]=True
                start=i
                max_len=2
        for l in range(3,n+1):
            for i in range(n+1-l):
                r=i+l-1
                if(s[i]==s[r] and dp[i+1][r-1]):
                    dp[i][r]=True
                    start=i
                    max_len=l
        return s[start:start+max_len]
</code></pre>
<h3 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53.最大子序和"></a>53.最大子序和</h3><pre><code>链接：https://leetcode-cn.com/problems/maximum-subarray/

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例:

输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
进阶:

如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</code></pre>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-subarray/solution/zui-da-zi-xu-he-cshi-xian-si-chong-jie-fa-bao-li-f/">https://leetcode-cn.com/problems/maximum-subarray/solution/zui-da-zi-xu-he-cshi-xian-si-chong-jie-fa-bao-li-f/</a><br>题解一：</p>
<pre><code>遍历整个数组，在数组的每一个位置时，求出一个全局最大值L，代表以当前位置
为结尾的最大字串，而G是当前位置的L和上一个位置L相比较后，取数值更大的。
当遍历到i时，以i个为结尾的最大字串就是我们的L。

l：代表以当前位置为结尾的最大字符
g：当前位置l和上一个位置l取数值最大

数组[-2,1,-3,4,-1,2,1,-5,4]
位置0：L=-2,G=-2
位置1：L=1,G=1
位置2：L=-2，G=1
位置3：L=4，G=4
位置4：L=3，G=4
位置5：L=5，G=5
位置6：L=6，G=6
位置7：L=-1，G=6
位置8：L=4，G=6
最后，全局最大值G就是我们的结果。</code></pre>
<pre><code>class Solution:
    def maxSubArray(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: int
        &quot;&quot;&quot;
        l=g=-10000000000
        for n in nums:
            l=max(n,l+n)
            g=max(l,g)
        return g</code></pre>
<p>题解二：</p>
<pre><code>class Solution:
    def maxSubArray(self, nums: List[int]) -&gt; int:
        for i in range(1,len(nums)):
            nums[i]=max(nums[i],nums[i]+nums[i-1])

        return max(nums) # 取子序和中最大值</code></pre>
<p>题解三|动态规划:<br>    1、定义数组元素的含义</p>
<pre><code>    dp[i]为以num[i]结尾的子段的最大子段和
    dp[1]为以num[1]结尾的最大子段和

2、寻找递推表达式

    只考虑第一个元素，则最大子段和为其本身 dp[0] = nums[0]

    考虑前两个元素，最大子段和为 nums[0],num[1]以及 nums[0] + num[1] 中最大值 设为dp[1]

    考虑前三个元素，如何求其最大子段和？还是分为两种情况讨论，第三个元素在最后的字串内吗？

    若第三个元素也包含在最后的字串内，则dp[2] = Max(dp[1]+nums[2] , nums[2])

    dp[i]=max(dp[i-1]+num[i],num[i])

3、找出初始值

    dp[0]=num[0]
    dp[1]=max(dp[0]+num[1],num[1])</code></pre>
<pre><code>class Solution:
    def maxSubArray(self, nums: List[int]) -&gt; int:
        lens=len(nums)
        if lens==0:
            return 0
        dp=lens*[0]
        dp[0]=nums[0]
        # dp[1]=max(dp[0]+nums[1],nums[1])
        res=dp[0]
        for i in range(1,lens):
            dp[i]=max(dp[i-1]+nums[i],nums[i])
            if dp[i]&gt;res:
                res=dp[i]
        return res

输入：
[-2,1,-3,4,-1,2,1,-5,4]
输出：
[-2, 1, 0, 0, 0, 0, 0, 0, 0]
[-2, 1, -2, 0, 0, 0, 0, 0, 0]
[-2, 1, -2, 4, 0, 0, 0, 0, 0]
[-2, 1, -2, 4, 3, 0, 0, 0, 0]
[-2, 1, -2, 4, 3, 5, 0, 0, 0]
[-2, 1, -2, 4, 3, 5, 6, 0, 0]
[-2, 1, -2, 4, 3, 5, 6, 1, 0]
[-2, 1, -2, 4, 3, 5, 6, 1, 5]</code></pre>
<h3 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62.不同路径"></a>62.不同路径</h3><pre><code>链接：https://leetcode-cn.com/problems/unique-paths/

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

问总共有多少条不同的路径？</code></pre>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/unique-path.png" alt="tree1"></p>
<pre><code>例如，上图是一个7 x 3 的网格。有多少可能的路径？

说明：m 和 n 的值均不超过 100。

示例 1:

输入: m = 3, n = 2
输出: 3
解释:
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -&gt; 向右 -&gt; 向下
2. 向右 -&gt; 向下 -&gt; 向右
3. 向下 -&gt; 向右 -&gt; 向右
示例 2:

输入: m = 7, n = 3
输出: 28</code></pre>
<p>题解一|动态规划：</p>
<p>1、定义数组元素的含义<br>    目的：从左上角到右下角一共有多少种路径<br>    dp[i][j]含义：从左上角走到(i,j)这个位置时，一共有dp[i][j]种路径</p>
<p>2、找到数组的递推关系式</p>
<pre><code>如何才能到达 (i, j) 这个位置呢？可以向下走或者向右走，所以有两种方式到达：

    一种是从 (i-1, j) 这个位置走一步到达
    一种是从(i, j - 1) 这个位置走一步到达

所以：dp[i][j]=dp[i-1][j]+dp[i][j-1]</code></pre>
<p>3、找到初始值</p>
<pre><code>当 dp[i][j] 中，如果 i 或者 j 有一个为 0，那么还能使用关系式吗？答是不能的，因为这个时候把 i - 1 或者 j - 1，就变成负数了，数组就会出问题了。

图中的最上面一行和左边一列，因此初始值如下：

    dp[0][0….n-1] = 1; // 相当于最上面一行，只能一直往右走
    dp[0…m-1][0] = 1; // 相当于最左面一列，只能一直往下走</code></pre>
<p>时间复杂度：O(m<em>n)<br>空间复杂度：O(m</em>n)，使用dp数组保存结果</p>
<pre><code>class Solution:
    def uniquePaths(self, m: int, n: int) -&gt; int:
        if m&lt;=0 or n&lt;=0:
            return 0
        dp=[ n*[_] for _ in range(m)] # 定义二维数组
        # print(dp)
        for i in range(m):
            dp[i][0]=1
        for j in range(n):
            dp[0][j]=1

        for i in range(1,m):
            for j in range(1,n):
                dp[i][j]=dp[i-1][j]+dp[i][j-1]
        return dp[m-1][n-1]
</code></pre>
<pre><code>class Solution:
    def uniquePaths(self, m: int, n: int) -&gt; int:
        if m&lt;=0 or n&lt;=0:
            return 0
        dp=[ m*[_] for _ in range(n)]
        # print(dp)
        for i in range(n):
            dp[i][0]=1
        for j in range(m):
            dp[0][j]=1

        for i in range(1,n):
            for j in range(1,m):
                dp[i][j]=dp[i-1][j]+dp[i][j-1]
        return dp[n-1][m-1]</code></pre>
<p>题解二|动态规划优化:</p>
<p>参考：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&amp;mid=2247486303&amp;idx=1&amp;sn=6034d1e6ca24253da64d6c539998f7c6&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&amp;mid=2247486303&amp;idx=1&amp;sn=6034d1e6ca24253da64d6c539998f7c6&amp;scene=21#wechat_redirect</a></p>
<p>转化成一维，关系式为 dp[i] = dp[i] + dp[i-1]</p>
<p>空间复杂度：O(n)</p>
<pre><code>class Solution:
    def uniquePaths(self, m: int, n: int) -&gt; int:
        if m&lt;=0 or n&lt;=0:
            return 0
        dp=n*[0] # n是列
        for i in range(n):
            dp[i]=1

        for i in range(1,m):
            dp[0]=1
            for j in range(1,n):
                dp[j]=dp[j-1]+dp[j]
        return dp[n-1]</code></pre>
<h3 id="63-不同路径-II"><a href="#63-不同路径-II" class="headerlink" title="63.不同路径 II"></a>63.不同路径 II</h3><pre><code>链接：https://leetcode-cn.com/problems/unique-paths-ii/

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

如上图

网格中的障碍物和空位置分别用 1 和 0 来表示。

说明：m 和 n 的值均不超过 100。

示例 1:

输入:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
输出: 2
解释:
3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下
2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</code></pre>
<p>题解一|动态规划：</p>
<p>1、定义数组元素的含义<br>    机器人从左上角走到(i, j) 这个位置时，一共有 dp[i][j] 种路径<br>2、找出关系数组元素间的关系式<br>    想象以下，机器人要怎么样才能到达 (i, j)这个位置？由于机器人可以向下走或者向右走，所以有两种方式到达。当遇到障碍时</p>
<pre><code>一种是从 (i-1, j) 这个位置走一步到达

一种是从(i, j-1) 这个位置走一步到达

因为是计算所有可能的步骤，所以是把所有可能走的路径都加起来，所以关系式是 dp[i][j] = dp[i-1][j] + dp[i][j-1]。（当没有遇到障碍时，就用以上的方式进行）</code></pre>
<p>3、找出初始值<br>    dp[0][0]=1</p>
<pre><code>dp[0][i]=dp[0][i-1]; // 相当于最上面一行，机器人只能一直往右走（当没有遇到障碍时）
dp[i][0]=dp[i-1][0]; // 相当于最左面一列，机器人只能一直往下走（当没有遇到障碍时）</code></pre>
<pre><code>class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -&gt; int:
        if obstacleGrid is None:
            return 0
        if obstacleGrid[0][0]==1 or obstacleGrid[-1][-1] == 1:
            return 0

        m=len(obstacleGrid)
        n=len(obstacleGrid[0])

        dp=[n*[0] for _ in range(m)]  # dp=[n*[_] for _ in range(m)]时结果有误

        dp[0][0]=1
        for i in range(1,m):
            if obstacleGrid[i][0] !=1:
                dp[i][0]=dp[i-1][0]

        for i in range(1,n):
            if obstacleGrid[0][i] !=1:
                dp[0][i]=dp[0][i-1]

        for i in range(1,m):
            for j in range(1,n):
                if obstacleGrid[i][j] != 1:
                    dp[i][j]=dp[i-1][j]+dp[i][j-1]
        # print(dp[m-1][n-1])
        return dp[-1][-1]
</code></pre>
<h3 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64.最小路径和"></a>64.最小路径和</h3><pre><code>链接：https://leetcode-cn.com/problems/minimum-path-sum/

给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。

示例:

输入:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 7
解释: 因为路径 1→3→1→1→1 的总和最小。</code></pre>
<p>题解一|动态规划：<br>1、定义数组元素的含义<br>    目的是从左上角到右下角，最小路径和是多少。<br>    dp[i][j]含义：当从左上角走到(i,j)位置时，最小路径和为dp[i][j]</p>
<pre><code>定义二维数据，数组是从下标 0 开始算起的，所以右下角的位置是 (m-1, n - 1)，所以 dp[m-1][n-1] 就是我们所求。</code></pre>
<p>2、找到数组的递推关系式</p>
<pre><code>如何才能到达 (i, j) 这个位置？由于可以向下走或者向右走，所以有两种方式到达：

    一种是从 (i-1, j) 这个位置走一步到达
    一种是从 (i, j-1) 这个位置走一步到达

不过本次计算不是所有可能路径，而是计算哪一个路径和最小。

所以：dp[i][j]=min(dp[i-1][j],dp[i][j-1])+arr[i][j]</code></pre>
<p>3、找到初始值</p>
<pre><code>当 dp[i][j] 中，如果 i 或者 j 有一个为 0，那么还能使用关系式吗？答是不能的，因为这个时候把 i - 1 或者 j - 1，就变成负数了，数组就会出问题了，所以我们的初始值是计算出所有的 dp[0][0….n-1] 和所有的 dp[0….m-1][0]

dp[0][j] = arr[0][j] + dp[0][j-1]; // 相当于最上面一行，只能一直往左走
dp[i][0] = arr[i][0] + dp[i][0];  // 相当于最左面一列，只能一直往下走</code></pre>
<p>时间复杂度：O(m<em>n)<br>空间复杂度：O(m</em>n)</p>
<pre><code>class Solution:
    def minPathSum(self, grid: List[List[int]]) -&gt; int:
        # print(grid)
        m=len(grid) # 行
        n=len(grid[0]) # 列
        if m&lt;=0 or n&lt;=0:
            return 0
        dp=[ n*[_] for _ in range(m)]
        # print(dp)
        dp[0][0]=grid[0][0] 

        for i in range(1,m):
            dp[i][0]=dp[i-1][0]+grid[i][0]

        for i in range(1,n):
            dp[0][i]=dp[0][i-1]+grid[0][i]

        for i in range(1,m):
            for j in range(1,n):
                dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j]
        # print(dp)

        return dp[m-1][n-1]
</code></pre>
<h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a>70.爬楼梯</h3><pre><code>链接：https://leetcode-cn.com/problems/climbing-stairs/

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1：

输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
示例 2：

输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶</code></pre>
<p>题解一|递归：</p>
<pre><code>class Solution:
    def climbStairs(self, n: int) -&gt; int:
        if n&lt;=2:
            return n
        return self.climbStairs(n-1)+self.climbStairs(n-2)</code></pre>
<p>题解二|动态规划：<br>1、定义数组元素的含义</p>
<pre><code>dp[i]含义：跳上第i个台阶总共有dp[i]种跳法；
dp[n]即为我们所求结果。</code></pre>
<p>2、找出数组元素间的关系式</p>
<pre><code>把一个规模比较大的问题分成几个规模比较小的问题，然后由小的问题推导出大的问题。
到达第 n 级的台阶有两种方式：
    一种是从第 n-1 级跳上来
    一种是从第 n-2 级跳上来
所以：dp[n] = dp[n-1] + dp[n-2]。</code></pre>
<p>3、找出初始值</p>
<pre><code>n=1时，dp[1]=dp[0]+dp[-1]，不允许下标为-1，所以dp[1]=1
n=0时，dp[0]=0
n=2时，dp[2]=dp[1]+dp[0]=1，所以以上初始值定义不严谨，因为dp[2]=2</code></pre>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<pre><code>class Solution:
    def climbStairs(self, n: int) -&gt; int:
        if n&lt;=2:
            return n
        dp=(n+1)*[0] # 注意是n+1
        dp[1]=1
        dp[2]=2
        for i in range(3,n+1):
            dp[i]=dp[i-1]+dp[i-2]
        return dp[n] # 返回最后一个数</code></pre>
<h3 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72.编辑距离"></a>72.编辑距离</h3><pre><code>链接：https://leetcode-cn.com/problems/edit-distance/

给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

插入一个字符
删除一个字符
替换一个字符
示例 1:

输入: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;
输出: 3
解释: 
horse -&gt; rorse (将 &#39;h&#39; 替换为 &#39;r&#39;)
rorse -&gt; rose (删除 &#39;r&#39;)
rose -&gt; ros (删除 &#39;e&#39;)
示例 2:

输入: word1 = &quot;intention&quot;, word2 = &quot;execution&quot;
输出: 5
解释: 
intention -&gt; inention (删除 &#39;t&#39;)
inention -&gt; enention (将 &#39;i&#39; 替换为 &#39;e&#39;)
enention -&gt; exention (将 &#39;n&#39; 替换为 &#39;x&#39;)
exention -&gt; exection (将 &#39;n&#39; 替换为 &#39;c&#39;)
exection -&gt; execution (插入 &#39;u&#39;)</code></pre>
<p>思路：</p>
<pre><code>if s1[i] == s2[j]:
    啥都别做（skip）
    i, j 同时向前移动
else:
    三选一：
        插入（insert）
        删除（delete）
        替换（replace）</code></pre>
<p>题解一|递归|自顶向下：</p>
<pre><code>class Solution:
    def minDistance(self, word1: str, word2: str) -&gt; int:
        def dp(i,j):
            if i==-1:
                return j+1
            if j==-1:
                return i+1
            if word1[i]==word2[j]:
                return dp(i-1,j-1) # 什么都不做
            else:
                return min(
                    dp(i,j-1)+1, # 插入
                    dp(i-1,j)+1, # 删除
                    dp(i-1,j-1)+1 # 替换
                    )
        return dp(len(word1)-1,len(word2)-1)</code></pre>
<p>解释：</p>
<pre><code>if s1[i] == s2[j]:
    return dp(i - 1, j - 1)  # 啥都不做
# 解释：
# 本来就相等，不需要任何操作
# s1[0..i] 和 s2[0..j] 的最小编辑距离等于
# s1[0..i-1] 和 s2[0..j-1] 的最小编辑距离
# 也就是说 dp(i, j) 等于 dp(i-1, j-1)

dp(i, j - 1) + 1,    # 插入
# 解释：
# 我直接在 s1[i] 插入一个和 s2[j] 一样的字符
# 那么 s2[j] 就被匹配了，前移 j，继续跟 i 对比
# 别忘了操作数加一

dp(i - 1, j) + 1,    # 删除
# 解释：
# 我直接把 s[i] 这个字符删掉
# 前移 i，继续跟 j 对比
# 操作数加一

dp(i - 1, j - 1) + 1 # 替换
# 解释：
# 我直接把 s1[i] 替换成 s2[j]，这样它俩就匹配了
# 同时前移 i，j 继续对比
# 操作数加一</code></pre>
<p>优化：</p>
<pre><code>class Solution:
    def minDistance(self, word1: str, word2: str) -&gt; int:
        memo=dict()

        def dp(i,j):
            if (i,j) in memo:
                return memo[(i,j)]
            if i==-1:
                return j+1
            if j==-1:
                return i+1
            if word1[i]==word2[j]:
                memo[(i,j)] = dp(i-1,j-1) # 什么都不做
            else:
                memo[(i,j)]= min(
                    dp(i,j-1)+1, # 插入
                    dp(i-1,j)+1, # 删除
                    dp(i-1,j-1)+1 # 替换
                    )
            return memo[(i,j)]
        return dp(len(word1)-1,len(word2)-1)</code></pre>
<p>题解二|动态规划：</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/dp4.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/dp4.png"></p>
<p>思路：</p>
<pre><code>理解 word1 上的删除等价 word2 上的增加, word1 上的增加等价于 word2 上的删除
2维的 dp array 中某一点 dp[i][j] 的意义: word1[ : i] 到 word[ : j] 转换所需要的最小的数目
不太需要关注具体进行了删除、增加还是替换操作，而是专注于 a 状态到 b 状态所需要的步数</code></pre>
<pre><code>class Solution:
    def minDistance(self, word1: str, word2: str) -&gt; int:
        m = len(word1)
        n = len(word2)
        dp = [[float(&#39;inf&#39;) for _ in range(n + 1)] for _ in range(m + 1)]
        # 初始化
        for i in range(m + 1):
            dp[i][0] = i
        for i in range(n + 1):
            dp[0][i] = i
        # 状态转移
        # i , j 代表 word1, word2 对应位置的 index
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                # 如果word1[:i][-1]==word2[:j][-1]
                if word1[i - 1] == word2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1]
                # 否则从三种状态中选一个最小的然后 +1
                else:
                    dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1
        return dp[m][n]</code></pre>
<p>题解三|动态规划：</p>
<pre><code>参考：https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&amp;mid=2247486294&amp;idx=1&amp;sn=dd8968700d19ea8b1db29065dc2f7b01&amp;scene=21#wechat_redirect</code></pre>
<p>1、定义数组元素的含义</p>
<pre><code>目的：求将 word1 转换成 word2 所使用的最少操作数 。

dp[i][j]的含义为：当字符串 word1 的长度为 i，字符串 word2 的长度为 j 时，将 word1 转化为 word2 所使用的最少操作次数为 dp[i][j]。</code></pre>
<p>2、找出关系数组元素间的关系式</p>
<pre><code>第一种：如果我们 word1[i] 与 word2 [j] 相等，这个时候不需要进行任何操作，所以 dp[i][j] = dp[i-1][j-1]。

第二种：如果我们 word1[i] 与 word2 [j] 不相等，这个时候我们就必须进行调整，而调整的操作有 3 种，我们要选择一种。
三种操作对应的关系式如下（注意字符串与字符的区别）：

（1）、如果把字符 word1[i] 替换成与 word2[j] 相等，则有 dp[i][j] = dp[i-1][j-1] + 1;

（2）、如果在字符串 word1末尾插入一个与 word2[j] 相等的字符，则有 dp[i][j] = dp[i][j-1] + 1;

（3）、如果把字符 word1[i] 删除，则有 dp[i][j] = dp[i-1][j] + 1;

所以应该选择一种操作，使得 dp[i][j] 的值最小，显然关系式有：dp[i][j] = min(dp[i-1] [j-1]，dp[i][j-1]，dp[i-1][j]) + 1;</code></pre>
<p>3、找出初始值</p>
<pre><code>当 dp[i][j] 中，如果 i 或者 j 有一个为 0，那么还能使用关系式吗？答是不能的，因为这个时候把 i - 1 或者 j - 1，就变成负数了，数组就会出问题了，所以我们的初始值是计算出所有的 dp[0][0….n] 和所有的 dp[0….m][0]。

这个还是非常容易计算的，因为当有一个字符串的长度为 0 时，转化为另外一个字符串，那就只能一直进行插入或者删除操作了。</code></pre>
<p>时间复杂度：O(m<em>n)<br>空间复杂度：O(m</em>n)</p>
<pre><code>class Solution:
    def minDistance(self, word1: str, word2: str) -&gt; int:
        m=len(word1)+1
        n=len(word2)+1
        dp = [ n*[_] for _ in range(m) ]
        for i in range(1,m):
            dp[i][0]=dp[i-1][0]+1

        for i in range(1,n):
            dp[0][i]=dp[0][i-1]+1

        for i in range(1,m):
            for j in range(1,n):
                if word1[i-1]==word2[j-1]:
                    dp[i][j]=dp[i-1][j-1]
                else:
                    dp[i][j]=min(dp[i-1][j-1],dp[i-1][j],dp[i][j-1])+1
        # print(dp)
        # print(dp[-1][-1])
        return dp[m-1][n-1]</code></pre>
<p>???题解四|动态规划优化：</p>
<p>定义额外变量 pre = (i-1,j-1) 的值<br>二维的dp[i][j]=min(dp[i-1][j],dp[i-1][j-1],dp[i][j-1])+1<br>转换为一维的dp[i]=min(dp[i-1],pre,dp[i])+1</p>
<p>空间复杂度：O(n)</p>
<pre><code>class Solution:
    def minDistance(self, word1: str, word2: str) -&gt; int:
        m=len(word1)+1
        n=len(word2)+1
        dp = n*[0]

        for i in range(0,n):
            dp[i]=i

        for i in range(1,m):
            tmp=dp[0]
            dp[0]=i
            for j in range(1,n):
                pre=tmp
                tmp=dp[j]
                if word1[i-1]==word2[j-1]:
                    dp[j]=pre
                else:
                    dp[j]=min(dp[j-1],pre,dp[j])+1
        return dp[n-1]</code></pre>
<h3 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91.解码方法"></a>91.解码方法</h3><pre><code>链接：https://leetcode-cn.com/problems/decode-ways/

一条包含字母 A-Z 的消息通过以下方式进行了编码：

&#39;A&#39; -&gt; 1
&#39;B&#39; -&gt; 2
...
&#39;Z&#39; -&gt; 26
给定一个只包含数字的非空字符串，请计算解码方法的总数。

示例 1:

输入: &quot;12&quot;
输出: 2
解释: 它可以解码为 &quot;AB&quot;（1 2）或者 &quot;L&quot;（12）。
示例 2:

输入: &quot;226&quot;
输出: 3
解释: 它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。</code></pre>
<p>题解一|动态规划：<br>    此题类似于青蛙跳台阶问题，不同的只是多了很多限制条件。</p>
<pre><code>青蛙跳台阶时，可以选择跳一级，也可以选择跳两级，所以青蛙到达第 n 级的台阶有两种方式：
一种是从第 n-1 级跳上来；
一种是从第 n-2 级跳上来；

解码也同理，最大编码为26，所以第 n 个位置编码的总数也有两种方式：
一种是从第 n-1 编码位置的总数；
一种是从第 n-2 编码位置的总数；

1、定义数组元素的含义
第 i 位置的编码总数有 dp[i] 个
d[i]代表第i个位置解码方法的总数

2、找出关系数组元素间的关系式
d[i]=d[i-1]+d[i-2]
d[i+1]=d[i]+d[i-1]

3、找出初始值
dp[0]=1
dp[1]=1
dp[2]=2(此题限制2不好，因为‘10’返回1，’27‘返回0)

4、限制条件
字符串以‘0’开头时返回0
字符串含有‘00’时返回0
字符串中s[i]=&#39;0&#39;但是int(s[i-1])&gt;2时返回0
字符串s[i-1:i]&gt;26时，此时应该分开计算。dp[i]+=dp[i-1]</code></pre>
<pre><code>class Solution:
    def numDecodings(self, s: str) -&gt; int:

        if s[0]==&#39;0&#39; or s is None:
            return 0
        if len(s)==1:
            return 1
        if len(s)==2:
            return 2

        dp=[0]*(len(s))
        dp[0]=1
        dp[1]=1
        dp[2]=2
        for i in range(2,len(s)):
            if s[i] != &#39;0&#39;:
                print(i)
                dp[i]+=dp[i-1]
            if s[i-1] ==&#39;1&#39; and (s[i-1]==&#39;2&#39; or s[i]&lt;=6):
                dp[i]+=dp[i-2]
            if s[i]==&#39;0&#39; and s[i-1]==&#39;0&#39;:
                return 0
        return dp[-1]

用例‘10’这个例子预期输出应该是1,但是实际输出为2，所以for循环从2开始有问题。
即使改成如下也有问题：
        if s==&#39;10&#39; or s==&#39;20&#39;:
            return 1
        elif int(s)&gt;26:
            return 0
        elif len(s)==2:
            return 2</code></pre>
<pre><code>class Solution:
    def numDecodings(self, s: str) -&gt; int:

        if s[0]==&#39;0&#39; or s is None:
            return 0
        if len(s)==1:
            return 1

        length=len(s)
        dp=[0]*(length+1)
        dp[0]=1
        dp[1]=1

        for i in range(1,len(s)):
            if s[i] != &#39;0&#39;:
                dp[i+1]+=dp[i]
            if s[i-1] ==&#39;1&#39; or (s[i-1]==&#39;2&#39; and int(s[i])&lt;=6):
                dp[i+1]+=dp[i-1]
            if s[i]==&#39;0&#39; and s[i-1]==&#39;0&#39;:
                return 0
        # print(dp[-1])
        return dp[length]</code></pre>
<h3 id="95-不同的二叉搜索树-II"><a href="#95-不同的二叉搜索树-II" class="headerlink" title="?95. 不同的二叉搜索树 II"></a>?95. 不同的二叉搜索树 II</h3><pre><code>链接：https://leetcode-cn.com/problems/unique-binary-search-trees-ii/

给定一个整数 n，生成所有由 1 ... n 为节点所组成的二叉搜索树。

示例:

输入: 3
输出:
[
  [1,null,3,2],
  [3,2,null,1],
  [3,1,null,null,2],
  [2,1,3],
  [1,null,2,null,3]
]
解释:
以上的输出对应以下 5 种不同结构的二叉搜索树：

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3</code></pre>
<p>题解一|递归：<br><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/tree3.png" alt="tree3"><br><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/tree4.png" alt="tree4"></p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def generateTrees(self, n: int) -&gt; List[TreeNode]:
        if n:
            return self.build(1,n)
        else:
            []
    def build(self,start,end):
        # 结束条件
        if start&gt;end:
            return [None,]

        trees=[]
        for i in range(start,end+1):
            leftTrees=self.build(start,i-1)
            rightTrees=self.build(i+1,end)
            for l in leftTrees:
                for r in rightTrees:
                    currentTree=TreeNode(i)
                    currentTree.left=l
                    currentTree.right=r
                    trees.append(currentTree)
        # print(trees)
        return trees</code></pre>
<h3 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96.不同的二叉搜索树"></a>96.不同的二叉搜索树</h3><pre><code>链接：https://leetcode-cn.com/problems/unique-binary-search-trees/

给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

示例:

输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3</code></pre>
<p>题解一|动态规划:</p>
<p>二叉树定义：</p>
<p>二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-binary-search-trees/solution/bu-tong-de-er-cha-sou-suo-shu-by-leetcode/">https://leetcode-cn.com/problems/unique-binary-search-trees/solution/bu-tong-de-er-cha-sou-suo-shu-by-leetcode/</a><br>方法：</p>
<pre><code>给定一个有序序列 1 ... n，为了根据序列构建一棵二叉搜索树。我们可以遍历每个数字 i，将该数字作为树根，1 ... (i-1) 序列将成为左子树，(i+1) ... n 序列将成为右子树。于是，我们可以递归地从子序列构建子树。
在上述方法中，由于根各自不同，每棵二叉树都保证是独特的。

可见，问题可以分解成规模较小的子问题。因此，我们可以存储并复用子问题的解，而不是递归的（也重复的）解决这些子问题，这就是动态规划法。</code></pre>
<p>函数定义：</p>
<pre><code>令G(n)的从1到n可以形成二叉搜索树个数
令f(i)为以i为根的二叉搜索树的个数

所以G(n)是解决问题的函数：G(n) = f(1) + f(2) + f(3) + f(4) + ... + f(n)</code></pre>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/tree.png" alt="tree"></p>
<p>1、定义数组元素的含义<br>    G[i]代表二叉搜索树的个数<br>2、找出数组之间的的关系式<br>    以i为根，[0,i-1]为左节点，[i+1,n]为右节点<br>    之后再对[0,i-1]和[i+1,n]递归求解</p>
<pre><code>f(i)=G(i-1)+G(n-i)
G(n)=f(1) + f(2) + f(3) + f(4) + ... + f(n)
    =G(0)G(n-1)+G(1)G(n-2)+...+G(n-1)G(0)</code></pre>
<p>3、找出初始值<br>    G[0]=1<br>    G[1]=1<br>    G[2]=2</p>
<pre><code>class Solution:
    def numTrees(self, n: int) -&gt; int:
        dp=[0]*(n+1)
        dp[0]=1
        dp[1]=1

        for i in range(2,n+1):
            for j in range(1,i+1):
                dp[i]+=dp[j-1]*dp[i-j]
        # print(dp)
        return dp[n]</code></pre>
<h3 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118.杨辉三角"></a>118.杨辉三角</h3><pre><code>链接：https://leetcode-cn.com/problems/pascals-triangle/

给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。

在杨辉三角中，每个数是它左上方和右上方的数的和。

示例:

输入: 5
输出:
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]</code></pre>
<p>题解一：</p>
<pre><code>class Solution:
    def generate(self, numRows: int) -&gt; List[List[int]]:
        triangle=[]
        for i in range(numRows):
            row=[None for _ in range(i+1)]
            row[0],row[-1]=1,1
            for j in range(1,len(row)-1):
                row[j]=triangle[i-1][j-1]+triangle[i-1][j]
            triangle.append(row)
        return triangle</code></pre>
<p>题解二|动态规划：</p>
<pre><code>1、定义数组元素的含义
    dp存储每个数

2、找出数组之间的的关系式
    遍历dp，将为0的位置使用动态规划填入，公式：dp[i][j]=dp[i-1][j-1]+dp[i-1][j]

3、找出初始值
    初始化结果数组，numRows表示结果数组dp的行数，每一行的元素个数等于所处第几行。全部初始化为0；
    将边界全部初始化为1；</code></pre>
<p>时间复杂度：O(n^2)，等差数列求和。<br>空间复杂度：O(n^2)，等差数列求和。</p>
<pre><code>class Solution:
    def generate(self, numRows: int) -&gt; List[List[int]]:
        dp=[[0]*i for i in range(1,numRows+1)]
        for i in range(numRows):
            dp[i][0]=dp[i][-1]=1
        for i in range(0,numRows):
            for j in range(i+1):
                if dp[i][j]==0:
                    dp[i][j]=dp[i-1][j-1]+dp[i-1][j]
        return dp</code></pre>
<pre><code>class Solution:
    def generate(self, numRows: int) -&gt; List[List[int]]:
        dp=[[1]*i for i in range(1,numRows+1)]
        for i in range(2,numRows):
            for j in range(1,i):
                dp[i][j]=dp[i-1][j-1]+dp[i-1][j]
        return dp</code></pre>
<h3 id="119-杨辉三角-II"><a href="#119-杨辉三角-II" class="headerlink" title="119. 杨辉三角 II"></a>119. 杨辉三角 II</h3><pre><code>链接：https://leetcode-cn.com/problems/pascals-triangle-ii/

给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。

在杨辉三角中，每个数是它左上方和右上方的数的和。

示例:

输入: 3
输出: [1,3,3,1]
进阶：你可以优化你的算法到 O(k) 空间复杂度吗？</code></pre>
<p>题解一|动态规划：</p>
<pre><code>class Solution:
    def getRow(self, rowIndex: int) -&gt; List[int]:
        dp=[[0]* i for i in range(1,rowIndex+2)] # 从1开始的，所以rowIndex+2
        for i in range(rowIndex+1):
            dp[i][0]=dp[i][-1]=1
        for i in range(rowIndex+1):
            for j in range(i+1):
                if dp[i][j]==0:
                    dp[i][j]=dp[i-1][j-1]+dp[i-1][j]
        return dp[rowIndex]</code></pre>
<h3 id="120-三角形最小路径和"><a href="#120-三角形最小路径和" class="headerlink" title="120.三角形最小路径和"></a>120.三角形最小路径和</h3><pre><code>链接：https://leetcode-cn.com/problems/triangle/

给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。

例如，给定三角形：

[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。

说明：

如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。</code></pre>
<p>题解一|动态规划：</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/dp1.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/dp1.png"></p>
<p>1、定义数组的含义</p>
<pre><code>dp[i][j]为最小路径和</code></pre>
<p>2、找出递推关系式</p>
<pre><code>从第二行开始，遍历区间[1,n):
    对每一层的元素进行遍历，遍历区间[0,len(triangle[i])，存在3种情况：
        首位；
        末位；
        其他元素；</code></pre>
<p>3、找到初始值</p>
<pre><code>class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -&gt; int:
        if triangle is None:
            return 0
        m=len(triangle)
        # print(triangle,m,triangle[0]) # m=4,triangle[0]=[2]
        if m==1:
            return triangle[0][0]
        dp=triangle
        for i in range(1,m):
            for j in range(len(triangle[i])):
                if j==0:
                    dp[i][j]=triangle[i-1][j]+triangle[i][j]
                elif j== len(triangle[i])-1:
                    dp[i][j]=triangle[i-1][j-1]+triangle[i][j]
                else:
                    dp[i][j]=min(triangle[i-1][j],triangle[i-1][j-1])+triangle[i][j]
        return min(dp[-1])</code></pre>
<p>优化一下，空间复杂度变为O(n).</p>
<pre><code>class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -&gt; int:
        if triangle is None:
            return 0
        m=len(triangle)
        if m==1:
            return triangle[0][0]
        for i in range(1,m):
            for j in range(len(triangle[i])):
                if j==0:
                    triangle[i][j]+=triangle[i-1][j]
                elif j== len(triangle[i])-1:
                    triangle[i][j]+=triangle[i-1][j-1]
                else:
                    triangle[i][j]+=min(triangle[i-1][j],triangle[i-1][j-1])
        return min(triangle[-1]) # 返回最后一行的最小值
</code></pre>
<h3 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139.单词拆分"></a>139.单词拆分</h3><pre><code>链接：https://leetcode-cn.com/problems/word-break/

给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。

说明：

拆分时可以重复使用字典中的单词。
你可以假设字典中没有重复的单词。
示例 1：

输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]
输出: true
解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。
示例 2：

输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]
输出: true
解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。
     注意你可以重复使用字典中的单词。
示例 3：

输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]
输出: false</code></pre>
<p>题解一|动态规划：</p>
<p>1、定义数组的含义</p>
<pre><code>dp=[False,...,false],长度为n+1，n为字符串长度。
dp[i]表示s的前i位是否可以用wordDict中的单词表示。</code></pre>
<p>2、找出递推关系式</p>
<pre><code>遍历字符串的所有子串，遍历开始索引i，遍历区间[0,n)：
    遍历结束索引j，遍历区间[i+1,n+1)：
        若dp[i]=True且s[i,⋯,j)在wordlist中：dp[j]=True

        解释：dp[i]=True说明s的前i位可以用wordDict表示，则s[i,⋯,j)出现在wordDict中，说明s的前j位可以表示。

返回dp[n]</code></pre>
<p>3、找到初始值</p>
<pre><code>初始化dp[0]=True，空字符可以被表示。</code></pre>
<p>时间复杂度：O(n^2)<br>空间复杂度：O(n)</p>
<pre><code>class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -&gt; bool:
        n=len(s)
        dp=(n+1)*[False]
        dp[0]=True
        for i in range(n):
            for j in range(i+1,n+1):
                if dp[i] and s[i:j] in wordDict:
                    dp[j]=True
        # return dp[n]
        return dp[-1]</code></pre>
<p>题解二|DFS|记忆化递归：</p>
<pre><code>class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -&gt; bool:
        memo=[None] * len(s)
        def dfs(first):
            if first &gt;= len(s):
                return True
            if memo[first] != None:
                return memo[first]

            for i in range(first,len(s)):
                if s[first:i+1] in wordDict and dfs(i+1):
                    memo[first]=True
                    return True
            memo[first]=False
            return False

        return dfs(0)</code></pre>
<p>??题解三|记忆化回溯）:</p>
<pre><code>1、使用记忆化函数，保存出现过的backtrack(s)，避免重复计算。

2、定义回溯函数backtrack(s)

    若s长度为0，则返回True，表示已经使用wordDict中的单词分割完。
    初试化当前字符串是否可以被分割res=False
    遍历结束索引i，遍历区间[1,n+1)：
        若s[0,⋯,i−1]在wordDict中：res=backtrack(s[i,...,n-1]) or  res。
        解释：保存遍历结束索引中，可以使字符串切割完成的情况。
    返回res

3、返回backtrack(s)</code></pre>
<pre><code>class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -&gt; bool:
        import functools
        @functools.lru_cache(None)
        def back_track(s):
            if (not s):
                return True
            res=False
            for i in range(1,len(s)+1):
                if(s[:i] in wordDict):
                    res=back_track(s[i:]) or res
            return res
        return back_track(s)</code></pre>
<p>题解四|BFS|超时：</p>
<pre><code>import collections

class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -&gt; bool:
        visited=[False]*len(s)
        queue=collections.deque()
        queue.append(0)

        while queue:
            i=queue.popleft()
            if visited[i]:
                continue
            else:
                visited[i]=False

            for j in range(i,len(s)):
                if s[i:j+1] in wordDict:
                    if j == len(s)-1:
                        return True
                    else:
                        queue.append(j+1)
        return False</code></pre>
<h3 id="152-乘积最大的连续子序列"><a href="#152-乘积最大的连续子序列" class="headerlink" title="152.乘积最大的连续子序列"></a>152.乘积最大的连续子序列</h3><pre><code>链接：https://leetcode-cn.com/problems/maximum-product-subarray/

给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。

示例 1:

输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
示例 2:

输入: [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</code></pre>
<p>题解一|动态规划:</p>
<p>此题类似于52题最大子序和，唯一的区别是：由于存在负数，那么会导致最大的变最小的，最小的变最大的，因此还需要维护当前最小值minTmp，minTmp = min(minTmp * nums[i], nums[i])</p>
<p>1、定义数组元素的含义</p>
<pre><code>dp[i]为以num[i]结尾的子段的最大子段乘积
dp[1]为以num[1]结尾的最大子段乘积</code></pre>
<p>2、寻找递推表达式</p>
<pre><code>只考虑第一个元素，则最大子段和为其本身 dp[0] = nums[0]

考虑前两个元素，最大子段和为 nums[0],num[1]以及 nums[0]*num[1] 中最大值 设为dp[1]

考虑前三个元素，如何求其最大子段乘积？还是分为两种情况讨论，第三个元素在最后的字串内吗？

若第三个元素也包含在最后的字串内，则dp[2] = Max(dp[1]*nums[2] , nums[2])

dp[i]=max(dp[i-1]*num[i],num[i])
由于存在负数：
dp_[i]=min(dp_[i-1]*num[i],num[i])</code></pre>
<p>3、找出初始值</p>
<pre><code>dp[0]=num[0]
dp[1]=max(dp[0]* num[1],num[1])</code></pre>
<pre><code>class Solution:
    def maxProduct(self, nums: List[int]) -&gt; int:
        lens=len(nums)
        if lens==0:
            return 0
        dp=lens*[0]
        mindp=lens*[0]
        dp[0]=nums[0]
        mindp[0]=nums[0]
        res=nums[0]
        for i in range(1,lens):
            dp[i]=max(dp[i-1]*nums[i],nums[i],mindp[i-1]*nums[i])
            mindp[i]=min(dp[i-1]*nums[i],nums[i],mindp[i-1]*nums[i])
            res=max(res,dp[i])
        return res</code></pre>
<pre><code>class Solution:
    def maxProduct(self, nums: List[int]) -&gt; int:
        lens=len(nums)
        if lens==0:
            return 0
        res=float(&#39;-inf&#39;)
        maxTmp=1
        minTmp=1
        for i in range(lens):
            if nums[i]&lt;0:
                maxTmp,minTmp=minTmp,maxTmp
            maxTmp=max(maxTmp*nums[i],nums[i])
            minTmp=min(minTmp*nums[i],nums[i])

            res=max(res,maxTmp)
        return res</code></pre>
<h3 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221.最大正方形"></a>221.最大正方形</h3><pre><code>链接：https://leetcode-cn.com/problems/maximal-square/

在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。

示例:

输入: 

1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0

输出: 4</code></pre>
<p>题解一|动态规划：</p>
<p>1、定义数组元素的含义</p>
<pre><code>dp[i][j]表示以(i,j)为右下角，且只包含1的正方形边长最大值;
计算出所有 dp(i,j) 的值，那么其中的最大值即为矩阵中只包含 1 的正方形的边长最大值，其平方即为最大正方形的面积。</code></pre>
<p>2、寻找递推表达式</p>
<pre><code>如果该位置的值是 0，则 dp(i,j)=0，因为当前位置不可能在由 1 组成的正方形中；

如果该位置的值是 1，则 dp(i,j) 的值由其上方、左方和左上方的三个相邻位置的 dp值决定。具体而言，当前位置的元素值等于三个相邻位置的元素中的最小值加 1，状态转移方程如下：

dp(i,j)=min(dp(i−1,j),dp(i−1,j−1),dp(i,j−1))+1</code></pre>
<p>3、找出初始值</p>
<pre><code>if matrix[i][j]==&#39;1&#39;:
    if i==0 or j==0:
        dp[i][j]=1</code></pre>
<pre><code>class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -&gt; int:
        if len(matrix)==0 or len(matrix[0])==0:
            return 0
        maxSide=0
        rows,columns=len(matrix),len(matrix[0])
        dp=[[0]*columns for _ in range(rows)]
        for i in range(rows):
            for j in range(columns):
                if matrix[i][j]==&#39;1&#39;:
                    if i==0 or j==0:
                        dp[i][j]=1
                    else:
                        dp[i][j]=min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1
                    maxSide=max(maxSide,dp[i][j])
        maxSquare=maxSide*maxSide
        return maxSquare
</code></pre>
<h3 id="264-丑数-II"><a href="#264-丑数-II" class="headerlink" title="264. 丑数 II"></a>264. 丑数 II</h3><pre><code>链接：https://leetcode-cn.com/problems/ugly-number-ii/

编写一个程序，找出第 n 个丑数。

丑数就是质因数只包含 2, 3, 5 的正整数。

示例:

输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。
说明:  

1 是丑数。
n 不超过1690。</code></pre>
<p>题解一|动态规划+3个指针:</p>
<pre><code>class Solution:
    def nthUglyNumber(self, n: int) -&gt; int:
        nums=[1]
        i2=i3=i5=0
        for i in range(1,n):
            ugly=min(nums[i2]*2,nums[i3]*3,nums[i5]*5)
            nums.append(ugly)
            if ugly == nums[i2]*2:
                i2+=1
            if ugly == nums[i3]*3:
                i3+=1
            if ugly== nums[i5]*5:
                i5+=1
        return nums[n-1]</code></pre>
<h3 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a>279. 完全平方数</h3><pre><code>链接：https://leetcode-cn.com/problems/perfect-squares/

给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。

示例 1:

输入: n = 12
输出: 3 
解释: 12 = 4 + 4 + 4.
示例 2:

输入: n = 13
输出: 2
解释: 13 = 4 + 9.</code></pre>
<p>题解一|动态规划：</p>
<p>1、定义数组元素的含义</p>
<pre><code>dp[i]表示i最少可以由几个平方数构成</code></pre>
<p>2、寻找递推表达式</p>
<pre><code>遍历dp，对于i，遍历区间[2,n+1)：
    遍历所有平方数小于i的数j，遍历区间[1,int(\sqrt&#123;i&#125;)+1):
        dp[i]=min(dp[i],dp[i-j*j]+1)
        始终保存所有可能情况中的最小值
返回dp[n]</code></pre>
<p>3、找出初始值<br>    dp=[0,1,2,…,n]，长度为n+1，最多次数就是全由1构成。</p>
<p>时间复杂度：O(n\sqrt{n})<br>空间复杂度：O(n)</p>
<pre><code>import math
class Solution:
    def numSquares(self, n: int) -&gt; int:
        dp=[i for i in range(n+1)]
        for i in range(2,n+1):
            for j in range(1,int(math.sqrt(i))+1): # 开方也可使用i**0.5
                dp[i]=min(dp[i],dp[i-j*j]+1)
        return dp[n]</code></pre>
<p>题解二|广度优先遍历bfs：</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/bfs.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/bfs.png"></p>
<p>借助队列实现广度优先遍历（层次遍历）:</p>
<pre><code>1、初始化队列queue=[n]，访问元组visited=&#123;&#125;，初试化路径长度step=0
2、特判，若n==0，返回0。
3、循环条件，队列不为空：

    step+=1，因为循环一次，意味着一层中的节点已经遍历完，所以路径长度需要加一。
    定义当前层中的节点数length=len(queue)，遍历当前层的所有节点：
        令tmp为队首元素。
        遍历所有可能数i的平方数，遍历区间[1,int(\sqrt&#123;tmp&#125;)+1)：
            定义x=tmp-i^2
            若x==0，返回当前的路径长度。
            若x not in visited，表示当前节点未出现过：将该节点入队并在访问数组中加入。
4、返回step</code></pre>
<p>时间复杂度：O(n*\sqrt{n})，并不准确<br>空间复杂度：O(n)</p>
<pre><code>from collections import deque
class Solution:
    def numSquares(self, n: int) -&gt; int:
        if n==0:
            return 0
        queue=deque([n])
        visited=set()
        step=0
        while queue:
            step+=1
            length=len(queue)
            for _ in range(length):
                tmp=queue.pop()
                for j in range(1,int(tmp**0.5)+1):
                    node=tmp-j**2
                    if node==0:
                        return step
                    if node not in visited:
                        queue.appendleft(node)
                        visited.add(node)
        return step</code></pre>
<h3 id="继续理解-300-最长上升子序列"><a href="#继续理解-300-最长上升子序列" class="headerlink" title="继续理解 300. 最长上升子序列"></a>继续理解 300. 最长上升子序列</h3><pre><code>链接：https://leetcode-cn.com/problems/longest-increasing-subsequence/

给定一个无序的整数数组，找到其中最长上升子序列的长度。

示例:

输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
说明:

可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
你算法的时间复杂度应该为 O(n^2) 。
进阶: 你能将算法的时间复杂度降低到 O(n*logn) 吗?</code></pre>
<p>题解一|动态规划：</p>
<p>1、定义数组元素的含义</p>
<pre><code>定义 dp[i] 为考虑前 i 个元素，以第 i 个数字结尾的最长上升子序列的长度，注意 nums[i] 必须被选取。</code></pre>
<p>2、寻找递推表达式</p>
<pre><code>从小到大计算 dp[] 数组的值，在计算 dp[i] 之前，我们已经计算出 dp[0…i−1] 的值:
dp[i]=max(dp[j])+1,其中0≤j&lt;i且num[j]&lt;num[i]</code></pre>
<p>3、找出初始值<br>    dp[i]=1，1 个字符显然是长度为 1 的上升子序列。</p>
<p>时间复杂度：O(n^2)，其中 n 为数组 nums 的长度。动态规划的状态数为 n，计算状态 dp[i] 时，需要 O(n) 的时间遍历 dp[0…i−1] 的所有状态，所以总时间复杂度为 O(n^2)<br>空间复杂度：O(n)，需要额外使用长度为 n 的 dp 数组。</p>
<pre><code>class Solution:
    def lengthOfLIS(self, nums: List[int]) -&gt; int:
        if not nums:
            return 0
        dp=[]
        for i in range(len(nums)):
            dp.append(1)
            for j in range(i):
                if nums[i]&gt;nums[j]:
                    dp[i]=max(dp[i],dp[j]+1)
        return max(dp)</code></pre>
<p>题解二|动态规划+二分查找：</p>
<p>1、定义数组元素的含义</p>
<pre><code>tails[k] 的值代表 长度为 k+1 子序列 的尾部元素值。</code></pre>
<p>2、寻找递推表达式</p>
<pre><code>设 res 为 tails 当前长度，代表直到当前的最长上升子序列长度。设 j∈[0,res)，考虑每轮遍历 nums[k] 时，通过二分法遍历 [0,res) 列表区间，找出 nums[k]的大小分界点，会出现两种情况：

    区间中存在 tails[i] &gt; nums[k] ： 将第一个满足 tails[i] &gt; nums[k]执行 tails[i] = nums[k] ；因为更小的 nums[k]后更可能接一个比它大的数字。

    区间中不存在 tails[i] &gt; nums[k] ： 意味着 nums[k]可以接在前面所有长度的子序列之后，因此肯定是接到最长的后面（长度为 res），新子序列长度为 res + 1。</code></pre>
<p>3、找出初始值<br>    tails[i]=0，tails 列表所有值 =0。</p>
<p>4、返回 res ，即最长上升子子序列长度。</p>
<p>时间复杂度 O(NlogN) ： 遍历 nums 列表需 O(N)，在每个 nums[i] 二分法需 O(logN)<br>空间复杂度 O(N) ： tails 列表占用线性大小额外空间。</p>
<pre><code>class Solution:
    def lengthOfLIS(self, nums: List[int]) -&gt; int:
        if not nums:
            return 0
        tails,res=[0]*len(nums),0
        for num in nums:
            i,j=0,res
            while i&lt;j:
                m=(i+j)//2
                if tails[m]&lt;num:
                    i=m+1
                else:
                    j=m
            tails[i]=num
            if j==res:
                res+=1
        return res</code></pre>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/02o_OPgePjaz3dXnw9TA1w">https://mp.weixin.qq.com/s/02o_OPgePjaz3dXnw9TA1w</a></p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/search.jpg" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/search.jpg"></p>
<h3 id="303-区域和检索-数组不可变"><a href="#303-区域和检索-数组不可变" class="headerlink" title="303. 区域和检索 - 数组不可变"></a>303. 区域和检索 - 数组不可变</h3><pre><code>链接：https://leetcode-cn.com/problems/range-sum-query-immutable/

给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。

示例：

给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()

sumRange(0, 2) -&gt; 1
sumRange(2, 5) -&gt; -1
sumRange(0, 5) -&gt; -3
说明:

你可以假设数组不可变。
会多次调用 sumRange 方法。</code></pre>
<p>题解一|暴力：</p>
<pre><code>缺点：每次调用sumRange都要重新进行计算</code></pre>
<pre><code>class NumArray:

    def __init__(self, nums: List[int]):
        self.nums=nums

    def sumRange(self, i: int, j: int) -&gt; int:
        sum=0
        for each in range(i,j+1):
            sum+=self.nums[each]
        return sum

# Your NumArray object will be instantiated and called as such:
# obj = NumArray(nums)
# param_1 = obj.sumRange(i,j)</code></pre>
<p>题解二|缓存+动态规划：</p>
<pre><code>class NumArray:

    def __init__(self, nums: List[int]):
        self.nums=nums
        if not nums:
            return
        n=len(nums)
        self.dp=[0]*(n+1)
        self.dp[1]=nums[0]
        for i in range(2,n+1):
            self.dp[i]=self.dp[i-1]+nums[i-1]

    def sumRange(self, i: int, j: int) -&gt; int:
        return self.dp[j+1]-self.dp[i]

# Your NumArray object will be instantiated and called as such:
# obj = NumArray(nums)
# param_1 = obj.sumRange(i,j)</code></pre>
<pre><code>class NumArray:

    def __init__(self, nums: List[int]):
        self.nums=nums
        if not nums:
            return
        n=len(nums)
        self.dp=[0]*(n+1)
        for i in range(0,n):
            self.dp[i+1]=self.dp[i]+nums[i]
        # print(self.dp)

    def sumRange(self, i: int, j: int) -&gt; int:
        return self.dp[j+1]-self.dp[i]

# Your NumArray object will be instantiated and called as such:
# obj = NumArray(nums)
# param_1 = obj.sumRange(i,j)</code></pre>
<h3 id="304-二维区域和检索-矩阵不可变"><a href="#304-二维区域和检索-矩阵不可变" class="headerlink" title="304. 二维区域和检索 - 矩阵不可变"></a>304. 二维区域和检索 - 矩阵不可变</h3><pre><code>链接：https://leetcode-cn.com/problems/range-sum-query-2d-immutable/

给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2)。

Range Sum Query 2D
上图子矩阵左上角 (row1, col1) = (2, 1) ，右下角(row2, col2) = (4, 3)，该子矩形内元素的总和为 8。

示例:

给定 matrix = [
  [3, 0, 1, 4, 2],
  [5, 6, 3, 2, 1],
  [1, 2, 0, 1, 5],
  [4, 1, 0, 1, 7],
  [1, 0, 3, 0, 5]
]

sumRegion(2, 1, 4, 3) -&gt; 8
sumRegion(1, 1, 2, 2) -&gt; 11
sumRegion(1, 2, 2, 4) -&gt; 12
说明:

你可以假设矩阵不可变。
会多次调用 sumRegion 方法。
你可以假设 row1 ≤ row2 且 col1 ≤ col2。</code></pre>
<p>题解一|动态规划：</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/dp22.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/dp22.png"></p>
<pre><code>sum(abcd)=sum(od)−sum(ob)−sum(oc)+sum(oa)</code></pre>
<p>1、定义数组的含义</p>
<pre><code>dp[i][j]表示矩阵左上角到matrix[i][j]的累加和</code></pre>
<pre><code>class NumMatrix:

    def __init__(self, matrix: List[List[int]]):

        if not matrix or not matrix[0]:pass
        else:
            row = len(matrix)
            col = len(matrix[0])
            self.dp = [[ 0 ] * (col + 1) for _ in range(row + 1)]
            # 求行的前缀和
            for i in range(1, row + 1):
                for j in range(1 ,col + 1):
                    self.dp[i][j] = self.dp[i][j - 1] + matrix[i - 1][j - 1] 
            # 求列的前缀和
            for j in range(1, col + 1):
                for i in range(1, row + 1):
                    self.dp[i][j] += self.dp[i - 1][j]
            # print(self.dp)

    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -&gt; int:
        return self.dp[row2 + 1][col2 + 1] - self.dp[row1][col2 + 1] - self.dp[row2 + 1][col1] + self.dp[row1][col1]

# Your NumMatrix object will be instantiated and called as such:
# obj = NumMatrix(matrix)
# param_1 = obj.sumRegion(row1,col1,row2,col2)</code></pre>
<pre><code>class NumMatrix:

    def __init__(self, matrix: List[List[int]]):

        if not matrix or not matrix[0]:pass
        else:
            row = len(matrix)
            col = len(matrix[0])
            self.dp = [[ 0 ] * (col + 1) for _ in range(row + 1)]

            for i in range(1, row + 1):
                for j in range(1, col + 1):
                    self.dp[i][j] = matrix[i - 1][j - 1] + self.dp[i - 1][j] + self.dp[i][j - 1] - self.dp[i-1][j-1] # [i-1, j-1]重复计算了, 所以需要减去.

    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -&gt; int:
        return self.dp[row2 + 1][col2 + 1] - self.dp[row1][col2 + 1] - self.dp[row2 + 1][col1] + self.dp[row1][col1]

# Your NumMatrix object will be instantiated and called as such:
# obj = NumMatrix(matrix)
# param_1 = obj.sumRegion(row1,col1,row2,col2)</code></pre>
<h3 id="334-递增的三元子序列"><a href="#334-递增的三元子序列" class="headerlink" title="334. 递增的三元子序列"></a>334. 递增的三元子序列</h3><pre><code>链接：https://leetcode-cn.com/problems/increasing-triplet-subsequence/

给定一个未排序的数组，判断这个数组中是否存在长度为 3 的递增子序列。

数学表达式如下:

如果存在这样的 i, j, k,  且满足 0 ≤ i &lt; j &lt; k ≤ n-1，
使得 arr[i] &lt; arr[j] &lt; arr[k] ，返回 true ; 否则返回 false 。
说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1) 。

示例 1:

输入: [1,2,3,4,5]
输出: true
示例 2:

输入: [5,4,3,2,1]
输出: false</code></pre>
<p>题解一|动态规划：</p>
<p>时间复杂度：O(n^2)<br>空间复杂度：O(n)</p>
<pre><code>class Solution:
    def increasingTriplet(self, nums: List[int]) -&gt; bool:
        n=len(nums)
        dp=[1]*n
        for i in range(1,n):
            for j in range(i):
                if nums[j]&lt;nums[i]:
                    dp[i]=max(dp[i],dp[j]+1)
                if dp[i]&gt;=3:
                    return True
        return False
</code></pre>
<p>题解二|双指针：</p>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<pre><code>class Solution:
    def increasingTriplet(self, nums: List[int]) -&gt; bool:
        m1,m2=float(&#39;inf&#39;),float(&#39;inf&#39;)
        for i in nums:
            if m1&gt;=i:
                m1=i
            elif m2&gt;=i:
                m2=i
            else:
                return True
        return False</code></pre>
<h3 id="338-比特位计数"><a href="#338-比特位计数" class="headerlink" title="338. 比特位计数"></a>338. 比特位计数</h3><pre><code>链接：https://leetcode-cn.com/problems/counting-bits/

给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。

示例 1:

输入: 2
输出: [0,1,1]
示例 2:

输入: 5
输出: [0,1,1,2,1,2]
进阶:

给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？
要求算法的空间复杂度为O(n)。
你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount）来执行此操作。</code></pre>
<p>题解一|动态规划：</p>
<p>1、定义数组含义</p>
<pre><code>dp[i]表示数字i计算其二进制数中的 1 的数目。</code></pre>
<p>2、找出数组递推关系式</p>
<pre><code>当i为奇数时：
    奇数一定比前面那个偶数多一个 1，因为多的就是最低位的 1。
当i为偶数时：
    二进制是逢2开始进位的，也就是在偶数的时候，一个偶数相当一另一个数成以2得到，在二进制运算中，就是左移一位，也就是在低位多加1个0，故遇到偶数的时候就是dp[i] = dp[i/2]。</code></pre>
<p>3、找到初始值</p>
<pre><code>dp[0]=0
dp[1]=1</code></pre>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<pre><code>class Solution:
    def countBits(self, num: int) -&gt; List[int]:
        if num==0:
            return [0]
        dp=[0]*(num+1)
        dp[0]=0
        dp[1]=1
        for i in range(2,num+1):
            if i%2==0:
                dp[i]=dp[i//2]
            else:
                dp[i]=dp[i-1]+1
        return dp</code></pre>
<h3 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343. 整数拆分"></a>343. 整数拆分</h3><pre><code>链接：https://leetcode-cn.com/problems/integer-break/

给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

示例 1:

输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
示例 2:

输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
说明: 你可以假设 n 不小于 2 且不大于 58。</code></pre>
<p>题解一|动态规划</p>
<p>1、定义数组</p>
<pre><code>dp[i]代表i拆分后的最大乘积</code></pre>
<p>2、递推表达式</p>
<pre><code>dp[i]=max(dp[i],j*(i-j),j*dp[i-j])

(i - j) * j 代表的是整数 i 拆分成 2 部分, 分别为 (i - j) * j；

j * dp[i - j]代表的是整数 i 拆 2 部分以上， dp[i - j] 就是代表在之前的动态规划求得的整数 i - j 的分割最大的乘积</code></pre>
<p>3、初始值<br>    dp[i]=1，从3开始。</p>
<pre><code>class Solution:
    def integerBreak(self, n: int) -&gt; int:
        dp=[1 for i in range(n+1)]
        for i in range(3,n+1):
            for j in range(1,i):
                dp[i]=max(dp[i],j*(i-j),j*dp[i-j])
        return dp[n]</code></pre>
<h3 id="354-俄罗斯套娃信封问题"><a href="#354-俄罗斯套娃信封问题" class="headerlink" title="354. 俄罗斯套娃信封问题"></a>354. 俄罗斯套娃信封问题</h3><pre><code>链接：https://leetcode-cn.com/problems/russian-doll-envelopes/

给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 (w, h) 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。

请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。

说明:
不允许旋转信封。

示例:

输入: envelopes = [[5,4],[6,4],[6,7],[2,3]]
输出: 3 
解释: 最多信封的个数为 3, 组合为: [2,3] =&gt; [5,4] =&gt; [6,7]。</code></pre>
<p>题解一|动态规划|超时</p>
<pre><code>class Solution:
    def maxEnvelopes(self, envelopes: List[List[int]]) -&gt; int:
        if not envelopes:
            return 0
        envelopes=sorted(envelopes,key=lambda x:(x[0],-x[1]))
        dp=[1]*len(envelopes)
        count=1
        for i in range(len(envelopes)):
            for j in range(i):
                if envelopes[i][1] &gt; envelopes[j][1] and dp[j]+1 &gt; dp[i]:
                    dp[i]=dp[j]+1
                count=max(count,dp[i])
        return count</code></pre>
<p>稍微修改下，通过：</p>
<pre><code>class Solution:
    def maxEnvelopes(self, envelopes: List[List[int]]) -&gt; int:
        if not envelopes:
            return 0
        envelopes=sorted(envelopes,key=lambda x:(x[0],-x[1]))
        dp=[1]*len(envelopes)
        for i in range(len(envelopes)):
            for j in range(i):
                if envelopes[i][1] &gt; envelopes[j][1] and dp[j]+1 &gt; dp[i]:
                    dp[i]=max(dp[i],dp[j]+1)
        return max(dp)</code></pre>
<h3 id="357-计算各个位数不同的数字个数"><a href="#357-计算各个位数不同的数字个数" class="headerlink" title="357. 计算各个位数不同的数字个数"></a>357. 计算各个位数不同的数字个数</h3><pre><code>链接：https://leetcode-cn.com/problems/count-numbers-with-unique-digits/

给定一个非负整数 n，计算各位数字都不同的数字 x 的个数，其中 0 ≤ x &lt; 10^n 。

示例:

输入: 2
输出: 91 
解释: 答案应为除去 11,22,33,44,55,66,77,88,99 外，在 [0,100) 区间内的所有数字。</code></pre>
<p>题解一|动态规划:</p>
<pre><code>数字一共有0~9十个，所以n超过十位一定会重复。

1位 10
2位 9*9+10 （第一位不能0）
3位 9*9*8+9*9+10
4位 9*9*8*7+9*9*8+9*9+10
...
i位 dp1[i] = dp2[i-1]*(10-(i-1))+dp1[i-1]  （i从2开始，dp1[1] = 10, dp2[1] = 9）</code></pre>
<pre><code>class Solution:
    def countNumbersWithUniqueDigits(self, n: int) -&gt; int:
        if n==0:
            return 1
        dp1=[0]*(n+1)
        dp2=[0]*(n+1)
        dp1[1]=10
        dp2[1]=9
        for i in range(2,min(11,n+1)):
            dp2[i]=dp2[i-1]*(10-(i-1))
            dp1[i]=dp2[i]+dp1[i-1]
        if n&gt;=11:
            return dp[10]
        return dp1[n]</code></pre>
<pre><code>class Solution:
    def countNumbersWithUniqueDigits(self, n: int) -&gt; int:
        if n==0:
            return 1
        fisrt,second=10,9*9
        size=min(n,10)
        for i in range(2,size+1):
            fisrt+=second
            second*=(10-i)
        return fisrt</code></pre>
<p>??题解二|回溯：</p>
<pre><code>class Solution:
    def countNumbersWithUniqueDigits(self, n: int) -&gt; int:
        used=[False]*10
        def backtrace(first,used):
            count=0
            if first != n:
                for i in range(10):
                    # 剪枝：多位数时，第一个数字不能为0
                    if i==0 and n&gt;1 and first==1:
                        continue
                    if used[i]:
                        continue
                    used[i]=True
                    count+=backtrace(first+1,used)+1
                    used[i]=False
            return count
        if not n:
            return 1
        return backtrace(0,used)</code></pre>
<h3 id="368-最大整除子集"><a href="#368-最大整除子集" class="headerlink" title="368. 最大整除子集"></a>368. 最大整除子集</h3><pre><code>链接：https://leetcode-cn.com/problems/largest-divisible-subset/

给出一个由无重复的正整数组成的集合，找出其中最大的整除子集，子集中任意一对 (Si，Sj) 都要满足：Si % Sj = 0 或 Sj % Si = 0。

如果有多个目标子集，返回其中任何一个均可。

示例 1:

输入: [1,2,3]
输出: [1,2] (当然, [1,3] 也正确)
示例 2:

输入: [1,2,4,8]
输出: [1,2,4,8]</code></pre>
<p>题解一|动态规划：</p>
<p>1、sorted()排序；<br>2、dp[i]表示以下标i位置元素结尾得最长序列。<br>3、遍历0-(i-1)，如果nums[i]整除nums[j]，则判断dp[i]和dp[j] + 1哪个大</p>
<pre><code>class Solution:
    def largestDivisibleSubset(self, nums: List[int]) -&gt; List[int]:
        if not nums:
            return []
        nums=sorted(nums)
        dp=[[i] for i in nums]
        res=[]
        for i in range(0,len(nums)):
            for j in range(0,i):
                if nums[i]%nums[j]==0:
                    if len(dp[i])&lt;len(dp[j]+[nums[i]]):
                        dp[i]=dp[j]+[nums[i]]
            if len(dp[i])&gt;len(res):
                res=dp[i]
        return res</code></pre>
<h3 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392. 判断子序列"></a>392. 判断子序列</h3><pre><code>链接：https://leetcode-cn.com/problems/is-subsequence/

给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 &lt;=100）。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，&quot;ace&quot;是&quot;abcde&quot;的一个子序列，而&quot;aec&quot;不是）。

示例 1:
s = &quot;abc&quot;, t = &quot;ahbgdc&quot;

返回 true.

示例 2:
s = &quot;axc&quot;, t = &quot;ahbgdc&quot;

返回 false.

后续挑战 :

如果有大量输入的 S，称作S1, S2, ... , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</code></pre>
<p>题解一|双指针：</p>
<pre><code>class Solution:
    def isSubsequence(self, s: str, t: str) -&gt; bool:
        p,q=0,0
        count=0
        while p&lt;len(s) and q&lt;len(t):
            if s[p]==t[q]:
                count+=1
                p+=1
            q+=1
        return p==len(s)</code></pre>
<p>题解二|二分+哈希：</p>
<pre><code>class Solution:
    def isSubsequence(self, s: str, t: str) -&gt; bool:
        hash=&#123;&#125;
        for i,word in enumerate(t):
            if word not in hash:
                hash[word]=[i] # 注意这里是列表
            else:
                hash[word].append(i)

        index = -1
        for word in s:
            if word not in hash:
                return False
            # 字母s出现的索引 用二分法找到其中大于index的第一个
            indexes = hash[word]
            left = 0
            right = len(indexes)
            while left &lt; right:
                mid = left + (right - left) // 2
                if indexes[mid] &gt; index:
                    right = mid
                else:
                    left = mid + 1
            if left == len(indexes):
                return False
            index = indexes[left]

        return True</code></pre>
<h3 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516. 最长回文子序列"></a>516. 最长回文子序列</h3><pre><code>给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。

示例 1:
输入:

&quot;bbbab&quot;
输出:

4
一个可能的最长回文子序列为 &quot;bbbb&quot;。

示例 2:
输入:

&quot;cbbd&quot;
输出:

2
一个可能的最长回文子序列为 &quot;bb&quot;。

提示：

1 &lt;= s.length &lt;= 1000
s 只包含小写英文字母</code></pre>
<p>题解一|动态规划：</p>
<p>1、dp 数组的定义是：在子串s[i..j]中，最长回文子序列的长度为dp[i][j]</p>
<p>2、状态转移方程</p>
<pre><code>if (s[i] == s[j])
    // 它俩一定在最长回文子序列中
    dp[i][j] = dp[i + 1][j - 1] + 2;
else
    // s[i+1..j] 和 s[i..j-1] 谁的回文子序列更长？
    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);</code></pre>
<p>答案：dp[0][n - 1]，也就是整个s的最长回文子序列的长度。</p>
<p>3、bad case</p>
<p>如果只有一个字符，显然最长回文子序列长度是 1，也就是dp[i][j] = 1,(i == j)。</p>
<p>因为i肯定小于等于j，所以对于那些i &gt; j的位置，根本不存在什么子序列，应该初始化为 0。</p>
<p>为了保证每次计算dp[i][j]，左、下、左下三个方向的位置已经被计算出来，只能斜着遍历或者反着遍历：</p>
<pre><code>class Solution:
    def longestPalindromeSubseq(self, s: str) -&gt; int:
        n=len(s)
        dp=[[0]*n for i in range(n)]

        for i in range(n):
            dp[i][i]=1

        # 反着遍历保证正确的状态转移
        for i in range(n-1,-1,-1):
            for j in range(i+1,n):
                if s[i] == s[j]:
                    dp[i][j]=dp[i+1][j-1]+2
                else:
                    dp[i][j]=max(dp[i+1][j],dp[i][j-1])
        return dp[0][n-1]
</code></pre>
<h3 id="651-4键键盘"><a href="#651-4键键盘" class="headerlink" title="???651.4键键盘"></a>???651.4键键盘</h3><p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/keyborad.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/keyborad.png"></p>
<p>如何在 N 次敲击按钮后得到最多的 A？</p>
<p>对 dp 数组的不同定义需要完全不同的逻辑，从而产生完全不同的解法。</p>
<p>题解一：</p>
<p>流程：对于动态规划问题，首先要明白有哪些「状态」，有哪些「选择」。</p>
<p>有哪些「选择」是很明显的：</p>
<pre><code>4 种，就是题目中提到的四个按键，分别是A、C-A、C-C、C-V（Ctrl简写为C）。</code></pre>
<p>有哪些「状态」？或者换句话说，我们需要知道什么信息，才能将原问题分解为规模更小的子问题？</p>
<p>定义三个状态行不行：</p>
<pre><code>第一个状态是剩余的按键次数，用n表示；
第二个状态是当前屏幕上字符 A 的数量，用a_num表示；
第三个状态是剪切板中字符 A 的数量，用copy表示。</code></pre>
<p>如此定义「状态」，就可以知道 base case：当剩余次数n为 0 时，a_num就是我们想要的答案。</p>
<p>结合刚才说的 4 种「选择」，我们可以把这几种选择通过状态转移表示出来：</p>
<pre><code>dp(n - 1, a_num + 1, copy),    # A
解释：按下 A 键，屏幕上加一个字符
同时消耗 1 个操作数

dp(n - 1, a_num + copy, copy), # C-V
解释：按下 C-V 粘贴，剪切板中的字符加入屏幕
同时消耗 1 个操作数

dp(n - 2, a_num, a_num)        # C-A C-C
解释：全选和复制必然是联合使用的，
剪切板中 A 的数量变为屏幕上 A 的数量
同时消耗 2 个操作数</code></pre>
<p>问题的规模n在不断减小，肯定可以到达n = 0的 base case，所以这个思路是正确的：</p>
<pre><code>def maxA(n):
    def dp(n,a_num,copy):
        # 初始值
        if n&lt;=0:
            return a_num
        # 所有选择全部试一遍，选择最大结果
        return max(
            dp(n-1,a_num+1,copy),
            dp(n-1,a_num+copy,copy),
            dp(n-2,a_num,a_num)
            )
    return dp(n,0,0) # 可以按n次按键，屏幕和剪切板种还没有A</code></pre>
<p>优化：</p>
<pre><code>def maxA(n):
    memo=dict()
    def dp(n,a_num,copy):
        # 初始值
        if n&lt;=0:
            return a_num
        # 避免计算重叠子问题
        if (n,a_num,copy) in demo:
            return memo[(n,a_num,copy)]

        memo[(n,a_num,copy)]= max(
            dp(n-1,a_num+1,copy),
            dp(n-1,a_num+copy,copy),
            dp(n-2,a_num,a_num)
            )
        return memo[(n,a_num,copy)]
    return dp(n,0,0) # 可以按n次按键，屏幕和剪切板种还没有A</code></pre>
<p>可以把这个 dp 函数写成 dp 数组：</p>
<pre><code>dp[n][a_num][copy] #状态的总数（时空复杂度）就是这个三维数组的体积</code></pre>
<p>我们知道变量n最多为N，但是a_num和copy最多为多少我们很难计算，复杂度起码也有 O(N^3) 吧。</p>
<p>题解二：</p>
<p>「选择」还是那 4 个，但是这次我们只定义一个「状态」，也就是剩余的敲击次数n。</p>
<p>最优按键序列一定只有两种情况：</p>
<pre><code>要么一直按A：A,A,…A（当 N 比较小时）。

要么是这么一个形式：A,A,…C-A,C-C,C-V,C-V,…C-V（当 N 比较大时）。</code></pre>
<p>因为字符数量少（N 比较小）时，C-A C-C C-V这一套操作的代价相对比较高，可能不如一个个按A；而当 N 比较大时，后期C-V的收获肯定很大。这种情况下整个操作序列大致是：开头连按几个A，然后C-A C-C组合再接若干C-V，然后再C-A C-C接着若干C-V，循环下去。</p>
<p>换句话说，最后一次按键要么是A要么是C-V。明确了这一点，可以通过这两种情况来设计算法：</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&amp;mid=2247486045&amp;idx=2&amp;sn=c270733b9ea06403ab9851bbc5d935db&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&amp;mid=2247486045&amp;idx=2&amp;sn=c270733b9ea06403ab9851bbc5d935db&amp;scene=21#wechat_redirect</a></p>
<h3 id="673-最长递增子序列的个数"><a href="#673-最长递增子序列的个数" class="headerlink" title="673. 最长递增子序列的个数"></a>673. 最长递增子序列的个数</h3><pre><code>链接：https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/

给定一个未排序的整数数组，找到最长递增子序列的个数。

示例 1:

输入: [1,3,5,4,7]
输出: 2
解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。
示例 2:

输入: [2,2,2,2,2]
输出: 5
解释: 最长递增子序列的长度是1，并且存在5个子序列的长度为1，因此输出5。</code></pre>
<p>题解一|动态规划：</p>
<pre><code>class Solution:
    def findNumberOfLIS(self, nums: List[int]) -&gt; int:
        if not nums:
            return 0
        dp=[1]*len(nums)
        count=[1]*len(nums)
        MAX=0
        for i in range(len(nums)):
            for j in range(i):
                if nums[i] &gt; nums[j]:
                    if dp[j]+1 &gt; dp[i]: # 代表第一次遇到最长子序列
                        dp[i]=max(dp[i],dp[j]+1)
                        count[i]=count[j]
                    elif dp[j]+1 == dp[i]: # 代表已经遇到最长子序列
                        count[i]+=count[j]
        MAX = max(dp)
        res=0
        for i in range(len(nums)):
            if dp[i]==MAX:
                res+=count[i]
        return res</code></pre>
<h3 id="674-最长连续递增序列"><a href="#674-最长连续递增序列" class="headerlink" title="674. 最长连续递增序列"></a>674. 最长连续递增序列</h3><pre><code>链接：https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/

给定一个未经排序的整数数组，找到最长且连续的的递增序列，并返回该序列的长度。

示例 1:

输入: [1,3,5,4,7]
输出: 3
解释: 最长连续递增序列是 [1,3,5], 长度为3。
尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。 
示例 2:

输入: [2,2,2,2,2]
输出: 1
解释: 最长连续递增序列是 [2], 长度为1。</code></pre>
<p>题解一|动态规划：</p>
<p>1、数组定义：dp[i]代表nums[i]值结尾的最长连续递增序列的长度<br>2、状态转移方程</p>
<pre><code>nums[i]＞nums[i−1]，i至少可以与i-1形成一个连续递增序列，因为它们俩挨着，并且是递增的，长度上是dp[i-1]+1

nums[i]＜=nums[i-1],这时候，不能形成连续递增序列，后一个数要比前一个数小，呈下降的趋势，注意不认为是递增的</code></pre>
<p>3、初始值dp[i]=1</p>
<p>时间复杂度：o(n)<br>空间复杂度：o(n)</p>
<pre><code>class Solution:
    def findLengthOfLCIS(self, nums: List[int]) -&gt; int:
        if not nums:
            return 0
        dp=[1]*len(nums)
        for i in range(1,len(nums)):
                if nums[i] &gt; nums[i-1]:
                    dp[i]=max(dp[i],dp[i-1]+1)
        return max(dp)                    </code></pre>
<p>o(1)</p>
<pre><code>public int findLengthOfLCIS(int[] nums) &#123;
        if (nums == null || nums.length == 0) return 0;
        int n = nums.length;
        int max = 1;
        int[] dp = new int[2];
        dp[0] = 1;
        for (int i = 1; i ＜ n; i++) &#123;
            dp[i % 2] = 1;//前一个状态值都会被覆盖，需要重新初始化
            if (nums[i] ＞ nums[i - 1]) &#123;
                dp[i % 2] += dp[(i - 1) % 2];//当前状态依赖前一状态，需要再前一状态上累加
            &#125;
            max = Math.max(max, dp[i % 2]);
        &#125;
        return max;
    &#125;
</code></pre>
<h3 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a>746. 使用最小花费爬楼梯</h3><pre><code>链接：https://leetcode-cn.com/problems/min-cost-climbing-stairs/

数组的每个索引作为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost[i](索引从0开始)。

每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。

您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。

示例 1:

输入: cost = [10, 15, 20]
输出: 15
解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。
 示例 2:

输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
输出: 6
解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。
注意：

cost 的长度将会在 [2, 1000]。
每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。</code></pre>
<p>题解一|动态规划：<br>1、定义<br>    dp[i]为踏上第i级台阶的最小花费<br>2、状态转移<br>踏上第i级台阶有两种方法：</p>
<pre><code>先踏上第i-2级台阶（最小总花费dp[i-2]），再直接迈两步踏上第i级台阶（花费cost[i]），最小总花费dp[i-2] + cost[i]；

先踏上第i-1级台阶（最小总花费dp[i-1]），再迈一步踏上第i级台阶（花费cost[i]），最小总花费dp[i-1] + cost[i]；

则dp[i]是上面这两个最小总花费中的最小值。</code></pre>
<p>因此状态转移方程是：dp[i] = min(dp[i-2], dp[i-1]) + cost[i]。</p>
<p>3、初始条件：</p>
<pre><code>最后一步踏上第0级台阶，最小花费dp[0] = cost[0]。

最后一步踏上第1级台阶有两个选择：

可以分别踏上第0级与第1级台阶，花费cost[0] + cost[1]；
也可以从地面开始迈两步直接踏上第1级台阶，花费cost[1]。
最小值dp[1] = min(cost[0] + cost[1], cost[1]) = cost[1]。</code></pre>
<pre><code>class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -&gt; int:
        if not cost:
            return 0
        dp=[0]*len(cost)
        dp[0]=cost[0]
        dp[1]=cost[1]
        for i in range(2,len(cost)):
            dp[i]=min(dp[i-1]+cost[i],dp[i-2]+cost[i])
        return min(dp[-1],dp[-2])</code></pre>
<h3 id="1025-除数博弈"><a href="#1025-除数博弈" class="headerlink" title="1025. 除数博弈"></a>1025. 除数博弈</h3><pre><code>链接：https://leetcode-cn.com/problems/divisor-game/

爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。

最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：

选出任一 x，满足 0 &lt; x &lt; N 且 N % x == 0 。
用 N - x 替换黑板上的数字 N 。
如果玩家无法执行这些操作，就会输掉游戏。

只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。

示例 1：

输入：2
输出：true
解释：爱丽丝选择 1，鲍勃无法进行操作。
示例 2：

输入：3
输出：false
解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。


提示：

1 &lt;= N &lt;= 1000</code></pre>
<p>题解一|归纳</p>
<p>思路：最后轮到谁时 N=1，那么谁就是输家。</p>
<p>假设N为奇数，即 N%2=1:</p>
<pre><code>那么 N 的约数x一定都是奇数，N-x 一定是偶数；</code></pre>
<p>假设N为偶数，即 N%2=0:</p>
<pre><code>那么 N 的约数x可能是奇数，也可能是偶数。x为奇数时，N-x为奇数；x为偶数时，N-x为偶数。</code></pre>
<p>题目中说“两个玩家都以最佳状态参与游戏”，并且爱丽丝先手，那她一定会努力让自己得胜。</p>
<p>结论：</p>
<pre><code>若N是偶数，爱丽丝一定会选x为奇数，让轮到鲍勃的(N-x)为奇数，这样她每次都会轮到偶数直至胜利；

若N是奇数，爱丽丝没得选，只能让鲍勃轮到的（N-x)为偶数，此时主动权就在鲍勃手中，他会让爱丽丝每次轮到奇数，直至鲍勃获胜。</code></pre>
<pre><code>class Solution:
    def divisorGame(self, N: int) -&gt; bool:
        return N%2==0</code></pre>
<p>题解二|动态规划</p>
<p>定义：dp[i]为当N=i时，Alice的输赢</p>
<pre><code>class Solution:
    def divisorGame(self, N: int) -&gt; bool:
        if N&lt;=1:
            return False
        dp=[False]* (N+1)
        dp[1]= False
        dp[2]= True
        for i in range(3,N+1):
            for j in range(1,i):
                if dp[i-j] == False and i%j == 0: # 当dp[i-j]为奇数时，dp[i]为偶数
                    dp[i]=True
                    break
        return dp[N]</code></pre>
<h3 id="面试题-08-01-三步问题"><a href="#面试题-08-01-三步问题" class="headerlink" title="面试题 08.01. 三步问题"></a>面试题 08.01. 三步问题</h3><pre><code>链接：https://leetcode-cn.com/problems/three-steps-problem-lcci/

三步问题。有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶或3阶。实现一种方法，计算小孩有多少种上楼梯的方式。结果可能很大，你需要对结果模1000000007。

示例1:

 输入：n = 3 
 输出：4
 说明: 有四种走法
示例2:

 输入：n = 5
 输出：13
提示:

n范围在[1, 1000000]之间</code></pre>
<p>题解一|动态规划</p>
<pre><code>class Solution:
    def watiaosToStep(self, n: int) -&gt; int:
        if n &lt; 3:
            return n
        dp=[0]*(n+1)
        dp[1]=1
        dp[2]=2
        dp[3]=4
        for i in range(4,n+1):
            dp[i]=(dp[i-1]+dp[i-2]+dp[i-3]) % 1000000007
        return dp[n]</code></pre>
<h3 id="面试题-16-17-连续数列"><a href="#面试题-16-17-连续数列" class="headerlink" title="面试题 16.17. 连续数列"></a>面试题 16.17. 连续数列</h3><pre><code>链接：https://leetcode-cn.com/problems/contiguous-sequence-lcci/

给定一个整数数组，找出总和最大的连续数列，并返回总和。

示例：

输入： [-2,1,-3,4,-1,2,1,-5,4]
输出： 6
解释： 连续子数组 [4,-1,2,1] 的和最大，为 6。
进阶：

如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。</code></pre>
<pre><code>class Solution:
    def maxSubArray(self, nums: List[int]) -&gt; int:
        if not nums:
            return 0
        if len(nums)==1:
            return nums[0]
        dp=[0]*len(nums)
        dp[0]=nums[0]
        dp[1]=max(dp[0]+nums[1],nums[1])
        for i in range(2,len(nums)):
            dp[i]=max(dp[i-1]+nums[i],nums[i])
        return max(dp)</code></pre>
<h3 id="面试题42-连续子数组的最大和"><a href="#面试题42-连续子数组的最大和" class="headerlink" title="面试题42. 连续子数组的最大和"></a>面试题42. 连续子数组的最大和</h3><pre><code>链接：https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/

输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。

要求时间复杂度为O(n)。

示例1:

输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。


提示：

1 &lt;= arr.length &lt;= 10^5
-100 &lt;= arr[i] &lt;= 100</code></pre>
<pre><code>class Solution:
    def maxSubArray(self, nums: List[int]) -&gt; int:
        if not nums:
            return 0
        if len(nums)==1:
            return nums[0]
        dp=[0]*len(nums)
        dp[0]=nums[0]
        dp[1]=max(dp[0]+nums[1],nums[1])
        for i in range(2,len(nums)):
            dp[i]=max(dp[i-1]+nums[i],nums[i])
        return max(dp)</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/LeetCode-7-%E9%80%92%E5%BD%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/LeetCode-7-%E9%80%92%E5%BD%92/" class="post-title-link" itemprop="url">LeetCode-7-递归</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-16 18:30:44" itemprop="dateCreated datePublished" datetime="2020-01-16T18:30:44+08:00">2020-01-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-18 22:37:06" itemprop="dateModified" datetime="2020-08-18T22:37:06+08:00">2020-08-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="七-递归"><a href="#七-递归" class="headerlink" title="七.递归"></a>七.递归</h2><p>参考文章：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&amp;mid=2247485092&amp;idx=1&amp;sn=ff44f169aa57cac8a8e6595b7ff49ab8&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&amp;mid=2247485092&amp;idx=1&amp;sn=ff44f169aa57cac8a8e6595b7ff49ab8&amp;scene=21#wechat_redirect</a></p>
<p>递归的三大要素:</p>
<pre><code>第一要素：明确你这个函数想要干什么
第二要素：寻找递归结束条件
第三要素：找出函数的等价关系式,不断缩小参数的范围</code></pre>
<p>递归优化（建议看完一题再看优化）：</p>
<pre><code>1.考虑是否重复计算
比如说f(n-1),f(n-2)等就是 f(n) 的子问题了，这些子问题会被重复计算。

一般我们可以把我们计算的结果保证起来，例如把 f(4) 的计算结果保证起来，当再次要计算 f(4) 的时候，我们先判断一下，之前是否计算过，如果计算过，直接把 f(4) 的结果取出来就可以了，没有计算过的话，再递归计算。</code></pre>
<pre><code>def fib(n):
        if n&lt;=2:
            return n

        # 判断是否计算过
        if arr[n] != -1:
            return arr[n]
        else:
            # 没有计算过，递归计算,并且把结果保存到 arr数组里
            arr[n]=f(n-1)+f(n-2)
            return arr[n]</code></pre>
<pre><code>2.考虑是否可以自底向上,这种方法也被称为递推。

对于递归的问题，我们一般都是从上往下递归的，直到递归到最底，再一层一层着把值返回。
不过，有时候当 n 比较大的时候，例如当 n = 10000 时，那么必须要往下递归10000层直到 n &lt;=1 才将结果慢慢返回，如果n太大的话，可能栈空间会不够用。</code></pre>
<pre><code>def f(n):
        if n&lt;=2:
            return n
        f1=1
        f2=2
        sum=0
        for i in range(3,n+1):
            sum=f1+f2
            f1=f2
            f2=sum
        return  sum</code></pre>
<h3 id="在两个长度相等的排序数组中找到上中位数"><a href="#在两个长度相等的排序数组中找到上中位数" class="headerlink" title="在两个长度相等的排序数组中找到上中位数"></a>在两个长度相等的排序数组中找到上中位数</h3><pre><code>给定两个有序数组arr1和arr2，已知两个数组的长度都为N，求两个数组中所有数的上中位数。要求时间复杂度O(logN)，空间复杂度O(1）

例如 arr1 = [1, 2,3,4]，arr2 = [3,4,5,6]。

总共8个数，则中位数就是第 4 小的数，为 3.

例如 arr1 = [0,1,2]，arr2 = [3,4,5]。

总共6个数，则中位数就是第 3 小的数，为 2.</code></pre>
<p>参考文章：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&amp;mid=2247485087&amp;idx=3&amp;sn=9db76b899a0ed1c9274211a0218c2e8e&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&amp;mid=2247485087&amp;idx=3&amp;sn=9db76b899a0ed1c9274211a0218c2e8e&amp;scene=21#wechat_redirect</a></p>
<p>题解一（递归）：</p>
<pre><code>(1)、当 两个数组的长度为偶数时：

mid1 = (n-1)/2 = 1。
mid2 = (n - 1)/2 = 1。</code></pre>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/median1.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/median1.png"></p>
<pre><code>(2)、当两个数组的长度为奇数时：

mid1 = (n-1)/2 = 2。
mid2 = (n - 1)/2 = 2。

如果 arr2[mid2] &gt; arr1[mid1] 时，则和上面那个情况有点小差别，这时候目标数只存在于 arr1[mid1…n] 和 arr2[0…mid2]中。注意他们的差别，从arr1[mid1+1…n] =&gt; arr1[mid1…n]。

(3)、总结

当数组长度为奇数时：
    arr2[mid1] &lt; arr1[mid2]：mid1+1~n和0～mid2
    arr2[mid1] &gt; arr1[mid2]：0～mid1和mid2+1～n
当数组长度为偶数时:
    arr2[mid1] &lt; arr1[mid2]：mid1~n和0～mid2
    arr2[mid1] &gt; arr1[mid2]：0～mid1和mid2～n</code></pre>
<pre><code>def getUpMedian(arr1, arr2):
    if arr1 is None or arr2 is None:
        return -1

    return helper(arr1, 0, len(arr1) - 1, arr2, 0, len(arr2) - 1)


def helper(arr1, l1, r1, arr2, l2, r2):
    # mid1 = (r1 + l1) // 2
    # mid2 = (r2 + l2) // 2

    mid1 = l1+(r1 - l1) // 2 # 不明白为何这样求中位数？
    mid2 = l2+(r2 - l2) // 2

    if l1 &gt;= r1:
        return min(arr1[l1], arr2[l2])

    offset = ((r1 - l1 + 1) &amp; 1) ^ 1

    if arr1[mid1] &lt; arr2[mid2]:
        return helper(arr1, mid1 + offset, r1, arr2, l2, mid2)
    elif arr1[mid1] &gt; arr2[mid2]:
        return helper(arr1, l1, mid1, arr2, mid2 + offset, r2)
    else:
        return arr1[mid1]

print(getUpMedian([1, 2, 4, 6,9], [2, 2, 7, 9,10]))</code></pre>
<p>题解二（迭代）：</p>
<pre><code>def getUpMedian(arr1, arr2):
    if arr1 is None or arr2 is None:
        return -1

    l1 = 0
    r1 = len(arr1) - 1
    l2 = 0
    r2 = len(arr2) - 1
    mid1, mid2 = 0, 0
    offset = 0

    while l1 &lt; r1:
        # mid1 = (r1 - l1) // 2
        # mid2 = (r2 - l2) // 2
        mid1 = l1 + (r1 - l1) // 2
        mid2 = l2 + (r2 - l2) // 2
        offset = ((r1 - l1 + 1) &amp; 1) ^ 1

        if arr1[mid1] &lt; arr2[mid2]:
            l1 = mid1 + offset
            r2 = mid2
        elif arr1[mid1] &gt; arr2[mid2]:
            r1 = mid1
            l2 = mid2 + offset
        else:
            return arr1[mid1]
    return min(arr1[l1], arr2[l2])

print(getUpMedian([1, 2, 4, 6, 9], [2, 2, 7, 9, 10]))</code></pre>
<h3 id="？？？求两个有序数组的第K小数"><a href="#？？？求两个有序数组的第K小数" class="headerlink" title="？？？求两个有序数组的第K小数"></a>？？？求两个有序数组的第K小数</h3><pre><code>给定两个有序数组arr1和arr2，已知两个数组的长度分别为 m1 和 m2，求两个数组中的第 K 小数。要求时间复杂度O(log(m1 + m2))。

【举例】
例如 arr1 = [1, 2,3]，arr2 = [3,4,5,6]，K = 4。

则第 K 小数为 3.

例如 arr1 = [0,1,2]，arr2 = [3,4,5，7，8]， K = 3;

则第 K 小数为 2.</code></pre>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&amp;mid=2247485084&amp;idx=3&amp;sn=2cd46fef0f9e80bfe5a47043afc8ccbb&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&amp;mid=2247485084&amp;idx=3&amp;sn=2cd46fef0f9e80bfe5a47043afc8ccbb&amp;scene=21#wechat_redirect</a></p>
<p>题解一（递归）：</p>
<pre><code>def findKth(arr1, arr2, k):
    if arr1 is None or len(arr1) &lt; 1:
        return arr2[k - 1]
    if arr2 is None or len(arr2) &lt; 1:
        return arr1[k - 1]
    return helper(arr1, 0, len(arr1) - 1, arr2, 0, len(arr2) - 1, k)


def helper(arr1, l1, r1, arr2, l2, r2, k):
    if l1 &gt; r1:
        return arr2[l2 + k]
    if l2 &gt; r2:
        return arr1[l1 + k]
    if k == 0:
        return min(arr1[l1], arr2[l2])

    mid1 = l1 + k // 2 if (l1 + k // 2) &lt; (r1) else r1
    mid2 = l2 + k // 2 if (l1 + k // 2) &lt; (r2 - l1) else r2

    if arr1[mid1] &lt; arr2[mid2]:
        return helper(arr1, mid1 + 1, r1, arr2, l2, r2, k - k // 2 - 1)
    elif arr1[mid1] &gt; arr2[mid2]:
        return helper(arr1, l1, r1, arr2, mid2 + 1, r2, k - k // 2 - 1)
    else:
        return arr1[mid1]
</code></pre>
<h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a>70.爬楼梯</h3><pre><code>链接：https://leetcode-cn.com/problems/climbing-stairs/

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1：

输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
示例 2：

输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶</code></pre>
<p>题解一(递归):</p>
<pre><code>第一要素：明确你这个函数想要干什么</code></pre>
<pre><code>    f(n) 的功能是跳上一个n级的台阶总共有多少种跳法.
    def f(n):
        pass</code></pre>
<pre><code>第二要素：寻找递归结束条件</code></pre>
<pre><code>    n=1,f(1) = 1
    n=2,f(2) = 2

    def f(n):
        if n&lt;= 2:
            return n</code></pre>
<pre><code>第三要素：找出函数的等价关系式,不断缩小参数的范围</code></pre>
<pre><code>    每次跳的时候，小青蛙可以跳一个台阶，也可以跳两个台阶，也就是说，每次跳的时候，小青蛙有两种跳法。

    跳上n个台阶时，可以从n-1台阶跳上来，或者从n-2台阶跳上来。

    第一种跳法：第一次我跳了一个台阶，那么还剩下n-1个台阶还没跳，剩下的n-1个台阶的跳法有f(n-1)种。

    第二种跳法：第一次跳了两个台阶，那么还剩下n-2个台阶还没，剩下的n-2个台阶的跳法有f(n-2)种。

    f(n) = f(n-1) + f(n-2)

    def f(n):
        # 递归结束条件
        if n&lt;=2:
            return n
        # 等价关系式
        return  fib(n-1)+fib(n-2)</code></pre>
<h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h3><pre><code>链接：https://leetcode-cn.com/problems/reverse-linked-list/

反转一个单链表。

示例:

输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL
进阶:
你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</code></pre>
<p>题解一（递归）:</p>
<pre><code>第一要素：明确你这个函数想要干什么</code></pre>
<pre><code>    reverseList(head) 的功能是反转单链表，head表示头节点
    def reverseList(head):
        pass</code></pre>
<pre><code>第二要素：寻找递归结束条件
当链表只有一个节点，或者链表为空时，递归结束。</code></pre>
<pre><code>    def reverseList(head):
        if head is None or head.next is None:
            return head</code></pre>
<pre><code>第三要素：找出函数的等价关系式,不断缩小参数的范围

等价条件中，一定是范围不断在缩小，对于链表来说，就是链表的节点个数不断在变小.
head -&gt; 1 -&gt; 2 -&gt;3 -&gt;4

newList -&gt; 4 -&gt; 3 -&gt; 2 &lt;- 1 &lt;- head

接下来只需要把节点 2 的 next 指向 1，然后把 1 的 next 指向 null,不就行了.

newList -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; null</code></pre>
<pre><code>    def reverseList(head):
        def helper(head):
            if head is None or head.next is None:
                return head
            pre,last=helper(head.next)
            last.next=head
            head.next=None
            return pre,head
        rt,_=helper(head)
        return rt</code></pre>
<pre><code>不理解？？？
class Solution(object):
    def reverseList(self, head):
        &quot;&quot;&quot;
        :type head: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        # 递归终止条件是当前为空，或者下一个节点为空
        if(head==None or head.next==None):
            return head
        # 这里的cur就是最后一个节点
        cur = self.reverseList(head.next)
        # 这里请配合动画演示理解
        # 如果链表是 1-&gt;2-&gt;3-&gt;4-&gt;5，那么此时的cur就是5
        # 而head是4，head的下一个是5，下下一个是空
        # 所以head.next.next 就是5-&gt;4
        head.next.next = head
        # 防止链表循环，需要将head.next设置为空
        head.next = None
        # 每层递归函数都返回cur，也就是最后一个节点
        return cur</code></pre>
<h3 id="509-斐波那契数列"><a href="#509-斐波那契数列" class="headerlink" title="509.斐波那契数列"></a>509.斐波那契数列</h3><pre><code>链接：https://leetcode-cn.com/problems/fibonacci-number/

斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：

F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.
给定 N，计算 F(N)。

 

示例 1：

输入：2
输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1.
示例 2：

输入：3
输出：2
解释：F(3) = F(2) + F(1) = 1 + 1 = 2.
示例 3：

输入：4
输出：3
解释：F(4) = F(3) + F(2) = 2 + 1 = 3.
 

提示：

0 ≤ N ≤ 30</code></pre>
<p>题解一（递归）:</p>
<pre><code>第一要素：明确你这个函数想要干什么</code></pre>
<pre><code>    f(n) 的功能是求第 n 项的值.

    def fib(n):
        pass</code></pre>
<pre><code>第二要素：寻找递归结束条件</code></pre>
<pre><code>    f(1) = f(2) = 1。所以递归结束条件可以为  n &lt;= 2。

    def fib(n):
        if n&lt;2:
            return 1</code></pre>
<pre><code>第三要素：找出函数的等价关系式,不断缩小参数的范围</code></pre>
<pre><code>    f(n) = f(n-1) + f(n-2)

    def fib(n):
        # 递归结束条件
        if n&lt;2:
            return 1
        # 等价关系式
        return  fib(n-1)+fib(n-2)</code></pre>
<h3 id="969-煎饼排序"><a href="#969-煎饼排序" class="headerlink" title="969. 煎饼排序"></a>969. 煎饼排序</h3><pre><code>链接：https://leetcode-cn.com/problems/pancake-sorting/

给定数组 A，我们可以对其进行煎饼翻转：我们选择一些正整数 k &lt;= A.length，然后反转 A 的前 k 个元素的顺序。我们要执行零次或多次煎饼翻转（按顺序一次接一次地进行）以完成对数组 A 的排序。

返回能使 A 排序的煎饼翻转操作所对应的 k 值序列。任何将数组排序且翻转次数在 10 * A.length 范围内的有效答案都将被判断为正确。

示例 1：

输入：[3,2,4,1]
输出：[4,2,4,3]
解释：
我们执行 4 次煎饼翻转，k 值分别为 4，2，4，和 3。
初始状态 A = [3, 2, 4, 1]
第一次翻转后 (k=4): A = [1, 4, 2, 3]
第二次翻转后 (k=2): A = [4, 1, 2, 3]
第三次翻转后 (k=4): A = [3, 2, 1, 4]
第四次翻转后 (k=3): A = [1, 2, 3, 4]，此时已完成排序。 
示例 2：

输入：[1,2,3]
输出：[]
解释：
输入已经排序，因此不需要翻转任何内容。
请注意，其他可能的答案，如[3，3]，也将被接受。

提示：

1 &lt;= A.length &lt;= 100
A[i] 是 [1, 2, ..., A.length] 的排列</code></pre>
<p>题解一|递归</p>
<p>思路：</p>
<pre><code>1、找到n个饼中最大的那个。

2、把这个最大的饼移到最底下。

3、递归调用pancakeSort(A, n - 1)。

base case：n == 1时，排序 1 个饼时不需要翻转。</code></pre>
<p>操作：</p>
<p>1、用锅铲将前 3 块饼翻转一下，这样最大的饼就翻到了最上面。</p>
<p>2、用锅铲将前n块饼全部翻转，这样最大的饼就翻到了第n块，也就是最后一块。</p>
<p>时间复杂度：因为递归调用的次数是n，每次递归调用都需要一次 for 循环，时间复杂度是 O(n)，所以总的复杂度是 O(n^2)。</p>
<pre><code>class Solution:
    def pancakeSort(self, A: List[int]) -&gt; List[int]:
        self.res=[]
        self.sort(A,len(A))
        return self.res

    def sort(self,arr,n):
        if n==1:
            return
        maxCake=0
        maxCakeIndex=0
        # 寻找最大饼的索引
        for i in range(n):
            if arr[i]&gt;maxCake:
                maxCake=arr[i]
                maxCakeIndex=i
        self.reverse(arr,0,maxCakeIndex) # 第一次翻转，将最大饼翻到最上面
        self.res.append(maxCakeIndex+1)
        self.reverse(arr,0,n-1) # 第二次翻转，将最大饼翻到最下面
        self.res.append(n)

        self.sort(arr,n-1) # 递归调用

    def reverse(self,arr,i,j):
        while i&lt;j:
            arr[i],arr[j]=arr[j],arr[i]
            i+=1
            j-=1</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/LeetCode-5-%E9%93%BE%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/LeetCode-5-%E9%93%BE%E8%A1%A8/" class="post-title-link" itemprop="url">LeetCode-5-链表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-15 22:01:02" itemprop="dateCreated datePublished" datetime="2020-01-15T22:01:02+08:00">2020-01-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-06 15:06:34" itemprop="dateModified" datetime="2020-11-06T15:06:34+08:00">2020-11-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="五、链表"><a href="#五、链表" class="headerlink" title="五、链表"></a>五、链表</h2><h3 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h3><pre><code>链接：https://leetcode-cn.com/problems/add-two-numbers/

给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。

如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

您可以假设除了数字 0 之外，这两个数都不会以 0 开头。

示例：

输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
输出：7 -&gt; 0 -&gt; 8
原因：342 + 465 = 807</code></pre>
<p>题解一：</p>
<pre><code>class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:
        if not l1:
            return l2
        if not l2:
            return l1
        dummy=res=ListNode(0)
        flag=0

        while l1 or l2:
            sum=0
            if l1:
                sum=l1.val
                l1=l1.next
            if l2:
                sum+=l2.val
                l2=l2.next
            tmp=(sum+flag)%10 # 余数
            flag=(sum+flag)//10 # 进位

            res.next=ListNode(tmp)
            res=res.next

            if flag: # 这里虽然创建了一个节点，但是并没有res=res.next,并没有右移。所以插入8时没有问题。同时case输入为[5]和[5]时，可以得到结果[0,1]，而非[0]
                res.next=ListNode(1)
        return dummy.next</code></pre>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:
        res=dummy=ListNode(-1)
        flag=0
        while l1 and l2:
            res.next=ListNode(l1.val+l2.val+flag)
            flag=res.next.val // 10
            res.next.val %= 10
            res=res.next
            l1=l1.next
            l2=l2.next

        p= l1 or l2
        while p:
            res.next=ListNode(p.val+flag)
            flag=res.next.val // 10
            res.next.val %= 10
            p=p.next
            res=res.next
        if flag:
            res.next=ListNode(1)
        return dummy.next</code></pre>
<h3 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19. 删除链表的倒数第N个节点"></a>19. 删除链表的倒数第N个节点</h3><pre><code>链接：https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/

给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。

示例：

给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.
说明：

给定的 n 保证是有效的。

进阶：你能尝试使用一趟扫描实现吗？</code></pre>
<p>题解一|两次遍历：</p>
<p>分析：<br>    删除从列表开头数起的第 (L−n+1) 个结点，其中 L 是列表的长度。只要我们找到列表的长度 L，这个问题就很容易解决。</p>
<pre><code>在第一次遍历中，我们找出列表的长度 L。
设置一个指向哑结点的指针，并移动它遍历列表，直至它到达第 (L−n) 个结点那里。我们把第 (L−n) 个结点的 next 指针重新链接至第 (L−n+2) 个结点，完成这个算法。</code></pre>
<p>时间复杂度：O(L)，该算法对列表进行了两次遍历，首先计算了列表的长度 L 其次找到第 (L−n) 个结点。 操作执行了 2L-n 步，时间复杂度为 O(L)。</p>
<p>空间复杂度：O(1)，我们只用了常量级的额外空间。</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode:
        dummy=ListNode(-1)
        dummy.next=head # 注意case:[1]和1
        p=dummy
        length=0
        while p:
            p=p.next
            length+=1 # 注意：这里length=6，而不是5，因为有一个头节点。
        length-=(n+1)
        p=dummy
        while length&gt;0:
            p=p.next
            length-=1
        p.next=p.next.next
        return dummy.next</code></pre>
<p>题解二|一次遍历：</p>
<p>分析：<br>    第一个指针从列表的开头向前移动 n+1 步，而第二个指针将从列表的开头出发。</p>
<pre><code>通过同时移动两个指针向前来保持这个恒定的间隔，直到第一个指针到达最后一个结点。

此时第二个指针将指向从最后一个结点数起的第 n 个结点。我们重新链接第二个指针所引用的结点的 next 指针指向该结点的下下个结点。</code></pre>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode:
        dummy=ListNode(-1)
        dummy.next=head # 如果dummy=head,case为[1],1不能通过。
        fast=slow=dummy
        while fast and n:
            fast=fast.next
            n-=1
        while fast.next and slow.next: # 注意不是while fast and slow：
            fast=fast.next
            slow=slow.next

        # print( fast.val,slow.val)
        slow.next=slow.next.next
        return dummy.next</code></pre>
<h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a>21. 合并两个有序链表</h3><pre><code>链接：https://leetcode-cn.com/problems/merge-two-sorted-lists/

将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

示例：

输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4
输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</code></pre>
<p>题解一：</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode:
        # if not l1:
        #     return l2
        # if not l2:
        #     return l1
        head=dummy=ListNode(-1)
        while l1 and l2:
            if l1.val &lt; l2.val:
                head.next=l1
                l1=l1.next
            else:
                head.next=l2
                l2=l2.next
            head=head.next
        if l1:
            head.next=l1
        if l2:
            head.next=l2
        return dummy.next</code></pre>
<h3 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h3><pre><code>链接：https://leetcode-cn.com/problems/swap-nodes-in-pairs/

给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

示例:

给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</code></pre>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/dong-hua-yan-shi-24-liang-liang-jiao-huan-lian-bia/">https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/dong-hua-yan-shi-24-liang-liang-jiao-huan-lian-bia/</a></p>
<p>题解一|递归：<br>分析：</p>
<pre><code>从链表的头节点 head 开始递归。
每次递归都负责交换一对节点。由 firstNode 和 secondNode 表示要交换的两个节点。
下一次递归则是传递的是下一对需要交换的节点。若链表中还有节点，则继续递归。
交换了两个节点以后，返回 secondNode，因为它是交换后的新头。
在所有节点交换完成以后，我们返回交换后的头，实际上是原始链表的第二个节点。</code></pre>
<p>时间复杂度：O(N)，其中 N 指的是链表的节点数量。<br>空间复杂度：O(N)，递归过程使用的堆栈空间。</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def swapPairs(self, head: ListNode) -&gt; ListNode:
        if not head or not head.next:
            return head

        first=head
        second=head.next

        # swap
        first.next=self.swapPairs(second.next)
        second.next=first

        return second</code></pre>
<p>题解二|迭代：</p>
<p>我们把链表分为两部分，即奇数节点为一部分，偶数节点为一部分，A 指的是交换节点中的前面的节点，B 指的是要交换节点中的后面的节点。在完成它们的交换，我们还得用 prevNode 记录 A 的前驱节点。</p>
<p>思路：</p>
<pre><code>1、firstNode（即 A） 和 secondNode（即 B） 分别遍历偶数节点和奇数节点，即两步看作一步。

2、交换两个节点：
    firstNode.next = secondNode.next
    secondNode.next = firstNode

3、还需要更新 prevNode.next 指向交换后的头。
    prevNode.next = secondNode

4、迭代完成后得到最终的交换结果。</code></pre>
<p>时间复杂度：O(N)，其中 N 指的是链表的节点数量。<br>空间复杂度：O(1)。</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def swapPairs(self, head: ListNode) -&gt; ListNode:
        dummy=ListNode(-1)
        dummy.next=head
        pre=dummy

        while head and head.next:
            first=head
            second=head.next

            # swap
            pre.next=second
            first.next=second.next
            second.next=first

            # Reinitializing the head and prev_node for next swap
            pre=first # 通过pre来构成新的链表
            # print(pre.val)
            head=first.next

        return dummy.next</code></pre>
<h3 id="61-旋转链表"><a href="#61-旋转链表" class="headerlink" title="61. 旋转链表"></a>61. 旋转链表</h3><pre><code>链接：https://leetcode-cn.com/problems/rotate-list/

给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。

示例 1:

输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2
输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL
解释:
向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL
向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL
示例 2:

输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4
输出: 2-&gt;0-&gt;1-&gt;NULL
解释:
向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL
向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL
向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL
向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL</code></pre>
<p>题解一|暴力法：</p>
<p>分析：</p>
<pre><code>首先遍历获得链表的长度以及链表尾部的指针（引用）；
之后头尾拼接起来；
随后我们只要从头遍历k - k % length步就能够找到旋转后链表的头指针，断开尾指针和头指针，返回头指针。</code></pre>
<p>关键点就是k，如果移动一次就相当于将倒数第一个元素1移到链表开头，如果移动两次就相当于将倒数第二和倒数第一个元素2和1移动到链表开头。</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode1.jpg" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode1.jpg"></p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode2.jpg" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode2.jpg"></p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode3.jpg" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode3.jpg"></p>
<pre><code>class Solution:
    def rotateRight(self, head: ListNode, k: int) -&gt; ListNode:
        if not head:
            return None
        cur=head
        length=1
        while cur.next:
            cur=cur.next
            length+=1
        cur.next=head # 头尾拼接
        k=length-k%length                                          
        while k:
            k-=1
            cur=cur.next
        head=cur.next # 找到头指针
        cur.next=None  # 断开尾节点             
        return head</code></pre>
<h3 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="82.删除排序链表中的重复元素 II"></a>82.删除排序链表中的重复元素 II</h3><pre><code>链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/

给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。

示例 1:

输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5
输出: 1-&gt;2-&gt;5
示例 2:

输入: 1-&gt;1-&gt;1-&gt;2-&gt;3
输出: 2-&gt;3</code></pre>
<p>题解一：</p>
<p>思路：</p>
<p>建立哑结点dummy，当前处理节点为curr，它的值为anchor，它的前序节点为prev。</p>
<p>如果curr的后序节点的值等于anchor，那么标注flag为True，curr一直后移下去，总之，curr移到连续的最后一个值为anchor的节点，停下来。如果经历了上述步骤，那么prev和curr.next相连，prev按兵不动，curr后移一位；如果没有经历，curr的值是独一无二的，那么prev和curr同时右移一位。继续循环直到curr移到最后一位。</p>
<p>时间复杂度: O(n), 空间复杂度: O(1)</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:
        dummy=ListNode(-1)
        dummy.next=head
        pre,curr=dummy,head

        while curr:
            anchor=curr.val
            flag=False
            while curr.next:
                if curr.next.val == anchor:
                    curr=curr.next
                    flag=True
                else:
                    break
            if flag:
                pre.next=curr.next # pre并未向前移动
            else:
                pre=curr
            curr=curr.next
        return dummy.next</code></pre>
<p>题解二|快慢指针：</p>
<pre><code>1. fast 遍历链表,让fast 去嗅探不相等元素
2. slow.next == fast --&gt; slow 与 fast 之间没有重复元素，slow 动。
3. slow.next != fast --&gt; slow 与 fast 之间存在重复元素，让slow指向的元素跳过这些重复元素，slow 不动。</code></pre>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:
        dummy=ListNode(-1)
        dummy.next=head
        slow=dummy
        fast=head

        while fast and fast.next:
            if fast.val != fast.next.val:
                if slow.next == fast: # 注意此处判断的是内存地址，而非节点的值
                    slow=fast
                    # print(&#39;111&#39;,slow)
                else:
                    # print(&#39;222&#39;,fast.next)
                    slow.next=fast.next # slow并未向前移动
            fast=fast.next
        if slow.next != fast: # 解决case:[1,1]
            slow.next=fast.next
        return dummy.next</code></pre>
<pre><code>class Solution:
    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:
        if head == None or head.next == None:
            return head
        dummy = ListNode(-1000)
        dummy.next = head
        slow = dummy
        fast = dummy.next
        while fast:
            if  fast.next and fast.next.val == fast.val:
                tmp = fast.val
                while fast and tmp == fast.val:
                    fast = fast.next
            else:
                slow.next = fast
                slow = fast
                fast = fast.next
        slow.next = fast
        return dummy.next</code></pre>
<pre><code>class Solution:
    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:
        if head == None or head.next == None:
            return head
        dummy = ListNode(-1)
        dummy.next = head
        slow = dummy
        fast = dummy.next
        while fast:
            while fast.next and slow.next.val == fast.next.val:
                fast = fast.next
            if slow.next == fast:
                slow = fast
            else:
                slow.next = fast.next
            fast = fast.next
        return dummy.next</code></pre>
<p>题解三|递归：</p>
<pre><code>class Solution:
    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:
        if not head:
            return head
        if head.next and head.val == head.next.val:
            while head.next and head.val == head.next.val:
                head=head.next
            return self.deleteDuplicates(head.next)
        else:
            head.next=self.deleteDuplicates(head.next) 
        return head</code></pre>
<h3 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a>83. 删除排序链表中的重复元素</h3><pre><code>链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/

给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。

示例 1:

输入: 1-&gt;1-&gt;2
输出: 1-&gt;2
示例 2:

输入: 1-&gt;1-&gt;2-&gt;3-&gt;3
输出: 1-&gt;2-&gt;3</code></pre>
<p>思路：因为是排序列表，通过将结点的值与它之后的结点进行比较来确定它是否为重复结点。如果它是重复的，我们更改当前结点的 next 指针，以便它跳过下一个结点并直接指向下一个结点之后的结点。</p>
<p>时间复杂度：O(n)，因为列表中的每个结点都检查一次以确定它是否重复，所以总运行时间为 O(n)，其中 n 是列表中的结点数。<br>空间复杂度：O(1)，没有使用额外的空间。</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:
        dummy=ListNode(-1)
        dummy.next=head
        while head and head.next:
            if head.val == head.next.val:
                head.next=head.next.next
            else:
                head=head.next
        return dummy.next</code></pre>
<pre><code>class Solution:
    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:
        dummy=head
        while head and head.next:
            if head.val == head.next.val:
                head.next=head.next.next
            else:
                head=head.next
        return dummy</code></pre>
<h3 id="86-分隔链表"><a href="#86-分隔链表" class="headerlink" title="86. 分隔链表"></a>86. 分隔链表</h3><pre><code>链接：https://leetcode-cn.com/problems/partition-list/

给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。

你应当保留两个分区中每个节点的初始相对位置。

示例:

输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3
输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</code></pre>
<p>分析：</p>
<pre><code>哈哈，差点没看懂题。</code></pre>
<p>这道题要求我们划分链表，把所有小于给定值的节点都移到前面，大于该值的节点顺序不变，相当于一个局部排序的问题。那么可以想到的一种解法是首先找到第一个大于或等于给定值的节点，用题目中给的例子来说就是先找到4，然后再找小于3的值，每找到一个就将其取出置于4之前即可</p>
<p>题解一|双指针法：</p>
<p>用两个指针before 和 after 来追踪上述的两个链表。两个指针可以用于分别创建两个链表，然后将这两个链表连接即可获得所需的链表。</p>
<p>时间复杂度: O(N)，其中N是原链表的长度，我们对该链表进行了遍历。<br>空间复杂度: O(1)，我们没有申请任何新空间。值得注意的是，我们只移动了原有的结点，因此没有使用任何额外空间。</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def partition(self, head: ListNode, x: int) -&gt; ListNode:
        before=bf=ListNode(-1)
        after=af=ListNode(-1)

        while head:
            if head.val &lt; x:
                before.next=head
                before=before.next
            else:
                after.next=head
                after=after.next
            head=head.next

        after.next=None
        before.next=af.next
        return bf.next</code></pre>
<h3 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a>92. 反转链表 II</h3><pre><code>链接：https://leetcode-cn.com/problems/reverse-linked-list-ii/

反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。

说明:
1 ≤ m ≤ n ≤ 链表长度。

示例:

输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4
输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</code></pre>
<p>题解一|迭代：</p>
<p>时间复杂度: O(N)。考虑包含 N 个结点的链表。对每个节点最多会处理<br>（第 n 个结点之后的结点不处理）。</p>
<p>空间复杂度: O(1)。我们仅仅在原有链表的基础上调整了一些指针，只使用了 O(1)的额外存储空间来获得结果。</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reverseBetween(self, head: ListNode, m: int, n: int) -&gt; ListNode:
        if not head:
            return None
        prev,cur=None,head
        while m&gt;1:
            prev=cur
            cur=cur.next
            m,n=m-1,n-1
        # print(cur.val,prev.val)
        # tail 指针指向从链表头起的第m个结点，此结点是反转后链表的尾部，故称为 tail。
        # con 指针指向第 m 个结点的前一个结点，此结点是新链表的头部。
        con,tail=prev,cur
        while n:
            next=cur.next
            cur.next=prev
            prev=cur
            cur=next
            n-=1
        if con:
            con.next=prev # 头节点链接反转后链表的头节点
        else:
            # head.next=prev
            head=prev
        tail.next=cur # 反转后的链表链接尾节点
        return head</code></pre>
<h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141.环形链表"></a>141.环形链表</h3><pre><code>链表：https://leetcode-cn.com/problems/linked-list-cycle

给定一个链表，判断链表中是否有环。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。

示例 1：

输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。


示例 2：

输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。


示例 3：

输入：head = [1], pos = -1
输出：false
解释：链表中没有环。

进阶：你能用 O(1)（即，常量）内存解决此问题吗？</code></pre>
<p>题解一|hash:</p>
<pre><code>时间复杂度：O(n)，对于含有 n个元素的链表，我们访问每个元素最多一次。添加一个结点到哈希表中只需要花费 O(1) 的时间。

空间复杂度：O(n)，空间取决于添加到哈希表中的元素数目，最多可以添加 n 个元素。</code></pre>
<pre><code>class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

class Solution:
    def hasCycle(self, head: ListNode) -&gt; bool:
        hash=&#123;&#125;
        while head :
            if head not in hash:
                hash[head]=0
                head=head.next
            else:
                return True
        return False</code></pre>
<p>题解二|快慢指针:</p>
<pre><code>class Solution:
    def hasCycle(self, head: ListNode) -&gt; bool:
        if not head or not head.next: 
            return False
        i,j=head,head.next
        while j and j.next: # 如果没有j.next，无法通过case ([1,2] -1).
            if i==j:
                return True
            i,j=i.next,j.next.next
        return False</code></pre>
<pre><code>class Solution:
    def hasCycle(self, head: ListNode) -&gt; bool:
        slow=fast=head
        while fast and fast.next: # 如果没有fast.next，无法通过case ([1] -1).
            fast=fast.next.next
            slow=slow.next
            # print(fast.val,slow.val)
            if fast == slow:
                # print(fast.val)
                return True # 返回True的节点并不一定就是环的入口节点。
        return False</code></pre>
<h3 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142.环形链表 II"></a>142.环形链表 II</h3><pre><code>链接：https://leetcode-cn.com/problems/linked-list-cycle-ii/

给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。

说明：不允许修改给定的链表。

示例 1：

输入：head = [3,2,0,-4], pos = 1
输出：tail connects to node index 1
解释：链表中有一个环，其尾部连接到第二个节点。

示例 2：

输入：head = [1,2], pos = 0
输出：tail connects to node index 0
解释：链表中有一个环，其尾部连接到第一个节点。


示例 3：

输入：head = [1], pos = -1
输出：no cycle
解释：链表中没有环。

进阶：你是否可以不用额外空间解决此题？</code></pre>
<p>题解一|hash：</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def detectCycle(self, head: ListNode) -&gt; ListNode:
        hash=&#123;&#125;
        while head:
            if head not in hash:
                hash[head]=0
                head=head.next
            else:
                return head
        return None</code></pre>
<p>题解二|快慢指针:</p>
<pre><code>class Solution:
    def detectCycle(self, head: ListNode) -&gt; ListNode:
        if not head or not head.next:
            return None
        slow,fast=head,head
        while fast and fast.next:
            slow=slow.next
            fast=fast.next.next
            if slow == fast:
                slow=head
                while slow != fast:
                    slow=slow.next
                    fast=fast.next
                return slow
        return None</code></pre>
<h3 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143. 重排链表"></a>143. 重排链表</h3><pre><code>链接：https://leetcode-cn.com/problems/reorder-list

给定一个单链表 L：L0→L1→…→Ln-1→Ln ，
将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

示例 1:

给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.
示例 2:

给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3.</code></pre>
<p>题解一|反转链表:</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode4.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode4.png"></p>
<p>思路：</p>
<pre><code>找中点
翻转中点之后的链表
依次拼接</code></pre>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reorderList(self, head: ListNode) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify head in-place instead.
        &quot;&quot;&quot;
        # 1、找中点, 偶数个时找上界
        if not head or not head.next:
            return head
        slow,fast=head,head
        while fast and fast.next:
            slow=slow.next
            fast=fast.next.next
        mid=slow        
        # 2、翻转中点之后的链表,采用是pre, slow双指针方法
        pre=None
        while slow:
            next=slow.next
            slow.next=pre
            pre=slow
            slow=next
        # 3、翻转链表和前面链表拼接
        p1=head # 链表头
        p2=pre # 翻转头

        # print(mid.val,p2.val)
        while p2 != mid:
            next1,next2=p1.next,p2.next
            p1.next=p2               
            p2.next=next1
            p1,p2=next1,next2
        return head</code></pre>
<p>题解二|栈：</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reorderList(self, head: ListNode) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify head in-place instead.
        &quot;&quot;&quot;
        if not head:
            return head
        dummy=head
        stack=[]
        while dummy:
            stack.append(dummy)
            dummy=dummy.next
        n=len(stack)
        mid=(n-1)//2

        dummy=head
        while mid:
            tmp=stack.pop() # 弹出链表最后一个节点
            tmp.next=dummy.next
            dummy.next=tmp
            dummy=tmp.next # 移动2个位置，使用dummy=dummy.next.next也可以。
            mid-=1
        stack.pop().next=None
        return head</code></pre>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reorderList(self, head: ListNode) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify head in-place instead.
        &quot;&quot;&quot;
        if not head:
            return head
        fast,slow=head,head
        stack=[]
        while fast.next and fast.next.next:
            fast=fast.next.next
            slow=slow.next
        while slow.next:
            stack.append(slow.next)
            slow.next=slow.next.next
        dummy=head
        while stack:
            tmp=stack.pop()
            tmp.next=dummy.next
            dummy.next=tmp
            dummy=dummy.next.next
        return head</code></pre>
<h3 id="147-对链表进行插入排序"><a href="#147-对链表进行插入排序" class="headerlink" title="147. 对链表进行插入排序"></a>147. 对链表进行插入排序</h3><pre><code>链接：https://leetcode-cn.com/problems/insertion-sort-list

对链表进行插入排序。


插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。
每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。


插入排序算法：

插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。
每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。
重复直到所有输入数据插入完为止。
 

示例 1：

输入: 4-&gt;2-&gt;1-&gt;3
输出: 1-&gt;2-&gt;3-&gt;4
示例 2：

输入: -1-&gt;5-&gt;3-&gt;4-&gt;0
输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</code></pre>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_17550379/article/details/80708238">https://blog.csdn.net/qq_17550379/article/details/80708238</a></p>
<p>数组的插入排序：</p>
<pre><code>def insertSort(lists):
    count=len(lists)
    for i in range(1,count):
        key=lists[i]
        j=i-1
        while j&gt;=0:
            if lists[j]&gt;key:
                lists[j+1]=lists[j]
                lists[j]=key
            j-=1
    return lists</code></pre>
<p>题解一：</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def insertionSortList(self, head: ListNode) -&gt; ListNode:
        if not head or not head.next:
            return head
        cur,nxt=head,head.next
        dummy=ListNode(float(&#39;-inf&#39;))
        dummy.next=head

        while nxt:
            if nxt.val &gt;= cur.val:
                cur=cur.next
                nxt=nxt.next
            else:
                cur.next=nxt.next # 断链

                pre1,pre2=dummy,dummy.next # 寻找插入位置
                while nxt.val &gt; pre2.val:
                    pre1=pre2
                    pre2=pre2.next

                pre1.next=nxt
                nxt.next=pre2

                nxt=cur.next # 再从第一个值开始循环
        return dummy.next</code></pre>
<p>题解二：</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def insertionSortList(self, head: ListNode) -&gt; ListNode:
        if head == None or head.next == None:
            return head

        dummy = ListNode(-1)
        dummy.next = head
        pre = dummy
        cur = head
        while cur:
            lat = cur.next
            if lat and lat.val &lt; cur.val:  # 只有cur.next比cur小的时候我们才寻找插入点
                while pre.next and pre.next.val &lt; lat.val:
                    pre = pre.next
                tmp = pre.next
                pre.next = lat
                cur.next = lat.next
                lat.next = tmp
                pre = dummy
            else:
                cur = lat

        return dummy.next</code></pre>
<p>？题解三：</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def insertionSortList(self, head: ListNode) -&gt; ListNode:
        p=dummy=ListNode(-1)
        curr=dummy.next=head
        while curr and curr.next:
            val = curr.next.val
            if curr.val &lt; val:
                curr=curr.next
                continue
            if p.next.val &gt; val:
                p=dummy
            while p.next.val &lt; val:
                p=p.next
            new=curr.next
            curr.next=new.next
            new.next=p.next
            p.next=new
        return dummy.next</code></pre>
<h3 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a>160. 相交链表</h3><pre><code>链接：https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</code></pre>
<p>题解一|暴力:</p>
<p>对链表A中的每一个结点 ai，遍历整个链表 B 并检查链表 B 中是否存在结点和 a<br>i相同。</p>
<p>时间复杂度 : (mn)<br>空间复杂度 : O(1)</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode:
        p,q=headA,headB
        while p:
            while q:
                if p == q:
                    return q
            q=q.next
        p=p.next
        return None</code></pre>
<p>题解二|hash：</p>
<p>分析：</p>
<pre><code>遍历链表 A 并将每个结点的地址/引用存储在哈希表中。然后检查链表 B 中的每一个结点 bi 是否在哈希表中。若在，则 bi为相交结点。</code></pre>
<p>时间复杂度 : O(m+n)。<br>空间复杂度 : O(m) 或 O(n)。</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode:
        p,q=headA,headB
        hash=&#123;&#125;
        while p:
            if p not in hash:
                hash[p]=1
            p=p.next
        while q:
            if q in hash:
                return q
            q=q.next</code></pre>
<p>题解三|双指针：</p>
<p>分析：<br>    两个指针分别从链表头开始扫描，每次分别走一步<br>    若指针走到null，则从另一个链表头部开始走<br>    两指针相同时:<br>        (利用此时两个指针移动步数一致)<br>        指针不为null：指针位置为相遇点<br>        指针为null：两个链表不相交</p>
<pre><code>创建两个指针 pA 和 pB，分别初始化为链表 A 和 B 的头结点。然后让它们向后逐结点遍历。

当 pA 到达链表的尾部时，将它重定位到链表 B 的头结点 (你没看错，就是链表 B); 类似的，当 pB 到达链表的尾部时，将它重定位到链表 A 的头结点。

若在某一时刻 pA 和 pB 相遇，则 pA/pB 为相交结点。

想弄清楚为什么这样可行, 可以考虑以下两个链表: A=&#123;1,3,5,7,9,11&#125; 和 B=&#123;2,4,9,11&#125;，相交于结点 9。 由于 B.length (=4) &lt; A.length (=6)，pB 比 pA少经过 2 个结点，会先到达尾部。将 pB 重定向到 A 的头结点，pA 重定向到 B 的头结点后，pB 要比 pA 多走 2 个结点。因此，它们会同时到达交点。

如果两个链表存在相交，它们末尾的结点必然相同。因此当 pA/pB 到达链表结尾时，记录下链表 A/B 对应的元素。若最后元素不相同，则两个链表不相交。</code></pre>
<p>时间复杂度 : O(m+n)<br>空间复杂度 : O(1)</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode:
        p,q=headA,headB
        while p != q:
            if p:
                p=p.next
            else:
                p=headB
            if q:
                q=q.next
            else:
                q=headA
        return p</code></pre>
<h3 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a>203. 移除链表元素</h3><pre><code>链接：https://leetcode-cn.com/problems/remove-linked-list-elements/

删除链表中等于给定值 val 的所有节点。

示例:

输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6
输出: 1-&gt;2-&gt;3-&gt;4-&gt;5</code></pre>
<p>题解一|删除头结点时另做考虑：</p>
<p>思路：删除头结点时另做考虑，由于头结点没有前一个结点。</p>
<pre><code>class Solution:
    def removeElements(self, head: ListNode, val: int) -&gt; ListNode:
        if not head:
            return head
        # 如果不对头结点单独考虑，无法解决case：[1]和1
        while head and head.val == val:
            head=head.next
        dummy=head
        while head and head.next:
            if head.next.val == val:
                # print(val)
                # head=head.next.next
                head.next=head.next.next
            else:
                head=head.next
        return dummy</code></pre>
<p>题解二：</p>
<pre><code>时间复杂度：O(N)，只遍历了一次
空间复杂度：O(1)

class Solution:
    def removeElements(self, head: ListNode, val: int) -&gt; ListNode:
        dummy=ListNode(0)
        dummy.next=head

        pre,curr=dummy,head
        # print(pre.val,curr.val) 0和1
        while curr:
            if curr.val == val:
                pre.next=curr.next
            else:
                pre=curr
            curr=curr.next

        return dummy.next</code></pre>
<pre><code>class Solution:
    def removeElements(self, head: ListNode, val: int) -&gt; ListNode:
        dummy=ListNode(0)
        dummy.next=head
        pre=dummy
        while pre.next:
            if pre.next.val == val:
                pre.next=pre.next.next
            else:
                pre=pre.next

        return dummy.next</code></pre>
<p>题解三|递归：</p>
<pre><code>class Solution:
    def removeElements(self, head: ListNode, val: int) -&gt; ListNode:
        if not head:
            return head
        head.next=self.removeElements(head.next,val) # 不能移动到代码最后        
        if head.val==val:
            return head.next
        else:
            return head</code></pre>
<h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h3><pre><code>链接：https://leetcode-cn.com/problems/reverse-linked-list/

反转一个单链表。

示例:

输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL
进阶:
你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</code></pre>
<p>参考：<br>    <a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-linked-list/solution/">https://leetcode.com/problems/reverse-linked-list/solution/</a><br>     <a target="_blank" rel="noopener" href="http://baijiahao.baidu.com/s?id=1574261186522385&wfr=spider&for=pc">http://baijiahao.baidu.com/s?id=1574261186522385&amp;wfr=spider&amp;for=pc</a><br>     <a target="_blank" rel="noopener" href="https://blog.csdn.net/autumn20080101/article/details/7607148">https://blog.csdn.net/autumn20080101/article/details/7607148</a><br>     <a target="_blank" rel="noopener" href="https://www.cnblogs.com/scud001/p/4423324.html">https://www.cnblogs.com/scud001/p/4423324.html</a></p>
<pre><code>初始状态，prev是NULL，head指向当前的头节点A，next指向A节点的下一个节点B。
首先从A节点开始逆序，将A节点的next指针指向prev，因为prev的当前值是NULL，所以A节点就从链表中脱离出来了，然后移动
head和next指针，使它们分别指向B节点和B的下一个节点C（因为当前的next已经指向B节点了，因此修改A节点的next指针不会
导致链表丢失）。逆向节点A之后，链表的状态如图（2）所示：

 从图（1）的初始状态到图（2）状态共做了四个操作，这四个操作的伪代码如下：

head-&gt;next = prev;

prev = head;

head = next;

next = head-&gt;next;

这四行伪代码就是循环算法的迭代体了，现在用这个迭代体对图（2）的状态再进行一轮迭代，就得到了图（3）的状态：

那么循环终止条件呢？现在对图（3）的状态再迭代一次得到图（4）的状态：

此时可以看出，在图（4）的基础上再进行一次迭代就可以完成链表的逆序，因此循环迭代的终止条件就是当前的head指针是NULL。

现在来总结一下，循环的初始条件是：

prev = NULL;

循环迭代体是：

//在头节点改变之前，先获取下一个节点的指针
next = head-&gt;Next;
//头节点的下一个节点要改成它的上一个节点，是一个逆转的过程
head-&gt;Next = prev;
//上一个节点前移指向头节点
prev = head;
//头节点前移指向下一个节点
head = next;

循环终止条件是：

head == NULL</code></pre>
<p><img src="http://p2lakvkq0.bkt.clouddn.com/linkedlist.jpg"></p>
<p>题解一|指针迭代：</p>
<p>反转一个节点的时候，把一个节点的后驱改为指向它前驱就可以了。这里需要注意的点就是，当你把当前节点的后驱指向前驱的时候，这个时候链表会被截断，也就是说后面的节点和当前节点分开了，所以我们需要一个变量来保存当前节点的后驱，以访丢失。</p>
<p>第一个指针叫 pre，最初是指向 null 的。<br>第二个指针 cur 指向 head，然后不断遍历 cur。<br>每次迭代到 cur，都将 cur 的 next 指向 pre，然后 pre 和 cur 前进一位。<br>都迭代完了(cur 变成 null 了)，pre 就是最后一个节点了。</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode5.JPG" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode5.JPG"></p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/baidu_31657889/article/details/91552141">https://blog.csdn.net/baidu_31657889/article/details/91552141</a></p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reverseList(self, head):
        &quot;&quot;&quot;
        :type head: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        prve = None
        while head:
            next = head.next # 记录当前节点的下一个节点
            head.next = prve # 将当前节点指向pre
            prve = head # pre节点和head节点前进一位
            head = next
        return prve</code></pre>
<pre><code>class Solution:
    def reverseList(self, head: ListNode) -&gt; ListNode:
        pre=None
        while head:
            pre, pre.next, head = head, pre, head.next
        return pre</code></pre>
<p>???题解二|递归:</p>
<p>递归的两个条件：</p>
<pre><code>终止条件是当前节点或者下一个节点==null
在函数内部，改变节点的指向，也就是 head 的下一个节点指向 head 递归函数那句

很不好理解，其实就是 head 的下一个节点指向head。</code></pre>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reverseList(self, head: ListNode) -&gt; ListNode:
        if head is None or head.next is None:  
            return head  # 递归终止条件是当前为空，或者下一个节点为空
        cur=self.reverseList(head.next) # cur是最后一个节点5
        head.next.next=head 
        head.next=None
        return cur
</code></pre>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reverseList(self, head: ListNode) -&gt; ListNode:
        def helper(head):
            if head is None or head.next is None:
                return head,head
            pre,last=helper(head.next)
            last.next=head
            head.next=None
            return pre,head
        res,_=helper(head)
        return res,_</code></pre>
<p>问题扩展：部分节点进行反转</p>
<h3 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234.回文链表"></a>234.回文链表</h3><pre><code>链接：https://leetcode-cn.com/problems/palindrome-linked-list/

请判断一个链表是否为回文链表。

示例 1:

输入: 1-&gt;2
输出: false
示例 2:

输入: 1-&gt;2-&gt;2-&gt;1
输出: true
进阶：
你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</code></pre>
<p>数组列表底层是使用数组存储值，我们可以通过索引在 O(1)的时间访问列表任何位置的值，这是由于内存寻址的方式。</p>
<p>链表存储的是称为节点的对象，每个节点保存一个值和指向下一个节点的指针。访问某个特定索引的节点需要 O(n) 的时间，因为要通过指针获取到下一个位置的节点。</p>
<p>题解一|数组：</p>
<p>分析：</p>
<p>确定数组列表是否为回文很简单，我们可以使用双指针法来比较两端的元素，并向中间移动。一个指针从起点向中间移动，另一个指针从终点向中间移动。这需要 O(n)的时间，因为访问每个元素的时间是 O(1)，而有 n 个元素要访问。</p>
<p>然后，直接在链表上操作并不简单，因为不论是正向访问还是反向访问都不是 O(1)。而将链表的值复制到数组列表中是 O(n)，因此最简单的方法就是将链表的值复制到数组列表中，再使用双指针法判断。</p>
<p>算法：</p>
<pre><code>复制链表值到数组列表中。
使用双指针法判断是否为回文。</code></pre>
<p>第一步，我们需要遍历链表将值复制到数组列表中。我们用 currentNode 指向当前节点。每次迭代向数组添加 currentNode.val，并更新 currentNode = currentNode.next，当 currentNode = null 则停止循环。</p>
<p>执行第二部的最佳方法取决于你使用的编程语言。在 Python 中，很容易构造一个列表的反向副本，也很容易比较两个列表。在其他语言中，就没有那么简单。因此最好使用双指针法来检查是否为回文。我们在起点放置一个指针，在结尾放置一个指针，每一次迭代判断两个指针指向的元素是否相同，若不同，返回 false；相同则将两个指针向内移动，并继续判断，直到相遇。</p>
<p>在编码的过程中，注意我们比较的是节点值的大小，而不是节点本身。正确的比较方式是：node_1.val==node_2.val，node_1==node_2 是错误的。</p>
<p>复杂度：</p>
<p>时间复杂度：O(n)，其中 n 指的是链表的元素个数。</p>
<pre><code>第一步： 遍历链表并将值复制到数组中，O(n)。
第二步：双指针判断是否为回文，执行了 O(n/2) 次的判断，即 O(n)。
总的时间复杂度：O(2n) = O(n)</code></pre>
<p>空间复杂度：O(n)，其中 n 指的是链表的元素个数，我们使用了一个数组列表存放链表的元素值。</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def isPalindrome(self, head: ListNode) -&gt; bool:
        arr=[]
        while head:
            arr.append(head.val)
            head=head.next
        return arr==arr[::-1]</code></pre>
<p>快慢指针：</p>
<pre><code>        l = 0
        r = len(tmp)-1
        while l&lt;r:
            if tmp[l] != tmp[r]:
                return False
            l += 1
            r -= 1
        return True</code></pre>
<p>题解二|快慢指针+反转链表：</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def isPalindrome(self, head: ListNode) -&gt; bool:
        def reverseList(head):
            pre=None
            while head:
                next=head.next
                head.next=pre
                pre=head
                head=next
            return pre

        # 快慢指针，快指针到达尾部，慢指针到达中间
        slow=fast=head
        while fast and fast.next:
            slow=slow.next
            fast=fast.next.next

        newHead=reverseList(slow)
        p1=head
        p2=newHead
        while p1 and p2:
            if p1.val != p2.val:
                return False
            p1=p1.next
            p2=p2.next
        return True</code></pre>
<h3 id="237-删除链表中的节点"><a href="#237-删除链表中的节点" class="headerlink" title="237.删除链表中的节点"></a>237.删除链表中的节点</h3><pre><code>链接：https://leetcode-cn.com/problems/delete-node-in-a-linked-list/

请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。

现有一个链表 -- head = [4,5,1,9]，它可以表示为:

示例 1:

输入: head = [4,5,1,9], node = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.
示例 2:

输入: head = [4,5,1,9], node = 1
输出: [4,5,9]
解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.
 

说明:

链表至少包含两个节点。
链表中所有节点的值都是唯一的。
给定的节点为非末尾节点并且一定是链表中的一个有效节点。
不要从你的函数中返回任何结果。</code></pre>
<p>题解一：<br>时间复杂度 O(1)<br>空间复杂度 O(1)</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def deleteNode(self, node):
        &quot;&quot;&quot;
        :type node: ListNode
        :rtype: void Do not return anything, modify node in-place instead.
        &quot;&quot;&quot;
        node.val=node.next.val
        node.next=node.next.next</code></pre>
<h3 id="328-奇偶链表"><a href="#328-奇偶链表" class="headerlink" title="328. 奇偶链表"></a>328. 奇偶链表</h3><pre><code>链接：https://leetcode-cn.com/problems/odd-even-linked-list/

给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。

请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。

示例 1:

输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL
示例 2:

输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL 
输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL
说明:

应当保持奇数节点和偶数节点的相对顺序。
链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</code></pre>
<p>题解一：</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def oddEvenList(self, head: ListNode) -&gt; ListNode:
        # odd:奇数
        # even:偶数
        if not head:
            return
        odd=head
        evenHead=even=head.next
        while odd.next and even.next:
            odd.next=odd.next.next
            even.next=even.next.next
            odd,even=odd.next,even.next
        odd.next=evenHead
        return head</code></pre>
<h3 id="876-链表的中间节点"><a href="#876-链表的中间节点" class="headerlink" title="876.链表的中间节点"></a>876.链表的中间节点</h3><pre><code>链接：https://leetcode-cn.com/problems/middle-of-the-linked-list/

给定一个带有头结点 head 的非空单链表，返回链表的中间结点。

如果有两个中间结点，则返回第二个中间结点。

示例 1：

输入：[1,2,3,4,5]
输出：此列表中的结点 3 (序列化形式：[3,4,5])
返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。
注意，我们返回了一个 ListNode 类型的对象 ans，这样：
ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.
示例 2：

输入：[1,2,3,4,5,6]
输出：此列表中的结点 4 (序列化形式：[4,5,6])
由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。
 

提示：给定链表的结点数介于 1 和 100 之间。</code></pre>
<p>题解一|数组：</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def middleNode(self, head: ListNode) -&gt; ListNode:
        arr=[]
        dummy=head
        while head:
            arr.append(head.val)
            head=head.next
        mid=len(arr)//2
        i=0
        while dummy:
            if i==mid:
                return dummy
            dummy=dummy.next
            i+=1</code></pre>
<p>题解二|快慢指针：</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def middleNode(self, head: ListNode) -&gt; ListNode:
        slow=fast=head
        while fast and fast.next:
            slow=slow.next
            fast=fast.next.next
        return slow</code></pre>
<h3 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a>剑指 Offer 06. 从尾到头打印链表</h3><pre><code>链接：https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/

输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。

示例 1：

输入：head = [1,3,2]
输出：[2,3,1]

限制：

0 &lt;= 链表长度 &lt;= 10000</code></pre>
<p>题解一：</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reversePrint(self, head: ListNode) -&gt; List[int]:
        arr=[]
        while head:
            arr.append(head.val)
            head=head.next
        return arr[::-1]</code></pre>
<h3 id="面试题-02-01-移除重复节点"><a href="#面试题-02-01-移除重复节点" class="headerlink" title="面试题 02.01. 移除重复节点"></a>面试题 02.01. 移除重复节点</h3><pre><code>链接：https://leetcode-cn.com/problems/remove-duplicate-node-lcci/

编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。

示例1:

 输入：[1, 2, 3, 3, 2, 1]
 输出：[1, 2, 3]
示例2:

 输入：[1, 1, 1, 1, 2]
 输出：[1, 2]
提示：

链表长度在[0, 20000]范围内。
链表元素在[0, 20000]范围内。
进阶：

如果不得使用临时缓冲区，该怎么解决？</code></pre>
<p>题解一|hash：</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def removeDuplicateNodes(self, head: ListNode) -&gt; ListNode:
        dummy=res=ListNode(-1)
        dummy.next=head
        hash=&#123;&#125;
        while head:
            if head.val not in hash:
                hash[head.val]=1
                res=head
            else:
                res.next=head.next
            head=head.next
        return dummy.next</code></pre>
<p>题解二|二重循环|python运行超时：</p>
<p>思路：</p>
<pre><code>1.快慢双指针，第一层大循环为slow非空的循环，
2.第二层循环为fast循环，prev的下一个始终指向fast，保证出现fast.val==slow.val时，可以有效的删除相同结点，只需要fast和prev即可完美做到
3.slow和fast双层循环依次进行，slow和fast以及以后的依次比较，直到结束</code></pre>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def removeDuplicateNodes(self, head: ListNode) -&gt; ListNode:
        fast=slow=head
        while slow:
            fast=slow.next
            pre=slow
            while fast:
                if fast.val == slow.val: # 注意对比的是fast和slow
                    pre.next=fast.next
                else:
                    pre=pre.next
                fast=fast.next
            slow=slow.next
        return head</code></pre>
<h3 id="面试题-02-02-返回倒数第-k-个节点"><a href="#面试题-02-02-返回倒数第-k-个节点" class="headerlink" title="面试题 02.02. 返回倒数第 k 个节点"></a>面试题 02.02. 返回倒数第 k 个节点</h3><pre><code>链接：https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/

实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。

注意：本题相对原题稍作改动

示例：

输入： 1-&gt;2-&gt;3-&gt;4-&gt;5 和 k = 2
输出： 4
说明：

给定的 k 保证是有效的。</code></pre>
<p>题解一：</p>
<pre><code>class Solution:
    def kthToLast(self, head: ListNode, k: int) -&gt; int:
        res=head
        n=1
        while head.next:
            n+=1
            head=head.next
        k=n-k
        while k&gt;0:
            k-=1
            res=res.next
        return res.val
</code></pre>
<pre><code>class Solution:
    def kthToLast(self, head: ListNode, k: int) -&gt; int:
        tmp=head
        n=0
        while head:
            head=head.next
            n+=1
        k=n-k
        while k&gt;0:
            k-=1
            tmp=tmp.next
        return tmp.val</code></pre>
<p>题解二|快慢指针:</p>
<pre><code>定义两个指针，快指针 fast， 慢指针 slow .
让 fast 先向前移动 k 个位置，然后 slow 和 fast 再一起向前移动 .
当 fast 到达链表尾部，返回 slow .</code></pre>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def kthToLast(self, head: ListNode, k: int) -&gt; int:
        fast=slow=head
        while fast:
            fast=fast.next
            if k==0:
                slow=slow.next
            else:
                k-=1
        return slow.val
</code></pre>
<h3 id="面试题-02-03-删除中间节点"><a href="#面试题-02-03-删除中间节点" class="headerlink" title="面试题 02.03. 删除中间节点"></a>面试题 02.03. 删除中间节点</h3><pre><code>链接：https://leetcode-cn.com/problems/delete-middle-node-lcci/

实现一种算法，删除单向链表中间的某个节点（除了第一个和最后一个节点，不一定是中间节点），假定你只能访问该节点。

示例：

输入：单向链表a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f中的节点c
结果：不返回任何数据，但该链表变为a-&gt;b-&gt;d-&gt;e-&gt;f</code></pre>
<p>题解一：</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def deleteNode(self, node):
        &quot;&quot;&quot;
        :type node: ListNode
        :rtype: void Do not return anything, modify node in-place instead.
        &quot;&quot;&quot;
        node.val=node.next.val
        node.next=node.next.next</code></pre>
<h3 id="面试题-02-04-分割链表"><a href="#面试题-02-04-分割链表" class="headerlink" title="面试题 02.04. 分割链表"></a>面试题 02.04. 分割链表</h3><pre><code>链接：https://leetcode-cn.com/problems/partition-list-lcci/

编写程序以 x 为基准分割链表，使得所有小于 x 的节点排在大于或等于 x 的节点之前。如果链表中包含 x，x 只需出现在小于 x 的元素之后(如下所示)。分割元素 x 只需处于“右半部分”即可，其不需要被置于左右两部分之间。

示例:

输入: head = 3-&gt;5-&gt;8-&gt;5-&gt;10-&gt;2-&gt;1, x = 5
输出: 3-&gt;1-&gt;2-&gt;10-&gt;5-&gt;5-&gt;8</code></pre>
<p>题解一：</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def partition(self, head: ListNode, x: int) -&gt; ListNode:
        before=bf=ListNode(-1)
        after=af=ListNode(-1)
        while head:
            if head.val&lt;x:
                before.next=head
                before=before.next
            else:
                after.next=head
                after=after.next
            head=head.next
        after.next=None
        before.next=af.next
        return bf.next</code></pre>
<h3 id="面试题-02-05-链表求和"><a href="#面试题-02-05-链表求和" class="headerlink" title="面试题 02.05. 链表求和"></a>面试题 02.05. 链表求和</h3><pre><code>链接：https://leetcode-cn.com/problems/sum-lists-lcci/

给定两个用链表表示的整数，每个节点包含一个数位。

这些数位是反向存放的，也就是个位排在链表首部。

编写函数对这两个整数求和，并用链表形式返回结果。

示例：

输入：(7 -&gt; 1 -&gt; 6) + (5 -&gt; 9 -&gt; 2)，即617 + 295
输出：2 -&gt; 1 -&gt; 9，即912
进阶：假设这些数位是正向存放的，请再做一遍。

示例：

输入：(6 -&gt; 1 -&gt; 7) + (2 -&gt; 9 -&gt; 5)，即617 + 295
输出：9 -&gt; 1 -&gt; 2，即912</code></pre>
<p>题解一：</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:
        if not l1:
            return l2
        if not l2:
            return l1
        dummy=res=ListNode(0)
        flag=0
        while l1 or l2:
            sum=0
            if l1:
                sum+=l1.val
                l1=l1.next
            if l2:
                sum+=l2.val
                l2=l2.next
            tmp=(sum+flag)%10
            flag=(sum+flag)//10
            res.next=ListNode(tmp)
            res=res.next
        if flag:
            res.next=ListNode(flag)
            # res.next=ListNode(1)
        return dummy.next</code></pre>
<h3 id="面试题-02-06-回文链表"><a href="#面试题-02-06-回文链表" class="headerlink" title="面试题 02.06. 回文链表"></a>面试题 02.06. 回文链表</h3><pre><code>链接：https://leetcode-cn.com/problems/palindrome-linked-list-lcci/

编写一个函数，检查输入的链表是否是回文的。

示例 1：

输入： 1-&gt;2
输出： false 
示例 2：

输入： 1-&gt;2-&gt;2-&gt;1
输出： true 


进阶：
你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</code></pre>
<p>题解一|数组：</p>
<pre><code>class Solution:
    def isPalindrome(self, head: ListNode) -&gt; bool:
        arr=[]
        while head:
            arr.append(head.val)
            head=head.next
        return arr==arr[::-1]</code></pre>
<p>题解二|快慢指针:</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def isPalindrome(self, head: ListNode) -&gt; bool:
        if not head:
            return True
        slow=fast=head
        while fast and fast.next:
            slow=slow.next
            fast=fast.next.next
        pre=slow
        while slow and slow.next:
            next=slow.next.next
            slow.next.next=pre
            pre=slow.next
            slow.next=next
        while head and pre:
            if head.val != pre.val:
                return False
            head=head.next
            pre=pre.next
        return True</code></pre>
<h3 id="面试题-02-07-链表相交"><a href="#面试题-02-07-链表相交" class="headerlink" title="面试题 02.07. 链表相交"></a>面试题 02.07. 链表相交</h3><pre><code>链接：https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/

给定两个（单向）链表，判定它们是否相交并返回交点。请注意相交的定义基于节点的引用，而不是基于节点的值。换句话说，如果一个链表的第k个节点与另一个链表的第j个节点是同一节点（引用完全相同），则这两个链表相交。


示例 1：

输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。

示例 2：

输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Reference of the node with value = 2
输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。

示例 3：

输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
解释：这两个链表不相交，因此返回 null。

注意：

如果两个链表没有交点，返回 null 。
在返回结果后，两个链表仍须保持原有的结构。
可假定整个链表结构中没有循环。
程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</code></pre>
<p>题解一|循环|超时：</p>
<pre><code>class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode:
        p,q=headA.next,headB.next
        while p:
            while q:
                if p==q:
                    return q
            q=q.next
        p=p.next
        return None</code></pre>
<p>题解二|双指针：</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/link10.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/link10.png"></p>
<p>算法让两个指针分别从A和B点往C点走，两个指针分别走到C后，又各自从另外一个指针的起点，也就是A指针第二次走从B点开始走，B指针同理，这样，A指针走的路径长度 AO + OC + BO 必定等于B指针走的路径长度 BO + OC + AO，这也就意味着这两个指针第二轮走必定会在O点相遇，相遇后也即到达了退出循环的条件。</p>
<pre><code>class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode:
        p,q=headA,headB
        while p != q:
            if p:
                p=p.next
            else:
                p=headB
            if q:
                q=q.next
            else:
                q=headA
        return p</code></pre>
<h3 id="面试题-02-08-环路检测"><a href="#面试题-02-08-环路检测" class="headerlink" title="面试题 02.08. 环路检测"></a>面试题 02.08. 环路检测</h3><pre><code>链接：https://leetcode-cn.com/problems/linked-list-cycle-lcci/

给定一个有环链表，实现一个算法返回环路的开头节点。
有环链表的定义：在链表中某个节点的next元素指向在它前面出现过的节点，则表明该链表存在环路。

示例 1：

输入：head = [3,2,0,-4], pos = 1
输出：tail connects to node index 1
解释：链表中有一个环，其尾部连接到第二个节点。

示例 2：

输入：head = [1,2], pos = 0
输出：tail connects to node index 0
解释：链表中有一个环，其尾部连接到第一个节点。

示例 3：

输入：head = [1], pos = -1
输出：no cycle
解释：链表中没有环。

进阶：你是否可以不用额外空间解决此题？</code></pre>
<p>题解一|双指针：</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode6.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode6.png"></p>
<p>z=n*环的大小+z</p>
<pre><code>class Solution:
    def detectCycle(self, head: ListNode) -&gt; ListNode:
        if not head:
            return None
        slow=fast=head
        while  fast and fast.next:
            slow=slow.next
            fast=fast.next.next
            if slow==fast:
                slow=head
                while slow!=fast:
                    slow=slow.next
                    fast=fast.next
                return slow
        return None</code></pre>
<pre><code>class Solution:
    def detectCycle(self, head: ListNode) -&gt; ListNode:
        if not head:
            return None
        slow=fast=head
        while True:
            if not (fast and fast.next):
                return
            slow=slow.next
            fast=fast.next.next
            if slow == fast:
                break
        slow=head
        while slow != fast:
            slow=slow.next
            fast=fast.next
        return slow  </code></pre>
<h3 id="面试题18-删除链表的节点"><a href="#面试题18-删除链表的节点" class="headerlink" title="面试题18. 删除链表的节点"></a>面试题18. 删除链表的节点</h3><pre><code>链接：https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/

给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。

返回删除后的链表的头节点。

注意：此题对比原题有改动

示例 1:

输入: head = [4,5,1,9], val = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.
示例 2:

输入: head = [4,5,1,9], val = 1
输出: [4,5,9]
解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.


说明：

题目保证链表中节点的值互不相同
若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点</code></pre>
<p>题解一：</p>
<pre><code>class Solution:
    def deleteNode(self, head: ListNode, val: int) -&gt; ListNode:
        dummy=ListNode(-1)
        dummy.next=head
        res=dummy
        while res.next:
            if res.next.val==val:
                res.next=res.next.next
            else:
                res=res.next
        return dummy.next</code></pre>
<h3 id="面试题22-链表中倒数第k个节点"><a href="#面试题22-链表中倒数第k个节点" class="headerlink" title="面试题22. 链表中倒数第k个节点"></a>面试题22. 链表中倒数第k个节点</h3><pre><code>链接：https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/

个链表的倒数第3个节点是值为4的节点。

示例：

给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.

返回链表 4-&gt;5.</code></pre>
<p>题解一：</p>
<pre><code>class Solution:
    def getKthFromEnd(self, head: ListNode, k: int) -&gt; ListNode:
        fast=slow=head
        while fast:
            fast=fast.next
            if k==0:
                slow=slow.next
            else:
                k-=1
        return slow</code></pre>
<h3 id="面试题24-反转链表"><a href="#面试题24-反转链表" class="headerlink" title="面试题24. 反转链表"></a>面试题24. 反转链表</h3><pre><code>链接：https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/

定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

示例:

输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL


限制：

0 &lt;= 节点个数 &lt;= 5000</code></pre>
<p>题解一：</p>
<pre><code>class Solution:
    def reverseList(self, head: ListNode) -&gt; ListNode:
        pre=None
        while head:
            next=head.next
            head.next=pre
            pre=head
            head=next
        return pre</code></pre>
<h3 id="面试题35-复杂链表的复制"><a href="#面试题35-复杂链表的复制" class="headerlink" title="面试题35. 复杂链表的复制"></a>面试题35. 复杂链表的复制</h3><pre><code>链接：https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/

请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</code></pre>
<p>题解一：</p>
<pre><code>class Solution:
    def copyRandomList(self, head: &#39;Node&#39;) -&gt; &#39;Node&#39;:
        return copy.deepcopy(head)</code></pre>
<p>题解二|深度优先遍历：</p>
<pre><code>&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, x: int, next: &#39;Node&#39; = None, random: &#39;Node&#39; = None):
        self.val = int(x)
        self.next = next
        self.random = random
&quot;&quot;&quot;
class Solution:
    def copyRandomList(self, head: &#39;Node&#39;) -&gt; &#39;Node&#39;:
        def dfs(head):
            if not head:
                return None
            if head in visited:
                return visited[head]
            copy=Node(head.val,None,None)
            visited[head]=copy
            copy.next=dfs(head.next)
            copy.random=dfs(head.random)
            return copy
        visited=&#123;&#125;
        return dfs(head)</code></pre>
<p>题解三|bfs：</p>
<pre><code>&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, x: int, next: &#39;Node&#39; = None, random: &#39;Node&#39; = None):
        self.val = int(x)
        self.next = next
        self.random = random
&quot;&quot;&quot;
import collections

class Solution:
    def copyRandomList(self, head: &#39;Node&#39;) -&gt; &#39;Node&#39;:
        visited=&#123;&#125;
        def bfs(head):
            if not head:
                return None
            clone=Node(head.val,None,None)
            queue=collections.deque()
            queue.append(head)
            visited[head]=clone
            while queue:
                tmp=queue.pop()
                if tmp.next and tmp.next not in visited:
                    visited[tmp.next]=Node(tmp.next.val,[],[])
                    queue.append(tmp.next)
                if tmp.random and tmp.random not in visited:
                    visited[tmp.random] = Node(tmp.random.val, [], [])
                    queue.append(tmp.random)
                visited[tmp].next=visited.get(tmp.next)
                visited[tmp].random=visited.get(tmp.random)
            return clone
        return bfs(head)</code></pre>
<h3 id="面试题52-两个链表的第一个公共节点"><a href="#面试题52-两个链表的第一个公共节点" class="headerlink" title="面试题52. 两个链表的第一个公共节点"></a>面试题52. 两个链表的第一个公共节点</h3><pre><code>链接：https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/

输入两个链表，找出它们的第一个公共节点。

如下面的两个链表：

在节点 c1 开始相交。

示例 1：

输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。

示例 2：

输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Reference of the node with value = 2
输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。

示例 3：

输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
解释：这两个链表不相交，因此返回 null。

注意：

如果两个链表没有交点，返回 null.
在返回结果后，两个链表仍须保持原有的结构。
可假定整个链表结构中没有循环。
程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</code></pre>
<p>题解一|hash：</p>
<pre><code>class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode:
        p=headA
        q=headB
        hash=&#123;&#125;
        while headA:
            if headA not in hash:
                hash[headA]=1
                headA=headA.next
        while headB:
            if headB in hash:
                return headB
            else:
                headB=headB.next
        return None</code></pre>
<p>题解二|双指针：</p>
<p>时间复杂度：O(M+N)<br>空间复杂度：O(1)</p>
<pre><code>class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode:
        node1, node2 = headA, headB

        while node1 != node2:
            node1 = node1.next if node1 else headB
            node2 = node2.next if node2 else headA

        return node1</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/LeetCode-3-%E6%A0%91-%E4%B8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/LeetCode-3-%E6%A0%91-%E4%B8%80/" class="post-title-link" itemprop="url">LeetCode-3.树-一</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-02 15:49:29" itemprop="dateCreated datePublished" datetime="2020-01-02T15:49:29+08:00">2020-01-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-04 15:51:20" itemprop="dateModified" datetime="2020-11-04T15:51:20+08:00">2020-11-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>参考文章：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/bjwu/p/9284534.html">https://www.cnblogs.com/bjwu/p/9284534.html</a></p>
<h2 id="三、树"><a href="#三、树" class="headerlink" title="三、树"></a>三、树</h2><h3 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94.二叉树的中序遍历"></a>94.二叉树的中序遍历</h3><pre><code>链接：https://leetcode-cn.com/problems/binary-tree-inorder-traversal/

给定一个二叉树，返回它的中序 遍历。

示例:

输入: [1,null,2,3]
   1
    \
     2
    /
   3

输出: [1,3,2]
进阶: 递归算法很简单，你可以通过迭代算法完成吗？</code></pre>
<p>题解一（递归）：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def inorderTraversal(self, root: TreeNode) -&gt; List[int]:
        res=[]
        if root:
            res=self.inorderTraversal(root.left)
            res.append(root.val)
            res+=self.inorderTraversal(root.right)
        return res</code></pre>
<pre><code>class Solution:
    def inorderTraversal(self, root):
        &quot;&quot;&quot;
        :type root: TreeNode
        :rtype: List[int]
        &quot;&quot;&quot;
        if not root:
            return [] 
        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)</code></pre>
<p>题解二（迭代）:<br><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/inorder.png" alt="inorder"></p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def inorderTraversal(self, root: TreeNode) -&gt; List[int]:
        res=[]
        stack=[]
        curr=root
        while stack or curr:
            if curr:
                stack.append(curr)
                curr=curr.left
            else:
                curr=stack.pop()
                res.append(curr.val)
                curr=curr.right
        return res</code></pre>
<h3 id="95-不同的二叉搜索树-II"><a href="#95-不同的二叉搜索树-II" class="headerlink" title="?95.不同的二叉搜索树 II"></a>?95.不同的二叉搜索树 II</h3><pre><code>链接：https://leetcode-cn.com/problems/unique-binary-search-trees-ii/

给定一个整数 n，生成所有由 1 ... n 为节点所组成的二叉搜索树。

示例:

输入: 3
输出:
[
  [1,null,3,2],
  [3,2,null,1],
  [3,1,null,null,2],
  [2,1,3],
  [1,null,2,null,3]
]
解释:
以上的输出对应以下 5 种不同结构的二叉搜索树：

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3</code></pre>
<p>题解一|递归：<br><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/tree3.png" alt="tree3"><br><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/tree4.png" alt="tree4"></p>
<pre><code>所以如果求 1...n 的所有可能。

我们只需要把 1 作为根节点，[ ] 空作为左子树，[ 2 ... n ] 的所有可能作为右子树。

2 作为根节点，[ 1 ] 作为左子树，[ 3...n ] 的所有可能作为右子树。

3 作为根节点，[ 1 2 ] 的所有可能作为左子树，[ 4 ... n ] 的所有可能作为右子树，然后左子树和右子树两两组合。

4 作为根节点，[ 1 2 3 ] 的所有可能作为左子树，[ 5 ... n ] 的所有可能作为右子树，然后左子树和右子树两两组合。

...

n 作为根节点，[ 1... n ] 的所有可能作为左子树，[ ] 作为右子树。

至于，[ 2 ... n ] 的所有可能以及 [ 4 ... n ] 以及其他情况的所有可能，可以利用上边的方法，把每个数字作为根节点，然后把所有可能的左子树和右子树组合起来即可。

如果只有一个数字，那么所有可能就是一种情况，把该数字作为一棵树。而如果是 [ ]，那就返回 null。</code></pre>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def generateTrees(self, n: int) -&gt; List[TreeNode]:
        if n:
            return self.build(1,n)
        else:
            []
    def build(self,start,end):
        # 结束条件
        if start&gt;end:
            return [None,]

        trees=[]
        for i in range(start,end+1):
            leftTrees=self.build(start,i-1)
            rightTrees=self.build(i+1,end)
            for l in leftTrees:
                for r in rightTrees:
                    currentTree=TreeNode(i)
                    currentTree.left=l
                    currentTree.right=r
                    trees.append(currentTree)
        # print(trees)
        return trees</code></pre>
<h3 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96.不同的二叉搜索树"></a>96.不同的二叉搜索树</h3><pre><code>链接：https://leetcode-cn.com/problems/unique-binary-search-trees/

给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

示例:

输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3</code></pre>
<p>题解一（动态规划）:<br>二叉树定义：</p>
<p>二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-binary-search-trees/solution/bu-tong-de-er-cha-sou-suo-shu-by-leetcode/">https://leetcode-cn.com/problems/unique-binary-search-trees/solution/bu-tong-de-er-cha-sou-suo-shu-by-leetcode/</a><br>方法：</p>
<pre><code>给定一个有序序列 1 ... n，为了根据序列构建一棵二叉搜索树。我们可以遍历每个数字 i，将该数字作为树根，1 ... (i-1) 序列将成为左子树，(i+1) ... n 序列将成为右子树。于是，我们可以递归地从子序列构建子树。
在上述方法中，由于根各自不同，每棵二叉树都保证是独特的。

可见，问题可以分解成规模较小的子问题。因此，我们可以存储并复用子问题的解，而不是递归的（也重复的）解决这些子问题，这就是动态规划法。</code></pre>
<p>函数定义：</p>
<pre><code>令G(n)的从1到n可以形成二叉搜索树个数
令f(i)为以i为根的二叉搜索树的个数

所以G(n)是解决问题的函数：G(n) = f(1) + f(2) + f(3) + f(4) + ... + f(n)</code></pre>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/tree.png" alt="tree"></p>
<p>1、定义数组元素的含义<br>    G[i]代表二叉搜索树的个数<br>2、找出数组之间的的关系式<br>    以i为根，[0,i-1]为左节点，[i+1,n]为右节点<br>    之后再对[0,i-1]和[i+1,n]递归求解</p>
<pre><code>f(i)=G(i−1)∗G(n−i)

G(n)=G(0)∗G(n−1)+G(1)∗(n−2)+...+G(n−1)∗G(0)</code></pre>
<p>3、找出初始值<br>    G[0]=1<br>    G[1]=1<br>    G[2]=2</p>
<p>时间复杂度：O(n^2)<br>空间复杂度：O(n)</p>
<p>dp[2] = f(1)+f(2)= dp[0] * dp[1] (1为根的情况) + dp[1] * dp[0] (2为根的情况)</p>
<pre><code>class Solution:
    def numTrees(self, n: int) -&gt; int:
        dp=[0]*(n+1)
        dp[0]=1
        dp[1]=1

        for i in range(2,n+1):
            for j in range(1,i+1):
                dp[i]+=dp[j-1]*dp[i-j] 
        # print(dp)
        return dp[n]</code></pre>
<h3 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98.验证二叉搜索树"></a>98.验证二叉搜索树</h3><pre><code>链接：https://leetcode-cn.com/problems/validate-binary-search-tree/

给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：

节点的左子树只包含小于当前节点的数。
节点的右子树只包含大于当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。
示例 1:

输入:
    2
   / \
  1   3
输出: true
示例 2:

输入:
    5
   / \
  1   4
     / \
    3   6
输出: false
解释: 输入为: [5,1,4,null,null,3,6]。
     根节点的值为 5 ，但是其右子节点值为 4 。</code></pre>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/validate-binary-search-tree/solution/die-dai-yu-di-gui-by-powcai/">https://leetcode-cn.com/problems/validate-binary-search-tree/solution/die-dai-yu-di-gui-by-powcai/</a></p>
<p>题解一|递归:</p>
<p>理解：</p>
<pre><code>当前节点的值是其左子树的值的上界（最大值）
当前节点的值是其右子树的值的下界（最小值）</code></pre>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isValidBST(self, root: TreeNode) -&gt; bool:
        def helper(root,lower=float(&#39;-inf&#39;),upper=float(&#39;inf&#39;)):
            if not root:
                return True
            val=root.val
            if val&lt;=lower or val&gt;=upper:
                return False

            if not helper(root.right,val,upper):
                return False

            if not helper(root.left,lower,val):
                return False

            return True
        return helper(root)</code></pre>
<pre><code>class Solution:
    def isValidBST(self, root: TreeNode, low = float(&#39;-inf&#39;), high = float(&#39;inf&#39;)) -&gt; bool:
        if not root:return True
        if not low&lt;root.val&lt;high:return False
        return self.isValidBST(root.left,low,root.val) and self.isValidBST(root.right,root.val,high)</code></pre>
<p>题解二|迭代：<br>时间复杂度 : O(N)。每个结点访问一次。<br>空间复杂度 : O(N)。我们跟进了整棵树。</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isValidBST(self, root: TreeNode) -&gt; bool:
        if not root:
            return True # 空树，否则过不了case[]
        stack=[(root,float(&#39;-inf&#39;),float(&#39;inf&#39;)),]
        while stack:
            root,lower,upper=stack.pop()
            # print(lower,upper)
            if not root:
                continue
            val=root.val
            if val&gt;=upper or val&lt;=lower:
                return False
            stack.append((root.right,val,upper)) # 此处的left和right的顺序没有关系
            stack.append((root.left,lower,val))
        return True</code></pre>
<p>题解三|中序遍历:<br>    中序遍历[1,2,3]，检查 inorder 中的每个元素是否小于下一个。</p>
<pre><code>时间复杂度 : 最坏情况下（树为二叉搜索树或破坏条件的元素是最右叶结点）为 &#123;O&#125;(N)。
空间复杂度 : &#123;O&#125;(N) 用于存储 stack。</code></pre>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isValidBST(self, root: TreeNode) -&gt; bool:
        stack=[]
        inorder=float(&#39;-inf&#39;)
        while stack or root:
            while root:
                stack.append(root)
                root=root.left
            root=stack.pop()
            if root.val &lt;= inorder: # 注意小于号，否则[1,1]不能pass。
                return False
            inorder=root.val
            root=root.right
        return True</code></pre>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isValidBST(self, root: TreeNode) -&gt; bool:
        stack=[]
        inorder=float(&#39;-inf&#39;)
        while stack or root:
            if root:
                stack.append(root)
                root=root.left
            else:
                root=stack.pop()
                if root.val &lt;= inorder:
                    return False
                inorder=root.val
                root=root.right
        return True</code></pre>
<h3 id="99-恢复二叉搜索树"><a href="#99-恢复二叉搜索树" class="headerlink" title="99.恢复二叉搜索树"></a>99.恢复二叉搜索树</h3><pre><code>链接：https://leetcode-cn.com/problems/recover-binary-search-tree/

二叉搜索树中的两个节点被错误地交换。

请在不改变其结构的情况下，恢复这棵树。

示例 1:

输入: [1,3,null,null,2]

   1
  /
 3
  \
   2

输出: [3,1,null,null,2]

   3
  /
 1
  \
   2
示例 2:

输入: [3,1,4,null,null,2]

  3
 / \
1   4
   /
  2

输出: [2,1,4,null,null,3]

  2
 / \
1   4
   /
  3
进阶:

使用 O(n) 空间复杂度的解法很容易实现。
你能想出一个只使用常数空间的解决方案吗？</code></pre>
<p>思路:<br>    难点：找到2个节点进行交换</p>
<pre><code>二叉树搜索树的中序遍历(中序遍历遍历元素是递增的)

中序遍历顺序是 1,3,2,4,我们只要找到节点3和节点2交换顺序即可!

这里我们有个规律发现这两个节点:

    第一个节点,是第一个按照中序遍历时候前一个节点大于后一个节点,我们选取前一个节点,这里指节点3;

    第二个节点,是在第一个节点找到之后, 后面出现前一个节点大于后一个节点,我们选择后一个节点,这里指节点2;</code></pre>
<p>题解一|递归：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def recoverTree(self, root: TreeNode) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify root in-place instead.
        &quot;&quot;&quot;
        self.firstNode=None
        self.secondNode=None
        self.pre=TreeNode(float(&#39;-inf&#39;))
        def helper(root):
            if not root:
                return
            helper(root.left)
            if self.firstNode is None and self.pre.val &gt;= root.val:
                self.firstNode=self.pre
            if self.firstNode and self.pre.val &gt;= root.val:
                self.secondNode=root
            self.pre=root
            helper(root.right)
        helper(root)
        self.firstNode.val,self.secondNode.val=self.secondNode.val,self.firstNode.val</code></pre>
<p>题解二|迭代：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def recoverTree(self, root: TreeNode) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify root in-place instead.
        &quot;&quot;&quot;
        firstNode=None
        secondNode=None
        pre=TreeNode(float(&#39;-inf&#39;))
        stack=[]
        while stack or root:
            while root:
                stack.append(root)
                root=root.left
            root=stack.pop()

            if not firstNode and pre.val &gt; root.val:
                firstNode=pre
            if firstNode and pre.val &gt; root.val:
                secondNode=root
            pre=root
            root=root.right
        firstNode.val,secondNode.val=secondNode.val,firstNode.val</code></pre>
<h3 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100.相同的树"></a>100.相同的树</h3><pre><code>链接：https://leetcode-cn.com/problems/same-tree/

给定两个二叉树，编写一个函数来检验它们是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

示例 1:

输入:       1         1
          / \       / \
         2   3     2   3

        [1,2,3],   [1,2,3]

输出: true
示例 2:

输入:      1          1
          /           \
         2             2

        [1,2],     [1,null,2]

输出: false
示例 3:

输入:       1         1
          / \       / \
         2   1     1   2

        [1,2,1],   [1,1,2]

输出: false</code></pre>
<p>题解一|递归:</p>
<p>时间复杂度 : O(N)，其中 N 是树的结点数，因为每个结点都访问一次。</p>
<p>空间复杂度 : 最优情况（完全平衡二叉树）时为 O(log(N))，最坏情况下（完全不平衡二叉树）时为 O(N)，用于维护递归栈。</p>
<pre><code>class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def isSameTree(self, p: TreeNode, q: TreeNode) -&gt; bool:
        if p is None and q is None:
            return True
        if p is None or q is None:
            return False
        if p.val != q.val:
            return False

        return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)
</code></pre>
<pre><code>class Solution:
    def isSameTree(self, p: TreeNode, q: TreeNode) -&gt; bool:
        if p is None and q is None:
            return True
        if p is None or q is None:
            return False
        if p.val == q.val:
            return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)</code></pre>
<p>题解二|迭代:</p>
<p>时间复杂度 : O(N)，其中 N 是树的结点数，因为每个结点都访问一次。</p>
<p>空间复杂度 : 最优情况（完全平衡二叉树）时为 O(log(N))，最坏情况下（完全不平衡二叉树）时为 O(N)，用于维护双向队列。</p>
<pre><code>class Solution:
    def isSameTree(self, p: TreeNode, q: TreeNode) -&gt; bool:
        from collections import deque
        def helper(p,q):
            if not p and not q:
                return True
            if not p or not q:
                return False
            if p.val != q.val:
                return False
            return True
        deq=deque([(p,q),])
        while deq:
            p,q=deq.popleft()
            if not helper(p,q):
                return False
            # 此处改为if q也可以。
            if p:  # 当p和q为None时，此时p.left不成立，所以需要判断。
                deq.append((p.left,q.left))
                deq.append((p.right,q.right))
        return True</code></pre>
<p>总结：第一种方法就是先序遍历的递归形式，第二种方法是层次遍历的非递归算法</p>
<h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101.对称二叉树"></a>101.对称二叉树</h3><pre><code>链接：https://leetcode-cn.com/problems/symmetric-tree/
给定一个二叉树，检查它是否是镜像对称的。

例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

    1
   / \
  2   2
 / \ / \
3  4 4  3
但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

    1
   / \
  2   2
   \   \
   3    3</code></pre>
<p>题解一|递归:</p>
<pre><code>class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def isSymmetric(self, root: TreeNode) -&gt; bool:
        if root is None:
            return True
        return self.isMirror(root.left,root.right)

    def isMirror(self,p,q):
        if p is None and q is None:
            return True
        if p is None or q is None:
            return False
        #if left.val != right.val:
        #    return False
        l=self.isMirror(p.left,q.right)
        r=self.isMirror(q.left,p.right) # 注意：此处是对称，注意节点的选择。
        return p.val==q.val and l and r</code></pre>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isSymmetric(self, root: TreeNode) -&gt; bool:
        def helper(p,q):
            if not p and not q:
                return True
            if not p or not q:
                return False
            if p.val != q.val:
                return False
            return helper(p.left,q.right) and helper(p.right,q.left)
        if not root:
            return True
        return helper(root.left,root.right)</code></pre>
<p>题解二（迭代）：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isSymmetric(self, root: TreeNode) -&gt; bool:
        from collections import deque
        def helper(p,q):
            if not p and not q:
                return True
            if not p or not q:
                return False
            if p.val != q.val:
                return False
            return True
        deq=deque([(root,root),])
        while deq:
            p,q=deq.popleft()
            if not helper(p,q):
                return False
            if p:  # 当p和q为None时，此时p.left不成立，所以需要判断。
                deq.append((p.left,q.right))
                deq.append((p.right,q.left))
        return True</code></pre>
<p>别人的迭代：</p>
<pre><code>class Solution(object):
    def isSymmetric(self, root):
        if root == None:
            return True
        # 用队列保存节点
        queue = [root,root]
        while queue:
            # 从队列中取出两个节点，再比较这两个节点
            left = queue.pop()
            right = queue.pop()
            # 如果两个节点都为空就继续循环，两者有一个为空就返回false
            if(left == None and right == None):
                continue
            if(left == None or right == None):
                return False
            if left.val!=right.val:
                return False
            # 将左节点的左孩子， 右节点的右孩子放入队列
            queue.append(left.left)
            queue.append(right.right)
            # 将左节点的右孩子，右节点的左孩子放入队列
            queue.append(left.right)
            queue.append(right.left)
        return True</code></pre>
<h3 id="102-二叉树的层次遍历"><a href="#102-二叉树的层次遍历" class="headerlink" title="102.二叉树的层次遍历"></a>102.二叉树的层次遍历</h3><pre><code>链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal/

给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。

例如:
给定二叉树: [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回其层次遍历结果：

[
  [3],
  [9,20],
  [15,7]
]</code></pre>
<p>题解一|递归：</p>
<pre><code>class Solution:

    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:
        res=[]

        def helper(node,depth):
            if not node:
                return
            if len(res)==depth:
                res.append([])
            res[depth].append(node.val)
            helper(node.left,depth+1)
            helper(node.right,depth+1)
        helper(root,0)
        return res</code></pre>
<p>题解二|迭代：<br>    我们将树上顶点按照层次依次放入队列结构中，队列中元素满足 FIFO（先进先出）的原则。在 Java 中可以使用 Queue 接口中的 LinkedList实现。在 Python 中如果使用 Queue 结构，但因为它是为多线程之间安全交换而设计的，所以使用了锁，会导致性能不佳。因此在 Python 中可以使用 deque 的 append() 和 popleft() 函数来快速实现队列的功能。</p>
<pre><code>第 0 层只包含根节点 root ，算法实现如下：

    初始化队列只包含一个节点 root 和层次编号 0 ： level = 0。
    当队列非空的时候：
        在输出结果 levels 中插入一个空列表，开始当前层的算法。
        计算当前层有多少个元素：等于队列的长度。
        将这些元素从队列中弹出，并加入 levels 当前层的空列表中。
        将他们的孩子节点作为下一层压入队列中。
        进入下一层 level++。</code></pre>
<pre><code>from collections import deque
class Solution:

    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:
        if root is None:
            return 
        res=[]
        queue=deque() # queue=[]
        queue.append(root)
        while len(queue)&gt;0:
            p=queue.popleft() # p=queue.pop(0)
            res.append(p.val)

            if p.left:
                queue.append(p.left)
            if p.right:
                queue.append(p.right)

        return res

预期输出：[[3],[9,20],[15,7]]
实际输出：[3, 9, 20, 15, 7]

所以，要想得到预期输出，需要增加深度。</code></pre>
<pre><code>class Solution:

    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:
        if root is None:
            return 
        res=[]
        queue=[root] # 不能使用这个queue.append([root])
        depth=0

        while queue:
            res.append([])
            for i in range(len(queue)):
                node=queue.pop(0)
                res[depth].append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            depth+=1

        return res</code></pre>
<pre><code>class Solution:
    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:
        if not root: return []
        res = []
        cur_level = [root]
        while cur_level:
            tmp = []
            next_level = []
            for node in cur_level:
                tmp.append(node.val)
                if node.left:
                    next_level.append(node.left)
                if node.right:
                    next_level.append(node.right)
            res.append(tmp)
            cur_level = next_level
        return res</code></pre>
<h3 id="103-二叉树的锯齿形层次遍历"><a href="#103-二叉树的锯齿形层次遍历" class="headerlink" title="103.二叉树的锯齿形层次遍历"></a>103.二叉树的锯齿形层次遍历</h3><pre><code>链接：https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/

给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

例如：
给定二叉树 [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回锯齿形层次遍历如下：

[
  [3],
  [20,9],
  [15,7]
]</code></pre>
<p>思路：锯齿形遍历和层次遍历的差异，如果仍然按层次遍历，但是我要第一层从左往右，第二层从右往左，第三从左往右，这种zigzag遍历方式如何实现？</p>
<pre><code>对层数进行一个奇偶判断即可，如下：
if depth %2 == 0:
    res[depth].append(root.val)
else:
    res[depth].insert(0, root.val)</code></pre>
<p>题解一|递归:</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def zigzagLevelOrder(self, root: TreeNode) -&gt; List[List[int]]:
        res=[]
        def helper(root,depth):
            if not root:
                return
            if len(res)==depth:
                res.append([])
            if depth %2 == 0:
                res[depth].append(root.val)
            else:
                res[depth].insert(0, root.val)

            helper(root.left,depth+1)
            helper(root.right,depth+1)

        helper(root,0)
        return res</code></pre>
<p>题解二|迭代：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def zigzagLevelOrder(self, root: TreeNode) -&gt; List[List[int]]:
        if not root:
            return []
        res=[]
        queue=[root]
        depth=0

        while queue:
            res.append([])
            for i in range(len(queue)):
                node=queue.pop(0)
                if depth % 2 == 0:
                    res[depth].append(node.val)
                else:
                    res[depth].insert(0,node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            depth+=1
        return res</code></pre>
<h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a>104. 二叉树的最大深度</h3><pre><code>链接：https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

示例：
给定二叉树 [3,9,20,null,null,15,7]，

    3
   / \
  9  20
    /  \
   15   7
返回它的最大深度 3 。</code></pre>
<p>题解一|递归：<br><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/youdao/tree1.png" alt="tree1"><br><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/youdao/tree2.png" alt="tree2"></p>
<p>时间复杂度：我们每个结点只访问一次，因此时间复杂度为 O(N)，<br>其中 N 是结点的数量。</p>
<p>空间复杂度：在最糟糕的情况下，树是完全不平衡的，例如每个结点只剩下左子结点，递归将会被调用 N 次（树的高度），因此保持调用栈的存储将是 O(N)。但在最好的情况下（树是完全平衡的），树的高度将是 log(N)。因此，在这种情况下的空间复杂度将是 O(log(N))。</p>
<pre><code>class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def maxDepth(self, root: TreeNode) -&gt; int:
        if root is None:
            return 0
        else:
            leftHeight=self.maxDepth(root.left)
            rightHeight=self.maxDepth(root.right)
            return max(leftHeight,rightHeight)+1</code></pre>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def maxDepth(self, root: TreeNode) -&gt; int:
        if not root:
            return 0
        return max(self.maxDepth(root.left),self.maxDepth(root.right))+1</code></pre>
<p>题解二|迭代：</p>
<pre><code>class Solution:
    def maxDepth(self, root: TreeNode) -&gt; int:
        if root is None:
            return 0
        stack=[(1,root)]
        depth=0

        while stack:
            curr,root=stack.pop()
            if root: # 如果弹出的节点不为空
                depth=max(depth,curr)
                stack.append((curr+1,root.left))
                stack.append((curr+1,root.right))
        return depth</code></pre>
<h3 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105.从前序与中序遍历序列构造二叉树"></a>105.从前序与中序遍历序列构造二叉树</h3><pre><code>链接：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/

根据一棵树的前序遍历与中序遍历构造二叉树。

注意:
你可以假设树中没有重复的元素。

例如，给出

前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：

    3
   / \
  9  20
    /  \
   15   7</code></pre>
<p>题解一|递归、模拟法：<br>    前序遍历和中序遍历有以下特点：<br>        前序遍历： 根节点 | 左子树 | 右子树 ； 例如：[1 | 2 4 5 | 3 6 7]<br>        中序遍历： 左子树 | 根节点 | 右子树 ； 例如：[4 2 5 | 1 | 6 3 7]<br>        对于每个左子树、右子树的前序遍历和中序遍历依然有此规律。<br>    思路：<br>        按前序遍历的顺序每次pop并建立节点root，在中序遍历中找到root的对应index，划分出哪些节点构成此节点的左子树inorder[:i]，哪些构成右子树inorder[i+1:]。<br>        返回值：递归构建完当前节点root左右子树后，返回root，作为上轮递归父节点的left或right。<br>        终止条件： 当inorder[:i]中序遍历无剩余元素时，说明当前root已经越过叶子节点，直接返回None。</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode:
        if not inorder: # 只能是判断inorder，而不能是preorder
            return
        root=TreeNode(preorder.pop(0))
        i=inorder.index(root.val)
        # print(i,inorder[:i],inorder[i+1:])

        root.left=self.buildTree(preorder,inorder[:i])
        root.right=self.buildTree(preorder,inorder[i+1:])
        return root</code></pre>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode:
        if not inorder:
            return
        # 前序遍历第一个值为根节点
        root=TreeNode(preorder[0])
        # 因为没有重复元素，所以可以直接根据值来查找根节点在中序遍历中的位置
        i=inorder.index(preorder[0])
        # print(i,inorder[:i],inorder[i+1:])

        # 构建左子树
        root.left=self.buildTree(preorder[1:i+1],inorder[:i])
        # 构建右子树
        root.right=self.buildTree(preorder[i+1:],inorder[i+1:])
        return root</code></pre>
<h3 id="106-从中序和后序遍历序列构造二叉树"><a href="#106-从中序和后序遍历序列构造二叉树" class="headerlink" title="106.从中序和后序遍历序列构造二叉树"></a>106.从中序和后序遍历序列构造二叉树</h3><pre><code>链接：https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/

根据一棵树的中序遍历与后序遍历构造二叉树。

注意:
你可以假设树中没有重复的元素。

例如，给出

中序遍历 inorder = [9,3,15,20,7]
后序遍历 postorder = [9,15,7,20,3]
返回如下的二叉树：

    3
   / \
  9  20
    /  \
   15   7</code></pre>
<p>题解一|递归：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -&gt; TreeNode: 
        if not inorder:
            return
        root=TreeNode(postorder.pop(-1))
        i=inorder.index(root.val)
        root.right=self.buildTree(inorder[i+1:],postorder) # 注意：需要先右节点，再左节点
        root.left=self.buildTree(inorder[0:i],postorder)
        return root</code></pre>
<pre><code>class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -&gt; TreeNode: 
        if len(inorder) == 0:
            return None

        # 后序遍历最后一个节点为根节点
        root = TreeNode(postorder[-1])

        # 根节点在中序遍历中的位置
        index = inorder.index(postorder[-1])

        # 构造左子树
        root.left = self.buildTree(inorder[:index], postorder[:index])

        # 构造右子树
        root.right = self.buildTree(inorder[index+1:], postorder[index:len(postorder) - 1])
        # root.right = self.buildTree(inorder[index+1:], postorder[index:-1])

        return root</code></pre>
<h3 id="107-二叉树的层次遍历-II"><a href="#107-二叉树的层次遍历-II" class="headerlink" title="107.二叉树的层次遍历 II"></a>107.二叉树的层次遍历 II</h3><pre><code>链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/

给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

例如：
给定二叉树 [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回其自底向上的层次遍历为：

[
  [15,7],
  [9,20],
  [3]
]</code></pre>
<p>题解一|递归：</p>
<pre><code>class Solution:
    def levelOrderBottom(self, root: TreeNode) -&gt; List[List[int]]:
        res=[]
        def helper(node,depth):
            if not node:
                return
            if len(res)==depth:
                res.insert(0,[])

            res[-(depth+1)].append(node.val)
            helper(node.left,depth+1)
            helper(node.right,depth+1)
        helper(root,0)
        return res</code></pre>
<p>题解二|迭代：</p>
<pre><code>class Solution:
    def levelOrderBottom(self, root: TreeNode) -&gt; List[List[int]]:
        from collections import deque
        if root is None: return
        queue=deque()
        queue.appendleft(root)
        res=[]
        while queue:
            tmp=[]
            for i in range(len(queue)):
                node=queue.pop()
                tmp.append(node.val)
                if node.left:
                    queue.appendleft(node.left)
                if node.right:
                    queue.appendleft(node.right)
            res.insert(0,tmp) # 注意与从上到下层次遍历区别
        return res</code></pre>
<pre><code>class Solution:
    def levelOrderBottom(self, root: TreeNode) -&gt; List[List[int]]:
        from collections import deque
        if root is None: return
        queue=deque()
        queue.append(root)
        res=[]
        while queue:
            tmp=[]
            for i in range(len(queue)):
                node=queue.popleft()
                tmp.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            res.insert(0,tmp)
        return res</code></pre>
<h3 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108.将有序数组转换为二叉搜索树"></a>108.将有序数组转换为二叉搜索树</h3><pre><code>链接：https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/

将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。

示例:

给定有序数组: [-10,-3,0,5,9],

一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：

      0
     / \
   -3   9
   /   /
 -10  5</code></pre>
<p>二叉搜索树：<br>    若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值<br>    若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值<br>    任意节点的左、右子树也分别为二叉搜索树<br>    没有键值相等的节点</p>
<p>二叉搜索树的特性：二叉搜索树的中序遍历结果为递增序列。</p>
<p>平衡二叉树，既然要做到平衡，我们只要把根节点选为数组的中点即可。</p>
<p>参考文章：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/solution/jiang-you-xu-shu-zu-zhuan-huan-wei-er-cha-sou-s-15/">https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/solution/jiang-you-xu-shu-zu-zhuan-huan-wei-er-cha-sou-s-15/</a></p>
<p>题解一|递归+二分：</p>
<p>1、函数作用<br>通过上述解题过程我们可以明确该问题的子问题是：构造树的每个节点以及该节点的左右子树。因此，递归函数的作用很明显：</p>
<pre><code>选取要构造关系的节点并创建它
构造该节点的左子树
构造该节点的右子树</code></pre>
<p>函数的输入为递增数组，函数的返回为完成构造的节点。</p>
<p>2、何时结束<br>当输入的递增数组为空时，只能构成一棵空树，此时返回空节点。</p>
<p>3、何时调用<br>当构造节点的左右子树时，对递增数组进行拆分并进行递归调用。</p>
<p>时间复杂度：O(n)<br>空间复杂度：O(log(n))</p>
<pre><code>class Solution:
    def sortedArrayToBST(self, nums: List[int]) -&gt; TreeNode:
        if not nums: # 此处使用if nums is None会越界。
            return None
        mid=len(nums)//2
        node=TreeNode(nums[mid])

        left=nums[:mid]
        right=nums[mid+1:]

        node.left=self.sortedArrayToBST(left)
        node.right=self.sortedArrayToBST(right)

        # node.left, node.right = map(self.sortedArrayToBST, [nums[:mid], nums[mid+1:]])

        return node</code></pre>
<p>扩展：将有序数组转换为二叉搜索树的结果为什么 不唯一 ？</p>
<p>众所周知，二叉搜索树的中序遍历是一个升序序列。</p>
<p>将有序数组作为输入，可以把该问题看做根据中序遍历序列创建二叉搜索树。</p>
<pre><code>这个问题的答案唯一吗。例如：是否可以根据中序遍历序列和二叉搜索树之间是否一一对应，答案是否定的。</code></pre>
<p>关于 BST 的知识：</p>
<pre><code>中序遍历不能唯一确定一棵二叉搜索树。
先序和后序遍历不能唯一确定一棵二叉搜索树。
先序/后序遍历和中序遍历的关系：
inorder = sorted(postorder) = sorted(preorder)，
中序+后序、中序+先序可以唯一确定一棵二叉树。</code></pre>
<p>因此，“有序数组 -&gt; BST”有多种答案：</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/bitTree1.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/bitTree1.png"></p>
<p>因此，添加一个附件条件：树的高度应该是平衡的、例如：每个节点的两棵子树高度差不超过 1。</p>
<pre><code>这种情况下答案唯一吗？仍然没有。</code></pre>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/bitTree2.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/bitTree2.png"></p>
<p>高度平衡意味着每次必须选择中间数字作为根节点。这对于奇数个数的数组是有用的，但对偶数个数的数组没有预定义的选择方案。</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/bitTree3.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/bitTree3.png"></p>
<p>对于偶数个数的数组，要么选择中间位置左边的元素作为根节点，要么选择中间位置右边的元素作为根节点，不同的选择方案会创建不同的平衡二叉搜索树。方法一始终选择中间位置左边的元素作为根节点，方法二始终选择中间位置右边的元素作为根节点。方法一和二会生成不同的二叉搜索树，这两种答案都是正确的。</p>
<h4 id="1、中序遍历：始终选择中间位置左边元素作为根节点"><a href="#1、中序遍历：始终选择中间位置左边元素作为根节点" class="headerlink" title="1、中序遍历：始终选择中间位置左边元素作为根节点"></a>1、中序遍历：始终选择中间位置左边元素作为根节点</h4><p>时间复杂度：O(N)，每个元素只访问一次。<br>空间复杂度：O(N)，二叉搜索树空间 O(N)，递归栈深度 O(logN)。</p>
<pre><code>class Solution:
    def sortedArrayToBST(self, nums: List[int]) -&gt; TreeNode:        
        def helper(left, right):
            if left &gt; right:
                return None

            mid=(left+right)//2
            root=TreeNode(nums[mid])
            root.left=helper(left,mid-1)
            root.right=helper(mid+1,right)
            return root

        return helper(0,len(nums)-1)</code></pre>
<h4 id="2、中序遍历：始终选择中间位置右边元素作为根节点"><a href="#2、中序遍历：始终选择中间位置右边元素作为根节点" class="headerlink" title="2、中序遍历：始终选择中间位置右边元素作为根节点"></a>2、中序遍历：始终选择中间位置右边元素作为根节点</h4><p>时间复杂度：O(N)，每个元素只访问一次。<br>空间复杂度：O(N)，二叉搜索树空间 O(N)，递归栈深度 O(logN)。</p>
<pre><code>class Solution:
    def sortedArrayToBST(self, nums: List[int]) -&gt; TreeNode:        
        def helper(left, right):
            if left &gt; right:
                return None

            mid=(left+right)//2
            if (left+right) % 2:
                mid+=1
            root=TreeNode(nums[mid])
            root.left=helper(left,mid-1)
            root.right=helper(mid+1,right)
            return root

        return helper(0,len(nums)-1)
</code></pre>
<h4 id="3、中序遍历：选择任意一个中间位置元素作为根节点"><a href="#3、中序遍历：选择任意一个中间位置元素作为根节点" class="headerlink" title="3、中序遍历：选择任意一个中间位置元素作为根节点"></a>3、中序遍历：选择任意一个中间位置元素作为根节点</h4><p>不做预定义选择，每次随机选择中间位置左边或者右边元素作为根节点。每次运行的结果都不同，但都是正确的。</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/bitTree4.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/bitTree4.png"></p>
<p>时间复杂度：O(N)，每个元素只访问一次。<br>空间复杂度：O(N)，二叉搜索树空间 O(N)，递归栈深度 O(logN)。</p>
<pre><code>from random import randint
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -&gt; TreeNode:        
        def helper(left, right):
            if left &gt; right:
                return None

            mid=(left+right)//2
            if (left+right) % 2:
                mid+=randint(0,1)
            root=TreeNode(nums[mid])
            root.left=helper(left,mid-1)
            root.right=helper(mid+1,right)
            return root

        return helper(0,len(nums)-1)
</code></pre>
<p>扩展：关于Python not 及is None的有趣现象（两者的区别）</p>
<pre><code>在使用 if A is None 来实现判断条件的时候，最后程序没有通过。这里的A代表之前定义的list类型的数据。最用改成if not A才通过。

那么到底判断A为空两者有什么区别呢。

发现A为空时，not A 就是True，但是这并不代表该对象没有定义，也不代表该对象没有其它的属性。它只是代表A中元素为空，仅此而已。

如果要看对象是否有定义，就要使用 is None来判断。

if not nums 和 if nums is None 有什么区别？
空列表, 0, None都满足第一个条件, 但是第二个只有None才满足</code></pre>
<h3 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110.平衡二叉树"></a>110.平衡二叉树</h3><pre><code>链接：https://leetcode-cn.com/problems/balanced-binary-tree/

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。

示例 1:

给定二叉树 [3,9,20,null,null,15,7]

    3
   / \
  9  20
    /  \
   15   7
返回 true 。

示例 2:

给定二叉树 [1,2,2,3,3,null,null,4,4]

       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
返回 false 。</code></pre>
<p>题解一|递归|自顶向下：</p>
<p>构造一个获取当前节点最大深度的方法 depth() ，通过比较左右子树最大高度差abs(self.depth(root.left) - self.depth(root.right))，来判断以此节点为根节点下是否是二叉平衡树；</p>
<p>从顶至底DFS，以每个节点为根节点，递归判断是否是平衡二叉树：</p>
<pre><code>若所有根节点都满足平衡二叉树性质，则返回 True ；
若其中任何一个节点作为根节点时，不满足平衡二叉树性质，则返回False。</code></pre>
<p>本方法产生大量重复的节点访问和计算，最差情况下时间复杂度 O(N^2)。</p>
<pre><code>class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def isBalanced(self, root: TreeNode) -&gt; bool:
        if root is None:
            return True
        return abs(self.height(root.left)-self.height(root.right))&lt;=1 and self.isBalanced(root.left) and self.isBalanced(root.right)

    def height(self,node):
        if not node:
            return 0
        return max(self.height(node.left),self.height(node.right))+1
</code></pre>
<p>?题解二|自底向上：</p>
<p>对二叉树做深度优先遍历DFS，递归过程中：</p>
<pre><code>终止条件：当DFS越过叶子节点时，返回高度0；
返回值：
    从底至顶，返回以每个节点root为根节点的子树最大高度(左右子树中最大的高度值加1，max(left,right) + 1)；
    当我们发现有一例 左/右子树高度差 ＞ 1 的情况时，代表此树不是平衡树，返回-1；

当发现不是平衡树时，后面的高度计算都没有意义了，因此一路返回-1，避免后续多余计算。</code></pre>
<p>最差情况是对树做一遍完整DFS，时间复杂度为 O(N)。</p>
<pre><code>class Solution:
    def isBalanced(self, root: TreeNode) -&gt; bool:
        return self.depth(root) != -1
    def depth(self,root):
        if not root:
            return 0
        left=self.depth(root.left)
        if left == -1:
            return -1
        right=self.depth(root.right)
        if right == -1:
            return -1

        return max(left,right)+1 if abs(left-right)&lt;=1 else -1</code></pre>
<h3 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111.二叉树的最小深度"></a>111.二叉树的最小深度</h3><pre><code>链接：https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

说明: 叶子节点是指没有子节点的节点。

示例:

给定二叉树 [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回它的最小深度  2.</code></pre>
<p>题解一|递归：</p>
<pre><code>class Solution:
    def minDepth(self, root: TreeNode) -&gt; int:
        if root is None:
            return 0
        else:
            leftHeight=self.minDepth(root.left)
            rightHeight=self.minDepth(root.right)
            if not root.left:
                return rightHeight+1
            if not root.right:
                return leftHeight+1
            return min(leftHeight,rightHeight)+1</code></pre>
<p>思路：</p>
<pre><code>1. 当 root 节点左右孩子都为空时，返回 1
2. 当 root 节点左右孩子有一个为空时，返回不为空的孩子节点的深度
3. 当 root 节点左右孩子都不为空时，返回左右孩子较小深度的节点值</code></pre>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def minDepth(self, root: TreeNode) -&gt; int:
        if not root:
            return 0
        left=self.minDepth(root.left)
        right=self.minDepth(root.right)
        if not root.left and not root.right:
            return 1
        elif not root.left or not root.right:
            if root.left:
                return left+1
            else:
                return right+1
        else:
            return min(left,right)+1</code></pre>
<p>题解二|层次遍历:</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def minDepth(self, root: TreeNode) -&gt; int:
        from collections import deque
        if root is None:
            return 0
        queue=deque()
        queue.append((root,1)) # 不能使用queue=deque((root,1))
        while queue:
            node,dep=queue.popleft()
            if not node.left and not node.right:
                return dep
            if node.left:
                queue.append((node.left,dep+1))
            if node.right:
                queue.append((node.right,dep+1))</code></pre>
<pre><code>from collections import deque
def minDepth(root):
    if not root:
        return 0
    queue=deque([root])
    depth=1
    while queue:
        size=len(queue)
        for i in range(size):
            cur=queue.pop()
            if not cur.left and not cur.right:
                return depth
            if cur.left:
                queue.appendleft(cur.left)
            if cur.right:
                queue.appendleft(cur.right)
        depth+=1
    return depth
</code></pre>
<h3 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a>114. 二叉树展开为链表</h3><pre><code>链接：https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/

给定一个二叉树，原地将它展开为一个单链表。

例如，给定二叉树

    1
   / \
  2   5
 / \   \
3   4   6
将其展开为：

1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6</code></pre>
<p>思路：</p>
<pre><code>将左子树插入到右子树的地方；
将原来的右子树接到左子树的最右边节点；
考虑新的右子树的根节点，一直重复上边的过程，直到新的右子树为 null；

    1
   / \
  2   5
 / \   \
3   4   6

//将 1 的左子树插入到右子树的地方
    1
     \
      2         5
     / \         \
    3   4         6        
//将原来的右子树接到左子树的最右边节点
    1
     \
      2          
     / \          
    3   4  
         \
          5
           \
            6

//将 2 的左子树插入到右子树的地方
    1
     \
      2          
       \          
        3       4  
                 \
                  5
                   \
                    6   

//将原来的右子树接到左子树的最右边节点
    1
     \
      2          
       \          
        3      
         \
          4  
           \
            5
             \
              6         </code></pre>
<p>题解一|递归：</p>
<pre><code>class Solution:
    def flatten(self, root: TreeNode) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify root in-place instead.
        &quot;&quot;&quot;
        if not root:
            return 
        if root.left: 
            pre=root.left # pre指向左子树
            while pre.right:
                pre=pre.right # 找到左子树的最右节点
            pre.right=root.right # 左子树的最右节点的右子树指向根节点的右子树
            root.right=root.left # 令根节点的右子树指向根节点的左子树
            root.left=None # 置空根节点的左子树
        self.flatten(root.left)
        self.flatten(root.right)</code></pre>
<p>题解二|迭代：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def flatten(self, root: TreeNode) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify root in-place instead.
        &quot;&quot;&quot;
        while root:
            if root.left:
                tmp=root.left
                while tmp.right:
                    tmp=tmp.right
                tmp.right=root.right
                root.right=root.left
                root.left=None
            root=root.right
        return </code></pre>
<h3 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a>116. 填充每个节点的下一个右侧节点指针</h3><pre><code>链接：https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/

给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

struct Node &#123;
  int val;
  Node *left;
  Node *right;
  Node *next;
&#125;
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有 next 指针都被设置为 NULL。

示例：

输入：&#123;&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:4&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:5&#125;,&quot;val&quot;:2&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:6&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;7&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7&#125;,&quot;val&quot;:3&#125;,&quot;val&quot;:1&#125;

输出：&#123;&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:null,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7&#125;,&quot;right&quot;:null,&quot;val&quot;:6&#125;,&quot;right&quot;:null,&quot;val&quot;:5&#125;,&quot;right&quot;:null,&quot;val&quot;:4&#125;,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;7&quot;,&quot;left&quot;:&#123;&quot;$ref&quot;:&quot;5&quot;&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;6&quot;&#125;,&quot;val&quot;:3&#125;,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;4&quot;&#125;,&quot;val&quot;:2&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;7&quot;&#125;,&quot;val&quot;:1&#125;

解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。

提示：

你只能使用常量级额外空间。
使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</code></pre>
<p>题解一|递归：</p>
<pre><code>&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val: int = 0, left: &#39;Node&#39; = None, right: &#39;Node&#39; = None, next: &#39;Node&#39; = None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next
&quot;&quot;&quot;
class Solution:
    def connect(self, root: &#39;Node&#39;) -&gt; &#39;Node&#39;:
        def helper(root):
            if not root:
                return
            l=root.left
            r=root.right
            while l: # while l and r:也可以
                l.next=r
                l=l.right
                r=r.left
            helper(root.left)
            helper(root.right)
        helper(root)
        return root</code></pre>
<p>题解二|迭代：</p>
<pre><code>&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val: int = 0, left: &#39;Node&#39; = None, right: &#39;Node&#39; = None, next: &#39;Node&#39; = None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next
&quot;&quot;&quot;
class Solution:
    def connect(self, root: &#39;Node&#39;) -&gt; &#39;Node&#39;:
        if not root:
            return
        queue=[root]
        while queue:
            size=len(queue)
            for i in range(size):
                tmp=queue.pop(0)
                if i &lt; size-1:
                    tmp.next=queue[0]
                if tmp.left:
                    queue.append(tmp.left)
                if tmp.right:
                    queue.append(tmp.right)
        return root</code></pre>
<h3 id="117-填充每个节点的下一个右侧节点指针-II"><a href="#117-填充每个节点的下一个右侧节点指针-II" class="headerlink" title="117. 填充每个节点的下一个右侧节点指针 II"></a>117. 填充每个节点的下一个右侧节点指针 II</h3><pre><code>链接：https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/

给定一个二叉树

struct Node &#123;
  int val;
  Node *left;
  Node *right;
  Node *next;
&#125;
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有 next 指针都被设置为 NULL。

进阶：

你只能使用常量级额外空间。
使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。

示例：

输入：root = [1,2,3,4,5,null,7]
输出：[1,#,2,3,#,4,5,7,#]
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。


提示：

树中的节点数小于 6000
-100 &lt;= node.val &lt;= 100</code></pre>
<p>？？题解一|递归：</p>
<pre><code>&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val: int = 0, left: &#39;Node&#39; = None, right: &#39;Node&#39; = None, next: &#39;Node&#39; = None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next
&quot;&quot;&quot;
class Solution:
    def connect(self, root: &#39;Node&#39;) -&gt; &#39;Node&#39;:
        def helper(root):
            if not root:
                return
            if root.left:
                return root.left
            if root.right:
                return root.right
            if root.next:
                return helper(root.next)
            return

        if not root:
            return
        if root.left and root.right:
            root.left.next=root.right
            root.right.next=helper(root.next)
        elif root.left:
            root.left.next=helper(root.next)
        elif root.right:
            root.right.next=helper(root.next)

        # 注意：先递归右子树，否则右子树根节点next关系没建立好，左子树到右子树子节点无法正确挂载
        self.connect(root.right)
        self.connect(root.left)
        return root</code></pre>
<p>题解二|迭代：</p>
<pre><code>&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val: int = 0, left: &#39;Node&#39; = None, right: &#39;Node&#39; = None, next: &#39;Node&#39; = None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next
&quot;&quot;&quot;

class Solution:
    def connect(self, root: &#39;Node&#39;) -&gt; &#39;Node&#39;:
        if not root:
            return
        queue=[root]
        while queue:
            size=len(queue)
            for i in range(size):
                tmp=queue.pop(0)
                if i &lt; size-1:
                    tmp.next=queue[0]
                if tmp.left:
                    queue.append(tmp.left)
                if tmp.right:
                    queue.append(tmp.right)
        return root</code></pre>
<h3 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a>124. 二叉树中的最大路径和</h3><pre><code>链接：https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/

给定一个非空二叉树，返回其最大路径和。

本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。

示例 1:

输入: [1,2,3]

       1
      / \
     2   3

输出: 6
示例 2:

输入: [-10,9,20,null,null,15,7]

   -10
   / \
  9  20
    /  \
   15   7

输出: 42</code></pre>
<p>??题解一|递归：</p>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/solution/shou-hui-tu-jie-hen-you-ya-de-yi-dao-dfsti-by-hyj8/">https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/solution/shou-hui-tu-jie-hen-you-ya-de-yi-dao-dfsti-by-hyj8/</a></p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def maxPathSum(self, root: TreeNode) -&gt; int:
        self.ans=float(&#39;-inf&#39;)
        def helper(root):
            if not root:
                return 0
            # 递归计算左右子节点的最大贡献值
            # 只有在最大贡献值大于0时，才回选取对应子节点
            leftMax=max(0,helper(root.left))
            rightMax=max(0,helper(root.right))

            # 节点的最大路径和取决于该节点值与该节点的左右节点的最大贡献值
            price=root.val+leftMax+rightMax  

            # 更新答案
            self.ans=max(self.ans,price)

            # 返回节点的最大贡献值
            return root.val+max(leftMax,rightMax)
        helper(root)
        return self.ans</code></pre>
<h3 id="129-求根到叶子节点数字之和"><a href="#129-求根到叶子节点数字之和" class="headerlink" title="129. 求根到叶子节点数字之和"></a>129. 求根到叶子节点数字之和</h3><pre><code>链接：https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/

给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。

例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。

计算从根到叶子节点生成的所有数字之和。

说明: 叶子节点是指没有子节点的节点。

示例 1:

输入: [1,2,3]
    1
   / \
  2   3
输出: 25
解释:
从根到叶子节点路径 1-&gt;2 代表数字 12.
从根到叶子节点路径 1-&gt;3 代表数字 13.
因此，数字总和 = 12 + 13 = 25.
示例 2:

输入: [4,9,0,5,1]
    4
   / \
  9   0
 / \
5   1
输出: 1026
解释:
从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495.
从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491.
从根到叶子节点路径 4-&gt;0 代表数字 40.
因此，数字总和 = 495 + 491 + 40 = 1026.</code></pre>
<p>题解一|递归：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def sumNumbers(self, root: TreeNode) -&gt; int:
        res=[]
        def helper(root,tmp=&#39;&#39;):
            if not root:
                return 
            if not root.left and not root.right:
                tmp+=str(root.val)
                res.append(tmp)
            helper(root.left,tmp+str(root.val))
            helper(root.right,tmp+str(root.val))
        helper(root)
        ans=0
        for i in res:
            ans+=int(i)
        return ans</code></pre>
<h3 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144.二叉树的前序遍历"></a>144.二叉树的前序遍历</h3><pre><code>链接：https://leetcode-cn.com/problems/binary-tree-preorder-traversal/

给定一个二叉树，返回它的 前序 遍历。

 示例:

输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [1,2,3]
进阶: 递归算法很简单，你可以通过迭代算法完成吗？</code></pre>
<p>题解一|递归：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def preorderTraversal(self, root: TreeNode) -&gt; List[int]:
        ans=[]
        if root:
            ans.append(root.val)
            ans+=self.preorderTraversal(root.left) # 这儿我之前直接用append，出来的结果会列表中嵌套列表
            ans+=self.preorderTraversal(root.right)
        return ans</code></pre>
<p>题解二|迭代|辅助栈|后进先出：</p>
<p>1、把二叉树的根节点 root 放进栈。</p>
<p>2、如果栈不为空，从栈中取出一个节点，把该节点放入容器的尾部；如果该节点的右子树不为空，则把有节点放入栈；如果该节点的左子树不为空，则把左子树放入栈中。</p>
<p>3、一直重复步骤 2 ，直到栈为空，此时遍历结束。</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def preorderTraversal(self, root: TreeNode) -&gt; List[int]:
        res=[]
        stack=[]
        stack.append(root)
        if root is None:
            return res
        while stack:
            tmp=stack.pop()
            res.append(tmp.val)
            if tmp.right:
                stack.append(tmp.right)
            if tmp.left:
                stack.append(tmp.left)
        return res</code></pre>
<p>题解三|迭代：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def preorderTraversal(self, root: TreeNode) -&gt; List[int]:
        res=[]
        stack=[]
        curr=root
        while stack or curr:
            if curr:
                res.append(curr.val)
                stack.append(curr.right)
                curr=curr.left
            else:
                curr=stack.pop()
        return res</code></pre>
<h3 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145.二叉树的后序遍历"></a>145.二叉树的后序遍历</h3><pre><code>链接：

给定一个二叉树，返回它的 后序 遍历。

示例:

输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [3,2,1]
进阶: 递归算法很简单，你可以通过迭代算法完成吗？</code></pre>
<p>题解一|递归:</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def postorderTraversal(self, root: TreeNode) -&gt; List[int]:
        res=[]
        if root:
            res=self.postorderTraversal(root.left)
            res+=self.postorderTraversal(root.right)
            res.append(root.val)
        return res</code></pre>
<p>题解二|迭代|辅助栈：</p>
<p>1、把二叉树的根节点 root 放进栈。</p>
<p>2、如果栈不为空，从栈中取出一个节点，把该节点插入到容器的头部。；如果该节点的左子树不为空，则把该左子树放入栈中；如果该节点的右子树不为空，则把右子树放入栈中。，</p>
<p>注意，之前的前序遍历和中序遍历，我们都是用 ArrayList 容器，并且是把节点插入到容器的尾部，这就是后序遍历的不同点。</p>
<p>3、一直重复步骤 2 ，直到栈为空，此时遍历结束。</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def postorderTraversal(self, root: TreeNode) -&gt; List[int]:
        res=[]
        stack=[]
        if root is None:
            return res
        stack.append(root)
        while stack:
            tmp=stack.pop()
            res.insert(0,tmp.val)
            if tmp.left:
                stack.append(tmp.left)
            if tmp.right:
                stack.append(tmp.right)
        return res</code></pre>
<p>题解三|递归：</p>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--34/">https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--34/</a></p>
<p>如果当前节点的右节点和上一次遍历的节点相同，那就表明当前是从右节点过来的了。</p>
<pre><code>class Solution:
    def postorderTraversal(self, root: TreeNode) -&gt; List[int]:
        res=[]
        stack=[]
        cur=root
        last=None

        while cur or stack:
            if cur:
                stack.append(cur)
                cur=cur.left
            else:
                tmp=stack[-1]
                # 是否变到右子树
                if tmp.right and tmp.right !=last:
                    cur=tmp.right
                else:
                    res.append(tmp.val)
                    last=tmp
                    stack.pop()
        return res
</code></pre>
<h3 id="173-二叉搜索树迭代器"><a href="#173-二叉搜索树迭代器" class="headerlink" title="173. 二叉搜索树迭代器"></a>173. 二叉搜索树迭代器</h3><pre><code>链接：https://leetcode-cn.com/problems/binary-search-tree-iterator/

实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。

调用 next() 将返回二叉搜索树中的下一个最小的数。

示例：

BSTIterator iterator = new BSTIterator(root);
iterator.next();    // 返回 3
iterator.next();    // 返回 7
iterator.hasNext(); // 返回 true
iterator.next();    // 返回 9
iterator.hasNext(); // 返回 true
iterator.next();    // 返回 15
iterator.hasNext(); // 返回 true
iterator.next();    // 返回 20
iterator.hasNext(); // 返回 false


提示：

next() 和 hasNext() 操作的时间复杂度是 O(1)，并使用 O(h) 内存，其中 h 是树的高度。
你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 中至少存在一个下一个最小的数。</code></pre>
<p>题解一|扁平化二叉搜索树：</p>
<p>时间复杂度：</p>
<p>构造迭代器花费的时间为 O(N)，问题陈述只要求我们分析两个函数的复杂性，但是在实现类时，还要注意初始化类对象所需的时间；在这种情况下，时间复杂度与二叉搜索树中的节点数成线性关系。</p>
<pre><code>next()：O(1)
hasNext()：O(1)</code></pre>
<p>空间复杂度：</p>
<p>O(N)，由于我们创建了一个数组来包含二叉搜索树中的所有节点值，这不符合问题陈述中的要求，任一函数的最大空间复杂度应为 O(h)，其中 h 指的是树的高度，对于平衡的二叉搜索树，高度通常为 logN。</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class BSTIterator:

    def __init__(self, root: TreeNode):
        self.queue=[]
        self.index=-1
        self.inorder(root)

    def inorder(self,root):
        if not root:
            return
        self.inorder(root.left)
        self.queue+=[root.val] # self.queue.append([root.val])
        self.inorder(root.right)

    def next(self) -&gt; int:
        &quot;&quot;&quot;
        @return the next smallest number
        &quot;&quot;&quot;
        self.index+=1
        return self.queue[self.index]

    def hasNext(self) -&gt; bool:
        &quot;&quot;&quot;
        @return whether we have a next smallest number
        &quot;&quot;&quot;
        return self.index+1 &lt; len(self.queue)

# Your BSTIterator object will be instantiated and called as such:
# obj = BSTIterator(root)
# param_1 = obj.next()
# param_2 = obj.hasNext()</code></pre>
<p>题解二|受控递归：</p>
<p>时间复杂度：</p>
<pre><code>hasNext()：若栈中还有元素，则返回 true，反之返回 false。所以这是一个 O(1) 的操作。

next()：包含了两个主要步骤。一个是从栈中弹出一个元素，它是下一个最小的元素。这是一个 O(1) 的操作。然而，随后我们要调用帮助函数 _inorder_left ，它需要递归的，将左节点添加到栈上，是线性时间的操作，最坏的情况下为 O(N)。但是我们只对含有右节点的节点进行调用，它也不会总是处理 N 个节点。只有当我们有一个倾斜的树，才会有 N 个节点。因此该操作的平均时间复杂度仍然是 O(1)，符合问题中所要求的。</code></pre>
<p>空间复杂度：O(h)，使用了一个栈来模拟递归。</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class BSTIterator:

    def __init__(self, root: TreeNode):
        self.queue=[]
        self.inorder(root)

    def inorder(self,root):
        while root:
            self.queue.append(root)
            root=root.left

    def next(self) -&gt; int:
        &quot;&quot;&quot;
        @return the next smallest number
        &quot;&quot;&quot;
        top=self.queue.pop()
        if top.right:
            self.inorder(top.right)
        return top.val

    def hasNext(self) -&gt; bool:
        &quot;&quot;&quot;
        @return whether we have a next smallest number
        &quot;&quot;&quot;
        return len(self.queue) &gt; 0



# Your BSTIterator object will be instantiated and called as such:
# obj = BSTIterator(root)
# param_1 = obj.next()
# param_2 = obj.hasNext()</code></pre>
<h3 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a>199. 二叉树的右视图</h3><pre><code>链接：https://leetcode-cn.com/problems/binary-tree-right-side-view/

给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

示例:

输入: [1,2,3,null,5,null,4]
输出: [1, 3, 4]
解释:

   1            &lt;---
 /   \
2     3         &lt;---
 \     \
  5     4       &lt;---</code></pre>
<p>题解一|递归：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def rightSideView(self, root: TreeNode) -&gt; List[int]:
        res=[]
        def helper(root,level):
            if not root:
                return []
            if level &gt; len(res):
                res.append(root.val)
            helper(root.right,level+1)
            helper(root.left,level+1)
        helper(root,1)
        return res</code></pre>
<p>题解二|广度优先搜索：</p>
<p>时间复杂度 : O(n)。 每个节点最多进队列一次，出队列一次，因此广度优先搜索的复杂度为线性。</p>
<p>空间复杂度 : O(n)。每个节点最多进队列一次，所以队列长度最大不不超过 n，所以这里的空间代价为 O(n)。</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def rightSideView(self, root):
        right=dict()
        max_depth=-1
        queue=[(root,0)]
        while queue:
            node,depth=queue.pop(0)
            if node:
                max_depth=max(max_depth,depth)
                right[depth]=node.val
                queue.append((node.left,depth+1))
                queue.append((node.right,depth+1))
        return [right[i] for i in range(max_depth+1)]</code></pre>
<p>题解三|深度优先搜索：</p>
<p>时间复杂度 : O(n)。深度优先搜索最多访问每个结点一次，因此是线性复杂度。</p>
<p>空间复杂度 : O(n)。最坏情况下，栈内会包含接近树高度的结点数量，占用 O(n) 的空间。</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def rightSideView(self, root):
        right=dict()
        max_depth=-1
        queue=[(root,0)]
        while queue:
            node,depth=queue.pop()
            if node:
                max_depth=max(max_depth,depth)
                right.setdefault(depth,node.val)
                queue.append((node.left,depth+1))
                queue.append((node.right,depth+1))
        return [right[i] for i in range(max_depth+1)]</code></pre>
<h3 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222.完全二叉树的节点个数"></a>222.完全二叉树的节点个数</h3><pre><code>链接：https://leetcode-cn.com/problems/count-complete-tree-nodes/

给出一个完全二叉树，求出该树的节点个数。

说明：

完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。

示例:

输入: 
    1
   / \
  2   3
 / \  /
4  5 6

输出: 6</code></pre>
<p>题解一|递归：</p>
<p>时间复杂度：O(N)。<br>空间复杂度：O(logN)，其中 d 指的是树的的高度，运行过程中堆栈所使用的空间。</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def countNodes(self, root: TreeNode) -&gt; int:

        self.res=0
        def helper(root):
            if not root:
                return 0
            if root:
                self.res+=1
            helper(root.left)
            helper(root.right)
            return self.res
        helper(root)

        return self.res</code></pre>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def __init__(self):
        self.res=0
    def countNodes(self, root: TreeNode) -&gt; int:
        if not root:
            return 0
        self.res+=1
        self.countNodes(root.left)
        self.countNodes(root.right)
        return self.res</code></pre>
<pre><code>class Solution:
    def countNodes(self, root: TreeNode) -&gt; int:
        return 1 + self.countNodes(root.right) + self.countNodes(root.left) if root else 0</code></pre>
<h3 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a>226. 翻转二叉树</h3><pre><code>链接：https://leetcode-cn.com/problems/invert-binary-tree/

翻转一棵二叉树。

示例：

输入：

     4
   /   \
  2     7
 / \   / \
1   3 6   9
输出：

     4
   /   \
  7     2
 / \   / \
9   6 3   1
备注:
这个问题是受到 Max Howell 的 原问题 启发的 ：

谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。</code></pre>
<p>题解一|递归：</p>
<p>交换一下左右节点，然后再递归的交换左节点，右节点。</p>
<p>递归的两个条件：</p>
<pre><code>终止条件：当前节点为null时返回
交换当前节点的左右节点，再递归的交换当前节点的左节点，递归的交换当前节点的右节点</code></pre>
<p>时间复杂度：每个元素都必须访问一次，所以是O(n)<br>空间复杂度：最坏的情况下，需要存放O(h)个函数调用(h是树的高度)，所以是O(h)</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def invertTree(self, root: TreeNode) -&gt; TreeNode:
        if not root:
            return
        root.left,root.right=self.invertTree(root.right),self.invertTree(root.left)
        return root</code></pre>
<pre><code>class Solution:
    def invertTree(self, root: TreeNode) -&gt; TreeNode:
        if not root:
            return
        root.left,root.right=root.right,root.left
        self.invertTree(root.left)
        self.invertTree(root.right)
        return root</code></pre>
<p>题解二|迭代|广度优先遍历）：</p>
<p>递归实现也就是深度优先遍历的方式，那么对应的就是广度优先遍历。</p>
<p>广度优先遍历需要额外的数据结构–队列，来存放临时遍历到的元素。</p>
<p>深度优先遍历的特点是一竿子插到底，不行了再退回来继续；而广度优先遍历的特点是层层扫荡。<br>所以，我们需要先将根节点放入到队列中，然后不断的迭代队列中的元素。<br>对当前元素调换其左右子树的位置，然后：</p>
<pre><code>判断其左子树是否为空，不为空就放入队列中
判断其右子树是否为空，不为空就放入队列中</code></pre>
<p>时间复杂度：同样每个节点都需要入队列/出队列一次，所以是O(n)<br>空间复杂度：最坏的情况下会包含所有的叶子节点，完全二叉树叶子节点是n/2个，所以时间复杂度是0(n)</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def invertTree(self, root: TreeNode) -&gt; TreeNode:
        if not root:
            return
        queue=[root] # 将二叉树中的节点逐层放入队列中，再迭代处理队列中的元素
        while queue:
            tmp=queue.pop(0) # 每次都从队列中拿一个节点，并交换这个节点的左右子树
            tmp.left,tmp.right=tmp.right,tmp.left
            if tmp.left: # 如果当前节点的左子树不为空，则放入队列等待后续处理 
                queue.append(tmp.left)
            if tmp.right: # 如果当前节点的右子树不为空，则放入队列等待后续处理    
                queue.append(tmp.right)
        return root # 返回处理完的根节点</code></pre>
<h3 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230. 二叉搜索树中第K小的元素"></a>230. 二叉搜索树中第K小的元素</h3><pre><code>给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。

说明：
你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。

示例 1:

输入: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
输出: 1
示例 2:

输入: root = [5,3,6,2,4,null,null,1], k = 3
       5
      / \
     3   6
    / \
   2   4
  /
 1
输出: 3
进阶：
如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化 kthSmallest 函数？</code></pre>
<p>题解一|递归|中序遍历：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthSmallest(self, root: TreeNode, k: int) -&gt; int:
        res=[]
        def inorder(root):
            if not root:
                return []
            return inorder(root.left)+[root.val]+inorder(root.right)
        return inorder(root)[k-1]</code></pre>
<p>题解二|迭代：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthSmallest(self, root: TreeNode, k: int) -&gt; int:
        stack=[]
        while True:
            while root:
                stack.append(root)
                root=root.left
            root=stack.pop()
            k-=1
            if not k:
                return root.val
            root=root.right</code></pre>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthSmallest(self, root: TreeNode, k: int) -&gt; int:
        if not root or not k:
            return
        stack=[]
        while stack or root:
            if root:
                stack.append(root)
                root=root.left
            else:
                root=stack.pop()
                k-=1
                if not k:
                    return root.val
                root=root.right</code></pre>
<h3 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a>235. 二叉搜索树的最近公共祖先</h3><pre><code>链接：https://leetcode-cn.com/problems/
lowest-common-ancestor-of-a-binary-search-tree/

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]

示例 1:

输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6 
解释: 节点 2 和节点 8 的最近公共祖先是 6。
示例 2:

输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
输出: 2
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。


说明:

所有节点的值都是唯一的。
p、q 为不同节点且均存在于给定的二叉搜索树中。</code></pre>
<p>题解一|递归：</p>
<p>思路：</p>
<pre><code>1、从根节点开始遍历树
2、如果节点 p 和节点 q 都在右子树上，那么以右孩子为根节点继续 1 的操作
3、如果节点 p 和节点 q 都在左子树上，那么以左孩子为根节点继续 1 的操作
4、如果条件 2 和条件 3 都不成立，这就意味着我们已经找到节 p 和节点 q 的 最近公共祖先(LCA) 了</code></pre>
<p>时间复杂度：O(N)<br>其中 N 为 BST 中节点的个数，在最坏的情况下我们可能需要访问 BST 中所有的节点。</p>
<p>空间复杂度：O(N)<br>所需开辟的额外空间主要是递归栈产生的，之所以是 N 是因为 BST 的高度为 N。</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: &#39;TreeNode&#39;, p: &#39;TreeNode&#39;, q: &#39;TreeNode&#39;) -&gt; &#39;TreeNode&#39;:
        if not root:
            return
        if p.val &lt; root.val and q.val &lt; root.val:
            return self.lowestCommonAncestor(root.left,p,q)
        elif p.val &gt; root.val and q.val &gt; root.val:
            return self.lowestCommonAncestor(root.right,p,q)
        else:
            return root</code></pre>
<p>题解二|迭代：</p>
<p>时间复杂度：O(N)<br>其中 NN 为 BST 中节点的个数，在最坏的情况下我们可能需要遍历 BST 中所有的节点。</p>
<p>空间复杂度：O(1)</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: &#39;TreeNode&#39;, p: &#39;TreeNode&#39;, q: &#39;TreeNode&#39;) -&gt; &#39;TreeNode&#39;:
        if not root:
            return
        while root:
            if p.val &lt; root.val and q.val &lt; root.val:
                root=root.left
            elif p.val &gt; root.val and q.val &gt; root.val:
                root=root.right
            else:
                return root</code></pre>
<h3 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a>236. 二叉树的最近公共祖先</h3><pre><code>链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]

示例 1:

输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
示例 2:

输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出: 5
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。

说明:

所有节点的值都是唯一的。
p、q 为不同节点且均存在于给定的二叉树中。</code></pre>
<p>题解一|递归：</p>
<p>最近公共祖先的定义： 设节点 root 为节点 p, q 的某公共祖先，若其左子节点 root.left 和右子节点 root.right 都不是 p,q 的公共祖先，则称 root 是 “最近的公共祖先” 。</p>
<p>根据以上定义，若 root 是 p, q 的 最近公共祖先 ，则只可能为以下情况之一：</p>
<p>p 和 q 在 root 的子树中，且分列 root 的 异侧（即分别在左、右子树中）；<br>p = root ，且 q 在 root 的左或右子树中；<br>q = root ，且 p 在 root 的左或右子树中；</p>
<p>递归解析：</p>
<p>1、终止条件：</p>
<pre><code>当越过叶节点，则直接返回 null ；
当 root 等于 p, q，则直接返回 root ；</code></pre>
<p>2、递推工作：</p>
<pre><code>开启递归左子节点，返回值记为 left ；
开启递归右子节点，返回值记为 right ；</code></pre>
<p>3、返回值： 根据 left 和 right ，可展开为四种情况；</p>
<pre><code>(1)当 left 和 right 同时为空 ：说明 root 的左/右子树中都不包含 p,q ，返回 null ；
(2)当 left 和 right 同时不为空 ：说明 p, q 分列在 root 的 异侧 （分别在 左 / 右子树），因此 root 为最近公共祖先，返回 root ；
(3)当 left 为空 ，right 不为空 ：p,q 都不在 root 的左子树中，直接返回 right。具体可分为两种情况：

    p,q 其中一个在 root 的 右子树 中，此时 right 指向 p（假设为 p ）；
    p,q 两节点都在 root 的 右子树 中，此时的 right 指向 最近公共祖先节点 ；

(4)当 left 不为空 ， right 为空 ：与情况 3. 同理；</code></pre>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: &#39;TreeNode&#39;, p: &#39;TreeNode&#39;, q: &#39;TreeNode&#39;) -&gt; &#39;TreeNode&#39;:
        if not root or root == p or root == q:
            return root
        left=self.lowestCommonAncestor(root.left,p,q)
        right=self.lowestCommonAncestor(root.right,p,q)
        if left and right: # 1
            return root
        elif not left and not right: # 2
            return 
        elif not left:  # 3
            return right
        elif not right: # 4
            return left</code></pre>
<h3 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a>257. 二叉树的所有路径</h3><pre><code>链接：https://leetcode-cn.com/problems/binary-tree-paths/

给定一个二叉树，返回所有从根节点到叶子节点的路径。

说明: 叶子节点是指没有子节点的节点。
示例:

输入:

   1
 /   \
2     3
 \
  5

输出: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]

解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3</code></pre>
<p><a target="_blank" rel="noopener" href="https://www.dazhuanlan.com/2019/10/18/5da9456f33ee7/">https://www.dazhuanlan.com/2019/10/18/5da9456f33ee7/</a></p>
<p>题解一|递归：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def binaryTreePaths(self, root: TreeNode) -&gt; List[str]:
        if not root:
            return []
        res=[]
        def helper(root,path):
            if not root.left and not root.right:
                res.append(path)
            if root.left:
                helper(root.left,path+&#39;-&gt;&#39;+str(root.left.val))
            if root.right:
                helper(root.right,path+&#39;-&gt;&#39;+str(root.right.val))
        helper(root,&#39;&#39;+str(root.val))
        return res</code></pre>
<p>题解二|回溯：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def binaryTreePaths(self, root: TreeNode) -&gt; List[str]:
        res=[]
        def helper(root,path):
            if root:
                path.append(str(root.val))
                left=helper(root.left,path)
                right=helper(root.right,path)
                if not left and not right:
                    res.append(&#39;-&gt;&#39;.join(path))
                path.pop()
                return True  # 别漏掉

        helper(root,[])
        return res</code></pre>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def binaryTreePaths(self, root: TreeNode) -&gt; List[str]:
        if not root:
            return []
        res=[]
        def helper(node,path):
            path.append(str(node.val))
            if not node.left and not node.right:
                res.append(&#39;-&gt;&#39;.join(path))
                return 
            if node.left:
                helper(node.left,path)
                path.pop()
            if node.right:
                helper(node.right,path)
                path.pop()
        helper(root,[])
        return res</code></pre>
<h3 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404. 左叶子之和"></a>404. 左叶子之和</h3><pre><code>链接：https://leetcode-cn.com/problems/sum-of-left-leaves/

计算给定二叉树的所有左叶子之和。

示例：

    3
   / \
  9  20
    /  \
   15   7

在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</code></pre>
<p>题解一|递归：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def sumOfLeftLeaves(self, root: TreeNode) -&gt; int:
        if not root:
            return 0
        self.res=0
        def helper(root):
            if not root:
                return 0
            # 注意：是左叶子，而不是左节点。
            if root.left and not root.left.left and not root.left.right: 
                self.res+=root.left.val
            helper(root.left)
            helper(root.right)
        helper(root)
        return self.res</code></pre>
<pre><code>class Solution:
    def sumOfLeftLeaves(self, root: TreeNode) -&gt; int:
        if not root:
            return 0
        sum = 0
        if root.left and not root.left.left and not root.left.right:
        # if root.left: 题目是左叶子，并非左结点。
            sum += root.left.val
        sum += self.sumOfLeftLeaves(root.left)
        sum += self.sumOfLeftLeaves(root.right)
        return sum</code></pre>
<p>题解二|迭代：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def sumOfLeftLeaves(self, root: TreeNode) -&gt; int:
        if not root:
            return 0
        stack=[root]
        res=0
        while stack:
            node=stack.pop()
            if node:
                if node.left and not node.left.left and not node.left.right:
                    res+=node.left.val
                stack.append(node.left)
                stack.append(node.right)
        return res</code></pre>
<h3 id="429-N叉树的层序遍历"><a href="#429-N叉树的层序遍历" class="headerlink" title="429. N叉树的层序遍历"></a>429. N叉树的层序遍历</h3><pre><code>给定一个 N 叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。

例如，给定一个 3叉树 :

返回其层序遍历:

[
     [1],
     [3,2,4],
     [5,6]
]

说明:

树的深度不会超过 1000。
树的节点总数不会超过 5000。</code></pre>
<p>题解一|迭代：</p>
<pre><code>&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
&quot;&quot;&quot;

class Solution:
    def levelOrder(self, root: &#39;Node&#39;) -&gt; List[List[int]]:
        if not root:
            return
        res=[]
        stack=[root]
        depth=0
        while stack:
            res.append([])
            for i in range(len(stack)):
                root=stack.pop(0)
                res[depth].append(root.val)
                for i in root.children:
                    stack.append(i)
            depth+=1
        return res</code></pre>
<pre><code>&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
&quot;&quot;&quot;

class Solution:
    def levelOrder(self, root: &#39;Node&#39;) -&gt; List[List[int]]:
        if not root:
            return
        res=[]
        stack=[root]
        depth=0
        while stack:
            res.append([])
            for i in range(len(stack)):
                root=stack.pop(0)
                res[depth].append(root.val)
                stack.extend(root.children)
                # for i in root.children:
                #     stack.append(i)
            depth+=1
        return res</code></pre>
<pre><code>&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
&quot;&quot;&quot;

class Solution:
    def levelOrder(self, root: &#39;Node&#39;) -&gt; List[List[int]]:
        if not root:
            return
        res=[]
        stack=[root]
        while stack:
            tmp=[]
            for i in range(len(stack)):
                root=stack.pop(0)
                tmp.append(root.val)
                stack.extend(root.children)
            res.append(tmp)
        return res</code></pre>
<pre><code>&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
&quot;&quot;&quot;

class Solution:
    def levelOrder(self, root: &#39;Node&#39;) -&gt; List[List[int]]:
        if not root:
            return
        res=[]
        stack=[root]
        while stack:
            tmp=[]
            res.append([])
            for i in stack:
                res[-1].append(i.val)
                tmp.extend(i.children)
            stack=tmp
        return res</code></pre>
<p>题解二|递归：</p>
<pre><code>&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
&quot;&quot;&quot;
class Solution:
    def levelOrder(self, root: &#39;Node&#39;) -&gt; List[List[int]]:
        res=[]
        def helper(node,depth):
            if not root:
                return
            if len(res)==depth:
                res.append([])
            res[depth].append(node.val)
            for i in node.children:
                helper(i,depth+1)
        helper(root,0)
        return res</code></pre>
<h3 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501. 二叉搜索树中的众数"></a>501. 二叉搜索树中的众数</h3><pre><code>链接：https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/

给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。

假定 BST 有如下定义：

结点左子树中所含结点的值小于等于当前结点的值
结点右子树中所含结点的值大于等于当前结点的值
左子树和右子树都是二叉搜索树
例如：
给定 BST [1,null,2,2],

   1
    \
     2
    /
   2
返回[2].

提示：如果众数超过1个，不需考虑输出顺序

进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</code></pre>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def findMode(self, root: TreeNode) -&gt; List[int]:
        hash=&#123;&#125;
        def helper(root):
            if root:
                if root.val not in hash:
                    hash[root.val]=1
                else:
                    hash[root.val]+=1
                helper(root.left)
                helper(root.right)

        helper(root)
        res=[]
        if not root:
            return 
        count=max(hash.values())
        for k,v in hash.items():
            if count==v:
                res.append(k)
        return res</code></pre>
<p>题解二|二叉搜索树处理：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def findMode(self, root: TreeNode) -&gt; List[int]:
        self.maxTimes=1
        self.curTimes=0
        self.lastNode=None
        self.ans=[]
        def helper(node):
            if node:
                helper(node.left)
                if self.lastNode and self.lastNode.val == node.val:
                    self.curTimes+=1
                else:
                    self.curTimes=1
                self.lastNode=node
                if self.curTimes == self.maxTimes:
                    self.ans.append(node.val)
                elif self.curTimes &gt; self.maxTimes:
                    self.ans=[]
                    self.maxTimes=self.curTimes
                    self.ans.append(node.val)
                helper(node.right)
        helper(root)
        return self.ans</code></pre>
<p>题解三|普通二叉树处理：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def findMode(self, root: TreeNode) -&gt; List[int]:
        self.maxTimes=1
        self.hash=dict()
        self.ans=set()
        def helper(node):
            if node:
                helper(node.left)
                num=self.hash.get(node.val,0)+1
                self.hash[node.val]=num
                if num== self.maxTimes:                                             
                    self.ans.add(node.val)
                elif num &gt; self.maxTimes:
                    self.ans.clear()
                    self.ans.add(node.val)
                    self.maxTimes=num
                helper(node.right)
        helper(root)
        return self.ans        </code></pre>
<h3 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530. 二叉搜索树的最小绝对差"></a>530. 二叉搜索树的最小绝对差</h3><pre><code>链接：https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/
给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。

示例：

输入：

   1
    \
     3
    /
   2

输出：
1

解释：
最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。

提示：

树中至少有 2 个节点。
本题与 783 https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/ 相同</code></pre>
<p>题解一|中序遍历：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def getMinimumDifference(self, root: TreeNode) -&gt; int:
        def inOrder(root):
            if not root:
                return []
            return inOrder(root.left)+[root.val]+inOrder(root.right)
        tmp=inOrder(root)
        res=float(&#39;inf&#39;)
        for i in range(1,len(tmp)):
            res=min(res,tmp[i]-tmp[i-1])
        return res</code></pre>
<h3 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538. 把二叉搜索树转换为累加树"></a>538. 把二叉搜索树转换为累加树</h3><pre><code>链接：https://leetcode-cn.com/problems/convert-bst-to-greater-tree/

给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。

例如：

输入: 原始二叉搜索树:
              5
            /   \
           2     13

输出: 转换为累加树:
             18
            /   \
          20     13</code></pre>
<p>题解一|递归|后序遍历：</p>
<pre><code>class Solution:
    def convertBST(self, root: TreeNode) -&gt; TreeNode:
        self.sum=0
        def helper(root):
            if not root:
                return
            helper(root.right)
            self.sum+=root.val
            root.val=self.sum
            helper(root.left)
        helper(root)
        return root</code></pre>
<p>题解二|迭代|后序遍历：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def convertBST(self, root: TreeNode) -&gt; TreeNode:
        sum,stack,node=0,[],root
        while stack or node:
            while node:
                stack.append(node)
                node=node.right
            node=stack.pop()
            sum+=node.val
            node.val=sum
            node=node.left
        return root</code></pre>
<h3 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a>543. 二叉树的直径</h3><pre><code>链接：https://leetcode-cn.com/problems/diameter-of-binary-tree/

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

示例 :
给定二叉树

          1
         / \
        2   3
       / \     
      4   5    
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

注意：两结点之间的路径长度是以它们之间边的数目表示。</code></pre>
<p>题解一|递归：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -&gt; int:
        self.res=0
        def helper(root):
            if not root:
                return 0
            left=helper(root.left)
            right=helper(root.right)
            self.res=max(self.res,left+right) # 每个结点都要去判断左子树+右子树的高度是否大于self.max，更新最大值
            return max(left,right)+1
        helper(root)
        return self.res</code></pre>
<h3 id="559-N叉树的最大深度"><a href="#559-N叉树的最大深度" class="headerlink" title="559. N叉树的最大深度"></a>559. N叉树的最大深度</h3><pre><code>链接：https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/

给定一个 N 叉树，找到其最大深度。

最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。

例如，给定一个 3叉树 :

我们应返回其最大深度，3。

说明:

树的深度不会超过 1000。
树的节点总不会超过 5000。</code></pre>
<p>题解一|递归：</p>
<pre><code>&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
&quot;&quot;&quot;

class Solution:
    def maxDepth(self, root: &#39;Node&#39;) -&gt; int:
        if not root:
            return 0
        elif not root.children:
            return 1
        else:
            height=[ self.maxDepth(i) for i in root.children]
            return max(height)+1</code></pre>
<p>题解二|迭代：</p>
<pre><code>&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
&quot;&quot;&quot;

class Solution:
    def maxDepth(self, root: &#39;Node&#39;) -&gt; int:
        stack=[]
        if root:
            stack.append((1,root))
        depth=0
        while stack:
            cur,root=stack.pop()
            if root:
                depth=max(depth,cur)
                for i in root.children:
                    stack.append((cur+1,i))
        return depth</code></pre>
<h3 id="563-二叉树的坡度"><a href="#563-二叉树的坡度" class="headerlink" title="563. 二叉树的坡度"></a>563. 二叉树的坡度</h3><pre><code>链接：https://leetcode-cn.com/problems/binary-tree-tilt/
给定一个二叉树，计算整个树的坡度。

一个树的节点的坡度定义即为，该节点左子树的结点之和和右子树结点之和的差的绝对值。空结点的的坡度是0。

整个树的坡度就是其所有节点的坡度之和。

示例：

输入：
         1
       /   \
      2     3
输出：1
解释：
结点 2 的坡度: 0
结点 3 的坡度: 0
结点 1 的坡度: |2-3| = 1
树的坡度 : 0 + 0 + 1 = 1

提示：

任何子树的结点的和不会超过 32 位整数的范围。
坡度的值不会超过 32 位整数的范围。</code></pre>
<p>题解一|递归：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def findTilt(self, root: TreeNode) -&gt; int:
        self.res=0
        def helper(root):
            if not root:
                return 0
            left = helper(root.left)
            right = helper(root.right)
            self.res+=abs(left-right)
            return left+right+root.val

        helper(root)
        return self.res</code></pre>
<h3 id="572-另一个树的子树"><a href="#572-另一个树的子树" class="headerlink" title="572. 另一个树的子树"></a>572. 另一个树的子树</h3><pre><code>链接：https://leetcode-cn.com/problems/subtree-of-another-tree/

给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。

示例 1:
给定的树 s:

     3
    / \
   4   5
  / \
 1   2
给定的树 t：

   4 
  / \
 1   2
返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。

示例 2:
给定的树 s：

     3
    / \
   4   5
  / \
 1   2
    /
   0
给定的树 t：

   4
  / \
 1   2
返回 false。</code></pre>
<p>题解一|递归：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSubtree(self, s: TreeNode, t: TreeNode) -&gt; bool:
        def helper(s,t):
            if not s and not t:
                return True
            if not s or not t:
                return False
            if s.val != t.val:
                return False
            return helper(s.left,t.left) and helper(s.right,t.right)
        if not s and not t:
            return True
        if not s or not t:
            return False
        return helper(s,t) or self.isSubtree(s.left,t) or self.isSubtree(s.right,t)</code></pre>
<h3 id="589-N叉树的前序遍历"><a href="#589-N叉树的前序遍历" class="headerlink" title="589. N叉树的前序遍历"></a>589. N叉树的前序遍历</h3><pre><code>链接：https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/

给定一个 N 叉树，返回其节点值的前序遍历。

例如，给定一个 3叉树 :

返回其前序遍历: [1,3,5,6,2,4]。  

说明: 递归法很简单，你可以使用迭代法完成此题吗?</code></pre>
<p>题解一|递归：</p>
<pre><code>&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
&quot;&quot;&quot;
class Solution:
    def preorder(self, root: &#39;Node&#39;) -&gt; List[int]:
        ans=[]
        if root:
            ans.append(root.val)
            for i in root.children:
                ans+=self.preorder(i)
        return ans</code></pre>
<pre><code>&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
&quot;&quot;&quot;
class Solution:
    def preorder(self, root: &#39;Node&#39;) -&gt; List[int]:
        if not root:
            return 
        res=[]
        def helper(root):
            if not root:
                return
            res.append(root.val)
            for i in root.children:
                helper(i)
        helper(root)
        return res
</code></pre>
<p>题解二|迭代：</p>
<pre><code>&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
&quot;&quot;&quot;
class Solution:
    def preorder(self, root: &#39;Node&#39;) -&gt; List[int]:
        if not root:
            return
        stack=[root]
        ans=[]
        while stack:
            root=stack.pop()
            ans.append(root.val)
            for i in root.children[::-1]:
                stack.append(i)
            # stack.extend(root.children[::-1]) # 不使用append
        return ans</code></pre>
<p>Python中append和extend的区别：</p>
<pre><code>a=[1,2,3]
b=[4,5]

b.extend(a) # 输出[4,5,1,2,3]
b.append(a) # 输出[4,5,[1,2,3]]</code></pre>
<h3 id="590-N叉树的后序遍历"><a href="#590-N叉树的后序遍历" class="headerlink" title="590. N叉树的后序遍历"></a>590. N叉树的后序遍历</h3><pre><code>链接：https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/

给定一个 N 叉树，返回其节点值的后序遍历。

例如，给定一个 3叉树 :

返回其后序遍历: [5,6,3,2,4,1].

说明: 递归法很简单，你可以使用迭代法完成此题吗?</code></pre>
<p>题解一|递归：</p>
<pre><code>&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
&quot;&quot;&quot;

class Solution:
    def postorder(self, root: &#39;Node&#39;) -&gt; List[int]:
        ans=[]
        if root:
            for i in root.children:
                ans+=self.postorder(i)
            ans.append(root.val)
        return ans</code></pre>
<p>题解二|迭代：</p>
<pre><code>&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
&quot;&quot;&quot;

class Solution:
    def postorder(self, root: &#39;Node&#39;) -&gt; List[int]:
        if not root:
            return
        stack=[root]
        res=[]
        while stack:
            root=stack.pop()
            res.append(root.val)
            for i in root.children:
                stack.append(i)
        return res[::-1]</code></pre>
<h3 id="606-根据二叉树创建字符串"><a href="#606-根据二叉树创建字符串" class="headerlink" title="606. 根据二叉树创建字符串"></a>606. 根据二叉树创建字符串</h3><pre><code>链接：https://leetcode-cn.com/problems/construct-string-from-binary-tree/

你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。

空节点则用一对空括号 &quot;()&quot; 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。

示例 1:

输入: 二叉树: [1,2,3,4]
       1
     /   \
    2     3
   /    
  4     

输出: &quot;1(2(4))(3)&quot;

解释: 原本将是“1(2(4)())(3())”，
在你省略所有不必要的空括号对之后，
它将是“1(2(4))(3)”。
示例 2:

输入: 二叉树: [1,2,3,null,4]
       1
     /   \
    2     3
     \  
      4 

输出: &quot;1(2()(4))(3)&quot;

解释: 和第一个示例相似，
除了我们不能省略第一个对括号来中断输入和输出之间的一对一映射关系。</code></pre>
<p>题解一|递归：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def tree2str(self, t: TreeNode) -&gt; str:
        if not t:
            return &#39;&#39;
        if not t.left and not t.right:
            return str(t.val)
        if not t.left and t.right:
            return str(t.val)+&#39;()&#39;+&#39;(&#39;+self.tree2str(t.right)+&#39;)&#39;
        if t.left and not t.right:
            return str(t.val)+&#39;(&#39;+self.tree2str(t.left)+&#39;)&#39;
        return str(t.val)+&#39;(&#39;+self.tree2str(t.left)+&#39;)&#39;+&#39;(&#39;+self.tree2str(t.right)+&#39;)&#39;</code></pre>
<h3 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a>617. 合并二叉树</h3><pre><code>链接：https://leetcode-cn.com/problems/merge-two-binary-trees/

给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。

你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。

示例 1:

输入: 
    Tree 1                     Tree 2                  
          1                         2                             
         / \                       / \                            
        3   2                     1   3                        
       /                           \   \                      
      5                             4   7                  
输出: 
合并后的树:
         3
        / \
       4   5
      / \   \ 
     5   4   7
注意: 合并必须从两个树的根节点开始。</code></pre>
<p>题解一|递归：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -&gt; TreeNode:
        if not t1 and not t2:
            return
        if not t1:
            return t2
        if not t2:
            return t1
        if t1 and t2:
            root=TreeNode()
            root.val=t1.val+t2.val
            root.left=self.mergeTrees(t1.left,t2.left)
            root.right=self.mergeTrees(t1.right,t2.right)
        return root</code></pre>
<h3 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637.二叉树的层平均值"></a>637.二叉树的层平均值</h3><pre><code>链接：https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/

给定一个非空二叉树, 返回一个由每层节点平均值组成的数组.

示例 1:

输入:
    3
   / \
  9  20
    /  \
   15   7
输出: [3, 14.5, 11]
解释:
第0层的平均值是 3,  第1层是 14.5, 第2层是 11. 因此返回 [3, 14.5, 11].
注意：

节点值的范围在32位有符号整数范围内。</code></pre>
<p>题解一|迭代：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def averageOfLevels(self, root: TreeNode) -&gt; List[float]:
        from collections import deque
        if root is None: return
        queue=deque()
        queue.append(root)
        res=[]
        while queue:
            tmp=[]
            for i in range(len(queue)):
                node=queue.popleft()
                tmp.append(node.val)
                s=0
                for each in tmp:
                    s+=each
                s=s/len(tmp)

                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            res.append(s)
        return res</code></pre>
<p>去掉脑残for循环，巨耗时。</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def averageOfLevels(self, root: TreeNode) -&gt; List[float]:
        from collections import deque
        if root is None: return
        queue=deque()
        queue.append(root)
        res=[]
        while queue:
            tmp=[]
            for i in range(len(queue)):
                node=queue.popleft()
                tmp.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            res.append(sum(tmp)/len(tmp))
        return res</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/LeetCode-1-%E6%95%B0%E7%BB%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/LeetCode-1-%E6%95%B0%E7%BB%84/" class="post-title-link" itemprop="url">LeetCode-1-数组</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-09-26 12:13:05" itemprop="dateCreated datePublished" datetime="2019-09-26T12:13:05+08:00">2019-09-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-11-13 15:17:56" itemprop="dateModified" datetime="2020-11-13T15:17:56+08:00">2020-11-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、数组"><a href="#一、数组" class="headerlink" title="一、数组"></a>一、数组</h2><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h3><pre><code>链接：https://leetcode-cn.com/problems/two-sum/

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

示例:

给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]</code></pre>
<p>题解一|暴力：</p>
<p>最简单的思路就是通过两遍循环直接进行暴力破解，时间复杂度O(n^2)，空间复杂度O(1)。</p>
<pre><code> class Solution:
    def twoSum(self,nums,target):
        for i in range(0,len(nums)):
            for j in range(i+1,len(nums)):
                if nums[j]==target-nums[i]:
                    return i,j</code></pre>
<p>题解二|hash：</p>
<p>接着思考如何进行优化，采用hash记录需要的key，遍历的时候找到需要的值。时间复杂度O(n)，空间复杂度O(n)。</p>
<pre><code> class Solution:
    def twoSum(self,nums,target):
        dicts=&#123;&#125;
        for i in range(len(nums)):
            tmp=nums[i]
            if target-tmp in dicts:
                return (dicts[target-tmp],i)
            dicts[tmp]=i</code></pre>
<pre><code> class Solution:
    def twoSum(self,nums,target):
        dicts=&#123;&#125;
        for i,num in enumerate(nums):
            if num in dicts:
                return [dicts[num],i]
            else:
                dicts[target-num]=i</code></pre>
<p>题解三|切片：</p>
<p>判断target-nums[i]是否在nums[i+1:]中，时间复杂度O(n)，空间复杂度O(1)。</p>
<pre><code> class Solution:
    def twoSum(self,nums,target):
        for i in range(len(nums)):
            if target-nums[i] in nums[i+1:]:
                return [i,nums.index(target-nums[i],i+1)]</code></pre>
<p>index()方法语法：list.index(x[, start[, end]])<br>参数:<br>    x– 查找的对象。<br>    start– 可选，查找的起始位置。<br>    end– 可选，查找的结束位置。<br>返回值:该方法返回查找对象的索引位置，如果没有找到对象则抛出异常。</p>
<h3 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h3><pre><code>链接：
https://leetcode-cn.com/problems/add-two-numbers/

给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。

如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

您可以假设除了数字 0 之外，这两个数都不会以 0 开头。

示例：

输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
输出：7 -&gt; 0 -&gt; 8
原因：342 + 465 = 807</code></pre>
<p>题解一：</p>
<pre><code>class ListNode:
    def __init__(self,x):
        self.val=x
        self.next=None
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:
        if l1 is None:
            return l2
        if l2 is None:
            return l1

        tmp=ListNode(0)
        res=tmp
        flag=0

        while l1 or l2:
            tmpSum=0
            if l1:
                tmpSum=l1.val
                l1=l1.next
            if l2:
                tmpSum+=l2.val
                l2=l2.next
            tmpRes=(tmpSum+falg)%10
            flag=(tmpSum+flag)//10

            res.next=ListNode(tmpRes)
            res=res.next # res后移

            # 这个判断是拿来解决此种情况的：
            # 输入：【5】和【5】
            # 输出：【0,1】
            if flag:
                res.next=ListNode(1) # 这里创建了节点，但是没有后移

        res=tmp.next # 把链表初始化的0后移
        return res</code></pre>
<pre><code>class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:
        res=dummy=ListNode(-1)
        flag=0
        while l1 and l2:
            res.next=ListNode(l1.val+l2.val+flag)
            flag=res.next.val // 10
            res.next.val %= 10
            res=res.next
            l1=l1.next
            l2=l2.next

        p= l1 or l2
        while p:
            res.next=ListNode(p.val+flag)
            flag=res.next.val // 10
            res.next.val %= 10
            p=p.next
            res=res.next
        if flag:
            res.next=ListNode(1)
        return dummy.next</code></pre>
<h3 id="？？4-寻找两个有序数组的中位数"><a href="#？？4-寻找两个有序数组的中位数" class="headerlink" title="？？4.寻找两个有序数组的中位数"></a>？？4.寻找两个有序数组的中位数</h3><pre><code>链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays/

给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。

请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。

你可以假设 nums1 和 nums2 不会同时为空。

示例 1:

nums1 = [1, 3]
nums2 = [2]

则中位数是 2.0
示例 2:

nums1 = [1, 2]
nums2 = [3, 4]

则中位数是 (2 + 3)/2 = 2.5</code></pre>
<p>题解一（暴力）：</p>
<h3 id="6-Z字形变换"><a href="#6-Z字形变换" class="headerlink" title="6.Z字形变换"></a>6.Z字形变换</h3><pre><code>链接：https://leetcode-cn.com/problems/zigzag-conversion/

将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。

比如输入字符串为 &quot;LEETCODEISHIRING&quot; 行数为 3 时，排列如下：

L   C   I   R
E T O E S I I G
E   D   H   N
之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&quot;LCIRETOESIIGEDHN&quot;。

请你实现这个将字符串进行指定行数变换的函数：

string convert(string s, int numRows);
示例 1:

输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 3
输出: &quot;LCIRETOESIIGEDHN&quot;
示例 2:

输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 4
输出: &quot;LDREOEIIECIHNTSG&quot;
解释:

L     D     R
E   O E   I I
E C   I H   N
T     S     G</code></pre>
<p>题解一：<br><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/z-word.png"><br><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/z-word1.png"></p>
<pre><code>class Solution:
    def convert(self, s: str, numRows: int) -&gt; str:
        if numRows&lt;2:
            return s
        ans=[&#39;&#39; for _ in range(numRows)]
        i,flag=0,-1
        for c in s:
            ans[i] += c
            if i==0 or i==numRows-1:
                flag=-flag
            i+=flag
        return &#39;&#39;.join(ans)
</code></pre>
<h3 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7.整数反转"></a>7.整数反转</h3><pre><code>链接：https://leetcode-cn.com/problems/reverse-integer/

给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。

示例 1:

输入: 123
输出: 321
示例 2:

输入: -123
输出: -321
示例 3:

输入: 120
输出: 21
注意:

假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31,  2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</code></pre>
<p>题解一：<br>int型的数值范围是 -2147483648～2147483647， 那么如果我们要翻转 1000000009 这个在范围内的数得到 9000000001，而翻转后的数就超过了范围。</p>
<pre><code>class Solution:
    def reverse(self, x: int) -&gt; int:
        x=int(str(x)[::-1]) if x&gt;=0 else -int(str((-x)[::-1])) # python3没有数字范围，如果其他语言之间int会造成精度缺失。
        # return x if x&lt;2**31-1 and x&gt;-2**31 else 0
        return x if x&lt;pow(2,31)-1 and x&gt;-pow(2,31) else 0</code></pre>
<p>题解二：<br>    # /:除法<br>    # //:整除<br>    # %：取模</p>
<pre><code>class Solution:
    def reverse(self, x):
        flag = 1 if x &gt;= 0 else -1
        new_x, x = 0, abs(x)
        while x:
            new_x = 10 * new_x + x % 10
            x //= 10
        new_x = flag * new_x
        return new_x if new_x &lt; 2147483648 and new_x &gt;= -2147483648 else 0</code></pre>
<h3 id="8-字符串转换整数-atoi"><a href="#8-字符串转换整数-atoi" class="headerlink" title="8.字符串转换整数(atoi)"></a>8.字符串转换整数(atoi)</h3><pre><code>链接：https://leetcode-cn.com/problems/string-to-integer-atoi/

请你来实现一个 atoi 函数，使其能将字符串转换成整数。

首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。

当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。

该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。

注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。

在任何情况下，若函数不能进行有效的转换时，请返回 0。

说明：

假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。

示例 1:

输入: &quot;42&quot;
输出: 42
示例 2:

输入: &quot;   -42&quot;
输出: -42
解释: 第一个非空白字符为 &#39;-&#39;, 它是一个负号。
     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。
示例 3:

输入: &quot;4193 with words&quot;
输出: 4193
解释: 转换截止于数字 &#39;3&#39; ，因为它的下一个字符不为数字。
示例 4:

输入: &quot;words and 987&quot;
输出: 0
解释: 第一个非空字符是 &#39;w&#39;, 但它不是数字或正、负号。
     因此无法执行有效的转换。
示例 5:

输入: &quot;-91283472332&quot;
输出: -2147483648
解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 </code></pre>
<p>          因此返回 INT_MIN (−231) 。<br>题解一|正则表达式：</p>
<pre><code>^：匹配字符串开头
[\+\-]：代表一个+字符或-字符
?：前面一个字符可有可无
\d：一个数字
+：前面一个字符的一个或多个
\D：一个非数字字符
*：前面一个字符的0个或多个</code></pre>
<pre><code>class Solution:
    def myAtoi(self, str: str) -&gt; int:
        return max(min(int(*re.findall(&#39;^[\+\-]?\d+&#39;,str.lstrip())),2**31-1),-2**31)
        #由于返回的是个列表，解包并且转换成整数</code></pre>
<pre><code>class Solution:
    def myAtoi(self, str: str) -&gt; int:
        # return max(min(int(*re.findall(&#39;^[\+\-]?\d+&#39;,str.lstrip())),2**31-1),-2**31)
        # print(re.findall(&#39;\d&#39;,str.lstrip())) # [&#39;4&#39;, &#39;2&#39;, &#39;4&#39;, &#39;4&#39;]
        # print(re.findall(&#39;\d*&#39;,str.lstrip())) # [&#39;4244&#39;, &#39;&#39;]
        # print(re.findall(&#39;\d+&#39;,str.lstrip())) # [&#39;4244&#39;]
        # print(re.findall(&#39;^[+-]\d+&#39;,str.lstrip())) # [&#39;-4244&#39;]
        # print(re.findall(&#39;^[+-]?\d+&#39;,str.lstrip())) # ?代表前面的+-可有可无。
        # #  re.findall返回的是一个字符串列表，int()数据类型转换不支持列表，用*对列表解包得到字符串。比如[7,8,8]→7,8,8
        # print(int(*re.findall(&#39;^[+-]\d+&#39;,str.lstrip()))) # -4244

        x=int(*re.findall(&#39;^[-+]?\d+&#39;,str.lstrip()))
        if x &gt; pow(2,31)-1:
            return pow(2,31)-1
        elif x &lt; pow(-2,31):
            return pow(-2,31)
        else:
            return x</code></pre>
<p>题解二|逐个强行转int：</p>
<pre><code>class Solution:
    def myAtoi(self, str: str) -&gt; int:
        str=str.lstrip()

        if len(str)==0:
            return 0
        last=0
        i=1 if str[0]==&#39;+&#39; or str[0]==&#39;-&#39; else 0
        #循环，直到无法强转成int，跳出循环
        while i&lt;=len(str):
            try:
                last=int(str[:i+1]) # int[&#39;aa&#39;]会报错，所以走break
                i+=1
            except:
                break
        # 判断数字是否超出范围
        if last&lt;-2**31:
            return -2**31
        if last&gt;2**31-1:
            return 2**31-1
        return last
</code></pre>
<h3 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9.回文数"></a>9.回文数</h3><pre><code>链接：https://leetcode-cn.com/problems/palindrome-number/

判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

示例 1:

输入: 121
输出: true
示例 2:

输入: -121
输出: false
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
示例 3:

输入: 10
输出: false
解释: 从右向左读, 为 01 。因此它不是一个回文数。</code></pre>
<p>题解一|整数转换为字符串:</p>
<pre><code>class Solution:
    def isPalindrome(self, x: int) -&gt; bool:
        x=str(x)
        if x == x[::-1]:
            return True
        else:
            return False

class Solution:
    def isPalindrome(self, x) :
        x=str(x)
        return x==x[::-1]

# 整数转字符串，通过下标对比确定该整数是否为回文数
class Solution:
    def isPalindrome(self, x) :
        x=str(x)
        for i in range(0,int(len(x)/2)):
            if x[i] != x[-i-1]:
                return False
        return True</code></pre>
<p>题解二（数字反转）:</p>
<pre><code>class Solution:
    def isPalindrome(self, x) :
        if x&lt;0:
            return False
        m,n=x,0

        while m:
            n=n*10+m%10
            m=m//10
        if x==n:
            return True
        else:
            return False</code></pre>
<h3 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11.盛最多水的容器"></a>11.盛最多水的容器</h3><pre><code>链接：https://leetcode-cn.com/problems/container-with-most-water/

给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

说明：你不能倾斜容器，且 n 的值至少为 2。</code></pre>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/youdao/water3.jpg"></p>
<pre><code>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。

示例:

输入: [1,8,6,2,5,4,8,3,7]
输出: 49</code></pre>
<p>思路：<br>    矩阵的面积=矩阵长度 * 矩阵宽度<br>    矩阵长度：两条垂直线的距离<br>    矩阵宽度：两条垂直线中较短一条的长度<br>    面积最大化：两条垂直线的距离越远越好，两条垂直线的最短长度也要越长越好。</p>
<p>解法一|暴力|超时：<br>    在这种情况下，我们将简单地考虑每对可能出现的线段组合并找出这些情况之下的最大面积。<br>    时间复杂度O(n^2)，计算n(n-1)/2种高度组合的面积，空间复杂度O(1)。</p>
<pre><code>不能通过case:[1,1],结果应该为1.
class Solution:
    def maxArea(self, height: List[int]) -&gt; int:
        area=0
        for i in range(len(height)):
            for j in range(i+1,len(height)):
                # print(&#39;i&#39;,i,height[i])
                # print(&#39;j&#39;,j,height[j])
                area=max(area,min(height[i],height[j])*(j-1)) # j-1为矩阵的长度</code></pre>
<pre><code>class Solution:
    def maxArea(self, height: List[int]) -&gt; int:
        area=0
        for i in range(len(height)-1):
            for j in range(i+1,len(height)):
                # print(&#39;i&#39;,i,height[i])
                # print(&#39;j&#39;,j,height[j])
                area=max(area,min(height[i],height[j])*(j-i)) # j-i为矩阵的长度
        return area</code></pre>
<p>解法二|双指针：</p>
<pre><code>设置两个指针 left 和 right，分别指向数组的最左端和最右端。此时，两条垂直线的距离是最远的，若要下一个矩阵面积比当前面积来得大，必须要把 height[left] 和 height[right] 中较短的垂直线往中间移动，看看是否可以找到更长的垂直线。
时间复杂度O(n)，空间复杂度O(1)。</code></pre>
<pre><code>class Solution:
    def maxArea(self, height: List[int]) -&gt; int:
        left=0
        right=len(height)-1
        area=0

        while left &lt; right:
            cur=min(height[left],height[right]) * (right-left)
            area=max(area,cur)

            if height[left]&lt;height[right]:
                left+=1
            else:
                right-=1
        return area</code></pre>
<h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h3><pre><code>链接：https://leetcode-cn.com/problems/3sum/

给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。

注意：答案中不可以包含重复的三元组。

例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]</code></pre>
<p>题解一|暴力：<br>    使用三重循环进行暴力破解，时间复杂度为O(n^3)，空间复杂度O(n)</p>
<p>题解二|排序+双指针：</p>
<pre><code>继续思考如何优化，可以通过双指针动态消去无效解来优化效率。
铺垫：先将给定 nums 排序，复杂度为 O(nlogn)
思路：固定 3 个指针中最左（最小）数字的指针 k，双指针 i，j 分设在数组索引 (k, len(nums))两端，通过双指针交替向中间移动，记录对于每个固定指针 k 的所有满足 nums[k] + nums[i] + nums[j] == 0 的 i,j 组合。
时间复杂度O(n^2)，空间复杂度O(n)。</code></pre>
<pre><code>class Solution:
    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:
        nums.sort()
        lens=len(nums)
        res=[]

        for k in range(lens):
            if k&gt;0 and nums[k]==nums[k-1]:
                continue

            i,j=k+1,lens-1
            while i&lt;j:
                sum=nums[k]+nums[i]+nums[j]
                if sum==0:
                    tmp=[nums[k],nums[i],nums[j]]
                    res.append(tmp)

                    while i&lt;j and nums[i]==nums[i+1]:
                        i+=1
                    while i&lt;j and nums[j]==nums[j-1]:
                        j-=1

                    i+=1
                    j-=1

                elif sum&lt;0:
                    i+=1
                else:
                    j-=1

        return res</code></pre>
<h3 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16.最接近的三数之和"></a>16.最接近的三数之和</h3><pre><code>链接：https://leetcode-cn.com/problems/3sum-closest/

给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。

例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.

与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).</code></pre>
<p>题解一|排序+双指针：</p>
<p>思路类似于三数之和，首先将数组进行排序，同时在左右指针运动过程中，记录与 target 绝对值差值最小的三数之和。</p>
<p>时间复杂度：O(nlogn) + O(n^2) = O(n^2)，空间复杂度O(1)</p>
<pre><code>class Solution:
    def threeSumClosest(self, nums: List[int], target: int) -&gt; int:
        nums.sort()
        length=len(nums)
        res=float(&#39;inf&#39;)

        for k in range(length):
            # if k&gt;0 and nums[k]==nums[k-1]:
            #    continue

            i,j=k+1,length-1
            while i&lt;j:
                sum=nums[k]+nums[i]+nums[j]
                if sum==target:
                    return target

                if abs(res-target)&gt;abs(sum-target):
                    res=sum

                if sum&lt;target:
                    i+=1
                else:
                    j-=1
        return res</code></pre>
<h3 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18.四数之和"></a>18.四数之和</h3><pre><code>链接：https://leetcode-cn.com/problems/4sum/

给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。

注意：

答案中不可以包含重复的四元组。

示例：

给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。

满足要求的四元组集合为：
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]</code></pre>
<p>题解一|排序+双指针：</p>
<p>和三数之和解法类似，先将数组排序固定两个元素，再用两个指针，一个指向头，一个指向尾，看四数之和为多少，太大了右指针左移，太小了左指针右移，因为有可能存在重复的数组，先将结果保存在set中，最后在转为list输出。</p>
<p>时间复杂度：O(n^3)，空间复杂度O(n)</p>
<pre><code>class Solution:
    def fourSum(self, nums: List[int], target: int) -&gt; List[List[int]]:
        nums.sort()
        length=len(nums)
        res=[]
        sets=set()

        for i in range(length-3):
            for j in range(i+1,length-2):
                left,right=j+1,length-1

                while left&lt;right:
                    sum=nums[i]+nums[j]+nums[left]+nums[right]
                    if sum==target:
                        tmp=(nums[i],nums[j],nums[left],nums[right])
                        sets.add(tmp) # 去重
                        left+=1
                        right-=1
                    elif sum&lt;target:
                        left+=1
                    else:
                        right-=1

        for each in sets:
            res.append(list(each))
        return res </code></pre>
<h3 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26.删除排序数组中的重复项"></a>26.删除排序数组中的重复项</h3><pre><code>链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/

给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

示例 1:

给定数组 nums = [1,1,2], 

函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 

你不需要考虑数组中超出新长度后面的元素。
示例 2:

给定 nums = [0,0,1,1,1,2,2,3,3,4],

函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。

你不需要考虑数组中超出新长度后面的元素。</code></pre>
<p>题解一|双指针：</p>
<p>思路：</p>
<p>采用两指针，一个指针i指向原数组需要判断的元素，一个指针j指向新数组新加入的元素。<br>由于是有序数组，因此只要判断原数组中的元素不同于新数组新加入的元素，就将原数组的元素和新数组后一元素交换位置即可，没有重复元素就是和自身交换位置。</p>
<p>第一个指针 i ：由于数组已完成排序，因为遍历数组，每遇到 nums[i] != nums[j<br>] ,就说明遇到了新的不同数字，记录之；</p>
<p>第二个指针 j ：每遇到新的不同数字时，执行 j += 1 ， j 指针有两个作用：</p>
<pre><code>记录数组中不同数字的数量；
作为修改数组元素的索引index。</code></pre>
<p>最终，返回 k+1 即可。<br>时间复杂度O(n),空间复杂福O(1)。</p>
<pre><code>class Solution:
    def removeDuplicates(self, nums: List[int]) -&gt; int:
        if not nums:
            return 0
        j=0
        for i in range(1,len(nums)):
            if nums[i]!=nums[j]:
                nums[j+1]=nums[i]
                j+=1
        return j+1
</code></pre>
<pre><code>class Solution:
    def removeDuplicates(self, nums: List[int]) -&gt; int:
        index=0
        for i in range(1,len(nums)):
            if nums[i] != nums[index]:
                index+=1
                nums[index]=nums[i]
        return index+1
</code></pre>
<pre><code>class Solution:
    def removeDuplicates(self, nums: List[int]) -&gt; int:
        if not nums:
            return 0
        slow=0
        for fast in range(len(nums)):
            if nums[slow] != nums[fast]:
                slow+=1
            nums[slow]=nums[fast]
        return slow+1</code></pre>
<pre><code>class Solution:
    def removeDuplicates(self, nums: List[int]) -&gt; int:
        if not nums:
            return 0
        slow=0
        for fast in range(len(nums)):
            if nums[fast] == nums[slow]:
                fast+=1
            else:
                slow+=1
                nums[slow]=nums[fast]
        return slow+1</code></pre>
<pre><code>class Solution:
    def removeDuplicates(self, nums: List[int]) -&gt; int:
        pre,cur=0,1
        while cur&lt;len(nums):
            if nums[pre]==nums[cur]:
                nums.pop(cur)
            else:
                pre,cur=pre+1,cur+1</code></pre>
<h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27.移除元素"></a>27.移除元素</h3><pre><code>链接：https://leetcode-cn.com/problems/remove-element/

给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

示例 1:

给定 nums = [3,2,2,3], val = 3,

函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。

你不需要考虑数组中超出新长度后面的元素。
示例 2:

给定 nums = [0,1,2,2,3,0,4,2], val = 2,

函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。

注意这五个元素可为任意顺序。

你不需要考虑数组中超出新长度后面的元素。</code></pre>
<p>题解一|双指针：</p>
<p>可以保留两个指针 i 和 j，其中 i 是慢指针，j 是快指针。当 nums[j]与val相等时，递增 j以跳过该元素。只要 nums[j] 不等于 val，我们就复制 nums[j]到 nums[i] 并同时递增两个索引。重复这一过程，直到 j 到达数组的末尾，该数组的新长度为 i。<br>时间复杂度O(n),空间复杂度O(1).</p>
<pre><code>class Solution:
    def removeElement(self, nums: List[int], val: int) -&gt; int:
        i=0
        for j in range(0,len(nums)):
            if nums[j] != val:
                nums[i]=nums[j]
                i+=1
        return i</code></pre>
<h3 id="29-两数相除"><a href="#29-两数相除" class="headerlink" title="29.两数相除"></a>29.两数相除</h3><pre><code>链接：https://leetcode-cn.com/problems/divide-two-integers/submissions/

给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。

返回被除数 dividend 除以除数 divisor 得到的商。

示例 1:

输入: dividend = 10, divisor = 3
输出: 3
示例 2:

输入: dividend = 7, divisor = -3
输出: -2
说明:

被除数和除数均为 32 位有符号整数。
除数不为 0。
假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。</code></pre>
<p>题解一|减法|超时:</p>
<p>超时：当被除数为2147483648，除数为 1，必然超时。</p>
<pre><code>class Solution:
    def divide(self, dividend: int, divisor: int) -&gt; int:
        res=0
        flag=1 if dividend ^ divisor &gt;=0 else -1
        dividend=abs(dividend)
        divisor=abs(divisor)
        while dividend &gt;= divisor:
            res+=1
            dividend-=divisor
        res=res*flag
        return min(max(res,-2**31),2**31-1)</code></pre>
<p>题解二|增倍除数:</p>
<pre><code>&lt;&lt; 是左移，末位补0，类比十进制数在末尾添0相当于原数乘以10，x&lt;&lt;1是将x的二进制表示左移一位，相当于原数x乘2。比如整数4在二进制下是100，4&lt;&lt;1左移1位变成1000(二进制)，结果是8。

&gt;&gt;是右移，右移1位相当于除以2。</code></pre>
<pre><code>class Solution:
    def divide(self, dividend: int, divisor: int) -&gt; int:
        res=0
        flag=1 if dividend ^ divisor &gt;=0 else -1
        dividend=abs(dividend)
        divisor=abs(divisor)
        while dividend &gt;= divisor:
            tmp,i=divisor,1
            while dividend&gt;=tmp:
                dividend-=tmp
                res+=i
                i &lt;&lt;=1
                tmp &lt;&lt;=1
        res=res*flag
        return min(max(res,-2**31),2**31-1)</code></pre>
<p>题解三（位移）：<br>算法是把除法化归成移位和减法两种运算方法。对于 10 进制数，移位运算就是乘（左移）除（右移）10，而我们都知道计算机中的移位运算是乘（左移）除（右移）2，因为计算机是通过二进制的方法存储数的。这样，类比十进制，二进制的除法（仍以 45/2 为例）可以写作（注意，这里我们并没有用到乘除法）</p>
<pre><code>class Solution:
    def divide(self, dividend: int, divisor: int) -&gt; int:
        res=0
        flag=1 if dividend ^ divisor &gt;=0 else -1
        dividend=abs(dividend)
        divisor=abs(divisor)
        count=0

        # 不断左移，直到大于被除数
        while dividend &gt;= divisor:
            count+=1
            divisor &lt;&lt;=1

        while count &gt; 0:
            count -=1
            divisor &gt;&gt;=1
            res &lt;&lt;=1
            if divisor &lt;= dividend:
                res+=1
                dividend -= divisor

        res=res*flag
        return min(max(res,-2**31),2**31-1)</code></pre>
<p>题解二：</p>
<pre><code>class Solution:
    def myAtoi(self, str: str) -&gt; int:
        # return max(min(int(*re.findall(&#39;^[\+\-]?\d+&#39;,str.lstrip())),2**31-1),-2**31)

        # print(re.findall(&#39;\d&#39;,str.lstrip())) # [&#39;4&#39;, &#39;2&#39;, &#39;4&#39;, &#39;4&#39;]
        # print(re.findall(&#39;\d*&#39;,str.lstrip())) # [&#39;4244&#39;, &#39;&#39;]
        # print(re.findall(&#39;\d+&#39;,str.lstrip())) # [&#39;4244&#39;]
        # print(re.findall(&#39;^[+-]\d+&#39;,str.lstrip())) # [&#39;-4244&#39;]
        print(re.findall(&#39;^[+-]?\d+&#39;,str.lstrip())) # [&#39;-4244&#39;]
        # #  re.findall返回的是一个字符串列表，int()数据类型转换不支持列表，用*对列表解包得到字符串。比如[7,8,8]→7,8,8
        # print(int(*re.findall(&#39;^[+-]\d+&#39;,str.lstrip()))) # -4244

        x=int(*re.findall(&#39;^[-+]?\d+&#39;,str.lstrip()))
        if x &gt; pow(2,31)-1:
            return pow(2,31)-1
        elif x &lt; pow(-2,31):
            return pow(-2,31)
        else:
            return x</code></pre>
<p>题解三：</p>
<pre><code>class Solution:
    def myAtoi(self, str: str) -&gt; int:
        return max(min(int(*re.findall(&#39;^[\+\-]?\d+&#39;,str.lstrip())),2**31-1),-2**31)</code></pre>
<h3 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a>31. 下一个排列</h3><pre><code>链接：https://leetcode-cn.com/problems/next-permutation/

实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须原地修改，只允许使用额外常数空间。

以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1</code></pre>
<p>题解一：</p>
<p>1.从右至左遍历nums，发现第一个小于右边的数nums[i]，将该nums[i]之后的数排升序；</p>
<p>2.第二层遍历nums[(i+1):]，发现第一个大于nums[i]的数nums[j]，交换两数，退出遍历break；</p>
<p>3.交换了也排好序了，退出第一次层遍历return nums</p>
<p>这里有个细节：nums本来就是降序，第一次遍历找不到nums[i],那么直接sort()</p>
<pre><code>class Solution:
    def nextPermutation(self, nums: List[int]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums in-place instead.
        &quot;&quot;&quot;
        for i in range(len(nums)-2,-1,-1):
            if nums[i] &lt; nums[i+1]:
                nums[i+1:]=sorted(nums[i+1:])
                for j in range(i+1,len(nums)):
                    if nums[i] &lt; nums[j]:
                        nums[i],nums[j]=nums[j],nums[i]
                        # break
                        return

        nums.sort()</code></pre>
<h3 id="36-有效的数独"><a href="#36-有效的数独" class="headerlink" title="36. 有效的数独"></a>36. 有效的数独</h3><pre><code>链接：https://leetcode-cn.com/problems/valid-sudoku/

判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。

数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。


上图是一个部分填充的有效的数独。

数独部分空格内已填入了数字，空白格用 &#39;.&#39; 表示。

示例 1:

输入:
[
  [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],
  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],
  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],
  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],
  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],
  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],
  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],
  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],
  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]
]
输出: true
示例 2:

输入:
[
  [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],
  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],
  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],
  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],
  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],
  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],
  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],
  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],
  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]
]
输出: false
解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。
     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
说明:

一个有效的数独（部分已被填充）不一定是可解的。
只需要根据以上规则，验证已经填入的数字是否有效即可。
给定数独序列只包含数字 1-9 和字符 &#39;.&#39; 。
给定数独永远是 9x9 形式的。</code></pre>
<p>题解一：</p>
<pre><code>class Solution:
    def isValidSudoku(self, board: List[List[str]]) -&gt; bool:
        rows=[&#123;&#125; for i in range(9)]
        columns=[&#123;&#125; for i in range(9)]
        boxes=[&#123;&#125; for i in range(9)]
        for i in range(9):
            for j in range(9):
                char=board[i][j]
                if char != &#39;.&#39;:
                    index=(i//3)*3+j//3
                    rows[i][char]=rows[i].get(char,0)+1
                    columns[j][char]=columns[j].get(char,0)+1
                    boxes[index][char]=boxes[index].get(char,0)+1

                    if rows[i][char]&gt;1 or columns[j][char]&gt;1 or boxes[index][char]&gt;1:
                        return False
        return True</code></pre>
<h3 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a>42. 接雨水</h3><pre><code>https://leetcode-cn.com/problems/trapping-rain-water/

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

示例 1：

输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
示例 2：

输入：height = [4,2,0,3,2,5]
输出：9


提示：

n == height.length
0 &lt;= n &lt;= 3 * 104
0 &lt;= height[i] &lt;= 105</code></pre>
<p>思路： 求出每个柱子上面能够存多少水，然后将每根柱子的存水量相加便能得到总的存水量，为求出每根柱子上能够存多少水，就要求出每根柱子左边最高的和右边最高柱子，然后用两者的最小值减去当前柱子的高度。 例如图中从左到右第二根柱子的高度为2，它左边最高柱子的值为5，右边最高柱子的值为4，因此它的最大存水量为 Min（4，5）-2=2。</p>
<p>题解一|暴力：</p>
<p>利用上面思路，从左到右遍历每根柱子，遍历的时候求出每根柱子左边最高和右边最高柱子的值，然后利用两者的最小值减去当前柱子的高度就行了。时间复杂度O（n^2）,空间复杂度O（1）。</p>
<p>注意：如果当前柱子大于它左右最大值的任何一个是存不了水的。</p>
<pre><code>def water(lists):
    length = len(lists)
    waters = 0  # 保存最大存水量

    # 一根柱子时，不围水
    if (lists is None or length &lt;= 1):
        return 0

    left, right = 0, 0
    for i in range(length):
        left, right = 0, 0 # 分别用于保存遍过程中，当前元素左边最大值，和右边最大值。
        for j in range(i):
            left = max(left, lists[j]) # 左边最大值
        print(&#39;left&#39;,left)

        for j in range(length-1, i, -1):
            right = max(right, lists[j]) # 右边最大值
        print(&#39;right&#39;,right)

        isWaterNums = min(left, right)
        if isWaterNums &gt; lists[i]:
            waters += isWaterNums - lists[i]
        else:
            waters += 0

        # waters+=lambda min(left,right)-lists[i] if min(left,right)&gt;lists[i] else 0
        # 如果最小值大于当前元素，存水量等于最小值减去当前元素；如果最小值小于当前元素，存水量为0

    return waters

print(water([1,4,3,1,3,2,3]))</code></pre>
<p>题解二|优化：</p>
<p>分析上面的算法发现算法的时间复杂度为O（n^2）。原因是对于每个元素都要从左到右，和从右到最左遍历其两边最大值，假如使用两个数组 left[ ] , right[ ]来保存每个元素左边最大值，右边最大值的话，这样就不用每次都遍历了，因此时间复杂度可以减少到O（n），但空间复杂度为O（n），典型的空间换时间算法。</p>
<p>对于数组[ 5, 2 , 6 , 2 , 4 ]<br>它的左数组：[5,5,6,6,6]<br>它的右数组：[4,4,6,6,6]<br>算法的流程：</p>
<p>从左到右遍历一次求出每个元素左边的最大值，保存在 left 数组中。<br>从右到左遍历一次求出每个元素右边的最大值，保存在right数。<br>最后一次遍历求出每个元素（每根柱子）的存水量。</p>
<pre><code>def water(lists):
    length = len(lists)
    waters = 0  # 保存最大存水量

    # 一根柱子时，不围水
    if (lists is None or length &lt;= 1):
        return 0

    leftLargest, rightLargest = 0, 0
    left = [0] * length  # left中保存每个元素左边的最大值，left[i]表示数组中第i个元素的左边最大值。
    right = [0] * length  # right中保存每个元素左边的最大值，right[i]，表示数组中第i个元素的右边最大值。

    # 遍历找到每个元素左边最大值
    for i in range(length):
        leftLargest = max(leftLargest, lists[i])
        # left.insert(i, leftLargest)
        # left.append(leftLargest)  # 使用insert正序插入的时候，顺序不会乱掉。
        left[i] = leftLargest

    # 遍历找到每个元素右边最大值
    for i in range(length - 1, -1, -1):
        rightLargest = max(rightLargest, lists[i])
        # right.insert(i, rightLargest) # 使用insert倒序插入的时候，顺序会乱掉。
        # right.append(rightLargest)    # 使用append获得的右边的顺序刚好是倒着的
        right[i] = rightLargest

    print(left)
    print(right)

    for i in range(length):
        waters += min(left[i], right[i]) - lists[i] if min(left[i], right[i]) &gt; lists[i] else 0

    return waters

print(water([5, 2, 6, 2, 4]))</code></pre>
<p>题解三|优化：</p>
<p>分析上面算法发现其实没有必要使用 left 数组，因为当从左到右遍历求存水量的过程中可以利用一个变量来保存当前元素左边的最大值。</p>
<pre><code>def water(lists):
    length = len(lists)
    waters = 0  # 保存最大存水量

    # 一根柱子时，不围水
    if (lists is None or length &lt;= 1):
        return 0

    leftLargest, rightLargest = 0, 0
    right = [0]*length  # right中保存每个元素左边的最大值，right[i]，表示数组中第i个元素的右边最大值。

    # 遍历找到每个元素右边最大值
    for i in range(length - 1, -1, -1):
        rightLargest = max(rightLargest, lists[i])
        # right.insert(i, rightLargest)
        # right.append(rightLargest)  # 使用insert倒序插入的时候，顺序会乱掉。
        right[i]=rightLargest

    for i in range(length):
        leftLargest = max(leftLargest, lists[i])
        waters += min(leftLargest, right[i]) - lists[i] if min(leftLargest, right[i]) &gt; lists[i] else 0

    return waters

print(water([5, 2, 6, 2, 4]))</code></pre>
<p>题解四|双指针：</p>
<pre><code>上面左右两边的黄色块分别表示当前元素左边最大值和右边最大值。

left ，right分别代表从左到右移动和从右到左移动的指针。

如果当前元素的左边最大值比右边最大值小，则left指针向右移动，否则right指针向左移动。

这种左右指针移动的目的是为了保证所求的左右最大值一定是当前元素的左右最大值。</code></pre>
<pre><code>def water(lists):
    length = len(lists)
    waters = 0  # 保存最大存水量

    # 一根柱子时，不围水
    if (lists is None or length &lt;= 1):
        return 0

    leftLargest, rightLargest = 0, 0
    left, right = 0, length - 1

    while left &lt; right:
        leftLargest = max(lists[left], leftLargest)
        rightLargest = max(lists[right], rightLargest)

        if leftLargest &gt; rightLargest:
            waters += rightLargest - lists[right]
            right -= 1

            print(&#39;1&#39;, waters)
        else:
            waters += leftLargest - lists[left]
            left += 1

            print(&#39;2&#39;, waters)
    return waters</code></pre>
<pre><code>def trap(height):
    if not height: return 0
    left = 0
    right = len(height) - 1
    res = 0
    # 记录左右边最大值
    left_max = height[left]
    right_max = height[right]
    while left &lt; right:
        if height[left] &lt; height[right]:
            if left_max &gt; height[left]:
                res += left_max - height[left]
            else:
                left_max = height[left]
            left += 1
        else:
            if right_max &gt; height[right]:
                res += right_max - height[right]
            else:
                right_max = height[right]
            right -= 1
    return res</code></pre>
<h3 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a>45. 跳跃游戏 II</h3><pre><code>链接：https://leetcode-cn.com/problems/jump-game-ii/

给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

你的目标是使用最少的跳跃次数到达数组的最后一个位置。

示例:

输入: [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</code></pre>
<p>题解一：<br>思路：</p>
<pre><code>1、如果某一个作为 起跳点 的格子可以跳跃的距离是 3，那么表示后面 3 个格子都可以作为 起跳点。
    11. 可以对每一个能作为 起跳点 的格子都尝试跳一次，把 能跳到最远的距离 不断更新。

2、如果从这个 起跳点 起跳叫做第 1 次 跳跃，那么从后面 3 个格子起跳 都 可以叫做第 2 次 跳跃。

3、所以，当一次 跳跃 结束时，从下一个格子开始，到现在 能跳到最远的距离，都 是下一次 跳跃 的 起跳点。
    31. 对每一次 跳跃 用 for 循环来模拟。
    32. 跳完一次之后，更新下一次 起跳点 的范围。
    33. 在新的范围内跳，更新 能跳到最远的距离。

4、记录 跳跃 次数，如果跳到了终点，就得到了结果。</code></pre>
<pre><code>class Solution:
    def jump(self, nums: List[int]) -&gt; int:
        ans=0
        start=0
        end=1
        while end&lt;len(nums):
            maxPos=0
            for i in range(start,end):
                maxPos=max(maxPos,nums[i]+i)
            start=end
            end=maxPos+1
            ans+=1
        return ans</code></pre>
<p>优化：</p>
<pre><code>class Solution:
    def jump(self, nums: List[int]) -&gt; int:
        ans=0
        end=0
        maxPos=0
        for i in range(0,len(nums)-1):
            maxPos=max(maxPos,nums[i]+i)
            if i==end:
                end=maxPos
                ans+=1
        return ans</code></pre>
<h3 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48.旋转图像"></a>48.旋转图像</h3><pre><code>链接：https://leetcode-cn.com/problems/rotate-image/

给定一个 n × n 的二维矩阵表示一个图像。

将图像顺时针旋转 90 度。

说明：

你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。

示例 1:

给定 matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

原地旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
示例 2:

给定 matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

原地旋转输入矩阵，使其变为:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]</code></pre>
<p>题解一|转置+翻转：</p>
<p>分析：先转置矩阵，然后翻转每一行。这个简单的方法已经能达到最优的时间复杂度O(N^2)。</p>
<p>时间复杂度：O(N^2)<br>空间复杂度：O(1) 由于旋转操作是 就地 完成的。</p>
<pre><code>class Solution:
    def rotate(self, matrix: List[List[int]]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify matrix in-place instead.
        &quot;&quot;&quot;
        n=len(matrix[0]) # 矩阵第一行matrix[0]
        # 矩阵转置
        for i in range(n):
            for j in range(i,n): # 注意这里是i，而不是从0开始。
                matrix[j][i],matrix[i][j]=matrix[i][j],matrix[j][i]
        # 翻转每行
        for i in range(n):
            matrix[i].reverse()
        return matrix</code></pre>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rotate-image/solution/xuan-zhuan-tu-xiang-by-leetcode/">https://leetcode-cn.com/problems/rotate-image/solution/xuan-zhuan-tu-xiang-by-leetcode/</a></p>
<h3 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a>49. 字母异位词分组</h3><pre><code>链接：https://leetcode-cn.com/problems/group-anagrams/

给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。

示例:

输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],
输出:
[
  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],
  [&quot;nat&quot;,&quot;tan&quot;],
  [&quot;bat&quot;]
]
·

所有输入均为小写字母。
不考虑答案输出的顺序。</code></pre>
<p>题解一|hash：</p>
<pre><code>class Solution:
    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:
        hash=&#123;&#125;
        for i in strs:
            tmp=tuple(sorted(i))
            if tmp not in hash:
                hash[tmp]=[i]
            else:
                hash[tmp].append(i)
        # print(hash)
        res=[i for i in hash.values()]
        return res</code></pre>
<p>输出：</p>
<pre><code>&#123;(&#39;a&#39;, &#39;e&#39;, &#39;t&#39;): [&#39;eat&#39;, &#39;tea&#39;, &#39;ate&#39;], (&#39;a&#39;, &#39;n&#39;, &#39;t&#39;): [&#39;tan&#39;, &#39;nat&#39;], (&#39;a&#39;, &#39;b&#39;, &#39;t&#39;): [&#39;bat&#39;]&#125;</code></pre>
<h3 id="66-加一"><a href="#66-加一" class="headerlink" title="66. 加一"></a>66. 加一</h3><p>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/plus-one/">https://leetcode-cn.com/problems/plus-one/</a></p>
<pre><code>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。

示例 1:

输入: [1,2,3]
输出: [1,2,4]
解释: 输入数组表示数字 123。
示例 2:

输入: [4,3,2,1]
输出: [4,3,2,2]
解释: 输入数组表示数字 4321。</code></pre>
<p>题解一：</p>
<p>思路：转换为int进行加1</p>
<p>题解二：</p>
<pre><code>class Solution:
    def plusOne(self, digits: List[int]) -&gt; List[int]:
        for i in range(len(digits)-1,-1,-1):
            digits[i]+=1
            digits[i] %= 10
            if digits[i] != 0: # 注意这里是digits[i]，而不是digits
                return digits

        digits=[0]*(len(digits)+1) # 解决case[9],输出[1,0]
        digits[0]=1 # 解决case[9],输出[1,0]
        return digits    </code></pre>
<p>题解三：</p>
<pre><code>class Solution:
    def plusOne(self, digits: List[int]) -&gt; List[int]:
        new=[]
        while digits and digits[-1] == 9:
            digits.pop()
            new.append(0)
        if not digits:
            return [1]+new
        else:
            digits[-1]+=1
            return digits+new</code></pre>
<p>题解四：</p>
<pre><code>class Solution:
    def plusOne(self, digits):
        length=len(digits)
        i=length-1
        while(i&gt;=0):
            if i==0:
                if (digits[i]+1)&gt;9:
                    digits[i]=0
                    result=[1]
                    result.extend(digits)
                    return result
            if (digits[i]+1)&lt;=9:
                digits[i]+=1
                return digits
            else:
                digits[i]=0
                i-=1
        return digits</code></pre>
<h3 id="69-x的平方根"><a href="#69-x的平方根" class="headerlink" title="69.x的平方根"></a>69.x的平方根</h3><pre><code>链接：https://leetcode-cn.com/problems/sqrtx/

实现 int sqrt(int x) 函数。

计算并返回 x 的平方根，其中 x 是非负整数。

由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

示例 1:

输入: 4
输出: 2
示例 2:

输入: 8
输出: 2
说明: 8 的平方根是 2.82842..., 
     由于返回类型是整数，小数部分将被舍去。</code></pre>
<p>题解一(二分法):</p>
<p>思路分析：使用二分法搜索平方根的思想很简单，就类似于小时候我们看的电视节目中的“猜价格”游戏，高了就往低了猜，低了就往高了猜，范围越来越小。因此，使用二分法猜算术平方根就很自然。</p>
<p>一个数的平方根肯定不会超过它自己，不过直觉还告诉我们，一个数的平方根最多不会超过它的一半，例如 8的平方根，8 的一半是 4，4^2=16&gt;8，如果这个数越大越是如此，因此我们要计算一下，这个边界是多少。为此，解如下不等式：(a/2)^2 &gt;= a</p>
<p>时间复杂度：O(logn)<br>空间复杂度：O(1)</p>
<pre><code>class Solution:
    def mySqrt(self, x: int) -&gt; int:
        left=0
        right=x//2+1
        while left &lt; right:
            # mid = left + (right - left + 1) // 2
            # mid=(left+right+1)&gt;&gt;1
            mid=(left+right+1)//2 # 使用除法的耗时比移位多
            square=mid*mid

            if square&gt;x:
                right=mid-1
            else:
                left=mid

        return left</code></pre>
<pre><code># 单独照顾0这个特例

class Solution:
    def mySqrt(self, x: int) -&gt; int:
        if x==0:
            return 0
        left=1
        right=x//2
        while left &lt; right:
            # mid=(left+right+1)&gt;&gt;1
            mid=(left+right+1)//2 # 使用除法的耗时比移位多
            # 一定取右中位数，如果取左中位数(left+right)//2，代码可能会进入死循环
            square=mid*mid

            if square&gt;x:
                right=mid-1
            else:
                left=mid

        return left</code></pre>
<pre><code>class Solution:

    def mySqrt(self, x):
        left = 0
        right = 999999
        while left &lt; right:
            # 这种取中位数的方法又快又好，是我刚学会的，原因在下面这篇文章的评论区
            # https://www.liwei.party/2019/06/17/leetcode-solution-new/search-insert-position/
            mid = (left + right + 1) &gt;&gt; 1
            square = mid * mid
            if square &gt; x:
                right = mid - 1
            else:
                left = mid

        return left</code></pre>
<p>?题解二（牛顿法）:</p>
<p>牛顿法的应用：一个是求方程的根，另一个是求解最优化问题</p>
<p>使用牛顿法可以得到一个正实数的算术平方根，因为题目中说“结果只保留整数部分”，因此，我们把使用牛顿法得到的浮点数转换为整数即可。</p>
<p>在迭代过程中，以直线代替曲线，用一阶泰勒展式（即在当前点的切线）代替原曲线，求直线与 xx 轴的交点，重复这个过程直到收敛。<br><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/newton.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/newton.png"></p>
<pre><code>class Solution:
    def mySqrt(self, x: int) -&gt; int:
        if x&lt;0:
            # raise Exception(&#39;不能输入负数)
            return -1
        if x==0:
            return 0

        cur=1
        while True:
            pre=cur
            cur=(cur+x/cur)/2
            if abs(cur-pre)&lt; 1e-6:
                return int(cur)</code></pre>
<h3 id="73-矩阵置零"><a href="#73-矩阵置零" class="headerlink" title="73. 矩阵置零"></a>73. 矩阵置零</h3><pre><code>链接：https://leetcode-cn.com/problems/set-matrix-zeroes/

给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。

示例 1:

输入: 
[
  [1,1,1],
  [1,0,1],
  [1,1,1]
]
输出: 
[
  [1,0,1],
  [0,0,0],
  [1,0,1]
]
示例 2:

输入: 
[
  [0,1,2,0],
  [3,4,5,2],
  [1,3,1,5]
]
输出: 
[
  [0,0,0,0],
  [0,4,5,0],
  [0,3,1,0]
]
进阶:

一个直接的解决方案是使用  O(mn) 的额外空间，但这并不是一个好的解决方案。
一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。
你能想出一个常数空间的解决方案吗？</code></pre>
<p>题解一：</p>
<p>分析：</p>
<pre><code>用 O(m+n)额外空间
两遍扫matrix,第一遍用集合记录哪些行,哪些列有0;第二遍置0</code></pre>
<p>时间复杂度：O(M*N)<br>空间复杂度：O(M+N)</p>
<pre><code>class Solution:
    def setZeroes(self, matrix: List[List[int]]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify matrix in-place instead.
        &quot;&quot;&quot;
        m=len(matrix)       # 行
        n=len(matrix[0])    # 列
        m_zero=set()
        n_zero=set()
        for i in range(m):
            for j in range(n):
                if matrix[i][j]== 0:
                    m_zero.add(i)
                    n_zero.add(j)
        for i in range(m):
            for j in range(n):
                if i in m_zero or j in n_zero: # 不是if 0 in m_zero or 0 in n_zero
                    matrix[i][j]=0
        return matrix</code></pre>
<p>题解二：</p>
<p>分析:</p>
<pre><code>用matrix第一行和第一列记录该行该列是否有0,作为标志位
但是对于第一行,和第一列要设置一个标志位,为了防止自己这一行(一列)也有0的情况.

参考：https://leetcode-cn.com/problems/set-matrix-zeroes/solution/li-yong-di-yi-xing-he-di-yi-lie-ji-lu-o1kong-jian-/

定义flag_line=False，判断第一行是否需要置0。
定义flag_row=False，判断第一列是否需要置0。
遍历第一列，若第一列中存在0，将flag_row=True，表示需要将第一列置0。
遍历第一行，若第一行中存在0，将flag_line=True，表示需要将第一行置0。

遍历矩阵，遍历区间，行区间[1,m)，列区间[1,m)，若matrix[i][j]==0，则将对应的行和列记录下来，即将第一行和第一列中对应的位置置为0。matrix[i][0]=matrix[0][j]=0

再遍历一次矩阵，若当前位置的行或列索引对应的第一行或者第一列处为0，即matrix[i][0]==0 or matrix[0][j]==0，将此位置置为0。
根据flag_line，判断是否需要将第一行置为0。
根据flag_row，判断第一列是否需要置0。


时间复杂度：O(M*N)
空间复杂度：O(1)</code></pre>
<pre><code>class Solution:
    def setZeroes(self, matrix: List[List[int]]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify matrix in-place instead.
        &quot;&quot;&quot;
        # 输入：[[1,1,1,1],[1,0,1,1],[1,1,1,1]]
        m=len(matrix)       # 行的个数
        n=len(matrix[0])    # 列的个数
        m0_flag=False
        n0_flag=False

        # 找第一行是否有0
        for j in range(n):
            if matrix[0][j] == 0:
                m0_flag=True
                break
        # 找第一列是否有0
        for i in range(m):
            if matrix[i][0]==0:
                n0_flag=True
                break
        # 把第一行或者第一列作为 标志位
        for i in range(1,m):
            for j in range(1,n):
                if matrix[i][j]==0:
                    matrix[i][0]=matrix[0][j]=0
        # print(matrix)
        # [[1, 0, 1, 1], [0, 0, 1, 1], [1, 1, 1, 1]]

        # 置0
        for i in range(1,m):
            for j in range(1,n):
                if(matrix[i][0]==0 or matrix[0][j]==0):
                    matrix[i][j]=0    
        # print(matrix)  
        # [[1, 0, 1, 1], [0, 0, 0, 0], [1, 0, 1, 1]]

        if m0_flag:
            for j in range(n):
                matrix[0][j]=0
        if n0_flag:
            for i in range(m):
                matrix[i][0]=0</code></pre>
<p>???</p>
<pre><code>class Solution:
    def setZeroes(self, matrix: List[List[int]]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify matrix in-place instead.
        &quot;&quot;&quot;
        flag_col = False
        row = len(matrix)
        col = len(matrix[0])
        for i in range(row):
            if matrix[i][0] == 0: flag_col = True
            for j in range(1,col):
                if matrix[i][j] == 0:
                    matrix[i][0] = matrix[0][j] = 0

        for i in range(row - 1, -1, -1):
            for j in range(col - 1, 0, -1):
                if matrix[i][0] == 0 or matrix[0][j] == 0:
                    matrix[i][j] = 0

            if flag_col == True: matrix[i][0] = 0
</code></pre>
<h3 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a>88. 合并两个有序数组</h3><pre><code>链接：https://leetcode-cn.com/problems/merge-sorted-array/

给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 num1 成为一个有序数组。

说明:

初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。
你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。
 

示例:

输入:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

输出: [1,2,2,3,5,6]</code></pre>
<p>题解一（合并后再排序）：</p>
<p>时间复杂度 : O((n + m)\log(n + m))<br>空间复杂度 : O(1)</p>
<pre><code>class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums1 in-place instead.
        &quot;&quot;&quot;
        nums1[:]=sorted(nums1[:m]+nums2)</code></pre>
<p>题解二（双指针 / 从前往后）：</p>
<p>时间复杂度 : O(n + m)<br>空间复杂度 : O(m)</p>
<pre><code>class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums1 in-place instead.
        &quot;&quot;&quot;
        copy=nums1[:m]
        nums1[:]=[]
        p1,p2=0,0
        while p1&lt;m and p2&lt;n:
            if copy[p1]&lt;nums2[p2]:
                nums1.append(copy[p1])
                p1+=1
            else:
                nums1.append(nums2[p2])
                p2+=1
        if p1&lt;m:
            nums1[p1+p2:]=copy[p1:]
        if p2&lt;n:
            nums1[p1+p2:]=nums2[p2:]</code></pre>
<p>题解三(双指针 / 从后往前)：</p>
<p>时间复杂度 : O(n + m)<br>空间复杂度 : O(1)</p>
<pre><code>class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums1 in-place instead.
        &quot;&quot;&quot;
        p1=m-1
        p2=n-1
        p=m+n-1
        while p1&gt;=0 and p2&gt;=0:
            if nums1[p1] &lt; nums2[p2]:
                nums1[p]=nums2[p2]
                p2-=1
            else:
                nums1[p]=nums1[p1]
                p1-=1
            p-=1
        nums1[:p2+1]=nums2[:p2+1] # 解决case:[0]，0，[1]，1</code></pre>
<h3 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a>167. 两数之和 II - 输入有序数组</h3><pre><code>链接：https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/

给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。

函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。

说明:

返回的下标值（index1 和 index2）不是从零开始的。
你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。
示例:

输入: numbers = [2, 7, 11, 15], target = 9
输出: [1,2]
解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</code></pre>
<p>题解一|暴力|超时：</p>
<pre><code>class Solution:
    def twoSum(self, numbers: List[int], target: int) -&gt; List[int]:
        n=len(numbers)
        for i in range(n):
            for j in range(i+1,n):
                if numbers[i]+numbers[j]==target:
                    return [i+1,j+1]</code></pre>
<p>题解二|双指针:</p>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<pre><code>class Solution:
    def twoSum(self, numbers: List[int], target: int) -&gt; List[int]:
        left=0
        right=len(numbers)-1
        while left &lt; right:
            if numbers[left]+numbers[right]==target:
                return [left+1,right+1]
            elif numbers[left]+numbers[right] &gt; target:
                right-=1
            else:
                left+=1
        return False</code></pre>
<h3 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189. 旋转数组"></a>189. 旋转数组</h3><pre><code>链接：https://leetcode-cn.com/problems/rotate-array/

给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。

示例 1:

输入: [1,2,3,4,5,6,7] 和 k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]
示例 2:

输入: [-1,-100,3,99] 和 k = 2
输出: [3,99,-1,-100]
解释: 
向右旋转 1 步: [99,-1,-100,3]
向右旋转 2 步: [3,99,-1,-100]
说明:

尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
要求使用空间复杂度为 O(1) 的 原地 算法。</code></pre>
<p>题解一|暴力|超时：</p>
<p>时间复杂度：O(n^2)<br>空间复杂度：O(1)</p>
<pre><code>class Solution:
    def rotate(self, nums: List[int], k: int) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums in-place instead.
        &quot;&quot;&quot;
        if not nums:
            return &#39;&#39;
        n=len(nums)
        k=k%n
        while k!=0:
            tmp=nums[n-1]
            i=n-1
            while i&gt;0:
                nums[i]=nums[i-1]
                i-=1
            nums[0]=tmp
            k-=1
        return nums</code></pre>
<p>题解二|切片：</p>
<pre><code>class Solution:
    def rotate(self, nums: List[int], k: int) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums in-place instead.
        &quot;&quot;&quot;
        n=len(nums)
        if n &lt; 2:
            pass
        else:
            while k&gt;0:
                tmp=nums[-1]
                nums[1:n]=nums[0:n-1]
                nums[0]=tmp
                k-=1</code></pre>
<h3 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a>283. 移动零</h3><pre><code>链接：https://leetcode-cn.com/problems/move-zeroes/

给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

示例:

输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
说明:

必须在原数组上操作，不能拷贝额外的数组。
尽量减少操作次数。</code></pre>
<p>思路：<br>    循环，统计0的个数，非0元素前移，0放在最后；</p>
<pre><code>新开一个数组，碰到0后放，非0放在前面；

index记录非0的位置；</code></pre>
<p>题解一：</p>
<pre><code>class Solution:
    def moveZeroes(self, nums: List[int]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums in-place instead.
        &quot;&quot;&quot;
        index=0
        for i in range(len(nums)):
            if nums[i] != 0:
                nums[index]=nums[i]
                index+=1
        for i in range(index,len(nums)):
            nums[i]=0
        return nums</code></pre>
<pre><code>class Solution:
    def moveZeroes(self, nums: List[int]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums in-place instead.
        &quot;&quot;&quot;
        index=0
        for i in range(len(nums)):
            if nums[i] != 0:
                nums[index]=nums[i]
                if i != index:
                    nums[i]=0
                index+=1
        return nums</code></pre>
<h3 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349.两个数组的交集"></a>349.两个数组的交集</h3><pre><code>链接：https://leetcode-cn.com/problems/intersection-of-two-arrays/

给定两个数组，编写一个函数来计算它们的交集。

示例 1：

输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]
示例 2：

输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[9,4]
 

说明：

输出结果中的每个元素一定是唯一的。
我们可以不考虑输出结果的顺序。</code></pre>
<p>题解一|集合：</p>
<p>集合（set）是一个无序的不重复元素序列，可以使用大括号 { } 或者 set() 函数创建集合。</p>
<p>注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。</p>
<pre><code>class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:
        res=set()
        for i in nums1:
            if i in nums2:
                res.add(i)
        return list(res)</code></pre>
<p>题解二：</p>
<p>时间复杂度：一般情况下是 O(m+n)，最坏情况下是 O(m×n) 。<br>空间复杂度：最坏的情况是 O(m+n)，数组中的所有元素都不同。</p>
<pre><code>class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:
        set1=set(num1)
        set2=set(num2)
        return list(set1 &amp; set2)</code></pre>
<h3 id="350-两个数组的交集-II"><a href="#350-两个数组的交集-II" class="headerlink" title="350. 两个数组的交集 II"></a>350. 两个数组的交集 II</h3><pre><code>链接：https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/

给定两个数组，编写一个函数来计算它们的交集。

示例 1：

输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2,2]
示例 2:

输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[4,9]

说明：

输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。
我们可以不考虑输出结果的顺序。
进阶：

如果给定的数组已经排好序呢？你将如何优化你的算法？
如果 nums1 的大小比 nums2 小很多，哪种方法更优？
如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？</code></pre>
<p>题解一|排序：</p>
<p>时间复杂度：O(mlogm+nlogn)，其中 m 和 n 分别是两个数组的长度。对两个数组进行排序的时间复杂度是 O(mlogm+nlogn)，遍历两个数组的时间复杂度是 O(m+n)，因此总时间复杂度是 O(mlogm+nlogn)。</p>
<p>空间复杂度：O(min(m,n))，其中 m 和 n 分别是两个数组的长度。为返回值创建一个数组 intersection，其长度为较短的数组的长度。不过在 C++ 中，我们可以直接创建一个 vector，不需要把答案临时存放在一个额外的数组中，所以这种实现的空间复杂度为 O(1)。</p>
<pre><code>class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:
        nums1.sort()
        nums2.sort()
        index1,index2=0,0
        intersection=[]
        while index1&lt;len(nums1) and index2&lt;len(nums2):
            if nums1[index1] &lt; nums2[index2]:
                index1+=1
            elif nums1[index1] &gt; nums2[index2]:
                index2+=1
            else:
                intersection.append(nums1[index1])
                index1+=1
                index2+=1
        return intersection</code></pre>
<p>题解二|hash：</p>
<pre><code>class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:
        hash=&#123;&#125;
        intersection=[]
        for i in nums1:
            hash[i]=hash.get(i,0)+1
        for i in nums2:
            if hash.get(i,0)&gt;0:
                intersection.append(i)
                hash[i]-=1
        return intersection</code></pre>
<pre><code>class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:
        hash=&#123;&#125;
        intersection=[]
        for i in nums1:
            hash[i]=hash.get(i,0)+1
        for i in nums2:
            if hash.get(i,0)&gt;0:
                intersection.append(i)
                hash[i]-=1
                if hash[i]==0: # 动态减少空间，以免hash表越来越大。
                    hash.pop(i)
        return intersection</code></pre>
<h3 id="442-数组中重复的数据"><a href="#442-数组中重复的数据" class="headerlink" title="442. 数组中重复的数据"></a>442. 数组中重复的数据</h3><pre><code>链接：https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/

给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。

找到所有出现两次的元素。

你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗？

示例：

输入:
[4,3,2,7,8,2,3,1]

输出:
[2,3]</code></pre>
<p>题解一|原地变负：</p>
<p>注意：1 ≤ a[i] ≤ n，所以变负时才不会越界。</p>
<pre><code>class Solution:
    def findDuplicates(self, nums: List[int]) -&gt; List[int]:
        ans=[]
        for num in nums:
            if nums[abs(num)-1] &lt; 0:
                ans.append(abs(num))
            nums[abs(num)-1]*=-1
        return ans</code></pre>
<h3 id="498-对角线遍历"><a href="#498-对角线遍历" class="headerlink" title="498. 对角线遍历"></a>498. 对角线遍历</h3><pre><code>给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。

示例:

输入:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]

输出:  [1,2,4,7,5,3,6,8,9]

解释:

说明:

给定矩阵中的元素总数不会超过 100000 。</code></pre>
<p>题解一：</p>
<p>规律：</p>
<pre><code>对于矩形来说，矩形对角线是最长的，也是遍历结果最长的一条，从这条线，到两边对称递减

遍历顺序：从左下角到右上角交错进行</code></pre>
<p>根据以上两个特点，我们可以想到是否同一条线上的坐标有数上的关系，而且，交替遍历是否可以看成奇数和偶数的替换呢？带着这种思考我们解析这个矩阵(以图中矩阵为例子)：</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/duijiaoxian.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/duijiaoxian.png"></p>
<pre><code>1、我们现在将每一条对角线作出从0 开始的编号，可以发现最后一个的编号是 M + N - 1；并且如果编号为奇数自上而下遍历，偶数则是自下而上遍历

2、关注每一条对角线上的坐标和：对于每一条对角线上的坐标(m,n)，m + n = 编号 是我们发现的规律

3、最后一步就是确定边界：

    多少次遍历：矩阵有多少个元素就遍历多少次；
    到什么时候结束：对于最长对角线以上来说，到 m 或者 n 中的某一个到 0 为止；对于最长对角线下面来说，到 m 或者 n 中的某一个到达边界为止。</code></pre>
<pre><code>class Solution:
    def findDiagonalOrder(self, matrix: List[List[int]]) -&gt; List[int]:
        if not matrix:
            return []
        size=len(matrix)*len(matrix[0])
        index=0
        result=[0]*size
        maxK=len(matrix)+len(matrix[0])


        for k in range(maxK):
            m,n=0,0
            if k%2==0: # 偶数部分
                if k&lt;len(matrix):
                    m=k
                    n=0
                else:
                    m=len(matrix)-1
                    n=k-m
                while m&gt;=0 and n&lt;len(matrix[0]): # n到达边界为止
                    result[index]=matrix[m][n]
                    index+=1
                    m-=1
                    n+=1
            else: # 奇数部分
                if k&lt;len(matrix[0]):
                    m=0
                    n=k
                else:
                    n=len(matrix[0])-1
                    m=k-n
                while m&lt;len(matrix) and n&gt;=0: # m到达边界为止
                    result[index]=matrix[m][n]
                    index+=1
                    m+=1
                    n-=1
        return result</code></pre>
<h3 id="867-转置矩阵"><a href="#867-转置矩阵" class="headerlink" title="867. 转置矩阵"></a>867. 转置矩阵</h3><pre><code>链接：https://leetcode-cn.com/problems/transpose-matrix/

给定一个矩阵 A， 返回 A 的转置矩阵。

矩阵的转置是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。

示例 1：

输入：[[1,2,3],[4,5,6],[7,8,9]]
输出：[[1,4,7],[2,5,8],[3,6,9]]
示例 2：

输入：[[1,2,3],[4,5,6]]
输出：[[1,4],[2,5],[3,6]]


提示：

1 &lt;= A.length &lt;= 1000
1 &lt;= A[0].length &lt;= 1000</code></pre>
<h3 id="1424-对角线遍历-II"><a href="#1424-对角线遍历-II" class="headerlink" title="1424. 对角线遍历 II"></a>1424. 对角线遍历 II</h3><pre><code>链接：https://leetcode-cn.com/problems/diagonal-traverse-ii/solution/mei-ge-shu-zu-yuan-su-de-wei-zhi-jue-ding-liao-ta-/

给你一个列表 nums ，里面每一个元素都是一个整数列表。请你依照下面各图的规则，按顺序返回 nums 中对角线上的整数。

示例 1：

输入：nums = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,4,2,7,5,3,8,6,9]
示例 2：

输入：nums = [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]]
输出：[1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16]
示例 3：

输入：nums = [[1,2,3],[4],[5,6,7],[8],[9,10,11]]
输出：[1,4,2,5,3,8,6,9,7,10,11]
示例 4：

输入：nums = [[1,2,3,4,5,6]]
输出：[1,2,3,4,5,6]

提示：

1 &lt;= nums.length &lt;= 10^5
1 &lt;= nums[i].length &lt;= 10^5
1 &lt;= nums[i][j] &lt;= 10^9
nums 中最多有 10^5 个数字。</code></pre>
<pre><code>class Solution:
    def findDiagonalOrder(self, nums: List[List[int]]) -&gt; List[int]:
        sub=[]
        for i in range(len(nums)):
            for j in range(len(nums[i])):
                if i+j &gt;= len(sub):
                    sub.append([])
                sub[i+j].append(nums[i][j])
        result=[]
        for i in sub:
            result+=i[::-1]
        return result</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92-%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92-%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">线性回归--从0开始实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-09-17 19:19:43" itemprop="dateCreated datePublished" datetime="2018-09-17T19:19:43+08:00">2018-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-18 17:10:52" itemprop="dateModified" datetime="2020-09-18T17:10:52+08:00">2020-09-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习和深度学习</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/gluon/" itemprop="url" rel="index"><span itemprop="name">gluon</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>代码：<a target="_blank" rel="noopener" href="https://github.com/Gladysgong/gluon_learning/blob/master/chap3_basic/">https://github.com/Gladysgong/gluon_learning/blob/master/chap3_basic/</a></p>
<h2 id="一-线性回归"><a href="#一-线性回归" class="headerlink" title="一.线性回归"></a>一.线性回归</h2><pre><code>线性回归输出是连续值，因此不适用于回归问题；
Softmax回归输出是是离散值，因为适用于分类问题。</code></pre>
<h3 id="1-线性回归要素"><a href="#1-线性回归要素" class="headerlink" title="1.线性回归要素"></a>1.线性回归要素</h3><pre><code>模型: 
    表达式：</code></pre>
<p>$$\hat{y} = x_1 w_1 + x_2 w_2 + b,$$</p>
<pre><code>    模型训练:
        训练数据
        损失函数
        优化算法:
            解析解：误差最小化问题的解可以直接用公式表达出来
            数值解：大多数深度学习模型并没有解析解，只能通过优化算法有限次迭代模型参数来尽可能降低损失函数的值
                   小批量随机梯度下降：批量大小和学习率是认为设定的，叫做超参数

    模型预测</code></pre>
<h3 id="2-线性回归表示方法"><a href="#2-线性回归表示方法" class="headerlink" title="2.线性回归表示方法"></a>2.线性回归表示方法</h3><pre><code>神经网络图
矢量计算表达式</code></pre>
<h2 id="二-线性回归–从0开始实现"><a href="#二-线性回归–从0开始实现" class="headerlink" title="二.线性回归–从0开始实现"></a>二.线性回归–从0开始实现</h2><pre class=" language-python"><code class="language-python"><span class="token operator">%</span>matplotlib inline
<span class="token keyword">from</span> IPython <span class="token keyword">import</span> display
<span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> pyplot <span class="token keyword">as</span> plt
<span class="token keyword">from</span> mxnet <span class="token keyword">import</span> autograd<span class="token punctuation">,</span> nd
<span class="token keyword">import</span> random</code></pre>
<h3 id="1-生成数据集"><a href="#1-生成数据集" class="headerlink" title="1.生成数据集"></a>1.生成数据集</h3><pre><code>numpy.random.normal(loc=0.0, scale=1.0, size=None)11
loc：float
    此概率分布的均值（对应着整个分布的中心centre）
scale：float
    此概率分布的标准差（对应于分布的宽度，scale越大越矮胖，scale越小，越瘦高）
size：int or tuple of ints
    输出的shape，默认为None</code></pre>
<pre class=" language-python"><code class="language-python">num_inputs<span class="token operator">=</span><span class="token number">2</span>
num_examples<span class="token operator">=</span><span class="token number">1000</span>
true_w<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">3.4</span><span class="token punctuation">]</span>
true_b<span class="token operator">=</span><span class="token number">4.2</span>
features<span class="token operator">=</span>nd<span class="token punctuation">.</span>random<span class="token punctuation">.</span>normal<span class="token punctuation">(</span>scale<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>shape<span class="token operator">=</span><span class="token punctuation">(</span>num_examples<span class="token punctuation">,</span>num_inputs<span class="token punctuation">)</span><span class="token punctuation">)</span>
labels<span class="token operator">=</span>true_w<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span>features<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span>true_w<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">*</span>features<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>true_b
labels<span class="token operator">+=</span>nd<span class="token punctuation">.</span>random<span class="token punctuation">.</span>normal<span class="token punctuation">(</span>scale<span class="token operator">=</span><span class="token number">0.01</span><span class="token punctuation">,</span>shape<span class="token operator">=</span>labels<span class="token punctuation">.</span>shape<span class="token punctuation">)</span></code></pre>
<pre class=" language-python"><code class="language-python">features<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>labels<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span></code></pre>
<pre><code>(
 [ 1.16307867  0.48380461]
 &lt;NDArray 2 @cpu(0)&gt;, 
 [ 4.87962484]
 &lt;NDArray 1 @cpu(0)&gt;)</code></pre>
<pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">use_svg_display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment" spellcheck="true"># 用矢量图表示</span>
    display<span class="token punctuation">.</span>set_matplotlib_formats<span class="token punctuation">(</span><span class="token string">'svg'</span><span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">set_figsize</span><span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">3.5</span><span class="token punctuation">,</span><span class="token number">2.5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment" spellcheck="true">#set_matplotlib_formats('svg')</span>
    use_svg_display<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true"># 设置图的尺寸</span>
    plt<span class="token punctuation">.</span>rcParams<span class="token punctuation">[</span><span class="token string">'figure.figsize'</span><span class="token punctuation">]</span><span class="token operator">=</span>figsize

set_figsize<span class="token punctuation">(</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>features<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>asnumpy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>labels<span class="token punctuation">.</span>asnumpy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># plt.show()</span></code></pre>
<pre><code>&lt;matplotlib.collections.PathCollection at 0x117cadda0&gt;</code></pre>
<p><img src="/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92-%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0/linear_regression_6_1.svg" alt="svg"></p>
<h3 id="2-读取数据"><a href="#2-读取数据" class="headerlink" title="2.读取数据"></a>2.读取数据</h3><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 每次返回batch_size(批量大小)个随机样本的特征和标签</span>
<span class="token comment" spellcheck="true"># 此函数已保存在gluonbook包中方便以后使用</span>
<span class="token keyword">def</span> <span class="token function">data_iter</span><span class="token punctuation">(</span>batch_size<span class="token punctuation">,</span>features<span class="token punctuation">,</span>labels<span class="token punctuation">)</span><span class="token punctuation">:</span>
    num_examples<span class="token operator">=</span>len<span class="token punctuation">(</span>features<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"长度："</span><span class="token punctuation">,</span>num_examples<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 1000,行数</span>
    indices<span class="token operator">=</span>list<span class="token punctuation">(</span>range<span class="token punctuation">(</span>num_examples<span class="token punctuation">)</span><span class="token punctuation">)</span> 
<span class="token comment" spellcheck="true">#     print("indices：",indices)  # 0-999</span>
    random<span class="token punctuation">.</span>shuffle<span class="token punctuation">(</span>indices<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 样本的读取顺序是随机的。</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>num_examples<span class="token punctuation">,</span>batch_size<span class="token punctuation">)</span><span class="token punctuation">:</span>
        j<span class="token operator">=</span>nd<span class="token punctuation">.</span>array<span class="token punctuation">(</span>indices<span class="token punctuation">[</span>i<span class="token punctuation">:</span>min<span class="token punctuation">(</span>i<span class="token operator">+</span>batch_size<span class="token punctuation">,</span>num_examples<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">yield</span> features<span class="token punctuation">.</span>take<span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">,</span>labels<span class="token punctuation">.</span>take<span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># take 函数根据索引返回对应元素。</span></code></pre>
<pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 每个批量的特征形状为（10， 2），分别对应批量大小和输入个数；标签形状为批量大小。</span>
batch_size <span class="token operator">=</span> <span class="token number">10</span>

<span class="token keyword">for</span> X<span class="token punctuation">,</span> y <span class="token keyword">in</span> data_iter<span class="token punctuation">(</span>batch_size<span class="token punctuation">,</span> features<span class="token punctuation">,</span> labels<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> y<span class="token punctuation">)</span>
    <span class="token keyword">break</span></code></pre>
<pre><code>长度： 1000

[[-1.4370029  -2.39830184]
 [ 0.86399084 -0.95994246]
 [-1.49929214  1.21278656]
 [ 2.52268934 -0.37837121]
 [ 1.39448225  0.56141484]
 [ 0.50767344  0.07797763]
 [ 0.37963197 -0.65589839]
 [-0.47827247 -1.17394924]
 [-0.11860342  1.41482413]
 [ 1.18384051  0.65427899]]
&lt;NDArray 10x2 @cpu(0)&gt; 
[  9.47776413   9.20563984  -2.91862679  10.52518559   5.09047413
   4.9430213    7.19049788   7.2272377   -0.82722223   4.32375574]
&lt;NDArray 10 @cpu(0)&gt;</code></pre>
<h3 id="3-初始化模型参数"><a href="#3-初始化模型参数" class="headerlink" title="3.初始化模型参数"></a>3.初始化模型参数</h3><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 将权重初始化成均值为 0 标准差为 0.01 的正态随机数，偏差则初始化成 0。</span>
w<span class="token operator">=</span>nd<span class="token punctuation">.</span>random<span class="token punctuation">.</span>normal<span class="token punctuation">(</span>scale<span class="token operator">=</span><span class="token number">0.01</span><span class="token punctuation">,</span>shape<span class="token operator">=</span><span class="token punctuation">(</span>num_inputs<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
b<span class="token operator">=</span>nd<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>shape<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<pre class=" language-python"><code class="language-python">w<span class="token punctuation">,</span>b</code></pre>
<pre><code>(
 [[ 0.01464221]
  [-0.01305814]]
 &lt;NDArray 2x1 @cpu(0)&gt;, 
 [ 0.]
 &lt;NDArray 1 @cpu(0)&gt;)</code></pre>
<pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 创建梯度，yinw需要对这些参数求梯度来迭代参数的值</span>
w<span class="token punctuation">.</span>attach_grad<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 申请存储梯度所需要的内存</span>
b<span class="token punctuation">.</span>attach_grad<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<h3 id="4-定义模型"><a href="#4-定义模型" class="headerlink" title="4.定义模型"></a>4.定义模型</h3><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 线性回归的矢量计算表达式的实现</span>
<span class="token comment" spellcheck="true"># 本函数已保存在 gluonbook 包中方便以后使用。</span>
<span class="token keyword">def</span> <span class="token function">linreg</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span>w<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> nd<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>X<span class="token punctuation">,</span>w<span class="token punctuation">)</span><span class="token operator">+</span>b <span class="token comment" spellcheck="true"># dot做矩阵乘法</span></code></pre>
<h3 id="5-定义损失函数"><a href="#5-定义损失函数" class="headerlink" title="5.定义损失函数"></a>5.定义损失函数</h3><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 使用平方损失来定义线性回归的损失函数</span>
<span class="token comment" spellcheck="true"># 本函数已保存在 gluonbook 包中方便以后使用。</span>
<span class="token keyword">def</span> <span class="token function">squared_loss</span><span class="token punctuation">(</span>y_hat<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span><span class="token punctuation">(</span>y_hat<span class="token operator">-</span>y<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>y_hat<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">2</span><span class="token operator">/</span><span class="token number">2</span> <span class="token comment" spellcheck="true"># y_hat是线性回归对真实价格 y 的预测或估计</span></code></pre>
<h3 id="6-定义优化算法"><a href="#6-定义优化算法" class="headerlink" title="6.定义优化算法"></a>6.定义优化算法</h3><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 使用sgd函数实现小批量随机梯度下降算法</span>
<span class="token comment" spellcheck="true"># 通过不断迭代模型参数来优化损失函数，这里自动求导模块计算得来的梯度是一个批量样本的梯度和，将它除以批量大小来得到平均值。</span>
<span class="token comment" spellcheck="true"># 本函数已保存在 gluonbook 包中方便以后使用。</span>
<span class="token keyword">def</span> <span class="token function">sgd</span><span class="token punctuation">(</span>params<span class="token punctuation">,</span>lr<span class="token punctuation">,</span>batch_size<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> param <span class="token keyword">in</span> params<span class="token punctuation">:</span>
        param<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">=</span>param<span class="token operator">-</span>lr<span class="token operator">*</span>param<span class="token punctuation">.</span>grad<span class="token operator">/</span>batch_size</code></pre>
<h3 id="7-训练模型"><a href="#7-训练模型" class="headerlink" title="7.训练模型"></a>7.训练模型</h3><pre class=" language-python"><code class="language-python">lr <span class="token operator">=</span> <span class="token number">0.03</span>
num_epochs <span class="token operator">=</span> <span class="token number">3</span>
net <span class="token operator">=</span> linreg
loss <span class="token operator">=</span> squared_loss

<span class="token keyword">for</span> epoch <span class="token keyword">in</span> range<span class="token punctuation">(</span>num_epochs<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 训练模型一共需要 num_epochs 个迭代周期。</span>
    <span class="token comment" spellcheck="true"># 在一个迭代周期中，使用训练数据集中所有样本一次（假设样本数能够被批量大小整除）。</span>
    <span class="token comment" spellcheck="true"># X 和 y 分别是小批量样本的特征和标签。</span>
    <span class="token keyword">for</span> X<span class="token punctuation">,</span> y <span class="token keyword">in</span> data_iter<span class="token punctuation">(</span>batch_size<span class="token punctuation">,</span> features<span class="token punctuation">,</span> labels<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">with</span> autograd<span class="token punctuation">.</span>record<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            l <span class="token operator">=</span> loss<span class="token punctuation">(</span>net<span class="token punctuation">(</span>X<span class="token punctuation">,</span> w<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># l 是有关小批量 X 和 y 的损失。</span>
        l<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 小批量的损失对模型参数求梯度。</span>
        sgd<span class="token punctuation">(</span><span class="token punctuation">[</span>w<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">,</span> lr<span class="token punctuation">,</span> batch_size<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 使用小批量随机梯度下降迭代模型参数。</span>
    train_l <span class="token operator">=</span> loss<span class="token punctuation">(</span>net<span class="token punctuation">(</span>features<span class="token punctuation">,</span> w<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">,</span> labels<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'epoch %d, loss %f'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>epoch <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> train_l<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>asnumpy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<pre><code>长度： 1000
epoch 1, loss 0.000048
长度： 1000
epoch 2, loss 0.000048
长度： 1000
epoch 3, loss 0.000048</code></pre>
<pre class=" language-python"><code class="language-python">true_w<span class="token punctuation">,</span>w</code></pre>
<pre><code>([2, -3.4], 
 [[ 2.00003362]
  [-3.40025949]]
 &lt;NDArray 2x1 @cpu(0)&gt;)</code></pre>
<pre class=" language-python"><code class="language-python">true_b<span class="token punctuation">,</span>b</code></pre>
<pre><code>(4.2, 
 [ 4.20015049]
 &lt;NDArray 1 @cpu(0)&gt;)</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/KNN/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/KNN/" class="post-title-link" itemprop="url">KNN</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-09-10 14:26:36" itemprop="dateCreated datePublished" datetime="2018-09-10T14:26:36+08:00">2018-09-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-18 16:59:41" itemprop="dateModified" datetime="2020-09-18T16:59:41+08:00">2020-09-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习和深度学习</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98%E3%80%8B/" itemprop="url" rel="index"><span itemprop="name">《机器学习实战》</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#coding:utf-8</span>

<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np
<span class="token keyword">import</span> operator</code></pre>
<pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">createDataSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    group<span class="token operator">=</span>np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1.0</span><span class="token punctuation">,</span><span class="token number">1.1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1.0</span><span class="token punctuation">,</span><span class="token number">1.0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0.1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    labels<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">,</span><span class="token string">'A'</span><span class="token punctuation">,</span><span class="token string">'B'</span><span class="token punctuation">,</span><span class="token string">'B'</span><span class="token punctuation">]</span>
    <span class="token keyword">return</span> group<span class="token punctuation">,</span>labels</code></pre>
<pre class=" language-python"><code class="language-python">group<span class="token punctuation">,</span>labels<span class="token operator">=</span>createDataSet<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<pre class=" language-python"><code class="language-python">group<span class="token punctuation">,</span>labels</code></pre>
<pre><code>(array([[1. , 1.1],
        [1. , 1. ],
        [0. , 0. ],
        [0. , 0.1]]), [&#39;A&#39;, &#39;A&#39;, &#39;B&#39;, &#39;B&#39;])</code></pre>
<pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">classify0</span><span class="token punctuation">(</span>inX<span class="token punctuation">,</span>dataSet<span class="token punctuation">,</span>labels<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span>
    dataSetSize<span class="token operator">=</span>dataSet<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># dataSet的行数</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"dataSetSize:"</span><span class="token punctuation">,</span>dataSetSize<span class="token punctuation">)</span>
    diffMat<span class="token operator">=</span>np<span class="token punctuation">.</span>tile<span class="token punctuation">(</span>inX<span class="token punctuation">,</span><span class="token punctuation">(</span>dataSetSize<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-</span>dataSet <span class="token comment" spellcheck="true"># 构造一个和dataSet一样的矩阵，再和dataSet相减</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"diffMat:"</span><span class="token punctuation">,</span>diffMat<span class="token punctuation">)</span>
    sqDiffMat<span class="token operator">=</span>diffMat<span class="token operator">**</span><span class="token number">2</span> <span class="token comment" spellcheck="true"># 矩阵的平方</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"sqDiffMat:"</span><span class="token punctuation">,</span>sqDiffMat<span class="token punctuation">)</span>
    sqDistances<span class="token operator">=</span>sqDiffMat<span class="token punctuation">.</span>sum<span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 按行相加</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"sqDistances:"</span><span class="token punctuation">,</span>sqDistances<span class="token punctuation">)</span>
    distances<span class="token operator">=</span>sqDistances<span class="token operator">**</span><span class="token number">0.5</span> <span class="token comment" spellcheck="true"># 开方，求距离</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"distances:"</span><span class="token punctuation">,</span>distances<span class="token punctuation">)</span>
    sortedDistIndicies<span class="token operator">=</span>distances<span class="token punctuation">.</span>argsort<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 对距离排序</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"sortedDistIndicies:"</span><span class="token punctuation">,</span>sortedDistIndicies<span class="token punctuation">)</span>
    classCount<span class="token operator">=</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;&amp;#125;</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span>
        voteIlabel<span class="token operator">=</span>labels<span class="token punctuation">[</span>sortedDistIndicies<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"voteIlable:"</span><span class="token punctuation">,</span>voteIlabel<span class="token punctuation">)</span>
        classCount<span class="token punctuation">[</span>voteIlabel<span class="token punctuation">]</span><span class="token operator">=</span>classCount<span class="token punctuation">.</span>get<span class="token punctuation">(</span>voteIlabel<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"classCount:"</span><span class="token punctuation">,</span>classCount<span class="token punctuation">)</span>
    sortedClassCount<span class="token operator">=</span>sorted<span class="token punctuation">(</span>classCount<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>key<span class="token operator">=</span>operator<span class="token punctuation">.</span>itemgetter<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>reverse<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>sortedClassCount<span class="token punctuation">)</span>
    <span class="token keyword">return</span> sortedClassCount<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
classify0<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1.0</span><span class="token punctuation">,</span><span class="token number">1.2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>group<span class="token punctuation">,</span>labels<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span></code></pre>
<pre><code>dataSetSize: 4
diffMat: [[0.  0.1]
 [0.  0.2]
 [1.  1.2]
 [1.  1.1]]
sqDiffMat: [[0.   0.01]
 [0.   0.04]
 [1.   1.44]
 [1.   1.21]]
sqDistances: [0.01 0.04 2.44 2.21]
distances: [0.1        0.2        1.56204994 1.48660687]
sortedDistIndicies: [0 1 3 2]
voteIlable: A
classCount: &#123;&#39;A&#39;: 1&#125;
voteIlable: A
classCount: &#123;&#39;A&#39;: 2&#125;
voteIlable: B
classCount: &#123;&#39;A&#39;: 2, &#39;B&#39;: 1&#125;
[(&#39;A&#39;, 2), (&#39;B&#39;, 1)]





&#39;A&#39;</code></pre>
<pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 将文本记录转换为numpy矩阵</span>
<span class="token keyword">def</span> <span class="token function">file2matrix</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token punctuation">:</span>
    fr<span class="token operator">=</span>open<span class="token punctuation">(</span>filename<span class="token punctuation">)</span>

    numberOfLines<span class="token operator">=</span>len<span class="token punctuation">(</span>fr<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    returnMat<span class="token operator">=</span>np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>numberOfLines<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 创建一个和文本一样形式的0矩阵</span>
    classLabelVector<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
    fr<span class="token operator">=</span>open<span class="token punctuation">(</span>filename<span class="token punctuation">)</span>

    index<span class="token operator">=</span><span class="token number">0</span>
    <span class="token keyword">for</span> line <span class="token keyword">in</span> fr<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        line<span class="token operator">=</span>line<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span>
        listFromLine<span class="token operator">=</span>line<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'\t'</span><span class="token punctuation">)</span>
        returnMat<span class="token punctuation">[</span>index<span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">=</span>listFromLine<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span>
        classLabelVector<span class="token punctuation">.</span>append<span class="token punctuation">(</span>int<span class="token punctuation">(</span>listFromLine<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        index<span class="token operator">+=</span><span class="token number">1</span>
    <span class="token keyword">return</span> returnMat<span class="token punctuation">,</span>classLabelVector</code></pre>
<pre class=" language-python"><code class="language-python">datingDataMat<span class="token punctuation">,</span>datingLabels<span class="token operator">=</span>file2matrix<span class="token punctuation">(</span><span class="token string">'datingTestSet2.txt'</span><span class="token punctuation">)</span>
datingDataMat<span class="token punctuation">,</span>datingLabels<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">20</span><span class="token punctuation">]</span></code></pre>
<pre><code>(array([[4.0920000e+04, 8.3269760e+00, 9.5395200e-01],
        [1.4488000e+04, 7.1534690e+00, 1.6739040e+00],
        [2.6052000e+04, 1.4418710e+00, 8.0512400e-01],
        ...,
        [2.6575000e+04, 1.0650102e+01, 8.6662700e-01],
        [4.8111000e+04, 9.1345280e+00, 7.2804500e-01],
        [4.3757000e+04, 7.8826010e+00, 1.3324460e+00]]),
 [3, 2, 1, 1, 1, 1, 3, 3, 1, 3, 1, 1, 2, 1, 1, 1, 1, 1, 2, 3])</code></pre>
<pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 分析数据，使用Matplotlib创建散点图</span>
<span class="token keyword">import</span> matplotlib
<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt
<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np
<span class="token comment" spellcheck="true"># mpl.rcParams['font.sans-serif'] = ['SimHei']  </span>
<span class="token comment" spellcheck="true"># mpl.rcParams['axes.unicode_minus'] = False  </span>
fig<span class="token operator">=</span>plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token punctuation">)</span>
ax<span class="token operator">=</span>fig<span class="token punctuation">.</span>add_subplot<span class="token punctuation">(</span><span class="token number">111</span><span class="token punctuation">)</span>

datingLabels <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>datingLabels<span class="token punctuation">)</span>

idx_1<span class="token operator">=</span>np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>datingLabels<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span>
p1<span class="token operator">=</span>ax<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>datingDataMat<span class="token punctuation">[</span>idx_1<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>datingDataMat<span class="token punctuation">[</span>idx_1<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>color<span class="token operator">=</span><span class="token string">'y'</span><span class="token punctuation">,</span>label<span class="token operator">=</span><span class="token string">'1'</span><span class="token punctuation">,</span>s<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span>
idx_2<span class="token operator">=</span>np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>datingLabels<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span>
p2<span class="token operator">=</span>ax<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>datingDataMat<span class="token punctuation">[</span>idx_2<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>datingDataMat<span class="token punctuation">[</span>idx_2<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>color<span class="token operator">=</span><span class="token string">'g'</span><span class="token punctuation">,</span>label<span class="token operator">=</span><span class="token string">'1'</span><span class="token punctuation">,</span>s<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">)</span>
idx_3<span class="token operator">=</span>np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>datingLabels<span class="token operator">==</span><span class="token number">3</span><span class="token punctuation">)</span>
p3<span class="token operator">=</span>ax<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>datingDataMat<span class="token punctuation">[</span>idx_3<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>datingDataMat<span class="token punctuation">[</span>idx_3<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>color<span class="token operator">=</span><span class="token string">'b'</span><span class="token punctuation">,</span>label<span class="token operator">=</span><span class="token string">'1'</span><span class="token punctuation">,</span>s<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true"># ax.scatter(datingDataMat[:,1],datingDataMat[:,2],15.0*np.array(datingLabels),15.0*np.array(datingLabels),c='yellow')</span>

plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span>u<span class="token string">'每年获取的飞行常客里程数'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span>u<span class="token string">'玩视频游戏所耗时间百分比'</span><span class="token punctuation">)</span>
ax<span class="token punctuation">.</span>legend<span class="token punctuation">(</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span>p2<span class="token punctuation">,</span>p3<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>u<span class="token string">'不喜欢'</span><span class="token punctuation">,</span> u<span class="token string">'魅力一般'</span><span class="token punctuation">,</span> u<span class="token string">'极具魅力'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> loc<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># ax.rc('font',family=['SeiHei'])</span>
<span class="token comment" spellcheck="true">#ax.legend((p1,p2,p3), (u'不喜欢', u'魅力一般', u'极具魅力'), loc=2, prop=zhfont)</span>
plt<span class="token punctuation">.</span>rcParams<span class="token punctuation">[</span><span class="token string">'font.sans-serif'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'SimHei'</span><span class="token punctuation">]</span>
plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<p><img src="/KNN/Untitled_7_0.png" alt="png"></p>
<pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 归一化特征值</span>
<span class="token keyword">def</span> <span class="token function">autoNorm</span><span class="token punctuation">(</span>dataSet<span class="token punctuation">)</span><span class="token punctuation">:</span>
    minVals<span class="token operator">=</span>dataSet<span class="token punctuation">.</span>min<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 3列数据中的3个最小值</span>
    maxVals<span class="token operator">=</span>dataSet<span class="token punctuation">.</span>max<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 3列数据中的3个最大值</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>minVals<span class="token punctuation">)</span>

    ranges<span class="token operator">=</span>maxVals<span class="token operator">-</span>minVals
    normDateSet<span class="token operator">=</span>np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>np<span class="token punctuation">.</span>shape<span class="token punctuation">(</span>dataSet<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>normDateSet<span class="token punctuation">)</span>
    m<span class="token operator">=</span>dataSet<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 行数1000</span>
    normDateSet<span class="token operator">=</span>dataSet<span class="token operator">-</span>np<span class="token punctuation">.</span>tile<span class="token punctuation">(</span>minVals<span class="token punctuation">,</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#dataSet减去同样格式的最小值组成的矩阵</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>normDateSet<span class="token punctuation">)</span>
    normDateSet<span class="token operator">=</span>normDateSet<span class="token operator">/</span>np<span class="token punctuation">.</span>tile<span class="token punctuation">(</span>ranges<span class="token punctuation">,</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> normDateSet<span class="token punctuation">,</span>ranges<span class="token punctuation">,</span>minVals</code></pre>
<p>normMat,ranges,minVals=autoNorm(datingDataMat)</p>
<pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 分类器针对约会网站的测试代码</span>
<span class="token keyword">def</span> <span class="token function">datingClassTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    hoRatio<span class="token operator">=</span><span class="token number">0.5</span>
    datingDataMat<span class="token punctuation">,</span>datingLabels<span class="token operator">=</span>file2matrix<span class="token punctuation">(</span><span class="token string">'datingTestSet2.txt'</span><span class="token punctuation">)</span>
    normMat<span class="token punctuation">,</span>ranges<span class="token punctuation">,</span>minVals<span class="token operator">=</span>autoNorm<span class="token punctuation">(</span>datingDataMat<span class="token punctuation">)</span>
    m<span class="token operator">=</span>normMat<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    numTestVecs<span class="token operator">=</span>int<span class="token punctuation">(</span>m<span class="token operator">*</span>hoRatio<span class="token punctuation">)</span>
    errorCount<span class="token operator">=</span><span class="token number">0.0</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>numTestVecs<span class="token punctuation">)</span><span class="token punctuation">:</span>
        classifierResult<span class="token operator">=</span>classify0<span class="token punctuation">(</span>normDateSet<span class="token punctuation">)</span></code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Lilly</p>
  <div class="site-description" itemprop="description">Up in the wind!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">133</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lilly</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
