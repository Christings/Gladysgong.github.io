<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"gongyanli.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Up in the wind!">
<meta property="og:type" content="website">
<meta property="og:title" content="茉莉Python">
<meta property="og:url" content="http://gongyanli.com/page/7/index.html">
<meta property="og:site_name" content="茉莉Python">
<meta property="og:description" content="Up in the wind!">
<meta property="og:locale">
<meta property="article:author" content="Lilly">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://gongyanli.com/page/7/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>茉莉Python</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">茉莉Python</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">voidqueens@hotmail.com</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/LeetCode-5-%E9%93%BE%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/LeetCode-5-%E9%93%BE%E8%A1%A8/" class="post-title-link" itemprop="url">LeetCode-5-链表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-15 22:01:02" itemprop="dateCreated datePublished" datetime="2020-01-15T22:01:02+08:00">2020-01-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-24 21:30:13" itemprop="dateModified" datetime="2020-09-24T21:30:13+08:00">2020-09-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="五、链表"><a href="#五、链表" class="headerlink" title="五、链表"></a>五、链表</h2><h3 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h3><pre><code>链接：https://leetcode-cn.com/problems/add-two-numbers/

给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。

如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

您可以假设除了数字 0 之外，这两个数都不会以 0 开头。

示例：

输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
输出：7 -&gt; 0 -&gt; 8
原因：342 + 465 = 807</code></pre>
<p>题解一：</p>
<pre><code>class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:
        if not l1:
            return l2
        if not l2:
            return l1
        dummy=res=ListNode(0)
        flag=0

        while l1 or l2:
            sum=0
            if l1:
                sum=l1.val
                l1=l1.next
            if l2:
                sum+=l2.val
                l2=l2.next
            tmp=(sum+flag)%10 # 余数
            flag=(sum+flag)//10 # 进位

            res.next=ListNode(tmp)
            res=res.next

            if flag: # 这里虽然创建了一个节点，但是并没有res=res.next,并没有右移。所以插入8时没有问题。同时case输入为[5]和[5]时，可以得到结果[0,1]，而非[0]
                res.next=ListNode(1)
        return dummy.next</code></pre>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:
        res=dummy=ListNode(-1)
        flag=0
        while l1 and l2:
            res.next=ListNode(l1.val+l2.val+flag)
            flag=res.next.val // 10
            res.next.val %= 10
            res=res.next
            l1=l1.next
            l2=l2.next

        p= l1 or l2
        while p:
            res.next=ListNode(p.val+flag)
            flag=res.next.val // 10
            res.next.val %= 10
            p=p.next
            res=res.next
        if flag:
            res.next=ListNode(1)
        return dummy.next</code></pre>
<h3 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19. 删除链表的倒数第N个节点"></a>19. 删除链表的倒数第N个节点</h3><pre><code>链接：https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/

给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。

示例：

给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.
说明：

给定的 n 保证是有效的。

进阶：你能尝试使用一趟扫描实现吗？</code></pre>
<p>题解一|两次遍历：</p>
<p>分析：<br>    删除从列表开头数起的第 (L−n+1) 个结点，其中 L 是列表的长度。只要我们找到列表的长度 L，这个问题就很容易解决。</p>
<pre><code>在第一次遍历中，我们找出列表的长度 L。
设置一个指向哑结点的指针，并移动它遍历列表，直至它到达第 (L−n) 个结点那里。我们把第 (L−n) 个结点的 next 指针重新链接至第 (L−n+2) 个结点，完成这个算法。</code></pre>
<p>时间复杂度：O(L)，该算法对列表进行了两次遍历，首先计算了列表的长度 L 其次找到第 (L−n) 个结点。 操作执行了 2L-n 步，时间复杂度为 O(L)。</p>
<p>空间复杂度：O(1)，我们只用了常量级的额外空间。</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode:
        dummy=ListNode(-1)
        dummy.next=head # 注意case:[1]和1
        p=dummy
        length=0
        while p:
            p=p.next
            length+=1 # 注意：这里length=6，而不是5，因为有一个头节点。
        length-=(n+1)
        p=dummy
        while length&gt;0:
            p=p.next
            length-=1
        p.next=p.next.next
        return dummy.next</code></pre>
<p>题解二|一次遍历：</p>
<p>分析：<br>    第一个指针从列表的开头向前移动 n+1 步，而第二个指针将从列表的开头出发。</p>
<pre><code>通过同时移动两个指针向前来保持这个恒定的间隔，直到第一个指针到达最后一个结点。

此时第二个指针将指向从最后一个结点数起的第 n 个结点。我们重新链接第二个指针所引用的结点的 next 指针指向该结点的下下个结点。</code></pre>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode:
        dummy=ListNode(-1)
        dummy.next=head # 如果dummy=head,case为[1],1不能通过。
        fast=slow=dummy
        while fast and n:
            fast=fast.next
            n-=1
        while fast.next and slow.next: # 注意不是while fast and slow：
            fast=fast.next
            slow=slow.next

        # print( fast.val,slow.val)
        slow.next=slow.next.next
        return dummy.next</code></pre>
<h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a>21. 合并两个有序链表</h3><pre><code>链接：https://leetcode-cn.com/problems/merge-two-sorted-lists/

将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

示例：

输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4
输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</code></pre>
<p>题解一：</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode:
        # if not l1:
        #     return l2
        # if not l2:
        #     return l1
        head=dummy=ListNode(-1)
        while l1 and l2:
            if l1.val &lt; l2.val:
                head.next=l1
                l1=l1.next
            else:
                head.next=l2
                l2=l2.next
            head=head.next
        if l1:
            head.next=l1
        if l2:
            head.next=l2
        return dummy.next</code></pre>
<h3 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h3><pre><code>链接：https://leetcode-cn.com/problems/swap-nodes-in-pairs/

给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

示例:

给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</code></pre>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/dong-hua-yan-shi-24-liang-liang-jiao-huan-lian-bia/">https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/dong-hua-yan-shi-24-liang-liang-jiao-huan-lian-bia/</a></p>
<p>题解一|递归：<br>分析：</p>
<pre><code>从链表的头节点 head 开始递归。
每次递归都负责交换一对节点。由 firstNode 和 secondNode 表示要交换的两个节点。
下一次递归则是传递的是下一对需要交换的节点。若链表中还有节点，则继续递归。
交换了两个节点以后，返回 secondNode，因为它是交换后的新头。
在所有节点交换完成以后，我们返回交换后的头，实际上是原始链表的第二个节点。</code></pre>
<p>时间复杂度：O(N)，其中 N 指的是链表的节点数量。<br>空间复杂度：O(N)，递归过程使用的堆栈空间。</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def swapPairs(self, head: ListNode) -&gt; ListNode:
        if not head or not head.next:
            return head

        first=head
        second=head.next

        # swap
        first.next=self.swapPairs(second.next)
        second.next=first

        return second</code></pre>
<p>题解二|迭代：</p>
<p>我们把链表分为两部分，即奇数节点为一部分，偶数节点为一部分，A 指的是交换节点中的前面的节点，B 指的是要交换节点中的后面的节点。在完成它们的交换，我们还得用 prevNode 记录 A 的前驱节点。</p>
<p>思路：</p>
<pre><code>1、firstNode（即 A） 和 secondNode（即 B） 分别遍历偶数节点和奇数节点，即两步看作一步。

2、交换两个节点：
    firstNode.next = secondNode.next
    secondNode.next = firstNode

3、还需要更新 prevNode.next 指向交换后的头。
    prevNode.next = secondNode

4、迭代完成后得到最终的交换结果。</code></pre>
<p>时间复杂度：O(N)，其中 N 指的是链表的节点数量。<br>空间复杂度：O(1)。</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def swapPairs(self, head: ListNode) -&gt; ListNode:
        dummy=ListNode(-1)
        dummy.next=head
        pre=dummy

        while head and head.next:
            first=head
            second=head.next

            # swap
            pre.next=second
            first.next=second.next
            second.next=first

            # Reinitializing the head and prev_node for next swap
            pre=first # 通过pre来构成新的链表
            # print(pre.val)
            head=first.next

        return dummy.next</code></pre>
<h3 id="61-旋转链表"><a href="#61-旋转链表" class="headerlink" title="61. 旋转链表"></a>61. 旋转链表</h3><pre><code>链接：https://leetcode-cn.com/problems/rotate-list/

给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。

示例 1:

输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2
输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL
解释:
向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL
向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL
示例 2:

输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4
输出: 2-&gt;0-&gt;1-&gt;NULL
解释:
向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL
向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL
向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL
向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL</code></pre>
<p>题解一|暴力法：</p>
<p>分析：</p>
<pre><code>首先遍历获得链表的长度以及链表尾部的指针（引用）；
之后头尾拼接起来；
随后我们只要从头遍历k - k % length步就能够找到旋转后链表的头指针，断开尾指针和头指针，返回头指针。</code></pre>
<p>关键点就是k，如果移动一次就相当于将倒数第一个元素1移到链表开头，如果移动两次就相当于将倒数第二和倒数第一个元素2和1移动到链表开头。</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode1.jpg" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode1.jpg"></p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode2.jpg" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode2.jpg"></p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode3.jpg" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode3.jpg"></p>
<pre><code>class Solution:
    def rotateRight(self, head: ListNode, k: int) -&gt; ListNode:
        if not head:
            return None
        cur=head
        length=1
        while cur.next:
            cur=cur.next
            length+=1
        cur.next=head # 头尾拼接
        k=length-k%length                                          
        while k:
            k-=1
            cur=cur.next
        head=cur.next # 找到头指针
        cur.next=None  # 断开尾节点             
        return head</code></pre>
<h3 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="82.删除排序链表中的重复元素 II"></a>82.删除排序链表中的重复元素 II</h3><pre><code>链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/

给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。

示例 1:

输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5
输出: 1-&gt;2-&gt;5
示例 2:

输入: 1-&gt;1-&gt;1-&gt;2-&gt;3
输出: 2-&gt;3</code></pre>
<p>题解一：</p>
<p>思路：</p>
<p>建立哑结点dummy，当前处理节点为curr，它的值为anchor，它的前序节点为prev。</p>
<p>如果curr的后序节点的值等于anchor，那么标注flag为True，curr一直后移下去，总之，curr移到连续的最后一个值为anchor的节点，停下来。如果经历了上述步骤，那么prev和curr.next相连，prev按兵不动，curr后移一位；如果没有经历，curr的值是独一无二的，那么prev和curr同时右移一位。继续循环直到curr移到最后一位。</p>
<p>时间复杂度: O(n), 空间复杂度: O(1)</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:
        dummy=ListNode(-1)
        dummy.next=head
        pre,curr=dummy,head

        while curr:
            anchor=curr.val
            flag=False
            while curr.next:
                if curr.next.val == anchor:
                    curr=curr.next
                    flag=True
                else:
                    break
            if flag:
                pre.next=curr.next # pre并未向前移动
            else:
                pre=curr
            curr=curr.next
        return dummy.next</code></pre>
<p>题解二|快慢指针：</p>
<pre><code>1. fast 遍历链表,让fast 去嗅探不相等元素
2. slow.next == fast --&gt; slow 与 fast 之间没有重复元素，slow 动。
3. slow.next != fast --&gt; slow 与 fast 之间存在重复元素，让slow指向的元素跳过这些重复元素，slow 不动。</code></pre>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:
        dummy=ListNode(-1)
        dummy.next=head
        slow=dummy
        fast=head

        while fast and fast.next:
            if fast.val != fast.next.val:
                if slow.next == fast: # 注意此处判断的是内存地址，而非节点的值
                    slow=fast
                    # print(&#39;111&#39;,slow)
                else:
                    # print(&#39;222&#39;,fast.next)
                    slow.next=fast.next # slow并未向前移动
            fast=fast.next
        if slow.next != fast: # 解决case:[1,1]
            slow.next=fast.next
        return dummy.next</code></pre>
<pre><code>class Solution:
    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:
        if head == None or head.next == None:
            return head
        dummy = ListNode(-1000)
        dummy.next = head
        slow = dummy
        fast = dummy.next
        while fast:
            if  fast.next and fast.next.val == fast.val:
                tmp = fast.val
                while fast and tmp == fast.val:
                    fast = fast.next
            else:
                slow.next = fast
                slow = fast
                fast = fast.next
        slow.next = fast
        return dummy.next</code></pre>
<pre><code>class Solution:
    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:
        if head == None or head.next == None:
            return head
        dummy = ListNode(-1)
        dummy.next = head
        slow = dummy
        fast = dummy.next
        while fast:
            while fast.next and slow.next.val == fast.next.val:
                fast = fast.next
            if slow.next == fast:
                slow = fast
            else:
                slow.next = fast.next
            fast = fast.next
        return dummy.next</code></pre>
<p>题解三|递归：</p>
<pre><code>class Solution:
    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:
        if not head:
            return head
        if head.next and head.val == head.next.val:
            while head.next and head.val == head.next.val:
                head=head.next
            return self.deleteDuplicates(head.next)
        else:
            head.next=self.deleteDuplicates(head.next) 
        return head</code></pre>
<h3 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a>83. 删除排序链表中的重复元素</h3><pre><code>链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/

给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。

示例 1:

输入: 1-&gt;1-&gt;2
输出: 1-&gt;2
示例 2:

输入: 1-&gt;1-&gt;2-&gt;3-&gt;3
输出: 1-&gt;2-&gt;3</code></pre>
<p>思路：因为是排序列表，通过将结点的值与它之后的结点进行比较来确定它是否为重复结点。如果它是重复的，我们更改当前结点的 next 指针，以便它跳过下一个结点并直接指向下一个结点之后的结点。</p>
<p>时间复杂度：O(n)，因为列表中的每个结点都检查一次以确定它是否重复，所以总运行时间为 O(n)，其中 n 是列表中的结点数。<br>空间复杂度：O(1)，没有使用额外的空间。</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:
        dummy=ListNode(-1)
        dummy.next=head
        while head and head.next:
            if head.val == head.next.val:
                head.next=head.next.next
            else:
                head=head.next
        return dummy.next</code></pre>
<pre><code>class Solution:
    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:
        dummy=head
        while head and head.next:
            if head.val == head.next.val:
                head.next=head.next.next
            else:
                head=head.next
        return dummy</code></pre>
<h3 id="86-分隔链表"><a href="#86-分隔链表" class="headerlink" title="86. 分隔链表"></a>86. 分隔链表</h3><pre><code>链接：https://leetcode-cn.com/problems/partition-list/

给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。

你应当保留两个分区中每个节点的初始相对位置。

示例:

输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3
输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</code></pre>
<p>分析：</p>
<pre><code>哈哈，差点没看懂题。</code></pre>
<p>这道题要求我们划分链表，把所有小于给定值的节点都移到前面，大于该值的节点顺序不变，相当于一个局部排序的问题。那么可以想到的一种解法是首先找到第一个大于或等于给定值的节点，用题目中给的例子来说就是先找到4，然后再找小于3的值，每找到一个就将其取出置于4之前即可</p>
<p>题解一|双指针法：</p>
<p>用两个指针before 和 after 来追踪上述的两个链表。两个指针可以用于分别创建两个链表，然后将这两个链表连接即可获得所需的链表。</p>
<p>时间复杂度: O(N)，其中N是原链表的长度，我们对该链表进行了遍历。<br>空间复杂度: O(1)，我们没有申请任何新空间。值得注意的是，我们只移动了原有的结点，因此没有使用任何额外空间。</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def partition(self, head: ListNode, x: int) -&gt; ListNode:
        before=bf=ListNode(-1)
        after=af=ListNode(-1)

        while head:
            if head.val &lt; x:
                before.next=head
                before=before.next
            else:
                after.next=head
                after=after.next
            head=head.next

        after.next=None
        before.next=af.next
        return bf.next</code></pre>
<h3 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a>92. 反转链表 II</h3><pre><code>链接：https://leetcode-cn.com/problems/reverse-linked-list-ii/

反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。

说明:
1 ≤ m ≤ n ≤ 链表长度。

示例:

输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4
输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</code></pre>
<p>题解一|迭代：</p>
<p>时间复杂度: O(N)。考虑包含 N 个结点的链表。对每个节点最多会处理<br>（第 n 个结点之后的结点不处理）。</p>
<p>空间复杂度: O(1)。我们仅仅在原有链表的基础上调整了一些指针，只使用了 O(1)的额外存储空间来获得结果。</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reverseBetween(self, head: ListNode, m: int, n: int) -&gt; ListNode:
        if not head:
            return None
        prev,cur=None,head
        while m&gt;1:
            prev=cur
            cur=cur.next
            m,n=m-1,n-1
        # print(cur.val,prev.val)
        # tail 指针指向从链表头起的第m个结点，此结点是反转后链表的尾部，故称为 tail。
        # con 指针指向第 m 个结点的前一个结点，此结点是新链表的头部。
        con,tail=prev,cur
        while n:
            next=cur.next
            cur.next=prev
            prev=cur
            cur=next
            n-=1
        if con:
            con.next=prev # 头节点链接反转后链表的头节点
        else:
            # head.next=prev
            head=prev
        tail.next=cur # 反转后的链表链接尾节点
        return head</code></pre>
<h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141.环形链表"></a>141.环形链表</h3><pre><code>链表：https://leetcode-cn.com/problems/linked-list-cycle

给定一个链表，判断链表中是否有环。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。

示例 1：

输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。


示例 2：

输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。


示例 3：

输入：head = [1], pos = -1
输出：false
解释：链表中没有环。

进阶：你能用 O(1)（即，常量）内存解决此问题吗？</code></pre>
<p>题解一|hash:</p>
<pre><code>时间复杂度：O(n)，对于含有 n个元素的链表，我们访问每个元素最多一次。添加一个结点到哈希表中只需要花费 O(1) 的时间。

空间复杂度：O(n)，空间取决于添加到哈希表中的元素数目，最多可以添加 n 个元素。</code></pre>
<pre><code>class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

class Solution:
    def hasCycle(self, head: ListNode) -&gt; bool:
        hash=&#123;&#125;
        while head :
            if head not in hash:
                hash[head]=0
                head=head.next
            else:
                return True
        return False</code></pre>
<p>题解二|快慢指针:</p>
<pre><code>class Solution:
    def hasCycle(self, head: ListNode) -&gt; bool:
        if not head or not head.next: 
            return False
        i,j=head,head.next
        while j and j.next: # 如果没有j.next，无法通过case ([1,2] -1).
            if i==j:
                return True
            i,j=i.next,j.next.next
        return False</code></pre>
<pre><code>class Solution:
    def hasCycle(self, head: ListNode) -&gt; bool:
        slow=fast=head
        while fast and fast.next: # 如果没有fast.next，无法通过case ([1] -1).
            fast=fast.next.next
            slow=slow.next
            # print(fast.val,slow.val)
            if fast == slow:
                # print(fast.val)
                return True # 返回True的节点并不一定就是环的入口节点。
        return False</code></pre>
<h3 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142.环形链表 II"></a>142.环形链表 II</h3><pre><code>链接：https://leetcode-cn.com/problems/linked-list-cycle-ii/

给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。

说明：不允许修改给定的链表。

示例 1：

输入：head = [3,2,0,-4], pos = 1
输出：tail connects to node index 1
解释：链表中有一个环，其尾部连接到第二个节点。

示例 2：

输入：head = [1,2], pos = 0
输出：tail connects to node index 0
解释：链表中有一个环，其尾部连接到第一个节点。


示例 3：

输入：head = [1], pos = -1
输出：no cycle
解释：链表中没有环。

进阶：你是否可以不用额外空间解决此题？</code></pre>
<p>题解一|hash：</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def detectCycle(self, head: ListNode) -&gt; ListNode:
        hash=&#123;&#125;
        while head:
            if head not in hash:
                hash[head]=0
                head=head.next
            else:
                return head
        return None</code></pre>
<p>题解二|快慢指针:</p>
<pre><code>class Solution:
    def detectCycle(self, head: ListNode) -&gt; ListNode:
        if not head or not head.next:
            return None
        slow,fast=head,head
        while fast and fast.next:
            slow=slow.next
            fast=fast.next.next
            if slow == fast:
                slow=head
                while slow != fast:
                    slow=slow.next
                    fast=fast.next
                return slow
        return None</code></pre>
<h3 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143. 重排链表"></a>143. 重排链表</h3><pre><code>链接：https://leetcode-cn.com/problems/reorder-list

给定一个单链表 L：L0→L1→…→Ln-1→Ln ，
将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

示例 1:

给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.
示例 2:

给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3.</code></pre>
<p>题解一|反转链表:</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode4.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode4.png"></p>
<p>思路：</p>
<pre><code>找中点
翻转中点之后的链表
依次拼接</code></pre>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reorderList(self, head: ListNode) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify head in-place instead.
        &quot;&quot;&quot;
        # 1、找中点, 偶数个时找上界
        if not head or not head.next:
            return head
        slow,fast=head,head
        while fast and fast.next:
            slow=slow.next
            fast=fast.next.next
        mid=slow        
        # 2、翻转中点之后的链表,采用是pre, slow双指针方法
        pre=None
        while slow:
            next=slow.next
            slow.next=pre
            pre=slow
            slow=next
        # 3、翻转链表和前面链表拼接
        p1=head # 链表头
        p2=pre # 翻转头

        # print(mid.val,p2.val)
        while p2 != mid:
            next1,next2=p1.next,p2.next
            p1.next=p2               
            p2.next=next1
            p1,p2=next1,next2
        return head</code></pre>
<p>题解二|栈：</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reorderList(self, head: ListNode) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify head in-place instead.
        &quot;&quot;&quot;
        if not head:
            return head
        dummy=head
        stack=[]
        while dummy:
            stack.append(dummy)
            dummy=dummy.next
        n=len(stack)
        mid=(n-1)//2

        dummy=head
        while mid:
            tmp=stack.pop() # 弹出链表最后一个节点
            tmp.next=dummy.next
            dummy.next=tmp
            dummy=tmp.next # 移动2个位置，使用dummy=dummy.next.next也可以。
            mid-=1
        stack.pop().next=None
        return head</code></pre>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reorderList(self, head: ListNode) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify head in-place instead.
        &quot;&quot;&quot;
        if not head:
            return head
        fast,slow=head,head
        stack=[]
        while fast.next and fast.next.next:
            fast=fast.next.next
            slow=slow.next
        while slow.next:
            stack.append(slow.next)
            slow.next=slow.next.next
        dummy=head
        while stack:
            tmp=stack.pop()
            tmp.next=dummy.next
            dummy.next=tmp
            dummy=dummy.next.next
        return head</code></pre>
<h3 id="147-对链表进行插入排序"><a href="#147-对链表进行插入排序" class="headerlink" title="147. 对链表进行插入排序"></a>147. 对链表进行插入排序</h3><pre><code>链接：https://leetcode-cn.com/problems/insertion-sort-list

对链表进行插入排序。


插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。
每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。


插入排序算法：

插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。
每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。
重复直到所有输入数据插入完为止。
 

示例 1：

输入: 4-&gt;2-&gt;1-&gt;3
输出: 1-&gt;2-&gt;3-&gt;4
示例 2：

输入: -1-&gt;5-&gt;3-&gt;4-&gt;0
输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</code></pre>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_17550379/article/details/80708238">https://blog.csdn.net/qq_17550379/article/details/80708238</a></p>
<p>数组的插入排序：</p>
<pre><code>def insertSort(lists):
    count=len(lists)
    for i in range(1,count):
        key=lists[i]
        j=i-1
        while j&gt;=0:
            if lists[j]&gt;key:
                lists[j+1]=lists[j]
                lists[j]=key
            j-=1
    return lists</code></pre>
<p>题解一：</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def insertionSortList(self, head: ListNode) -&gt; ListNode:
        if not head or not head.next:
            return head
        cur,nxt=head,head.next
        dummy=ListNode(float(&#39;-inf&#39;))
        dummy.next=head

        while nxt:
            if nxt.val &gt;= cur.val:
                cur=cur.next
                nxt=nxt.next
            else:
                cur.next=nxt.next # 断链

                pre1,pre2=dummy,dummy.next # 寻找插入位置
                while nxt.val &gt; pre2.val:
                    pre1=pre2
                    pre2=pre2.next

                pre1.next=nxt
                nxt.next=pre2

                nxt=cur.next # 再从第一个值开始循环
        return dummy.next</code></pre>
<p>题解二：</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def insertionSortList(self, head: ListNode) -&gt; ListNode:
        if head == None or head.next == None:
            return head

        dummy = ListNode(-1)
        dummy.next = head
        pre = dummy
        cur = head
        while cur:
            lat = cur.next
            if lat and lat.val &lt; cur.val:  # 只有cur.next比cur小的时候我们才寻找插入点
                while pre.next and pre.next.val &lt; lat.val:
                    pre = pre.next
                tmp = pre.next
                pre.next = lat
                cur.next = lat.next
                lat.next = tmp
                pre = dummy
            else:
                cur = lat

        return dummy.next</code></pre>
<p>？题解三：</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def insertionSortList(self, head: ListNode) -&gt; ListNode:
        p=dummy=ListNode(-1)
        curr=dummy.next=head
        while curr and curr.next:
            val = curr.next.val
            if curr.val &lt; val:
                curr=curr.next
                continue
            if p.next.val &gt; val:
                p=dummy
            while p.next.val &lt; val:
                p=p.next
            new=curr.next
            curr.next=new.next
            new.next=p.next
            p.next=new
        return dummy.next</code></pre>
<h3 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a>160. 相交链表</h3><pre><code>链接：https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</code></pre>
<p>题解一|暴力:</p>
<p>对链表A中的每一个结点 ai，遍历整个链表 B 并检查链表 B 中是否存在结点和 a<br>i相同。</p>
<p>时间复杂度 : (mn)<br>空间复杂度 : O(1)</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode:
        p,q=headA,headB
        while p:
            while q:
                if p == q:
                    return q
            q=q.next
        p=p.next
        return None</code></pre>
<p>题解二|hash：</p>
<p>分析：</p>
<pre><code>遍历链表 A 并将每个结点的地址/引用存储在哈希表中。然后检查链表 B 中的每一个结点 bi 是否在哈希表中。若在，则 bi为相交结点。</code></pre>
<p>时间复杂度 : O(m+n)。<br>空间复杂度 : O(m) 或 O(n)。</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode:
        p,q=headA,headB
        hash=&#123;&#125;
        while p:
            if p not in hash:
                hash[p]=1
            p=p.next
        while q:
            if q in hash:
                return q
            q=q.next</code></pre>
<p>题解三|双指针：</p>
<p>分析：<br>    两个指针分别从链表头开始扫描，每次分别走一步<br>    若指针走到null，则从另一个链表头部开始走<br>    两指针相同时:<br>        (利用此时两个指针移动步数一致)<br>        指针不为null：指针位置为相遇点<br>        指针为null：两个链表不相交</p>
<pre><code>创建两个指针 pA 和 pB，分别初始化为链表 A 和 B 的头结点。然后让它们向后逐结点遍历。

当 pA 到达链表的尾部时，将它重定位到链表 B 的头结点 (你没看错，就是链表 B); 类似的，当 pB 到达链表的尾部时，将它重定位到链表 A 的头结点。

若在某一时刻 pA 和 pB 相遇，则 pA/pB 为相交结点。

想弄清楚为什么这样可行, 可以考虑以下两个链表: A=&#123;1,3,5,7,9,11&#125; 和 B=&#123;2,4,9,11&#125;，相交于结点 9。 由于 B.length (=4) &lt; A.length (=6)，pB 比 pA少经过 2 个结点，会先到达尾部。将 pB 重定向到 A 的头结点，pA 重定向到 B 的头结点后，pB 要比 pA 多走 2 个结点。因此，它们会同时到达交点。

如果两个链表存在相交，它们末尾的结点必然相同。因此当 pA/pB 到达链表结尾时，记录下链表 A/B 对应的元素。若最后元素不相同，则两个链表不相交。</code></pre>
<p>时间复杂度 : O(m+n)<br>空间复杂度 : O(1)</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode:
        p,q=headA,headB
        while p != q:
            if p:
                p=p.next
            else:
                p=headB
            if q:
                q=q.next
            else:
                q=headA
        return p</code></pre>
<h3 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a>203. 移除链表元素</h3><pre><code>链接：https://leetcode-cn.com/problems/remove-linked-list-elements/

删除链表中等于给定值 val 的所有节点。

示例:

输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6
输出: 1-&gt;2-&gt;3-&gt;4-&gt;5</code></pre>
<p>题解一|删除头结点时另做考虑：</p>
<p>思路：删除头结点时另做考虑，由于头结点没有前一个结点。</p>
<pre><code>class Solution:
    def removeElements(self, head: ListNode, val: int) -&gt; ListNode:
        if not head:
            return head
        # 如果不对头结点单独考虑，无法解决case：[1]和1
        while head and head.val == val:
            head=head.next
        dummy=head
        while head and head.next:
            if head.next.val == val:
                # print(val)
                # head=head.next.next
                head.next=head.next.next
            else:
                head=head.next
        return dummy</code></pre>
<p>题解二：</p>
<pre><code>时间复杂度：O(N)，只遍历了一次
空间复杂度：O(1)

class Solution:
    def removeElements(self, head: ListNode, val: int) -&gt; ListNode:
        dummy=ListNode(0)
        dummy.next=head

        pre,curr=dummy,head
        # print(pre.val,curr.val) 0和1
        while curr:
            if curr.val == val:
                pre.next=curr.next
            else:
                pre=curr
            curr=curr.next

        return dummy.next</code></pre>
<pre><code>class Solution:
    def removeElements(self, head: ListNode, val: int) -&gt; ListNode:
        dummy=ListNode(0)
        dummy.next=head
        pre=dummy
        while pre.next:
            if pre.next.val == val:
                pre.next=pre.next.next
            else:
                pre=pre.next

        return dummy.next</code></pre>
<p>题解三|递归：</p>
<pre><code>class Solution:
    def removeElements(self, head: ListNode, val: int) -&gt; ListNode:
        if not head:
            return head
        head.next=self.removeElements(head.next,val) # 不能移动到代码最后        
        if head.val==val:
            return head.next
        else:
            return head</code></pre>
<h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h3><pre><code>链接：https://leetcode-cn.com/problems/reverse-linked-list/

反转一个单链表。

示例:

输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL
进阶:
你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</code></pre>
<p>参考：<br>    <a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-linked-list/solution/">https://leetcode.com/problems/reverse-linked-list/solution/</a><br>     <a target="_blank" rel="noopener" href="http://baijiahao.baidu.com/s?id=1574261186522385&wfr=spider&for=pc">http://baijiahao.baidu.com/s?id=1574261186522385&amp;wfr=spider&amp;for=pc</a><br>     <a target="_blank" rel="noopener" href="https://blog.csdn.net/autumn20080101/article/details/7607148">https://blog.csdn.net/autumn20080101/article/details/7607148</a><br>     <a target="_blank" rel="noopener" href="https://www.cnblogs.com/scud001/p/4423324.html">https://www.cnblogs.com/scud001/p/4423324.html</a></p>
<pre><code>初始状态，prev是NULL，head指向当前的头节点A，next指向A节点的下一个节点B。
首先从A节点开始逆序，将A节点的next指针指向prev，因为prev的当前值是NULL，所以A节点就从链表中脱离出来了，然后移动
head和next指针，使它们分别指向B节点和B的下一个节点C（因为当前的next已经指向B节点了，因此修改A节点的next指针不会
导致链表丢失）。逆向节点A之后，链表的状态如图（2）所示：

 从图（1）的初始状态到图（2）状态共做了四个操作，这四个操作的伪代码如下：

head-&gt;next = prev;

prev = head;

head = next;

next = head-&gt;next;

这四行伪代码就是循环算法的迭代体了，现在用这个迭代体对图（2）的状态再进行一轮迭代，就得到了图（3）的状态：

那么循环终止条件呢？现在对图（3）的状态再迭代一次得到图（4）的状态：

此时可以看出，在图（4）的基础上再进行一次迭代就可以完成链表的逆序，因此循环迭代的终止条件就是当前的head指针是NULL。

现在来总结一下，循环的初始条件是：

prev = NULL;

循环迭代体是：

//在头节点改变之前，先获取下一个节点的指针
next = head-&gt;Next;
//头节点的下一个节点要改成它的上一个节点，是一个逆转的过程
head-&gt;Next = prev;
//上一个节点前移指向头节点
prev = head;
//头节点前移指向下一个节点
head = next;

循环终止条件是：

head == NULL</code></pre>
<p><img src="http://p2lakvkq0.bkt.clouddn.com/linkedlist.jpg"></p>
<p>题解一|指针迭代：</p>
<p>反转一个节点的时候，把一个节点的后驱改为指向它前驱就可以了。这里需要注意的点就是，当你把当前节点的后驱指向前驱的时候，这个时候链表会被截断，也就是说后面的节点和当前节点分开了，所以我们需要一个变量来保存当前节点的后驱，以访丢失。</p>
<p>第一个指针叫 pre，最初是指向 null 的。<br>第二个指针 cur 指向 head，然后不断遍历 cur。<br>每次迭代到 cur，都将 cur 的 next 指向 pre，然后 pre 和 cur 前进一位。<br>都迭代完了(cur 变成 null 了)，pre 就是最后一个节点了。</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode5.JPG" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode5.JPG"></p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/baidu_31657889/article/details/91552141">https://blog.csdn.net/baidu_31657889/article/details/91552141</a></p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reverseList(self, head):
        &quot;&quot;&quot;
        :type head: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        prve = None
        while head:
            next = head.next # 记录当前节点的下一个节点
            head.next = prve # 将当前节点指向pre
            prve = head # pre节点和head节点前进一位
            head = next
        return prve</code></pre>
<pre><code>class Solution:
    def reverseList(self, head: ListNode) -&gt; ListNode:
        pre=None
        while head:
            pre, pre.next, head = head, pre, head.next
        return pre</code></pre>
<p>???题解二|递归:</p>
<p>递归的两个条件：</p>
<pre><code>终止条件是当前节点或者下一个节点==null
在函数内部，改变节点的指向，也就是 head 的下一个节点指向 head 递归函数那句

很不好理解，其实就是 head 的下一个节点指向head。</code></pre>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reverseList(self, head: ListNode) -&gt; ListNode:
        if head is None or head.next is None:  
            return head  # 递归终止条件是当前为空，或者下一个节点为空
        cur=self.reverseList(head.next) # cur是最后一个节点5
        head.next.next=head 
        head.next=None
        return cur
</code></pre>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reverseList(self, head: ListNode) -&gt; ListNode:
        def helper(head):
            if head is None or head.next is None:
                return head,head
            pre,last=helper(head.next)
            last.next=head
            head.next=None
            return pre,head
        res,_=helper(head)
        return res,_</code></pre>
<p>问题扩展：部分节点进行反转</p>
<h3 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234.回文链表"></a>234.回文链表</h3><pre><code>链接：https://leetcode-cn.com/problems/palindrome-linked-list/

请判断一个链表是否为回文链表。

示例 1:

输入: 1-&gt;2
输出: false
示例 2:

输入: 1-&gt;2-&gt;2-&gt;1
输出: true
进阶：
你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</code></pre>
<p>数组列表底层是使用数组存储值，我们可以通过索引在 O(1)的时间访问列表任何位置的值，这是由于内存寻址的方式。</p>
<p>链表存储的是称为节点的对象，每个节点保存一个值和指向下一个节点的指针。访问某个特定索引的节点需要 O(n) 的时间，因为要通过指针获取到下一个位置的节点。</p>
<p>题解一|数组：</p>
<p>分析：</p>
<p>确定数组列表是否为回文很简单，我们可以使用双指针法来比较两端的元素，并向中间移动。一个指针从起点向中间移动，另一个指针从终点向中间移动。这需要 O(n)的时间，因为访问每个元素的时间是 O(1)，而有 n 个元素要访问。</p>
<p>然后，直接在链表上操作并不简单，因为不论是正向访问还是反向访问都不是 O(1)。而将链表的值复制到数组列表中是 O(n)，因此最简单的方法就是将链表的值复制到数组列表中，再使用双指针法判断。</p>
<p>算法：</p>
<pre><code>复制链表值到数组列表中。
使用双指针法判断是否为回文。</code></pre>
<p>第一步，我们需要遍历链表将值复制到数组列表中。我们用 currentNode 指向当前节点。每次迭代向数组添加 currentNode.val，并更新 currentNode = currentNode.next，当 currentNode = null 则停止循环。</p>
<p>执行第二部的最佳方法取决于你使用的编程语言。在 Python 中，很容易构造一个列表的反向副本，也很容易比较两个列表。在其他语言中，就没有那么简单。因此最好使用双指针法来检查是否为回文。我们在起点放置一个指针，在结尾放置一个指针，每一次迭代判断两个指针指向的元素是否相同，若不同，返回 false；相同则将两个指针向内移动，并继续判断，直到相遇。</p>
<p>在编码的过程中，注意我们比较的是节点值的大小，而不是节点本身。正确的比较方式是：node_1.val==node_2.val，node_1==node_2 是错误的。</p>
<p>复杂度：</p>
<p>时间复杂度：O(n)，其中 n 指的是链表的元素个数。</p>
<pre><code>第一步： 遍历链表并将值复制到数组中，O(n)。
第二步：双指针判断是否为回文，执行了 O(n/2) 次的判断，即 O(n)。
总的时间复杂度：O(2n) = O(n)</code></pre>
<p>空间复杂度：O(n)，其中 n 指的是链表的元素个数，我们使用了一个数组列表存放链表的元素值。</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def isPalindrome(self, head: ListNode) -&gt; bool:
        arr=[]
        while head:
            arr.append(head.val)
            head=head.next
        return arr==arr[::-1]</code></pre>
<p>快慢指针：</p>
<pre><code>        l = 0
        r = len(tmp)-1
        while l&lt;r:
            if tmp[l] != tmp[r]:
                return False
            l += 1
            r -= 1
        return True</code></pre>
<p>题解二|快慢指针+反转链表：</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def isPalindrome(self, head: ListNode) -&gt; bool:
        def reverseList(head):
            pre=None
            while head:
                next=head.next
                head.next=pre
                pre=head
                head=next
            return pre

        # 快慢指针，快指针到达尾部，慢指针到达中间
        slow=fast=head
        while fast and fast.next:
            slow=slow.next
            fast=fast.next.next

        newHead=reverseList(slow)
        p1=head
        p2=newHead
        while p1 and p2:
            if p1.val != p2.val:
                return False
            p1=p1.next
            p2=p2.next
        return True</code></pre>
<h3 id="237-删除链表中的节点"><a href="#237-删除链表中的节点" class="headerlink" title="237.删除链表中的节点"></a>237.删除链表中的节点</h3><pre><code>链接：https://leetcode-cn.com/problems/delete-node-in-a-linked-list/

请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。

现有一个链表 -- head = [4,5,1,9]，它可以表示为:

示例 1:

输入: head = [4,5,1,9], node = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.
示例 2:

输入: head = [4,5,1,9], node = 1
输出: [4,5,9]
解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.
 

说明:

链表至少包含两个节点。
链表中所有节点的值都是唯一的。
给定的节点为非末尾节点并且一定是链表中的一个有效节点。
不要从你的函数中返回任何结果。</code></pre>
<p>题解一：<br>时间复杂度 O(1)<br>空间复杂度 O(1)</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def deleteNode(self, node):
        &quot;&quot;&quot;
        :type node: ListNode
        :rtype: void Do not return anything, modify node in-place instead.
        &quot;&quot;&quot;
        node.val=node.next.val
        node.next=node.next.next</code></pre>
<h3 id="876-链表的中间节点"><a href="#876-链表的中间节点" class="headerlink" title="876.链表的中间节点"></a>876.链表的中间节点</h3><pre><code>链接：https://leetcode-cn.com/problems/middle-of-the-linked-list/

给定一个带有头结点 head 的非空单链表，返回链表的中间结点。

如果有两个中间结点，则返回第二个中间结点。

示例 1：

输入：[1,2,3,4,5]
输出：此列表中的结点 3 (序列化形式：[3,4,5])
返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。
注意，我们返回了一个 ListNode 类型的对象 ans，这样：
ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.
示例 2：

输入：[1,2,3,4,5,6]
输出：此列表中的结点 4 (序列化形式：[4,5,6])
由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。
 

提示：给定链表的结点数介于 1 和 100 之间。</code></pre>
<p>题解一|数组：</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def middleNode(self, head: ListNode) -&gt; ListNode:
        arr=[]
        dummy=head
        while head:
            arr.append(head.val)
            head=head.next
        mid=len(arr)//2
        i=0
        while dummy:
            if i==mid:
                return dummy
            dummy=dummy.next
            i+=1</code></pre>
<p>题解二|快慢指针：</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def middleNode(self, head: ListNode) -&gt; ListNode:
        slow=fast=head
        while fast and fast.next:
            slow=slow.next
            fast=fast.next.next
        return slow</code></pre>
<h3 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a>剑指 Offer 06. 从尾到头打印链表</h3><pre><code>链接：https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/

输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。

示例 1：

输入：head = [1,3,2]
输出：[2,3,1]

限制：

0 &lt;= 链表长度 &lt;= 10000</code></pre>
<p>题解一：</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reversePrint(self, head: ListNode) -&gt; List[int]:
        arr=[]
        while head:
            arr.append(head.val)
            head=head.next
        return arr[::-1]</code></pre>
<h3 id="面试题-02-01-移除重复节点"><a href="#面试题-02-01-移除重复节点" class="headerlink" title="面试题 02.01. 移除重复节点"></a>面试题 02.01. 移除重复节点</h3><pre><code>链接：https://leetcode-cn.com/problems/remove-duplicate-node-lcci/

编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。

示例1:

 输入：[1, 2, 3, 3, 2, 1]
 输出：[1, 2, 3]
示例2:

 输入：[1, 1, 1, 1, 2]
 输出：[1, 2]
提示：

链表长度在[0, 20000]范围内。
链表元素在[0, 20000]范围内。
进阶：

如果不得使用临时缓冲区，该怎么解决？</code></pre>
<p>题解一|hash：</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def removeDuplicateNodes(self, head: ListNode) -&gt; ListNode:
        dummy=res=ListNode(-1)
        dummy.next=head
        hash=&#123;&#125;
        while head:
            if head.val not in hash:
                hash[head.val]=1
                res=head
            else:
                res.next=head.next
            head=head.next
        return dummy.next</code></pre>
<p>题解二|二重循环|python运行超时：</p>
<p>思路：</p>
<pre><code>1.快慢双指针，第一层大循环为slow非空的循环，
2.第二层循环为fast循环，prev的下一个始终指向fast，保证出现fast.val==slow.val时，可以有效的删除相同结点，只需要fast和prev即可完美做到
3.slow和fast双层循环依次进行，slow和fast以及以后的依次比较，直到结束</code></pre>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def removeDuplicateNodes(self, head: ListNode) -&gt; ListNode:
        fast=slow=head
        while slow:
            fast=slow.next
            pre=slow
            while fast:
                if fast.val == slow.val: # 注意对比的是fast和slow
                    pre.next=fast.next
                else:
                    pre=pre.next
                fast=fast.next
            slow=slow.next
        return head</code></pre>
<h3 id="面试题-02-02-返回倒数第-k-个节点"><a href="#面试题-02-02-返回倒数第-k-个节点" class="headerlink" title="面试题 02.02. 返回倒数第 k 个节点"></a>面试题 02.02. 返回倒数第 k 个节点</h3><pre><code>链接：https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/

实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。

注意：本题相对原题稍作改动

示例：

输入： 1-&gt;2-&gt;3-&gt;4-&gt;5 和 k = 2
输出： 4
说明：

给定的 k 保证是有效的。</code></pre>
<p>题解一：</p>
<pre><code>class Solution:
    def kthToLast(self, head: ListNode, k: int) -&gt; int:
        res=head
        n=1
        while head.next:
            n+=1
            head=head.next
        k=n-k
        while k&gt;0:
            k-=1
            res=res.next
        return res.val
</code></pre>
<pre><code>class Solution:
    def kthToLast(self, head: ListNode, k: int) -&gt; int:
        tmp=head
        n=0
        while head:
            head=head.next
            n+=1
        k=n-k
        while k&gt;0:
            k-=1
            tmp=tmp.next
        return tmp.val</code></pre>
<p>题解二|快慢指针:</p>
<pre><code>定义两个指针，快指针 fast， 慢指针 slow .
让 fast 先向前移动 k 个位置，然后 slow 和 fast 再一起向前移动 .
当 fast 到达链表尾部，返回 slow .</code></pre>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def kthToLast(self, head: ListNode, k: int) -&gt; int:
        fast=slow=head
        while fast:
            fast=fast.next
            if k==0:
                slow=slow.next
            else:
                k-=1
        return slow.val
</code></pre>
<h3 id="面试题-02-03-删除中间节点"><a href="#面试题-02-03-删除中间节点" class="headerlink" title="面试题 02.03. 删除中间节点"></a>面试题 02.03. 删除中间节点</h3><pre><code>链接：https://leetcode-cn.com/problems/delete-middle-node-lcci/

实现一种算法，删除单向链表中间的某个节点（除了第一个和最后一个节点，不一定是中间节点），假定你只能访问该节点。

示例：

输入：单向链表a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f中的节点c
结果：不返回任何数据，但该链表变为a-&gt;b-&gt;d-&gt;e-&gt;f</code></pre>
<p>题解一：</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def deleteNode(self, node):
        &quot;&quot;&quot;
        :type node: ListNode
        :rtype: void Do not return anything, modify node in-place instead.
        &quot;&quot;&quot;
        node.val=node.next.val
        node.next=node.next.next</code></pre>
<h3 id="面试题-02-04-分割链表"><a href="#面试题-02-04-分割链表" class="headerlink" title="面试题 02.04. 分割链表"></a>面试题 02.04. 分割链表</h3><pre><code>链接：https://leetcode-cn.com/problems/partition-list-lcci/

编写程序以 x 为基准分割链表，使得所有小于 x 的节点排在大于或等于 x 的节点之前。如果链表中包含 x，x 只需出现在小于 x 的元素之后(如下所示)。分割元素 x 只需处于“右半部分”即可，其不需要被置于左右两部分之间。

示例:

输入: head = 3-&gt;5-&gt;8-&gt;5-&gt;10-&gt;2-&gt;1, x = 5
输出: 3-&gt;1-&gt;2-&gt;10-&gt;5-&gt;5-&gt;8</code></pre>
<p>题解一：</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def partition(self, head: ListNode, x: int) -&gt; ListNode:
        before=bf=ListNode(-1)
        after=af=ListNode(-1)
        while head:
            if head.val&lt;x:
                before.next=head
                before=before.next
            else:
                after.next=head
                after=after.next
            head=head.next
        after.next=None
        before.next=af.next
        return bf.next</code></pre>
<h3 id="面试题-02-05-链表求和"><a href="#面试题-02-05-链表求和" class="headerlink" title="面试题 02.05. 链表求和"></a>面试题 02.05. 链表求和</h3><pre><code>链接：https://leetcode-cn.com/problems/sum-lists-lcci/

给定两个用链表表示的整数，每个节点包含一个数位。

这些数位是反向存放的，也就是个位排在链表首部。

编写函数对这两个整数求和，并用链表形式返回结果。

示例：

输入：(7 -&gt; 1 -&gt; 6) + (5 -&gt; 9 -&gt; 2)，即617 + 295
输出：2 -&gt; 1 -&gt; 9，即912
进阶：假设这些数位是正向存放的，请再做一遍。

示例：

输入：(6 -&gt; 1 -&gt; 7) + (2 -&gt; 9 -&gt; 5)，即617 + 295
输出：9 -&gt; 1 -&gt; 2，即912</code></pre>
<p>题解一：</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:
        if not l1:
            return l2
        if not l2:
            return l1
        dummy=res=ListNode(0)
        flag=0
        while l1 or l2:
            sum=0
            if l1:
                sum+=l1.val
                l1=l1.next
            if l2:
                sum+=l2.val
                l2=l2.next
            tmp=(sum+flag)%10
            flag=(sum+flag)//10
            res.next=ListNode(tmp)
            res=res.next
        if flag:
            res.next=ListNode(flag)
            # res.next=ListNode(1)
        return dummy.next</code></pre>
<h3 id="面试题-02-06-回文链表"><a href="#面试题-02-06-回文链表" class="headerlink" title="面试题 02.06. 回文链表"></a>面试题 02.06. 回文链表</h3><pre><code>链接：https://leetcode-cn.com/problems/palindrome-linked-list-lcci/

编写一个函数，检查输入的链表是否是回文的。

示例 1：

输入： 1-&gt;2
输出： false 
示例 2：

输入： 1-&gt;2-&gt;2-&gt;1
输出： true 


进阶：
你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</code></pre>
<p>题解一|数组：</p>
<pre><code>class Solution:
    def isPalindrome(self, head: ListNode) -&gt; bool:
        arr=[]
        while head:
            arr.append(head.val)
            head=head.next
        return arr==arr[::-1]</code></pre>
<p>题解二|快慢指针:</p>
<pre><code># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def isPalindrome(self, head: ListNode) -&gt; bool:
        if not head:
            return True
        slow=fast=head
        while fast and fast.next:
            slow=slow.next
            fast=fast.next.next
        pre=slow
        while slow and slow.next:
            next=slow.next.next
            slow.next.next=pre
            pre=slow.next
            slow.next=next
        while head and pre:
            if head.val != pre.val:
                return False
            head=head.next
            pre=pre.next
        return True</code></pre>
<h3 id="面试题-02-07-链表相交"><a href="#面试题-02-07-链表相交" class="headerlink" title="面试题 02.07. 链表相交"></a>面试题 02.07. 链表相交</h3><pre><code>链接：https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/

给定两个（单向）链表，判定它们是否相交并返回交点。请注意相交的定义基于节点的引用，而不是基于节点的值。换句话说，如果一个链表的第k个节点与另一个链表的第j个节点是同一节点（引用完全相同），则这两个链表相交。


示例 1：

输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。

示例 2：

输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Reference of the node with value = 2
输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。

示例 3：

输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
解释：这两个链表不相交，因此返回 null。

注意：

如果两个链表没有交点，返回 null 。
在返回结果后，两个链表仍须保持原有的结构。
可假定整个链表结构中没有循环。
程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</code></pre>
<p>题解一|循环|超时：</p>
<pre><code>class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode:
        p,q=headA.next,headB.next
        while p:
            while q:
                if p==q:
                    return q
            q=q.next
        p=p.next
        return None</code></pre>
<p>题解二|双指针：</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/link10.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/link10.png"></p>
<p>算法让两个指针分别从A和B点往C点走，两个指针分别走到C后，又各自从另外一个指针的起点，也就是A指针第二次走从B点开始走，B指针同理，这样，A指针走的路径长度 AO + OC + BO 必定等于B指针走的路径长度 BO + OC + AO，这也就意味着这两个指针第二轮走必定会在O点相遇，相遇后也即到达了退出循环的条件。</p>
<pre><code>class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode:
        p,q=headA,headB
        while p != q:
            if p:
                p=p.next
            else:
                p=headB
            if q:
                q=q.next
            else:
                q=headA
        return p</code></pre>
<h3 id="面试题-02-08-环路检测"><a href="#面试题-02-08-环路检测" class="headerlink" title="面试题 02.08. 环路检测"></a>面试题 02.08. 环路检测</h3><pre><code>链接：https://leetcode-cn.com/problems/linked-list-cycle-lcci/

给定一个有环链表，实现一个算法返回环路的开头节点。
有环链表的定义：在链表中某个节点的next元素指向在它前面出现过的节点，则表明该链表存在环路。

示例 1：

输入：head = [3,2,0,-4], pos = 1
输出：tail connects to node index 1
解释：链表中有一个环，其尾部连接到第二个节点。

示例 2：

输入：head = [1,2], pos = 0
输出：tail connects to node index 0
解释：链表中有一个环，其尾部连接到第一个节点。

示例 3：

输入：head = [1], pos = -1
输出：no cycle
解释：链表中没有环。

进阶：你是否可以不用额外空间解决此题？</code></pre>
<p>题解一|双指针：</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode6.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode6.png"></p>
<p>z=n*环的大小+z</p>
<pre><code>class Solution:
    def detectCycle(self, head: ListNode) -&gt; ListNode:
        if not head:
            return None
        slow=fast=head
        while  fast and fast.next:
            slow=slow.next
            fast=fast.next.next
            if slow==fast:
                slow=head
                while slow!=fast:
                    slow=slow.next
                    fast=fast.next
                return slow
        return None</code></pre>
<pre><code>class Solution:
    def detectCycle(self, head: ListNode) -&gt; ListNode:
        if not head:
            return None
        slow=fast=head
        while True:
            if not (fast and fast.next):
                return
            slow=slow.next
            fast=fast.next.next
            if slow == fast:
                break
        slow=head
        while slow != fast:
            slow=slow.next
            fast=fast.next
        return slow  </code></pre>
<h3 id="面试题18-删除链表的节点"><a href="#面试题18-删除链表的节点" class="headerlink" title="面试题18. 删除链表的节点"></a>面试题18. 删除链表的节点</h3><pre><code>链接：https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/

给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。

返回删除后的链表的头节点。

注意：此题对比原题有改动

示例 1:

输入: head = [4,5,1,9], val = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.
示例 2:

输入: head = [4,5,1,9], val = 1
输出: [4,5,9]
解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.


说明：

题目保证链表中节点的值互不相同
若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点</code></pre>
<p>题解一：</p>
<pre><code>class Solution:
    def deleteNode(self, head: ListNode, val: int) -&gt; ListNode:
        dummy=ListNode(-1)
        dummy.next=head
        res=dummy
        while res.next:
            if res.next.val==val:
                res.next=res.next.next
            else:
                res=res.next
        return dummy.next</code></pre>
<h3 id="面试题22-链表中倒数第k个节点"><a href="#面试题22-链表中倒数第k个节点" class="headerlink" title="面试题22. 链表中倒数第k个节点"></a>面试题22. 链表中倒数第k个节点</h3><pre><code>链接：https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/

个链表的倒数第3个节点是值为4的节点。

示例：

给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.

返回链表 4-&gt;5.</code></pre>
<p>题解一：</p>
<pre><code>class Solution:
    def getKthFromEnd(self, head: ListNode, k: int) -&gt; ListNode:
        fast=slow=head
        while fast:
            fast=fast.next
            if k==0:
                slow=slow.next
            else:
                k-=1
        return slow</code></pre>
<h3 id="面试题24-反转链表"><a href="#面试题24-反转链表" class="headerlink" title="面试题24. 反转链表"></a>面试题24. 反转链表</h3><pre><code>链接：https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/

定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

示例:

输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL


限制：

0 &lt;= 节点个数 &lt;= 5000</code></pre>
<p>题解一：</p>
<pre><code>class Solution:
    def reverseList(self, head: ListNode) -&gt; ListNode:
        pre=None
        while head:
            next=head.next
            head.next=pre
            pre=head
            head=next
        return pre</code></pre>
<h3 id="面试题35-复杂链表的复制"><a href="#面试题35-复杂链表的复制" class="headerlink" title="面试题35. 复杂链表的复制"></a>面试题35. 复杂链表的复制</h3><pre><code>链接：https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/

请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</code></pre>
<p>题解一：</p>
<pre><code>class Solution:
    def copyRandomList(self, head: &#39;Node&#39;) -&gt; &#39;Node&#39;:
        return copy.deepcopy(head)</code></pre>
<p>题解二|深度优先遍历：</p>
<pre><code>&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, x: int, next: &#39;Node&#39; = None, random: &#39;Node&#39; = None):
        self.val = int(x)
        self.next = next
        self.random = random
&quot;&quot;&quot;
class Solution:
    def copyRandomList(self, head: &#39;Node&#39;) -&gt; &#39;Node&#39;:
        def dfs(head):
            if not head:
                return None
            if head in visited:
                return visited[head]
            copy=Node(head.val,None,None)
            visited[head]=copy
            copy.next=dfs(head.next)
            copy.random=dfs(head.random)
            return copy
        visited=&#123;&#125;
        return dfs(head)</code></pre>
<p>题解三|bfs：</p>
<pre><code>&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, x: int, next: &#39;Node&#39; = None, random: &#39;Node&#39; = None):
        self.val = int(x)
        self.next = next
        self.random = random
&quot;&quot;&quot;
import collections

class Solution:
    def copyRandomList(self, head: &#39;Node&#39;) -&gt; &#39;Node&#39;:
        visited=&#123;&#125;
        def bfs(head):
            if not head:
                return None
            clone=Node(head.val,None,None)
            queue=collections.deque()
            queue.append(head)
            visited[head]=clone
            while queue:
                tmp=queue.pop()
                if tmp.next and tmp.next not in visited:
                    visited[tmp.next]=Node(tmp.next.val,[],[])
                    queue.append(tmp.next)
                if tmp.random and tmp.random not in visited:
                    visited[tmp.random] = Node(tmp.random.val, [], [])
                    queue.append(tmp.random)
                visited[tmp].next=visited.get(tmp.next)
                visited[tmp].random=visited.get(tmp.random)
            return clone
        return bfs(head)</code></pre>
<h3 id="面试题52-两个链表的第一个公共节点"><a href="#面试题52-两个链表的第一个公共节点" class="headerlink" title="面试题52. 两个链表的第一个公共节点"></a>面试题52. 两个链表的第一个公共节点</h3><pre><code>链接：https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/

输入两个链表，找出它们的第一个公共节点。

如下面的两个链表：

在节点 c1 开始相交。

示例 1：

输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。

示例 2：

输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Reference of the node with value = 2
输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。

示例 3：

输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
解释：这两个链表不相交，因此返回 null。

注意：

如果两个链表没有交点，返回 null.
在返回结果后，两个链表仍须保持原有的结构。
可假定整个链表结构中没有循环。
程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</code></pre>
<p>题解一|hash：</p>
<pre><code>class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode:
        p=headA
        q=headB
        hash=&#123;&#125;
        while headA:
            if headA not in hash:
                hash[headA]=1
                headA=headA.next
        while headB:
            if headB in hash:
                return headB
            else:
                headB=headB.next
        return None</code></pre>
<p>题解二|双指针：</p>
<p>时间复杂度：O(M+N)<br>空间复杂度：O(1)</p>
<pre><code>class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode:
        node1, node2 = headA, headB

        while node1 != node2:
            node1 = node1.next if node1 else headB
            node2 = node2.next if node2 else headA

        return node1</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/LeetCode-3-%E6%A0%91-%E4%B8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/LeetCode-3-%E6%A0%91-%E4%B8%80/" class="post-title-link" itemprop="url">LeetCode-3.树-一</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-02 15:49:29" itemprop="dateCreated datePublished" datetime="2020-01-02T15:49:29+08:00">2020-01-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-13 16:31:01" itemprop="dateModified" datetime="2020-09-13T16:31:01+08:00">2020-09-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>参考文章：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/bjwu/p/9284534.html">https://www.cnblogs.com/bjwu/p/9284534.html</a></p>
<h2 id="三、树"><a href="#三、树" class="headerlink" title="三、树"></a>三、树</h2><h3 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94.二叉树的中序遍历"></a>94.二叉树的中序遍历</h3><pre><code>链接：https://leetcode-cn.com/problems/binary-tree-inorder-traversal/

给定一个二叉树，返回它的中序 遍历。

示例:

输入: [1,null,2,3]
   1
    \
     2
    /
   3

输出: [1,3,2]
进阶: 递归算法很简单，你可以通过迭代算法完成吗？</code></pre>
<p>题解一（递归）：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def inorderTraversal(self, root: TreeNode) -&gt; List[int]:
        res=[]
        if root:
            res=self.inorderTraversal(root.left)
            res.append(root.val)
            res+=self.inorderTraversal(root.right)
        return res</code></pre>
<pre><code>class Solution:
    def inorderTraversal(self, root):
        &quot;&quot;&quot;
        :type root: TreeNode
        :rtype: List[int]
        &quot;&quot;&quot;
        if not root:
            return [] 
        return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)</code></pre>
<p>题解二（迭代）:<br><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/inorder.png" alt="inorder"></p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def inorderTraversal(self, root: TreeNode) -&gt; List[int]:
        res=[]
        stack=[]
        curr=root
        while stack or curr:
            if curr:
                stack.append(curr)
                curr=curr.left
            else:
                curr=stack.pop()
                res.append(curr.val)
                curr=curr.right
        return res</code></pre>
<h3 id="95-不同的二叉搜索树-II"><a href="#95-不同的二叉搜索树-II" class="headerlink" title="?95.不同的二叉搜索树 II"></a>?95.不同的二叉搜索树 II</h3><pre><code>链接：https://leetcode-cn.com/problems/unique-binary-search-trees-ii/

给定一个整数 n，生成所有由 1 ... n 为节点所组成的二叉搜索树。

示例:

输入: 3
输出:
[
  [1,null,3,2],
  [3,2,null,1],
  [3,1,null,null,2],
  [2,1,3],
  [1,null,2,null,3]
]
解释:
以上的输出对应以下 5 种不同结构的二叉搜索树：

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3</code></pre>
<p>题解一|递归：<br><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/tree3.png" alt="tree3"><br><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/tree4.png" alt="tree4"></p>
<pre><code>所以如果求 1...n 的所有可能。

我们只需要把 1 作为根节点，[ ] 空作为左子树，[ 2 ... n ] 的所有可能作为右子树。

2 作为根节点，[ 1 ] 作为左子树，[ 3...n ] 的所有可能作为右子树。

3 作为根节点，[ 1 2 ] 的所有可能作为左子树，[ 4 ... n ] 的所有可能作为右子树，然后左子树和右子树两两组合。

4 作为根节点，[ 1 2 3 ] 的所有可能作为左子树，[ 5 ... n ] 的所有可能作为右子树，然后左子树和右子树两两组合。

...

n 作为根节点，[ 1... n ] 的所有可能作为左子树，[ ] 作为右子树。

至于，[ 2 ... n ] 的所有可能以及 [ 4 ... n ] 以及其他情况的所有可能，可以利用上边的方法，把每个数字作为根节点，然后把所有可能的左子树和右子树组合起来即可。

如果只有一个数字，那么所有可能就是一种情况，把该数字作为一棵树。而如果是 [ ]，那就返回 null。</code></pre>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def generateTrees(self, n: int) -&gt; List[TreeNode]:
        if n:
            return self.build(1,n)
        else:
            []
    def build(self,start,end):
        # 结束条件
        if start&gt;end:
            return [None,]

        trees=[]
        for i in range(start,end+1):
            leftTrees=self.build(start,i-1)
            rightTrees=self.build(i+1,end)
            for l in leftTrees:
                for r in rightTrees:
                    currentTree=TreeNode(i)
                    currentTree.left=l
                    currentTree.right=r
                    trees.append(currentTree)
        # print(trees)
        return trees</code></pre>
<h3 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96.不同的二叉搜索树"></a>96.不同的二叉搜索树</h3><pre><code>链接：https://leetcode-cn.com/problems/unique-binary-search-trees/

给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

示例:

输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3</code></pre>
<p>题解一（动态规划）:<br>二叉树定义：</p>
<p>二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-binary-search-trees/solution/bu-tong-de-er-cha-sou-suo-shu-by-leetcode/">https://leetcode-cn.com/problems/unique-binary-search-trees/solution/bu-tong-de-er-cha-sou-suo-shu-by-leetcode/</a><br>方法：</p>
<pre><code>给定一个有序序列 1 ... n，为了根据序列构建一棵二叉搜索树。我们可以遍历每个数字 i，将该数字作为树根，1 ... (i-1) 序列将成为左子树，(i+1) ... n 序列将成为右子树。于是，我们可以递归地从子序列构建子树。
在上述方法中，由于根各自不同，每棵二叉树都保证是独特的。

可见，问题可以分解成规模较小的子问题。因此，我们可以存储并复用子问题的解，而不是递归的（也重复的）解决这些子问题，这就是动态规划法。</code></pre>
<p>函数定义：</p>
<pre><code>令G(n)的从1到n可以形成二叉搜索树个数
令f(i)为以i为根的二叉搜索树的个数

所以G(n)是解决问题的函数：G(n) = f(1) + f(2) + f(3) + f(4) + ... + f(n)</code></pre>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/tree.png" alt="tree"></p>
<p>1、定义数组元素的含义<br>    G[i]代表二叉搜索树的个数<br>2、找出数组之间的的关系式<br>    以i为根，[0,i-1]为左节点，[i+1,n]为右节点<br>    之后再对[0,i-1]和[i+1,n]递归求解</p>
<pre><code>f(i)=G(i−1)∗G(n−i)

G(n)=G(0)∗G(n−1)+G(1)∗(n−2)+...+G(n−1)∗G(0)</code></pre>
<p>3、找出初始值<br>    G[0]=1<br>    G[1]=1<br>    G[2]=2</p>
<p>时间复杂度：O(n^2)<br>空间复杂度：O(n)</p>
<p>dp[2] = f(1)+f(2)= dp[0] * dp[1] (1为根的情况) + dp[1] * dp[0] (2为根的情况)</p>
<pre><code>class Solution:
    def numTrees(self, n: int) -&gt; int:
        dp=[0]*(n+1)
        dp[0]=1
        dp[1]=1

        for i in range(2,n+1):
            for j in range(1,i+1):
                dp[i]+=dp[j-1]*dp[i-j] 
        # print(dp)
        return dp[n]</code></pre>
<h3 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98.验证二叉搜索树"></a>98.验证二叉搜索树</h3><pre><code>链接：https://leetcode-cn.com/problems/validate-binary-search-tree/

给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：

节点的左子树只包含小于当前节点的数。
节点的右子树只包含大于当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。
示例 1:

输入:
    2
   / \
  1   3
输出: true
示例 2:

输入:
    5
   / \
  1   4
     / \
    3   6
输出: false
解释: 输入为: [5,1,4,null,null,3,6]。
     根节点的值为 5 ，但是其右子节点值为 4 。</code></pre>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/validate-binary-search-tree/solution/die-dai-yu-di-gui-by-powcai/">https://leetcode-cn.com/problems/validate-binary-search-tree/solution/die-dai-yu-di-gui-by-powcai/</a></p>
<p>题解一|递归:</p>
<p>理解：</p>
<pre><code>当前节点的值是其左子树的值的上界（最大值）
当前节点的值是其右子树的值的下界（最小值）</code></pre>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isValidBST(self, root: TreeNode) -&gt; bool:
        def helper(root,lower=float(&#39;-inf&#39;),upper=float(&#39;inf&#39;)):
            if not root:
                return True
            val=root.val
            if val&lt;=lower or val&gt;=upper:
                return False

            if not helper(root.right,val,upper):
                return False

            if not helper(root.left,lower,val):
                return False

            return True
        return helper(root)</code></pre>
<pre><code>class Solution:
    def isValidBST(self, root: TreeNode, low = float(&#39;-inf&#39;), high = float(&#39;inf&#39;)) -&gt; bool:
        if not root:return True
        if not low&lt;root.val&lt;high:return False
        return self.isValidBST(root.left,low,root.val) and self.isValidBST(root.right,root.val,high)</code></pre>
<p>题解二|迭代：<br>时间复杂度 : O(N)。每个结点访问一次。<br>空间复杂度 : O(N)。我们跟进了整棵树。</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isValidBST(self, root: TreeNode) -&gt; bool:
        if not root:
            return True # 空树，否则过不了case[]
        stack=[(root,float(&#39;-inf&#39;),float(&#39;inf&#39;)),]
        while stack:
            root,lower,upper=stack.pop()
            # print(lower,upper)
            if not root:
                continue
            val=root.val
            if val&gt;=upper or val&lt;=lower:
                return False
            stack.append((root.right,val,upper)) # 此处的left和right的顺序没有关系
            stack.append((root.left,lower,val))
        return True</code></pre>
<p>题解三|中序遍历:<br>    中序遍历[1,2,3]，检查 inorder 中的每个元素是否小于下一个。</p>
<pre><code>时间复杂度 : 最坏情况下（树为二叉搜索树或破坏条件的元素是最右叶结点）为 &#123;O&#125;(N)。
空间复杂度 : &#123;O&#125;(N) 用于存储 stack。</code></pre>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isValidBST(self, root: TreeNode) -&gt; bool:
        stack=[]
        inorder=float(&#39;-inf&#39;)
        while stack or root:
            while root:
                stack.append(root)
                root=root.left
            root=stack.pop()
            if root.val &lt;= inorder: # 注意小于号，否则[1,1]不能pass。
                return False
            inorder=root.val
            root=root.right
        return True</code></pre>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isValidBST(self, root: TreeNode) -&gt; bool:
        stack=[]
        inorder=float(&#39;-inf&#39;)
        while stack or root:
            if root:
                stack.append(root)
                root=root.left
            else:
                root=stack.pop()
                if root.val &lt;= inorder:
                    return False
                inorder=root.val
                root=root.right
        return True</code></pre>
<h3 id="99-恢复二叉搜索树"><a href="#99-恢复二叉搜索树" class="headerlink" title="99.恢复二叉搜索树"></a>99.恢复二叉搜索树</h3><pre><code>链接：https://leetcode-cn.com/problems/recover-binary-search-tree/

二叉搜索树中的两个节点被错误地交换。

请在不改变其结构的情况下，恢复这棵树。

示例 1:

输入: [1,3,null,null,2]

   1
  /
 3
  \
   2

输出: [3,1,null,null,2]

   3
  /
 1
  \
   2
示例 2:

输入: [3,1,4,null,null,2]

  3
 / \
1   4
   /
  2

输出: [2,1,4,null,null,3]

  2
 / \
1   4
   /
  3
进阶:

使用 O(n) 空间复杂度的解法很容易实现。
你能想出一个只使用常数空间的解决方案吗？</code></pre>
<p>思路:<br>    难点：找到2个节点进行交换</p>
<pre><code>二叉树搜索树的中序遍历(中序遍历遍历元素是递增的)

中序遍历顺序是 1,3,2,4,我们只要找到节点3和节点2交换顺序即可!

这里我们有个规律发现这两个节点:

    第一个节点,是第一个按照中序遍历时候前一个节点大于后一个节点,我们选取前一个节点,这里指节点3;

    第二个节点,是在第一个节点找到之后, 后面出现前一个节点大于后一个节点,我们选择后一个节点,这里指节点2;</code></pre>
<p>题解一|递归：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def recoverTree(self, root: TreeNode) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify root in-place instead.
        &quot;&quot;&quot;
        self.firstNode=None
        self.secondNode=None
        self.pre=TreeNode(float(&#39;-inf&#39;))
        def helper(root):
            if not root:
                return
            helper(root.left)
            if self.firstNode is None and self.pre.val &gt;= root.val:
                self.firstNode=self.pre
            if self.firstNode and self.pre.val &gt;= root.val:
                self.secondNode=root
            self.pre=root
            helper(root.right)
        helper(root)
        self.firstNode.val,self.secondNode.val=self.secondNode.val,self.firstNode.val</code></pre>
<p>题解二|迭代：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def recoverTree(self, root: TreeNode) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify root in-place instead.
        &quot;&quot;&quot;
        firstNode=None
        secondNode=None
        pre=TreeNode(float(&#39;-inf&#39;))
        stack=[]
        while stack or root:
            while root:
                stack.append(root)
                root=root.left
            root=stack.pop()

            if not firstNode and pre.val &gt; root.val:
                firstNode=pre
            if firstNode and pre.val &gt; root.val:
                secondNode=root
            pre=root
            root=root.right
        firstNode.val,secondNode.val=secondNode.val,firstNode.val</code></pre>
<h3 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100.相同的树"></a>100.相同的树</h3><pre><code>链接：https://leetcode-cn.com/problems/same-tree/

给定两个二叉树，编写一个函数来检验它们是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

示例 1:

输入:       1         1
          / \       / \
         2   3     2   3

        [1,2,3],   [1,2,3]

输出: true
示例 2:

输入:      1          1
          /           \
         2             2

        [1,2],     [1,null,2]

输出: false
示例 3:

输入:       1         1
          / \       / \
         2   1     1   2

        [1,2,1],   [1,1,2]

输出: false</code></pre>
<p>题解一|递归:</p>
<p>时间复杂度 : O(N)，其中 N 是树的结点数，因为每个结点都访问一次。</p>
<p>空间复杂度 : 最优情况（完全平衡二叉树）时为 O(log(N))，最坏情况下（完全不平衡二叉树）时为 O(N)，用于维护递归栈。</p>
<pre><code>class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def isSameTree(self, p: TreeNode, q: TreeNode) -&gt; bool:
        if p is None and q is None:
            return True
        if p is None or q is None:
            return False
        if p.val != q.val:
            return False

        return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)
</code></pre>
<pre><code>class Solution:
    def isSameTree(self, p: TreeNode, q: TreeNode) -&gt; bool:
        if p is None and q is None:
            return True
        if p is None or q is None:
            return False
        if p.val == q.val:
            return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)</code></pre>
<p>题解二|迭代:</p>
<p>时间复杂度 : O(N)，其中 N 是树的结点数，因为每个结点都访问一次。</p>
<p>空间复杂度 : 最优情况（完全平衡二叉树）时为 O(log(N))，最坏情况下（完全不平衡二叉树）时为 O(N)，用于维护双向队列。</p>
<pre><code>class Solution:
    def isSameTree(self, p: TreeNode, q: TreeNode) -&gt; bool:
        from collections import deque
        def helper(p,q):
            if not p and not q:
                return True
            if not p or not q:
                return False
            if p.val != q.val:
                return False
            return True
        deq=deque([(p,q),])
        while deq:
            p,q=deq.popleft()
            if not helper(p,q):
                return False
            # 此处改为if q也可以。
            if p:  # 当p和q为None时，此时p.left不成立，所以需要判断。
                deq.append((p.left,q.left))
                deq.append((p.right,q.right))
        return True</code></pre>
<p>总结：第一种方法就是先序遍历的递归形式，第二种方法是层次遍历的非递归算法</p>
<h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101.对称二叉树"></a>101.对称二叉树</h3><pre><code>链接：https://leetcode-cn.com/problems/symmetric-tree/
给定一个二叉树，检查它是否是镜像对称的。

例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

    1
   / \
  2   2
 / \ / \
3  4 4  3
但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

    1
   / \
  2   2
   \   \
   3    3</code></pre>
<p>题解一|递归:</p>
<pre><code>class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def isSymmetric(self, root: TreeNode) -&gt; bool:
        if root is None:
            return True
        return self.isMirror(root.left,root.right)

    def isMirror(self,p,q):
        if p is None and q is None:
            return True
        if p is None or q is None:
            return False
        #if left.val != right.val:
        #    return False
        l=self.isMirror(p.left,q.right)
        r=self.isMirror(q.left,p.right) # 注意：此处是对称，注意节点的选择。
        return p.val==q.val and l and r</code></pre>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isSymmetric(self, root: TreeNode) -&gt; bool:
        def helper(p,q):
            if not p and not q:
                return True
            if not p or not q:
                return False
            if p.val != q.val:
                return False
            return helper(p.left,q.right) and helper(p.right,q.left)
        if not root:
            return True
        return helper(root.left,root.right)</code></pre>
<p>题解二（迭代）：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isSymmetric(self, root: TreeNode) -&gt; bool:
        from collections import deque
        def helper(p,q):
            if not p and not q:
                return True
            if not p or not q:
                return False
            if p.val != q.val:
                return False
            return True
        deq=deque([(root,root),])
        while deq:
            p,q=deq.popleft()
            if not helper(p,q):
                return False
            if p:  # 当p和q为None时，此时p.left不成立，所以需要判断。
                deq.append((p.left,q.right))
                deq.append((p.right,q.left))
        return True</code></pre>
<p>别人的迭代：</p>
<pre><code>class Solution(object):
    def isSymmetric(self, root):
        if root == None:
            return True
        # 用队列保存节点
        queue = [root,root]
        while queue:
            # 从队列中取出两个节点，再比较这两个节点
            left = queue.pop()
            right = queue.pop()
            # 如果两个节点都为空就继续循环，两者有一个为空就返回false
            if(left == None and right == None):
                continue
            if(left == None or right == None):
                return False
            if left.val!=right.val:
                return False
            # 将左节点的左孩子， 右节点的右孩子放入队列
            queue.append(left.left)
            queue.append(right.right)
            # 将左节点的右孩子，右节点的左孩子放入队列
            queue.append(left.right)
            queue.append(right.left)
        return True</code></pre>
<h3 id="102-二叉树的层次遍历"><a href="#102-二叉树的层次遍历" class="headerlink" title="102.二叉树的层次遍历"></a>102.二叉树的层次遍历</h3><pre><code>链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal/

给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。

例如:
给定二叉树: [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回其层次遍历结果：

[
  [3],
  [9,20],
  [15,7]
]</code></pre>
<p>题解一|递归：</p>
<pre><code>class Solution:

    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:
        res=[]

        def helper(node,depth):
            if not node:
                return
            if len(res)==depth:
                res.append([])
            res[depth].append(node.val)
            helper(node.left,depth+1)
            helper(node.right,depth+1)
        helper(root,0)
        return res</code></pre>
<p>题解二|迭代：<br>    我们将树上顶点按照层次依次放入队列结构中，队列中元素满足 FIFO（先进先出）的原则。在 Java 中可以使用 Queue 接口中的 LinkedList实现。在 Python 中如果使用 Queue 结构，但因为它是为多线程之间安全交换而设计的，所以使用了锁，会导致性能不佳。因此在 Python 中可以使用 deque 的 append() 和 popleft() 函数来快速实现队列的功能。</p>
<pre><code>第 0 层只包含根节点 root ，算法实现如下：

    初始化队列只包含一个节点 root 和层次编号 0 ： level = 0。
    当队列非空的时候：
        在输出结果 levels 中插入一个空列表，开始当前层的算法。
        计算当前层有多少个元素：等于队列的长度。
        将这些元素从队列中弹出，并加入 levels 当前层的空列表中。
        将他们的孩子节点作为下一层压入队列中。
        进入下一层 level++。</code></pre>
<pre><code>from collections import deque
class Solution:

    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:
        if root is None:
            return 
        res=[]
        queue=deque() # queue=[]
        queue.append(root)
        while len(queue)&gt;0:
            p=queue.popleft() # p=queue.pop(0)
            res.append(p.val)

            if p.left:
                queue.append(p.left)
            if p.right:
                queue.append(p.right)

        return res

预期输出：[[3],[9,20],[15,7]]
实际输出：[3, 9, 20, 15, 7]

所以，要想得到预期输出，需要增加深度。</code></pre>
<pre><code>class Solution:

    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:
        if root is None:
            return 
        res=[]
        queue=[root] # 不能使用这个queue.append([root])
        depth=0

        while queue:
            res.append([])
            for i in range(len(queue)):
                node=queue.pop(0)
                res[depth].append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            depth+=1

        return res</code></pre>
<pre><code>class Solution:
    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:
        if not root: return []
        res = []
        cur_level = [root]
        while cur_level:
            tmp = []
            next_level = []
            for node in cur_level:
                tmp.append(node.val)
                if node.left:
                    next_level.append(node.left)
                if node.right:
                    next_level.append(node.right)
            res.append(tmp)
            cur_level = next_level
        return res</code></pre>
<h3 id="103-二叉树的锯齿形层次遍历"><a href="#103-二叉树的锯齿形层次遍历" class="headerlink" title="103.二叉树的锯齿形层次遍历"></a>103.二叉树的锯齿形层次遍历</h3><pre><code>链接：https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/

给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

例如：
给定二叉树 [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回锯齿形层次遍历如下：

[
  [3],
  [20,9],
  [15,7]
]</code></pre>
<p>思路：锯齿形遍历和层次遍历的差异，如果仍然按层次遍历，但是我要第一层从左往右，第二层从右往左，第三从左往右，这种zigzag遍历方式如何实现？</p>
<pre><code>对层数进行一个奇偶判断即可，如下：
if depth %2 == 0:
    res[depth].append(root.val)
else:
    res[depth].insert(0, root.val)</code></pre>
<p>题解一|递归:</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def zigzagLevelOrder(self, root: TreeNode) -&gt; List[List[int]]:
        res=[]
        def helper(root,depth):
            if not root:
                return
            if len(res)==depth:
                res.append([])
            if depth %2 == 0:
                res[depth].append(root.val)
            else:
                res[depth].insert(0, root.val)

            helper(root.left,depth+1)
            helper(root.right,depth+1)

        helper(root,0)
        return res</code></pre>
<p>题解二|迭代：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def zigzagLevelOrder(self, root: TreeNode) -&gt; List[List[int]]:
        if not root:
            return []
        res=[]
        queue=[root]
        depth=0

        while queue:
            res.append([])
            for i in range(len(queue)):
                node=queue.pop(0)
                if depth % 2 == 0:
                    res[depth].append(node.val)
                else:
                    res[depth].insert(0,node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            depth+=1
        return res</code></pre>
<h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a>104. 二叉树的最大深度</h3><pre><code>链接：https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

示例：
给定二叉树 [3,9,20,null,null,15,7]，

    3
   / \
  9  20
    /  \
   15   7
返回它的最大深度 3 。</code></pre>
<p>题解一|递归：<br><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/youdao/tree1.png" alt="tree1"><br><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/youdao/tree2.png" alt="tree2"></p>
<p>时间复杂度：我们每个结点只访问一次，因此时间复杂度为 O(N)，<br>其中 N 是结点的数量。</p>
<p>空间复杂度：在最糟糕的情况下，树是完全不平衡的，例如每个结点只剩下左子结点，递归将会被调用 N 次（树的高度），因此保持调用栈的存储将是 O(N)。但在最好的情况下（树是完全平衡的），树的高度将是 log(N)。因此，在这种情况下的空间复杂度将是 O(log(N))。</p>
<pre><code>class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def maxDepth(self, root: TreeNode) -&gt; int:
        if root is None:
            return 0
        else:
            leftHeight=self.maxDepth(root.left)
            rightHeight=self.maxDepth(root.right)
            return max(leftHeight,rightHeight)+1</code></pre>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def maxDepth(self, root: TreeNode) -&gt; int:
        if not root:
            return 0
        return max(self.maxDepth(root.left),self.maxDepth(root.right))+1</code></pre>
<p>题解二|迭代：</p>
<pre><code>class Solution:
    def maxDepth(self, root: TreeNode) -&gt; int:
        if root is None:
            return 0
        stack=[(1,root)]
        depth=0

        while stack:
            curr,root=stack.pop()
            if root: # 如果弹出的节点不为空
                depth=max(depth,curr)
                stack.append((curr+1,root.left))
                stack.append((curr+1,root.right))
        return depth</code></pre>
<h3 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105.从前序与中序遍历序列构造二叉树"></a>105.从前序与中序遍历序列构造二叉树</h3><pre><code>链接：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/

根据一棵树的前序遍历与中序遍历构造二叉树。

注意:
你可以假设树中没有重复的元素。

例如，给出

前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：

    3
   / \
  9  20
    /  \
   15   7</code></pre>
<p>题解一|递归、模拟法：<br>    前序遍历和中序遍历有以下特点：<br>        前序遍历： 根节点 | 左子树 | 右子树 ； 例如：[1 | 2 4 5 | 3 6 7]<br>        中序遍历： 左子树 | 根节点 | 右子树 ； 例如：[4 2 5 | 1 | 6 3 7]<br>        对于每个左子树、右子树的前序遍历和中序遍历依然有此规律。<br>    思路：<br>        按前序遍历的顺序每次pop并建立节点root，在中序遍历中找到root的对应index，划分出哪些节点构成此节点的左子树inorder[:i]，哪些构成右子树inorder[i+1:]。<br>        返回值：递归构建完当前节点root左右子树后，返回root，作为上轮递归父节点的left或right。<br>        终止条件： 当inorder[:i]中序遍历无剩余元素时，说明当前root已经越过叶子节点，直接返回None。</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode:
        if not inorder:
            return
        root=TreeNode(preorder.pop(0))
        i=inorder.index(root.val)
        # print(i,inorder[:i],inorder[i+1:])

        root.left=self.buildTree(preorder,inorder[:i])
        root.right=self.buildTree(preorder,inorder[i+1:])
        return root</code></pre>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode:
        if not inorder:
            return
        # 前序遍历第一个值为根节点
        root=TreeNode(preorder[0])
        # 因为没有重复元素，所以可以直接根据值来查找根节点在中序遍历中的位置
        i=inorder.index(preorder[0])
        # print(i,inorder[:i],inorder[i+1:])

        # 构建左子树
        root.left=self.buildTree(preorder[1:i+1],inorder[:i])
        # 构建右子树
        root.right=self.buildTree(preorder[i+1:],inorder[i+1:])
        return root</code></pre>
<h3 id="106-从中序和后序遍历序列构造二叉树"><a href="#106-从中序和后序遍历序列构造二叉树" class="headerlink" title="106.从中序和后序遍历序列构造二叉树"></a>106.从中序和后序遍历序列构造二叉树</h3><pre><code>链接：https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/

根据一棵树的中序遍历与后序遍历构造二叉树。

注意:
你可以假设树中没有重复的元素。

例如，给出

中序遍历 inorder = [9,3,15,20,7]
后序遍历 postorder = [9,15,7,20,3]
返回如下的二叉树：

    3
   / \
  9  20
    /  \
   15   7</code></pre>
<p>题解一|递归：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -&gt; TreeNode: 
        if not inorder:
            return
        root=TreeNode(postorder.pop(-1))
        i=inorder.index(root.val)
        root.right=self.buildTree(inorder[i+1:],postorder) # 注意：需要先右节点，再左节点
        root.left=self.buildTree(inorder[0:i],postorder)
        return root</code></pre>
<pre><code>class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -&gt; TreeNode: 
        if len(inorder) == 0:
            return None

        # 后序遍历最后一个节点为根节点
        root = TreeNode(postorder[-1])

        # 根节点在中序遍历中的位置
        index = inorder.index(postorder[-1])

        # 构造左子树
        root.left = self.buildTree(inorder[:index], postorder[:index])

        # 构造右子树
        root.right = self.buildTree(inorder[index+1:], postorder[index:len(postorder) - 1])
        # root.right = self.buildTree(inorder[index+1:], postorder[index:-1])

        return root</code></pre>
<h3 id="107-二叉树的层次遍历-II"><a href="#107-二叉树的层次遍历-II" class="headerlink" title="107.二叉树的层次遍历 II"></a>107.二叉树的层次遍历 II</h3><pre><code>链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/

给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

例如：
给定二叉树 [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回其自底向上的层次遍历为：

[
  [15,7],
  [9,20],
  [3]
]</code></pre>
<p>题解一|递归：</p>
<pre><code>class Solution:
    def levelOrderBottom(self, root: TreeNode) -&gt; List[List[int]]:
        res=[]
        def helper(node,depth):
            if not node:
                return
            if len(res)==depth:
                res.insert(0,[])

            res[-(depth+1)].append(node.val)
            helper(node.left,depth+1)
            helper(node.right,depth+1)
        helper(root,0)
        return res</code></pre>
<p>题解二|迭代：</p>
<pre><code>class Solution:
    def levelOrderBottom(self, root: TreeNode) -&gt; List[List[int]]:
        from collections import deque
        if root is None: return
        queue=deque()
        queue.appendleft(root)
        res=[]
        while queue:
            tmp=[]
            for i in range(len(queue)):
                node=queue.pop()
                tmp.append(node.val)
                if node.left:
                    queue.appendleft(node.left)
                if node.right:
                    queue.appendleft(node.right)
            res.insert(0,tmp) # 注意与从上到下层次遍历区别
        return res</code></pre>
<pre><code>class Solution:
    def levelOrderBottom(self, root: TreeNode) -&gt; List[List[int]]:
        from collections import deque
        if root is None: return
        queue=deque()
        queue.append(root)
        res=[]
        while queue:
            tmp=[]
            for i in range(len(queue)):
                node=queue.popleft()
                tmp.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            res.insert(0,tmp)
        return res</code></pre>
<h3 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108.将有序数组转换为二叉搜索树"></a>108.将有序数组转换为二叉搜索树</h3><pre><code>链接：https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/

将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。

示例:

给定有序数组: [-10,-3,0,5,9],

一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：

      0
     / \
   -3   9
   /   /
 -10  5</code></pre>
<p>二叉搜索树：<br>    若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值<br>    若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值<br>    任意节点的左、右子树也分别为二叉搜索树<br>    没有键值相等的节点</p>
<p>二叉搜索树的特性：二叉搜索树的中序遍历结果为递增序列。</p>
<p>平衡二叉树，既然要做到平衡，我们只要把根节点选为数组的中点即可。</p>
<p>参考文章：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/solution/jiang-you-xu-shu-zu-zhuan-huan-wei-er-cha-sou-s-15/">https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/solution/jiang-you-xu-shu-zu-zhuan-huan-wei-er-cha-sou-s-15/</a></p>
<p>题解一|递归+二分：</p>
<p>1、函数作用<br>通过上述解题过程我们可以明确该问题的子问题是：构造树的每个节点以及该节点的左右子树。因此，递归函数的作用很明显：</p>
<pre><code>选取要构造关系的节点并创建它
构造该节点的左子树
构造该节点的右子树</code></pre>
<p>函数的输入为递增数组，函数的返回为完成构造的节点。</p>
<p>2、何时结束<br>当输入的递增数组为空时，只能构成一棵空树，此时返回空节点。</p>
<p>3、何时调用<br>当构造节点的左右子树时，对递增数组进行拆分并进行递归调用。</p>
<p>时间复杂度：O(n)<br>空间复杂度：O(log(n))</p>
<pre><code>class Solution:
    def sortedArrayToBST(self, nums: List[int]) -&gt; TreeNode:
        if not nums: # 此处使用if nums is None会越界。
            return None
        mid=len(nums)//2
        node=TreeNode(nums[mid])

        left=nums[:mid]
        right=nums[mid+1:]

        node.left=self.sortedArrayToBST(left)
        node.right=self.sortedArrayToBST(right)

        # node.left, node.right = map(self.sortedArrayToBST, [nums[:mid], nums[mid+1:]])

        return node</code></pre>
<p>扩展：将有序数组转换为二叉搜索树的结果为什么 不唯一 ？</p>
<p>众所周知，二叉搜索树的中序遍历是一个升序序列。</p>
<p>将有序数组作为输入，可以把该问题看做根据中序遍历序列创建二叉搜索树。</p>
<pre><code>这个问题的答案唯一吗。例如：是否可以根据中序遍历序列和二叉搜索树之间是否一一对应，答案是否定的。</code></pre>
<p>关于 BST 的知识：</p>
<pre><code>中序遍历不能唯一确定一棵二叉搜索树。
先序和后序遍历不能唯一确定一棵二叉搜索树。
先序/后序遍历和中序遍历的关系：
inorder = sorted(postorder) = sorted(preorder)，
中序+后序、中序+先序可以唯一确定一棵二叉树。</code></pre>
<p>因此，“有序数组 -&gt; BST”有多种答案：</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/bitTree1.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/bitTree1.png"></p>
<p>因此，添加一个附件条件：树的高度应该是平衡的、例如：每个节点的两棵子树高度差不超过 1。</p>
<pre><code>这种情况下答案唯一吗？仍然没有。</code></pre>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/bitTree2.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/bitTree2.png"></p>
<p>高度平衡意味着每次必须选择中间数字作为根节点。这对于奇数个数的数组是有用的，但对偶数个数的数组没有预定义的选择方案。</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/bitTree3.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/bitTree3.png"></p>
<p>对于偶数个数的数组，要么选择中间位置左边的元素作为根节点，要么选择中间位置右边的元素作为根节点，不同的选择方案会创建不同的平衡二叉搜索树。方法一始终选择中间位置左边的元素作为根节点，方法二始终选择中间位置右边的元素作为根节点。方法一和二会生成不同的二叉搜索树，这两种答案都是正确的。</p>
<h4 id="1、中序遍历：始终选择中间位置左边元素作为根节点"><a href="#1、中序遍历：始终选择中间位置左边元素作为根节点" class="headerlink" title="1、中序遍历：始终选择中间位置左边元素作为根节点"></a>1、中序遍历：始终选择中间位置左边元素作为根节点</h4><p>时间复杂度：O(N)，每个元素只访问一次。<br>空间复杂度：O(N)，二叉搜索树空间 O(N)，递归栈深度 O(logN)。</p>
<pre><code>class Solution:
    def sortedArrayToBST(self, nums: List[int]) -&gt; TreeNode:        
        def helper(left, right):
            if left &gt; right:
                return None

            mid=(left+right)//2
            root=TreeNode(nums[mid])
            root.left=helper(left,mid-1)
            root.right=helper(mid+1,right)
            return root

        return helper(0,len(nums)-1)</code></pre>
<h4 id="2、中序遍历：始终选择中间位置右边元素作为根节点"><a href="#2、中序遍历：始终选择中间位置右边元素作为根节点" class="headerlink" title="2、中序遍历：始终选择中间位置右边元素作为根节点"></a>2、中序遍历：始终选择中间位置右边元素作为根节点</h4><p>时间复杂度：O(N)，每个元素只访问一次。<br>空间复杂度：O(N)，二叉搜索树空间 O(N)，递归栈深度 O(logN)。</p>
<pre><code>class Solution:
    def sortedArrayToBST(self, nums: List[int]) -&gt; TreeNode:        
        def helper(left, right):
            if left &gt; right:
                return None

            mid=(left+right)//2
            if (left+right) % 2:
                mid+=1
            root=TreeNode(nums[mid])
            root.left=helper(left,mid-1)
            root.right=helper(mid+1,right)
            return root

        return helper(0,len(nums)-1)
</code></pre>
<h4 id="3、中序遍历：选择任意一个中间位置元素作为根节点"><a href="#3、中序遍历：选择任意一个中间位置元素作为根节点" class="headerlink" title="3、中序遍历：选择任意一个中间位置元素作为根节点"></a>3、中序遍历：选择任意一个中间位置元素作为根节点</h4><p>不做预定义选择，每次随机选择中间位置左边或者右边元素作为根节点。每次运行的结果都不同，但都是正确的。</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/bitTree4.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/bitTree4.png"></p>
<p>时间复杂度：O(N)，每个元素只访问一次。<br>空间复杂度：O(N)，二叉搜索树空间 O(N)，递归栈深度 O(logN)。</p>
<pre><code>from random import randint
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -&gt; TreeNode:        
        def helper(left, right):
            if left &gt; right:
                return None

            mid=(left+right)//2
            if (left+right) % 2:
                mid+=randint(0,1)
            root=TreeNode(nums[mid])
            root.left=helper(left,mid-1)
            root.right=helper(mid+1,right)
            return root

        return helper(0,len(nums)-1)
</code></pre>
<p>扩展：关于Python not 及is None的有趣现象（两者的区别）</p>
<pre><code>在使用 if A is None 来实现判断条件的时候，最后程序没有通过。这里的A代表之前定义的list类型的数据。最用改成if not A才通过。

那么到底判断A为空两者有什么区别呢。

发现A为空时，not A 就是True，但是这并不代表该对象没有定义，也不代表该对象没有其它的属性。它只是代表A中元素为空，仅此而已。

如果要看对象是否有定义，就要使用 is None来判断。

if not nums 和 if nums is None 有什么区别？
空列表, 0, None都满足第一个条件, 但是第二个只有None才满足</code></pre>
<h3 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110.平衡二叉树"></a>110.平衡二叉树</h3><pre><code>链接：https://leetcode-cn.com/problems/balanced-binary-tree/

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。

示例 1:

给定二叉树 [3,9,20,null,null,15,7]

    3
   / \
  9  20
    /  \
   15   7
返回 true 。

示例 2:

给定二叉树 [1,2,2,3,3,null,null,4,4]

       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
返回 false 。</code></pre>
<p>题解一|递归|自顶向下：</p>
<p>构造一个获取当前节点最大深度的方法 depth() ，通过比较左右子树最大高度差abs(self.depth(root.left) - self.depth(root.right))，来判断以此节点为根节点下是否是二叉平衡树；</p>
<p>从顶至底DFS，以每个节点为根节点，递归判断是否是平衡二叉树：</p>
<pre><code>若所有根节点都满足平衡二叉树性质，则返回 True ；
若其中任何一个节点作为根节点时，不满足平衡二叉树性质，则返回False。</code></pre>
<p>本方法产生大量重复的节点访问和计算，最差情况下时间复杂度 O(N^2)。</p>
<pre><code>class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def isBalanced(self, root: TreeNode) -&gt; bool:
        if root is None:
            return True
        return abs(self.height(root.left)-self.height(root.right))&lt;=1 and self.isBalanced(root.left) and self.isBalanced(root.right)

    def height(self,node):
        if not node:
            return 0
        return max(self.height(node.left),self.height(node.right))+1
</code></pre>
<p>?题解二|自底向上：</p>
<p>对二叉树做深度优先遍历DFS，递归过程中：</p>
<pre><code>终止条件：当DFS越过叶子节点时，返回高度0；
返回值：
    从底至顶，返回以每个节点root为根节点的子树最大高度(左右子树中最大的高度值加1，max(left,right) + 1)；
    当我们发现有一例 左/右子树高度差 ＞ 1 的情况时，代表此树不是平衡树，返回-1；

当发现不是平衡树时，后面的高度计算都没有意义了，因此一路返回-1，避免后续多余计算。</code></pre>
<p>最差情况是对树做一遍完整DFS，时间复杂度为 O(N)。</p>
<pre><code>class Solution:
    def isBalanced(self, root: TreeNode) -&gt; bool:
        return self.depth(root) != -1
    def depth(self,root):
        if not root:
            return 0
        left=self.depth(root.left)
        if left == -1:
            return -1
        right=self.depth(root.right)
        if right == -1:
            return -1

        return max(left,right)+1 if abs(left-right)&lt;=1 else -1</code></pre>
<h3 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111.二叉树的最小深度"></a>111.二叉树的最小深度</h3><pre><code>链接：https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

说明: 叶子节点是指没有子节点的节点。

示例:

给定二叉树 [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
返回它的最小深度  2.</code></pre>
<p>题解一|递归：</p>
<pre><code>class Solution:
    def minDepth(self, root: TreeNode) -&gt; int:
        if root is None:
            return 0
        else:
            leftHeight=self.minDepth(root.left)
            rightHeight=self.minDepth(root.right)
            if not root.left:
                return rightHeight+1
            if not root.right:
                return leftHeight+1
            return min(leftHeight,rightHeight)+1</code></pre>
<p>思路：</p>
<pre><code>1. 当 root 节点左右孩子都为空时，返回 1
2. 当 root 节点左右孩子有一个为空时，返回不为空的孩子节点的深度
3. 当 root 节点左右孩子都不为空时，返回左右孩子较小深度的节点值</code></pre>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def minDepth(self, root: TreeNode) -&gt; int:
        if not root:
            return 0
        left=self.minDepth(root.left)
        right=self.minDepth(root.right)
        if not root.left and not root.right:
            return 1
        elif not root.left or not root.right:
            if root.left:
                return left+1
            else:
                return right+1
        else:
            return min(left,right)+1</code></pre>
<p>题解二|层次遍历:</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def minDepth(self, root: TreeNode) -&gt; int:
        from collections import deque
        if root is None:
            return 0
        queue=deque()
        queue.append((root,1)) # 不能使用queue=deque((root,1))
        while queue:
            node,dep=queue.popleft()
            if not node.left and not node.right:
                return dep
            if node.left:
                queue.append((node.left,dep+1))
            if node.right:
                queue.append((node.right,dep+1))</code></pre>
<pre><code>from collections import deque
def minDepth(root):
    if not root:
        return 0
    queue=deque([root])
    depth=1
    while queue:
        size=len(queue)
        for i in range(size):
            cur=queue.pop()
            if not cur.left and not cur.right:
                return depth
            if cur.left:
                queue.appendleft(cur.left)
            if cur.right:
                queue.appendleft(cur.right)
        depth+=1
    return depth
</code></pre>
<h3 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a>114. 二叉树展开为链表</h3><pre><code>链接：https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/

给定一个二叉树，原地将它展开为一个单链表。

例如，给定二叉树

    1
   / \
  2   5
 / \   \
3   4   6
将其展开为：

1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6</code></pre>
<p>思路：</p>
<pre><code>将左子树插入到右子树的地方；
将原来的右子树接到左子树的最右边节点；
考虑新的右子树的根节点，一直重复上边的过程，直到新的右子树为 null；

    1
   / \
  2   5
 / \   \
3   4   6

//将 1 的左子树插入到右子树的地方
    1
     \
      2         5
     / \         \
    3   4         6        
//将原来的右子树接到左子树的最右边节点
    1
     \
      2          
     / \          
    3   4  
         \
          5
           \
            6

//将 2 的左子树插入到右子树的地方
    1
     \
      2          
       \          
        3       4  
                 \
                  5
                   \
                    6   

//将原来的右子树接到左子树的最右边节点
    1
     \
      2          
       \          
        3      
         \
          4  
           \
            5
             \
              6         </code></pre>
<p>题解一|递归：</p>
<pre><code>class Solution:
    def flatten(self, root: TreeNode) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify root in-place instead.
        &quot;&quot;&quot;
        if not root:
            return 
        if root.left: 
            pre=root.left # pre指向左子树
            while pre.right:
                pre=pre.right # 找到左子树的最右节点
            pre.right=root.right # 左子树的最右节点的右子树指向根节点的右子树
            root.right=root.left # 令根节点的右子树指向根节点的左子树
            root.left=None # 置空根节点的左子树
        self.flatten(root.left)
        self.flatten(root.right)</code></pre>
<p>题解二|迭代：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def flatten(self, root: TreeNode) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify root in-place instead.
        &quot;&quot;&quot;
        while root:
            if root.left:
                tmp=root.left
                while tmp.right:
                    tmp=tmp.right
                tmp.right=root.right
                root.right=root.left
                root.left=None
            root=root.right
        return </code></pre>
<h3 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a>116. 填充每个节点的下一个右侧节点指针</h3><pre><code>链接：https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/

给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

struct Node &#123;
  int val;
  Node *left;
  Node *right;
  Node *next;
&#125;
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有 next 指针都被设置为 NULL。

示例：

输入：&#123;&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:4&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:5&#125;,&quot;val&quot;:2&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:6&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;7&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7&#125;,&quot;val&quot;:3&#125;,&quot;val&quot;:1&#125;

输出：&#123;&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:null,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7&#125;,&quot;right&quot;:null,&quot;val&quot;:6&#125;,&quot;right&quot;:null,&quot;val&quot;:5&#125;,&quot;right&quot;:null,&quot;val&quot;:4&#125;,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;7&quot;,&quot;left&quot;:&#123;&quot;$ref&quot;:&quot;5&quot;&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;6&quot;&#125;,&quot;val&quot;:3&#125;,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;4&quot;&#125;,&quot;val&quot;:2&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;7&quot;&#125;,&quot;val&quot;:1&#125;

解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。

提示：

你只能使用常量级额外空间。
使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</code></pre>
<p>题解一|递归：</p>
<pre><code>&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val: int = 0, left: &#39;Node&#39; = None, right: &#39;Node&#39; = None, next: &#39;Node&#39; = None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next
&quot;&quot;&quot;
class Solution:
    def connect(self, root: &#39;Node&#39;) -&gt; &#39;Node&#39;:
        def helper(root):
            if not root:
                return
            l=root.left
            r=root.right
            while l:
                l.next=r
                l=l.right
                r=r.left
            helper(root.left)
            helper(root.right)
        helper(root)
        return root</code></pre>
<p>题解二|迭代：</p>
<pre><code>&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val: int = 0, left: &#39;Node&#39; = None, right: &#39;Node&#39; = None, next: &#39;Node&#39; = None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next
&quot;&quot;&quot;
class Solution:
    def connect(self, root: &#39;Node&#39;) -&gt; &#39;Node&#39;:
        if not root:
            return
        queue=[root]
        while queue:
            size=len(queue)
            for i in range(size):
                tmp=queue.pop(0)
                if i &lt; size-1:
                    tmp.next=queue[0]
                if tmp.left:
                    queue.append(tmp.left)
                if tmp.right:
                    queue.append(tmp.right)
        return root</code></pre>
<h3 id="117-填充每个节点的下一个右侧节点指针-II"><a href="#117-填充每个节点的下一个右侧节点指针-II" class="headerlink" title="117. 填充每个节点的下一个右侧节点指针 II"></a>117. 填充每个节点的下一个右侧节点指针 II</h3><pre><code>链接：https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/

给定一个二叉树

struct Node &#123;
  int val;
  Node *left;
  Node *right;
  Node *next;
&#125;
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有 next 指针都被设置为 NULL。

进阶：

你只能使用常量级额外空间。
使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。

示例：

输入：root = [1,2,3,4,5,null,7]
输出：[1,#,2,3,#,4,5,7,#]
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。


提示：

树中的节点数小于 6000
-100 &lt;= node.val &lt;= 100</code></pre>
<p>？？题解一|递归：</p>
<pre><code>&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val: int = 0, left: &#39;Node&#39; = None, right: &#39;Node&#39; = None, next: &#39;Node&#39; = None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next
&quot;&quot;&quot;
class Solution:
    def connect(self, root: &#39;Node&#39;) -&gt; &#39;Node&#39;:
        def helper(root):
            if not root:
                return
            if root.left:
                return root.left
            if root.right:
                return root.right
            if root.next:
                return helper(root.next)
            return

        if not root:
            return
        if root.left and root.right:
            root.left.next=root.right
            root.right.next=helper(root.next)
        elif root.left:
            root.left.next=helper(root.next)
        elif root.right:
            root.right.next=helper(root.next)

        # 注意：先递归右子树，否则右子树根节点next关系没建立好，左子树到右子树子节点无法正确挂载
        self.connect(root.right)
        self.connect(root.left)
        return root</code></pre>
<p>题解二|迭代：</p>
<pre><code>&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val: int = 0, left: &#39;Node&#39; = None, right: &#39;Node&#39; = None, next: &#39;Node&#39; = None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next
&quot;&quot;&quot;

class Solution:
    def connect(self, root: &#39;Node&#39;) -&gt; &#39;Node&#39;:
        if not root:
            return
        queue=[root]
        while queue:
            size=len(queue)
            for i in range(size):
                tmp=queue.pop(0)
                if i &lt; size-1:
                    tmp.next=queue[0]
                if tmp.left:
                    queue.append(tmp.left)
                if tmp.right:
                    queue.append(tmp.right)
        return root</code></pre>
<h3 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a>124. 二叉树中的最大路径和</h3><pre><code>链接：https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/

给定一个非空二叉树，返回其最大路径和。

本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。

示例 1:

输入: [1,2,3]

       1
      / \
     2   3

输出: 6
示例 2:

输入: [-10,9,20,null,null,15,7]

   -10
   / \
  9  20
    /  \
   15   7

输出: 42</code></pre>
<p>??题解一|递归：</p>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/solution/shou-hui-tu-jie-hen-you-ya-de-yi-dao-dfsti-by-hyj8/">https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/solution/shou-hui-tu-jie-hen-you-ya-de-yi-dao-dfsti-by-hyj8/</a></p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def maxPathSum(self, root: TreeNode) -&gt; int:
        self.ans=float(&#39;-inf&#39;)
        def helper(root):
            if not root:
                return 0
            # 递归计算左右子节点的最大贡献值
            # 只有在最大贡献值大于0时，才回选取对应子节点
            leftMax=max(0,helper(root.left))
            rightMax=max(0,helper(root.right))

            # 节点的最大路径和取决于该节点值与该节点的左右节点的最大贡献值
            price=root.val+leftMax+rightMax  

            # 更新答案
            self.ans=max(self.ans,price)

            # 返回节点的最大贡献值
            return root.val+max(leftMax,rightMax)
        helper(root)
        return self.ans</code></pre>
<h3 id="129-求根到叶子节点数字之和"><a href="#129-求根到叶子节点数字之和" class="headerlink" title="129. 求根到叶子节点数字之和"></a>129. 求根到叶子节点数字之和</h3><pre><code>链接：https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/

给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。

例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。

计算从根到叶子节点生成的所有数字之和。

说明: 叶子节点是指没有子节点的节点。

示例 1:

输入: [1,2,3]
    1
   / \
  2   3
输出: 25
解释:
从根到叶子节点路径 1-&gt;2 代表数字 12.
从根到叶子节点路径 1-&gt;3 代表数字 13.
因此，数字总和 = 12 + 13 = 25.
示例 2:

输入: [4,9,0,5,1]
    4
   / \
  9   0
 / \
5   1
输出: 1026
解释:
从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495.
从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491.
从根到叶子节点路径 4-&gt;0 代表数字 40.
因此，数字总和 = 495 + 491 + 40 = 1026.</code></pre>
<p>题解一|递归：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def sumNumbers(self, root: TreeNode) -&gt; int:
        res=[]
        def helper(root,tmp=&#39;&#39;):
            if not root:
                return 
            if not root.left and not root.right:
                tmp+=str(root.val)
                res.append(tmp)
            helper(root.left,tmp+str(root.val))
            helper(root.right,tmp+str(root.val))
        helper(root)
        ans=0
        for i in res:
            ans+=int(i)
        return ans</code></pre>
<h3 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144.二叉树的前序遍历"></a>144.二叉树的前序遍历</h3><pre><code>链接：https://leetcode-cn.com/problems/binary-tree-preorder-traversal/

给定一个二叉树，返回它的 前序 遍历。

 示例:

输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [1,2,3]
进阶: 递归算法很简单，你可以通过迭代算法完成吗？</code></pre>
<p>题解一|递归：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def preorderTraversal(self, root: TreeNode) -&gt; List[int]:
        ans=[]
        if root:
            ans.append(root.val)
            ans+=self.preorderTraversal(root.left) # 这儿我之前直接用append，出来的结果会列表中嵌套列表
            ans+=self.preorderTraversal(root.right)
        return ans</code></pre>
<p>题解二|迭代|辅助栈|后进先出：</p>
<p>1、把二叉树的根节点 root 放进栈。</p>
<p>2、如果栈不为空，从栈中取出一个节点，把该节点放入容器的尾部；如果该节点的右子树不为空，则把有节点放入栈；如果该节点的左子树不为空，则把左子树放入栈中。</p>
<p>3、一直重复步骤 2 ，直到栈为空，此时遍历结束。</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def preorderTraversal(self, root: TreeNode) -&gt; List[int]:
        res=[]
        stack=[]
        stack.append(root)
        if root is None:
            return res
        while stack:
            tmp=stack.pop()
            res.append(tmp.val)
            if tmp.right:
                stack.append(tmp.right)
            if tmp.left:
                stack.append(tmp.left)
        return res</code></pre>
<p>题解三|迭代：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def preorderTraversal(self, root: TreeNode) -&gt; List[int]:
        res=[]
        stack=[]
        curr=root
        while stack or curr:
            if curr:
                res.append(curr.val)
                stack.append(curr.right)
                curr=curr.left
            else:
                curr=stack.pop()
        return res</code></pre>
<h3 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145.二叉树的后序遍历"></a>145.二叉树的后序遍历</h3><pre><code>链接：

给定一个二叉树，返回它的 后序 遍历。

示例:

输入: [1,null,2,3]  
   1
    \
     2
    /
   3 

输出: [3,2,1]
进阶: 递归算法很简单，你可以通过迭代算法完成吗？</code></pre>
<p>题解一|递归:</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def postorderTraversal(self, root: TreeNode) -&gt; List[int]:
        res=[]
        if root:
            res=self.postorderTraversal(root.left)
            res+=self.postorderTraversal(root.right)
            res.append(root.val)
        return res</code></pre>
<p>题解二|迭代|辅助栈：</p>
<p>1、把二叉树的根节点 root 放进栈。</p>
<p>2、如果栈不为空，从栈中取出一个节点，把该节点插入到容器的头部。；如果该节点的左子树不为空，则把该左子树放入栈中；如果该节点的右子树不为空，则把右子树放入栈中。，</p>
<p>注意，之前的前序遍历和中序遍历，我们都是用 ArrayList 容器，并且是把节点插入到容器的尾部，这就是后序遍历的不同点。</p>
<p>3、一直重复步骤 2 ，直到栈为空，此时遍历结束。</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def postorderTraversal(self, root: TreeNode) -&gt; List[int]:
        res=[]
        stack=[]
        if root is None:
            return res
        stack.append(root)
        while stack:
            tmp=stack.pop()
            res.insert(0,tmp.val)
            if tmp.left:
                stack.append(tmp.left)
            if tmp.right:
                stack.append(tmp.right)
        return res</code></pre>
<p>题解三|递归：</p>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--34/">https://leetcode-cn.com/problems/binary-tree-postorder-traversal/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--34/</a></p>
<p>如果当前节点的右节点和上一次遍历的节点相同，那就表明当前是从右节点过来的了。</p>
<pre><code>class Solution:
    def postorderTraversal(self, root: TreeNode) -&gt; List[int]:
        res=[]
        stack=[]
        cur=root
        last=None

        while cur or stack:
            if cur:
                stack.append(cur)
                cur=cur.left
            else:
                tmp=stack[-1]
                # 是否变到右子树
                if tmp.right and tmp.right !=last:
                    cur=tmp.right
                else:
                    res.append(tmp.val)
                    last=tmp
                    stack.pop()
        return res
</code></pre>
<h3 id="173-二叉搜索树迭代器"><a href="#173-二叉搜索树迭代器" class="headerlink" title="173. 二叉搜索树迭代器"></a>173. 二叉搜索树迭代器</h3><pre><code>链接：https://leetcode-cn.com/problems/binary-search-tree-iterator/

实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。

调用 next() 将返回二叉搜索树中的下一个最小的数。

示例：

BSTIterator iterator = new BSTIterator(root);
iterator.next();    // 返回 3
iterator.next();    // 返回 7
iterator.hasNext(); // 返回 true
iterator.next();    // 返回 9
iterator.hasNext(); // 返回 true
iterator.next();    // 返回 15
iterator.hasNext(); // 返回 true
iterator.next();    // 返回 20
iterator.hasNext(); // 返回 false


提示：

next() 和 hasNext() 操作的时间复杂度是 O(1)，并使用 O(h) 内存，其中 h 是树的高度。
你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 中至少存在一个下一个最小的数。</code></pre>
<p>题解一|扁平化二叉搜索树：</p>
<p>时间复杂度：</p>
<p>构造迭代器花费的时间为 O(N)，问题陈述只要求我们分析两个函数的复杂性，但是在实现类时，还要注意初始化类对象所需的时间；在这种情况下，时间复杂度与二叉搜索树中的节点数成线性关系。</p>
<pre><code>next()：O(1)
hasNext()：O(1)</code></pre>
<p>空间复杂度：</p>
<p>O(N)，由于我们创建了一个数组来包含二叉搜索树中的所有节点值，这不符合问题陈述中的要求，任一函数的最大空间复杂度应为 O(h)，其中 h 指的是树的高度，对于平衡的二叉搜索树，高度通常为 logN。</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class BSTIterator:

    def __init__(self, root: TreeNode):
        self.queue=[]
        self.index=-1
        self.inorder(root)

    def inorder(self,root):
        if not root:
            return
        self.inorder(root.left)
        self.queue+=[root.val] # self.queue.append([root.val])
        self.inorder(root.right)

    def next(self) -&gt; int:
        &quot;&quot;&quot;
        @return the next smallest number
        &quot;&quot;&quot;
        self.index+=1
        return self.queue[self.index]

    def hasNext(self) -&gt; bool:
        &quot;&quot;&quot;
        @return whether we have a next smallest number
        &quot;&quot;&quot;
        return self.index+1 &lt; len(self.queue)

# Your BSTIterator object will be instantiated and called as such:
# obj = BSTIterator(root)
# param_1 = obj.next()
# param_2 = obj.hasNext()</code></pre>
<p>题解二|受控递归：</p>
<p>时间复杂度：</p>
<pre><code>hasNext()：若栈中还有元素，则返回 true，反之返回 false。所以这是一个 O(1) 的操作。

next()：包含了两个主要步骤。一个是从栈中弹出一个元素，它是下一个最小的元素。这是一个 O(1) 的操作。然而，随后我们要调用帮助函数 _inorder_left ，它需要递归的，将左节点添加到栈上，是线性时间的操作，最坏的情况下为 O(N)。但是我们只对含有右节点的节点进行调用，它也不会总是处理 N 个节点。只有当我们有一个倾斜的树，才会有 N 个节点。因此该操作的平均时间复杂度仍然是 O(1)，符合问题中所要求的。</code></pre>
<p>空间复杂度：O(h)，使用了一个栈来模拟递归。</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class BSTIterator:

    def __init__(self, root: TreeNode):
        self.queue=[]
        self.inorder(root)

    def inorder(self,root):
        while root:
            self.queue.append(root)
            root=root.left

    def next(self) -&gt; int:
        &quot;&quot;&quot;
        @return the next smallest number
        &quot;&quot;&quot;
        top=self.queue.pop()
        if top.right:
            self.inorder(top.right)
        return top.val

    def hasNext(self) -&gt; bool:
        &quot;&quot;&quot;
        @return whether we have a next smallest number
        &quot;&quot;&quot;
        return len(self.queue) &gt; 0



# Your BSTIterator object will be instantiated and called as such:
# obj = BSTIterator(root)
# param_1 = obj.next()
# param_2 = obj.hasNext()</code></pre>
<h3 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a>199. 二叉树的右视图</h3><pre><code>链接：https://leetcode-cn.com/problems/binary-tree-right-side-view/

给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

示例:

输入: [1,2,3,null,5,null,4]
输出: [1, 3, 4]
解释:

   1            &lt;---
 /   \
2     3         &lt;---
 \     \
  5     4       &lt;---</code></pre>
<p>题解一|递归：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def rightSideView(self, root: TreeNode) -&gt; List[int]:
        res=[]
        def helper(root,level):
            if not root:
                return []
            if level &gt; len(res):
                res.append(root.val)
            helper(root.right,level+1)
            helper(root.left,level+1)
        helper(root,1)
        return res</code></pre>
<p>题解二|广度优先搜索：</p>
<p>时间复杂度 : O(n)。 每个节点最多进队列一次，出队列一次，因此广度优先搜索的复杂度为线性。</p>
<p>空间复杂度 : O(n)。每个节点最多进队列一次，所以队列长度最大不不超过 n，所以这里的空间代价为 O(n)。</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def rightSideView(self, root):
        right=dict()
        max_depth=-1
        queue=[(root,0)]
        while queue:
            node,depth=queue.pop(0)
            if node:
                max_depth=max(max_depth,depth)
                right[depth]=node.val
                queue.append((node.left,depth+1))
                queue.append((node.right,depth+1))
        return [right[i] for i in range(max_depth+1)]</code></pre>
<p>题解三|深度优先搜索：</p>
<p>时间复杂度 : O(n)。深度优先搜索最多访问每个结点一次，因此是线性复杂度。</p>
<p>空间复杂度 : O(n)。最坏情况下，栈内会包含接近树高度的结点数量，占用 O(n) 的空间。</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def rightSideView(self, root):
        right=dict()
        max_depth=-1
        queue=[(root,0)]
        while queue:
            node,depth=queue.pop()
            if node:
                max_depth=max(max_depth,depth)
                right.setdefault(depth,node.val)
                queue.append((node.left,depth+1))
                queue.append((node.right,depth+1))
        return [right[i] for i in range(max_depth+1)]</code></pre>
<h3 id="222-完全二叉树的节点个数"><a href="#222-完全二叉树的节点个数" class="headerlink" title="222.完全二叉树的节点个数"></a>222.完全二叉树的节点个数</h3><pre><code>链接：https://leetcode-cn.com/problems/count-complete-tree-nodes/

给出一个完全二叉树，求出该树的节点个数。

说明：

完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。

示例:

输入: 
    1
   / \
  2   3
 / \  /
4  5 6

输出: 6</code></pre>
<p>题解一|递归：</p>
<p>时间复杂度：O(N)。<br>空间复杂度：O(logN)，其中 d 指的是树的的高度，运行过程中堆栈所使用的空间。</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def countNodes(self, root: TreeNode) -&gt; int:

        self.res=0
        def helper(root):
            if not root:
                return 0
            if root:
                self.res+=1
            helper(root.left)
            helper(root.right)
            return self.res
        helper(root)

        return self.res</code></pre>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def __init__(self):
        self.res=0
    def countNodes(self, root: TreeNode) -&gt; int:
        if not root:
            return 0
        self.res+=1
        self.countNodes(root.left)
        self.countNodes(root.right)
        return self.res</code></pre>
<pre><code>class Solution:
    def countNodes(self, root: TreeNode) -&gt; int:
        return 1 + self.countNodes(root.right) + self.countNodes(root.left) if root else 0</code></pre>
<h3 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a>226. 翻转二叉树</h3><pre><code>链接：https://leetcode-cn.com/problems/invert-binary-tree/

翻转一棵二叉树。

示例：

输入：

     4
   /   \
  2     7
 / \   / \
1   3 6   9
输出：

     4
   /   \
  7     2
 / \   / \
9   6 3   1
备注:
这个问题是受到 Max Howell 的 原问题 启发的 ：

谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。</code></pre>
<p>题解一|递归：</p>
<p>交换一下左右节点，然后再递归的交换左节点，右节点。</p>
<p>递归的两个条件：</p>
<pre><code>终止条件：当前节点为null时返回
交换当前节点的左右节点，再递归的交换当前节点的左节点，递归的交换当前节点的右节点</code></pre>
<p>时间复杂度：每个元素都必须访问一次，所以是O(n)<br>空间复杂度：最坏的情况下，需要存放O(h)个函数调用(h是树的高度)，所以是O(h)</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def invertTree(self, root: TreeNode) -&gt; TreeNode:
        if not root:
            return
        root.left,root.right=self.invertTree(root.right),self.invertTree(root.left)
        return root</code></pre>
<pre><code>class Solution:
    def invertTree(self, root: TreeNode) -&gt; TreeNode:
        if not root:
            return
        root.left,root.right=root.right,root.left
        self.invertTree(root.left)
        self.invertTree(root.right)
        return root</code></pre>
<p>题解二|迭代|广度优先遍历）：</p>
<p>递归实现也就是深度优先遍历的方式，那么对应的就是广度优先遍历。</p>
<p>广度优先遍历需要额外的数据结构–队列，来存放临时遍历到的元素。</p>
<p>深度优先遍历的特点是一竿子插到底，不行了再退回来继续；而广度优先遍历的特点是层层扫荡。<br>所以，我们需要先将根节点放入到队列中，然后不断的迭代队列中的元素。<br>对当前元素调换其左右子树的位置，然后：</p>
<pre><code>判断其左子树是否为空，不为空就放入队列中
判断其右子树是否为空，不为空就放入队列中</code></pre>
<p>时间复杂度：同样每个节点都需要入队列/出队列一次，所以是O(n)<br>空间复杂度：最坏的情况下会包含所有的叶子节点，完全二叉树叶子节点是n/2个，所以时间复杂度是0(n)</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def invertTree(self, root: TreeNode) -&gt; TreeNode:
        if not root:
            return
        queue=[root] # 将二叉树中的节点逐层放入队列中，再迭代处理队列中的元素
        while queue:
            tmp=queue.pop(0) # 每次都从队列中拿一个节点，并交换这个节点的左右子树
            tmp.left,tmp.right=tmp.right,tmp.left
            if tmp.left: # 如果当前节点的左子树不为空，则放入队列等待后续处理 
                queue.append(tmp.left)
            if tmp.right: # 如果当前节点的右子树不为空，则放入队列等待后续处理    
                queue.append(tmp.right)
        return root # 返回处理完的根节点</code></pre>
<h3 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230. 二叉搜索树中第K小的元素"></a>230. 二叉搜索树中第K小的元素</h3><pre><code>给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。

说明：
你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。

示例 1:

输入: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
输出: 1
示例 2:

输入: root = [5,3,6,2,4,null,null,1], k = 3
       5
      / \
     3   6
    / \
   2   4
  /
 1
输出: 3
进阶：
如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化 kthSmallest 函数？</code></pre>
<p>题解一|递归|中序遍历：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthSmallest(self, root: TreeNode, k: int) -&gt; int:
        res=[]
        def inorder(root):
            if not root:
                return []
            return inorder(root.left)+[root.val]+inorder(root.right)
        return inorder(root)[k-1]</code></pre>
<p>题解二|迭代：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthSmallest(self, root: TreeNode, k: int) -&gt; int:
        stack=[]
        while True:
            while root:
                stack.append(root)
                root=root.left
            root=stack.pop()
            k-=1
            if not k:
                return root.val
            root=root.right</code></pre>
<h3 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a>235. 二叉搜索树的最近公共祖先</h3><pre><code>链接：https://leetcode-cn.com/problems/
lowest-common-ancestor-of-a-binary-search-tree/

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]

示例 1:

输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6 
解释: 节点 2 和节点 8 的最近公共祖先是 6。
示例 2:

输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
输出: 2
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。


说明:

所有节点的值都是唯一的。
p、q 为不同节点且均存在于给定的二叉搜索树中。</code></pre>
<p>题解一|递归：</p>
<p>思路：</p>
<pre><code>1、从根节点开始遍历树
2、如果节点 p 和节点 q 都在右子树上，那么以右孩子为根节点继续 1 的操作
3、如果节点 p 和节点 q 都在左子树上，那么以左孩子为根节点继续 1 的操作
4、如果条件 2 和条件 3 都不成立，这就意味着我们已经找到节 p 和节点 q 的 最近公共祖先(LCA) 了</code></pre>
<p>时间复杂度：O(N)<br>其中 N 为 BST 中节点的个数，在最坏的情况下我们可能需要访问 BST 中所有的节点。</p>
<p>空间复杂度：O(N)<br>所需开辟的额外空间主要是递归栈产生的，之所以是 N 是因为 BST 的高度为 N。</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: &#39;TreeNode&#39;, p: &#39;TreeNode&#39;, q: &#39;TreeNode&#39;) -&gt; &#39;TreeNode&#39;:
        if not root:
            return
        if p.val &lt; root.val and q.val &lt; root.val:
            return self.lowestCommonAncestor(root.left,p,q)
        elif p.val &gt; root.val and q.val &gt; root.val:
            return self.lowestCommonAncestor(root.right,p,q)
        else:
            return root</code></pre>
<p>题解二|迭代：</p>
<p>时间复杂度：O(N)<br>其中 NN 为 BST 中节点的个数，在最坏的情况下我们可能需要遍历 BST 中所有的节点。</p>
<p>空间复杂度：O(1)</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: &#39;TreeNode&#39;, p: &#39;TreeNode&#39;, q: &#39;TreeNode&#39;) -&gt; &#39;TreeNode&#39;:
        if not root:
            return
        while root:
            if p.val &lt; root.val and q.val &lt; root.val:
                root=root.left
            elif p.val &gt; root.val and q.val &gt; root.val:
                root=root.right
            else:
                return root</code></pre>
<h3 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a>236. 二叉树的最近公共祖先</h3><pre><code>链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]

示例 1:

输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
示例 2:

输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出: 5
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。

说明:

所有节点的值都是唯一的。
p、q 为不同节点且均存在于给定的二叉树中。</code></pre>
<p>题解一|递归：</p>
<p>最近公共祖先的定义： 设节点 root 为节点 p, q 的某公共祖先，若其左子节点 root.left 和右子节点 root.right 都不是 p,q 的公共祖先，则称 root 是 “最近的公共祖先” 。</p>
<p>根据以上定义，若 root 是 p, q 的 最近公共祖先 ，则只可能为以下情况之一：</p>
<p>p 和 q 在 root 的子树中，且分列 root 的 异侧（即分别在左、右子树中）；<br>p = root ，且 q 在 root 的左或右子树中；<br>q = root ，且 p 在 root 的左或右子树中；</p>
<p>递归解析：</p>
<p>1、终止条件：</p>
<pre><code>当越过叶节点，则直接返回 null ；
当 root 等于 p, q，则直接返回 root ；</code></pre>
<p>2、递推工作：</p>
<pre><code>开启递归左子节点，返回值记为 left ；
开启递归右子节点，返回值记为 right ；</code></pre>
<p>3、返回值： 根据 left 和 right ，可展开为四种情况；</p>
<pre><code>(1)当 left 和 right 同时为空 ：说明 root 的左/右子树中都不包含 p,q ，返回 null ；
(2)当 left 和 right 同时不为空 ：说明 p, q 分列在 root 的 异侧 （分别在 左 / 右子树），因此 root 为最近公共祖先，返回 root ；
(3)当 left 为空 ，right 不为空 ：p,q 都不在 root 的左子树中，直接返回 right。具体可分为两种情况：

    p,q 其中一个在 root 的 右子树 中，此时 right 指向 p（假设为 p ）；
    p,q 两节点都在 root 的 右子树 中，此时的 right 指向 最近公共祖先节点 ；

(4)当 left 不为空 ， right 为空 ：与情况 3. 同理；</code></pre>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: &#39;TreeNode&#39;, p: &#39;TreeNode&#39;, q: &#39;TreeNode&#39;) -&gt; &#39;TreeNode&#39;:
        if not root or root == p or root == q:
            return root
        left=self.lowestCommonAncestor(root.left,p,q)
        right=self.lowestCommonAncestor(root.right,p,q)
        if left and right: # 1
            return root
        elif not left and not right: # 2
            return 
        elif not left:  # 3
            return right
        elif not right: # 4
            return left</code></pre>
<h3 id="257-二叉树的所有路径"><a href="#257-二叉树的所有路径" class="headerlink" title="257. 二叉树的所有路径"></a>257. 二叉树的所有路径</h3><pre><code>链接：https://leetcode-cn.com/problems/binary-tree-paths/

给定一个二叉树，返回所有从根节点到叶子节点的路径。

说明: 叶子节点是指没有子节点的节点。
示例:

输入:

   1
 /   \
2     3
 \
  5

输出: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]

解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3</code></pre>
<p><a target="_blank" rel="noopener" href="https://www.dazhuanlan.com/2019/10/18/5da9456f33ee7/">https://www.dazhuanlan.com/2019/10/18/5da9456f33ee7/</a></p>
<p>题解一|递归：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def binaryTreePaths(self, root: TreeNode) -&gt; List[str]:
        if not root:
            return []
        res=[]
        def helper(root,path):
            if not root.left and not root.right:
                res.append(path)
            if root.left:
                helper(root.left,path+&#39;-&gt;&#39;+str(root.left.val))
            if root.right:
                helper(root.right,path+&#39;-&gt;&#39;+str(root.right.val))
        helper(root,&#39;&#39;+str(root.val))
        return res</code></pre>
<p>题解二|回溯：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def binaryTreePaths(self, root: TreeNode) -&gt; List[str]:
        res=[]
        def helper(root,path):
            if root:
                path.append(str(root.val))
                left=helper(root.left,path)
                right=helper(root.right,path)
                if not left and not right:
                    res.append(&#39;-&gt;&#39;.join(path))
                path.pop()
                return True  # 别漏掉

        helper(root,[])
        return res</code></pre>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def binaryTreePaths(self, root: TreeNode) -&gt; List[str]:
        if not root:
            return []
        res=[]
        def helper(node,path):
            path.append(str(node.val))
            if not node.left and not node.right:
                res.append(&#39;-&gt;&#39;.join(path))
                return 
            if node.left:
                helper(node.left,path)
                path.pop()
            if node.right:
                helper(node.right,path)
                path.pop()
        helper(root,[])
        return res</code></pre>
<h3 id="404-左叶子之和"><a href="#404-左叶子之和" class="headerlink" title="404. 左叶子之和"></a>404. 左叶子之和</h3><pre><code>链接：https://leetcode-cn.com/problems/sum-of-left-leaves/

计算给定二叉树的所有左叶子之和。

示例：

    3
   / \
  9  20
    /  \
   15   7

在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</code></pre>
<p>题解一|递归：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def sumOfLeftLeaves(self, root: TreeNode) -&gt; int:
        if not root:
            return 0
        self.res=0
        def helper(root):
            if not root:
                return 0
            # 注意：是左叶子，而不是左节点。
            if root.left and not root.left.left and not root.left.right: 
                self.res+=root.left.val
            helper(root.left)
            helper(root.right)
        helper(root)
        return self.res</code></pre>
<pre><code>class Solution:
    def sumOfLeftLeaves(self, root: TreeNode) -&gt; int:
        if not root:
            return 0
        sum = 0
        if root.left and not root.left.left and not root.left.right:
        # if root.left: 题目是左叶子，并非左结点。
            sum += root.left.val
        sum += self.sumOfLeftLeaves(root.left)
        sum += self.sumOfLeftLeaves(root.right)
        return sum</code></pre>
<p>题解二|迭代：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def sumOfLeftLeaves(self, root: TreeNode) -&gt; int:
        if not root:
            return 0
        stack=[root]
        res=0
        while stack:
            node=stack.pop()
            if node:
                if node.left and not node.left.left and not node.left.right:
                    res+=node.left.val
                stack.append(node.left)
                stack.append(node.right)
        return res</code></pre>
<h3 id="429-N叉树的层序遍历"><a href="#429-N叉树的层序遍历" class="headerlink" title="429. N叉树的层序遍历"></a>429. N叉树的层序遍历</h3><pre><code>给定一个 N 叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。

例如，给定一个 3叉树 :

返回其层序遍历:

[
     [1],
     [3,2,4],
     [5,6]
]

说明:

树的深度不会超过 1000。
树的节点总数不会超过 5000。</code></pre>
<p>题解一|迭代：</p>
<pre><code>&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
&quot;&quot;&quot;

class Solution:
    def levelOrder(self, root: &#39;Node&#39;) -&gt; List[List[int]]:
        if not root:
            return
        res=[]
        stack=[root]
        depth=0
        while stack:
            res.append([])
            for i in range(len(stack)):
                root=stack.pop(0)
                res[depth].append(root.val)
                for i in root.children:
                    stack.append(i)
            depth+=1
        return res</code></pre>
<pre><code>&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
&quot;&quot;&quot;

class Solution:
    def levelOrder(self, root: &#39;Node&#39;) -&gt; List[List[int]]:
        if not root:
            return
        res=[]
        stack=[root]
        depth=0
        while stack:
            res.append([])
            for i in range(len(stack)):
                root=stack.pop(0)
                res[depth].append(root.val)
                stack.extend(root.children)
                # for i in root.children:
                #     stack.append(i)
            depth+=1
        return res</code></pre>
<pre><code>&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
&quot;&quot;&quot;

class Solution:
    def levelOrder(self, root: &#39;Node&#39;) -&gt; List[List[int]]:
        if not root:
            return
        res=[]
        stack=[root]
        while stack:
            tmp=[]
            for i in range(len(stack)):
                root=stack.pop(0)
                tmp.append(root.val)
                stack.extend(root.children)
            res.append(tmp)
        return res</code></pre>
<pre><code>&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
&quot;&quot;&quot;

class Solution:
    def levelOrder(self, root: &#39;Node&#39;) -&gt; List[List[int]]:
        if not root:
            return
        res=[]
        stack=[root]
        while stack:
            tmp=[]
            res.append([])
            for i in stack:
                res[-1].append(i.val)
                tmp.extend(i.children)
            stack=tmp
        return res</code></pre>
<p>题解二|递归：</p>
<pre><code>&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
&quot;&quot;&quot;
class Solution:
    def levelOrder(self, root: &#39;Node&#39;) -&gt; List[List[int]]:
        res=[]
        def helper(node,depth):
            if not root:
                return
            if len(res)==depth:
                res.append([])
            res[depth].append(node.val)
            for i in node.children:
                helper(i,depth+1)
        helper(root,0)
        return res</code></pre>
<h3 id="501-二叉搜索树中的众数"><a href="#501-二叉搜索树中的众数" class="headerlink" title="501. 二叉搜索树中的众数"></a>501. 二叉搜索树中的众数</h3><pre><code>链接：https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/

给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。

假定 BST 有如下定义：

结点左子树中所含结点的值小于等于当前结点的值
结点右子树中所含结点的值大于等于当前结点的值
左子树和右子树都是二叉搜索树
例如：
给定 BST [1,null,2,2],

   1
    \
     2
    /
   2
返回[2].

提示：如果众数超过1个，不需考虑输出顺序

进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</code></pre>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def findMode(self, root: TreeNode) -&gt; List[int]:
        hash=&#123;&#125;
        def helper(root):
            if root:
                if root.val not in hash:
                    hash[root.val]=1
                else:
                    hash[root.val]+=1
                helper(root.left)
                helper(root.right)

        helper(root)
        res=[]
        if not root:
            return 
        count=max(hash.values())
        for k,v in hash.items():
            if count==v:
                res.append(k)
        return res</code></pre>
<p>题解二|二叉搜索树处理：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def findMode(self, root: TreeNode) -&gt; List[int]:
        self.maxTimes=1
        self.curTimes=0
        self.lastNode=None
        self.ans=[]
        def helper(node):
            if node:
                helper(node.left)
                if self.lastNode and self.lastNode.val == node.val:
                    self.curTimes+=1
                else:
                    self.curTimes=1
                self.lastNode=node
                if self.curTimes == self.maxTimes:
                    self.ans.append(node.val)
                elif self.curTimes &gt; self.maxTimes:
                    self.ans=[]
                    self.maxTimes=self.curTimes
                    self.ans.append(node.val)
                helper(node.right)
        helper(root)
        return self.ans</code></pre>
<p>题解三|普通二叉树处理：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def findMode(self, root: TreeNode) -&gt; List[int]:
        self.maxTimes=1
        self.hash=dict()
        self.ans=set()
        def helper(node):
            if node:
                helper(node.left)
                num=self.hash.get(node.val,0)+1
                self.hash[node.val]=num
                if num== self.maxTimes:                                             
                    self.ans.add(node.val)
                elif num &gt; self.maxTimes:
                    self.ans.clear()
                    self.ans.add(node.val)
                    self.maxTimes=num
                helper(node.right)
        helper(root)
        return self.ans        </code></pre>
<h3 id="530-二叉搜索树的最小绝对差"><a href="#530-二叉搜索树的最小绝对差" class="headerlink" title="530. 二叉搜索树的最小绝对差"></a>530. 二叉搜索树的最小绝对差</h3><pre><code>链接：https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/
给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。

示例：

输入：

   1
    \
     3
    /
   2

输出：
1

解释：
最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。

提示：

树中至少有 2 个节点。
本题与 783 https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/ 相同</code></pre>
<p>题解一|中序遍历：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def getMinimumDifference(self, root: TreeNode) -&gt; int:
        def inOrder(root):
            if not root:
                return []
            return inOrder(root.left)+[root.val]+inOrder(root.right)
        tmp=inOrder(root)
        res=float(&#39;inf&#39;)
        for i in range(1,len(tmp)):
            res=min(res,tmp[i]-tmp[i-1])
        return res</code></pre>
<h3 id="538-把二叉搜索树转换为累加树"><a href="#538-把二叉搜索树转换为累加树" class="headerlink" title="538. 把二叉搜索树转换为累加树"></a>538. 把二叉搜索树转换为累加树</h3><pre><code>链接：https://leetcode-cn.com/problems/convert-bst-to-greater-tree/

给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。

例如：

输入: 原始二叉搜索树:
              5
            /   \
           2     13

输出: 转换为累加树:
             18
            /   \
          20     13</code></pre>
<p>题解一|递归|后序遍历：</p>
<pre><code>class Solution:
    def convertBST(self, root: TreeNode) -&gt; TreeNode:
        self.sum=0
        def helper(root):
            if not root:
                return
            helper(root.right)
            self.sum+=root.val
            root.val=self.sum
            helper(root.left)
        helper(root)
        return root</code></pre>
<p>题解二|迭代|后序遍历：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def convertBST(self, root: TreeNode) -&gt; TreeNode:
        sum,stack,node=0,[],root
        while stack or node:
            while node:
                stack.append(node)
                node=node.right
            node=stack.pop()
            sum+=node.val
            node.val=sum
            node=node.left
        return root</code></pre>
<h3 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a>543. 二叉树的直径</h3><pre><code>链接：https://leetcode-cn.com/problems/diameter-of-binary-tree/

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

示例 :
给定二叉树

          1
         / \
        2   3
       / \     
      4   5    
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

注意：两结点之间的路径长度是以它们之间边的数目表示。</code></pre>
<p>题解一|递归：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -&gt; int:
        self.res=0
        def helper(root):
            if not root:
                return 0
            left=helper(root.left)
            right=helper(root.right)
            self.res=max(self.res,left+right) # 每个结点都要去判断左子树+右子树的高度是否大于self.max，更新最大值
            return max(left,right)+1
        helper(root)
        return self.res</code></pre>
<h3 id="559-N叉树的最大深度"><a href="#559-N叉树的最大深度" class="headerlink" title="559. N叉树的最大深度"></a>559. N叉树的最大深度</h3><pre><code>链接：https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/

给定一个 N 叉树，找到其最大深度。

最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。

例如，给定一个 3叉树 :

我们应返回其最大深度，3。

说明:

树的深度不会超过 1000。
树的节点总不会超过 5000。</code></pre>
<p>题解一|递归：</p>
<pre><code>&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
&quot;&quot;&quot;

class Solution:
    def maxDepth(self, root: &#39;Node&#39;) -&gt; int:
        if not root:
            return 0
        elif not root.children:
            return 1
        else:
            height=[ self.maxDepth(i) for i in root.children]
            return max(height)+1</code></pre>
<p>题解二|迭代：</p>
<pre><code>&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
&quot;&quot;&quot;

class Solution:
    def maxDepth(self, root: &#39;Node&#39;) -&gt; int:
        stack=[]
        if root:
            stack.append((1,root))
        depth=0
        while stack:
            cur,root=stack.pop()
            if root:
                depth=max(depth,cur)
                for i in root.children:
                    stack.append((cur+1,i))
        return depth</code></pre>
<h3 id="563-二叉树的坡度"><a href="#563-二叉树的坡度" class="headerlink" title="563. 二叉树的坡度"></a>563. 二叉树的坡度</h3><pre><code>链接：https://leetcode-cn.com/problems/binary-tree-tilt/
给定一个二叉树，计算整个树的坡度。

一个树的节点的坡度定义即为，该节点左子树的结点之和和右子树结点之和的差的绝对值。空结点的的坡度是0。

整个树的坡度就是其所有节点的坡度之和。

示例：

输入：
         1
       /   \
      2     3
输出：1
解释：
结点 2 的坡度: 0
结点 3 的坡度: 0
结点 1 的坡度: |2-3| = 1
树的坡度 : 0 + 0 + 1 = 1

提示：

任何子树的结点的和不会超过 32 位整数的范围。
坡度的值不会超过 32 位整数的范围。</code></pre>
<p>题解一|递归：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def findTilt(self, root: TreeNode) -&gt; int:
        self.res=0
        def helper(root):
            if not root:
                return 0
            left = helper(root.left)
            right = helper(root.right)
            self.res+=abs(left-right)
            return left+right+root.val

        helper(root)
        return self.res</code></pre>
<h3 id="572-另一个树的子树"><a href="#572-另一个树的子树" class="headerlink" title="572. 另一个树的子树"></a>572. 另一个树的子树</h3><pre><code>链接：https://leetcode-cn.com/problems/subtree-of-another-tree/

给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。

示例 1:
给定的树 s:

     3
    / \
   4   5
  / \
 1   2
给定的树 t：

   4 
  / \
 1   2
返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。

示例 2:
给定的树 s：

     3
    / \
   4   5
  / \
 1   2
    /
   0
给定的树 t：

   4
  / \
 1   2
返回 false。</code></pre>
<p>题解一|递归：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSubtree(self, s: TreeNode, t: TreeNode) -&gt; bool:
        def helper(s,t):
            if not s and not t:
                return True
            if not s or not t:
                return False
            if s.val != t.val:
                return False
            return helper(s.left,t.left) and helper(s.right,t.right)
        if not s and not t:
            return True
        if not s or not t:
            return False
        return helper(s,t) or self.isSubtree(s.left,t) or self.isSubtree(s.right,t)</code></pre>
<h3 id="589-N叉树的前序遍历"><a href="#589-N叉树的前序遍历" class="headerlink" title="589. N叉树的前序遍历"></a>589. N叉树的前序遍历</h3><pre><code>链接：https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/

给定一个 N 叉树，返回其节点值的前序遍历。

例如，给定一个 3叉树 :

返回其前序遍历: [1,3,5,6,2,4]。  

说明: 递归法很简单，你可以使用迭代法完成此题吗?</code></pre>
<p>题解一|递归：</p>
<pre><code>&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
&quot;&quot;&quot;
class Solution:
    def preorder(self, root: &#39;Node&#39;) -&gt; List[int]:
        ans=[]
        if root:
            ans.append(root.val)
            for i in root.children:
                ans+=self.preorder(i)
        return ans</code></pre>
<pre><code>&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
&quot;&quot;&quot;
class Solution:
    def preorder(self, root: &#39;Node&#39;) -&gt; List[int]:
        if not root:
            return 
        res=[]
        def helper(root):
            if not root:
                return
            res.append(root.val)
            for i in root.children:
                helper(i)
        helper(root)
        return res
</code></pre>
<p>题解二|迭代：</p>
<pre><code>&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
&quot;&quot;&quot;
class Solution:
    def preorder(self, root: &#39;Node&#39;) -&gt; List[int]:
        if not root:
            return
        stack=[root]
        ans=[]
        while stack:
            root=stack.pop()
            ans.append(root.val)
            for i in root.children[::-1]:
                stack.append(i)
            # stack.extend(root.children[::-1]) # 不使用append
        return ans</code></pre>
<p>Python中append和extend的区别：</p>
<pre><code>a=[1,2,3]
b=[4,5]

b.extend(a) # 输出[4,5,1,2,3]
b.append(a) # 输出[4,5,[1,2,3]]</code></pre>
<h3 id="590-N叉树的后序遍历"><a href="#590-N叉树的后序遍历" class="headerlink" title="590. N叉树的后序遍历"></a>590. N叉树的后序遍历</h3><pre><code>链接：https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/

给定一个 N 叉树，返回其节点值的后序遍历。

例如，给定一个 3叉树 :

返回其后序遍历: [5,6,3,2,4,1].

说明: 递归法很简单，你可以使用迭代法完成此题吗?</code></pre>
<p>题解一|递归：</p>
<pre><code>&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
&quot;&quot;&quot;

class Solution:
    def postorder(self, root: &#39;Node&#39;) -&gt; List[int]:
        ans=[]
        if root:
            for i in root.children:
                ans+=self.postorder(i)
            ans.append(root.val)
        return ans</code></pre>
<p>题解二|迭代：</p>
<pre><code>&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
&quot;&quot;&quot;

class Solution:
    def postorder(self, root: &#39;Node&#39;) -&gt; List[int]:
        if not root:
            return
        stack=[root]
        res=[]
        while stack:
            root=stack.pop()
            res.append(root.val)
            for i in root.children:
                stack.append(i)
        return res[::-1]</code></pre>
<h3 id="606-根据二叉树创建字符串"><a href="#606-根据二叉树创建字符串" class="headerlink" title="606. 根据二叉树创建字符串"></a>606. 根据二叉树创建字符串</h3><pre><code>链接：https://leetcode-cn.com/problems/construct-string-from-binary-tree/

你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。

空节点则用一对空括号 &quot;()&quot; 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。

示例 1:

输入: 二叉树: [1,2,3,4]
       1
     /   \
    2     3
   /    
  4     

输出: &quot;1(2(4))(3)&quot;

解释: 原本将是“1(2(4)())(3())”，
在你省略所有不必要的空括号对之后，
它将是“1(2(4))(3)”。
示例 2:

输入: 二叉树: [1,2,3,null,4]
       1
     /   \
    2     3
     \  
      4 

输出: &quot;1(2()(4))(3)&quot;

解释: 和第一个示例相似，
除了我们不能省略第一个对括号来中断输入和输出之间的一对一映射关系。</code></pre>
<p>题解一|递归：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def tree2str(self, t: TreeNode) -&gt; str:
        if not t:
            return &#39;&#39;
        if not t.left and not t.right:
            return str(t.val)
        if not t.left and t.right:
            return str(t.val)+&#39;()&#39;+&#39;(&#39;+self.tree2str(t.right)+&#39;)&#39;
        if t.left and not t.right:
            return str(t.val)+&#39;(&#39;+self.tree2str(t.left)+&#39;)&#39;
        return str(t.val)+&#39;(&#39;+self.tree2str(t.left)+&#39;)&#39;+&#39;(&#39;+self.tree2str(t.right)+&#39;)&#39;</code></pre>
<h3 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a>617. 合并二叉树</h3><pre><code>链接：https://leetcode-cn.com/problems/merge-two-binary-trees/

给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。

你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。

示例 1:

输入: 
    Tree 1                     Tree 2                  
          1                         2                             
         / \                       / \                            
        3   2                     1   3                        
       /                           \   \                      
      5                             4   7                  
输出: 
合并后的树:
         3
        / \
       4   5
      / \   \ 
     5   4   7
注意: 合并必须从两个树的根节点开始。</code></pre>
<p>题解一|递归：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def mergeTrees(self, t1: TreeNode, t2: TreeNode) -&gt; TreeNode:
        if not t1 and not t2:
            return
        if not t1:
            return t2
        if not t2:
            return t1
        if t1 and t2:
            root=TreeNode()
            root.val=t1.val+t2.val
            root.left=self.mergeTrees(t1.left,t2.left)
            root.right=self.mergeTrees(t1.right,t2.right)
        return root</code></pre>
<h3 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637.二叉树的层平均值"></a>637.二叉树的层平均值</h3><pre><code>链接：https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/

给定一个非空二叉树, 返回一个由每层节点平均值组成的数组.

示例 1:

输入:
    3
   / \
  9  20
    /  \
   15   7
输出: [3, 14.5, 11]
解释:
第0层的平均值是 3,  第1层是 14.5, 第2层是 11. 因此返回 [3, 14.5, 11].
注意：

节点值的范围在32位有符号整数范围内。</code></pre>
<p>题解一|迭代：</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def averageOfLevels(self, root: TreeNode) -&gt; List[float]:
        from collections import deque
        if root is None: return
        queue=deque()
        queue.append(root)
        res=[]
        while queue:
            tmp=[]
            for i in range(len(queue)):
                node=queue.popleft()
                tmp.append(node.val)
                s=0
                for each in tmp:
                    s+=each
                s=s/len(tmp)

                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            res.append(s)
        return res</code></pre>
<p>去掉脑残for循环，巨耗时。</p>
<pre><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def averageOfLevels(self, root: TreeNode) -&gt; List[float]:
        from collections import deque
        if root is None: return
        queue=deque()
        queue.append(root)
        res=[]
        while queue:
            tmp=[]
            for i in range(len(queue)):
                node=queue.popleft()
                tmp.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            res.append(sum(tmp)/len(tmp))
        return res</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/LeetCode-1-%E6%95%B0%E7%BB%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/LeetCode-1-%E6%95%B0%E7%BB%84/" class="post-title-link" itemprop="url">LeetCode-1-数组</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-09-26 12:13:05" itemprop="dateCreated datePublished" datetime="2019-09-26T12:13:05+08:00">2019-09-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-27 21:17:21" itemprop="dateModified" datetime="2020-10-27T21:17:21+08:00">2020-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、数组"><a href="#一、数组" class="headerlink" title="一、数组"></a>一、数组</h2><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h3><pre><code>链接：https://leetcode-cn.com/problems/two-sum/

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

示例:

给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]</code></pre>
<p>题解一|暴力：</p>
<p>最简单的思路就是通过两遍循环直接进行暴力破解，时间复杂度O(n^2)，空间复杂度O(1)。</p>
<pre><code> class Solution:
    def twoSum(self,nums,target):
        for i in range(0,len(nums)):
            for j in range(i+1,len(nums)):
                if nums[j]==target-nums[i]:
                    return i,j</code></pre>
<p>题解二|hash：</p>
<p>接着思考如何进行优化，采用hash记录需要的key，遍历的时候找到需要的值。时间复杂度O(n)，空间复杂度O(n)。</p>
<pre><code> class Solution:
    def twoSum(self,nums,target):
        dicts=&#123;&#125;
        for i in range(len(nums)):
            tmp=nums[i]
            if target-tmp in dicts:
                return (dicts[target-tmp],i)
            dicts[tmp]=i</code></pre>
<pre><code> class Solution:
    def twoSum(self,nums,target):
        dicts=&#123;&#125;
        for i,num in enumerate(nums):
            if num in dicts:
                return [dicts[num],i]
            else:
                dicts[target-num]=i</code></pre>
<p>题解三|切片：</p>
<p>判断target-nums[i]是否在nums[i+1:]中，时间复杂度O(n)，空间复杂度O(1)。</p>
<pre><code> class Solution:
    def twoSum(self,nums,target):
        for i in range(len(nums)):
            if target-nums[i] in nums[i+1:]:
                return [i,nums.index(target-nums[i],i+1)]</code></pre>
<p>index()方法语法：list.index(x[, start[, end]])<br>参数:<br>    x– 查找的对象。<br>    start– 可选，查找的起始位置。<br>    end– 可选，查找的结束位置。<br>返回值:该方法返回查找对象的索引位置，如果没有找到对象则抛出异常。</p>
<h3 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h3><pre><code>链接：
https://leetcode-cn.com/problems/add-two-numbers/

给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。

如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

您可以假设除了数字 0 之外，这两个数都不会以 0 开头。

示例：

输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
输出：7 -&gt; 0 -&gt; 8
原因：342 + 465 = 807</code></pre>
<p>题解一：</p>
<pre><code>class ListNode:
    def __init__(self,x):
        self.val=x
        self.next=None
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:
        if l1 is None:
            return l2
        if l2 is None:
            return l1

        tmp=ListNode(0)
        res=tmp
        flag=0

        while l1 or l2:
            tmpSum=0
            if l1:
                tmpSum=l1.val
                l1=l1.next
            if l2:
                tmpSum+=l2.val
                l2=l2.next
            tmpRes=(tmpSum+falg)%10
            flag=(tmpSum+flag)//10

            res.next=ListNode(tmpRes)
            res=res.next # res后移

            # 这个判断是拿来解决此种情况的：
            # 输入：【5】和【5】
            # 输出：【0,1】
            if flag:
                res.next=ListNode(1) # 这里创建了节点，但是没有后移

        res=tmp.next # 把链表初始化的0后移
        return res</code></pre>
<pre><code>class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:
        res=dummy=ListNode(-1)
        flag=0
        while l1 and l2:
            res.next=ListNode(l1.val+l2.val+flag)
            flag=res.next.val // 10
            res.next.val %= 10
            res=res.next
            l1=l1.next
            l2=l2.next

        p= l1 or l2
        while p:
            res.next=ListNode(p.val+flag)
            flag=res.next.val // 10
            res.next.val %= 10
            p=p.next
            res=res.next
        if flag:
            res.next=ListNode(1)
        return dummy.next</code></pre>
<h3 id="？？4-寻找两个有序数组的中位数"><a href="#？？4-寻找两个有序数组的中位数" class="headerlink" title="？？4.寻找两个有序数组的中位数"></a>？？4.寻找两个有序数组的中位数</h3><pre><code>链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays/

给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。

请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。

你可以假设 nums1 和 nums2 不会同时为空。

示例 1:

nums1 = [1, 3]
nums2 = [2]

则中位数是 2.0
示例 2:

nums1 = [1, 2]
nums2 = [3, 4]

则中位数是 (2 + 3)/2 = 2.5</code></pre>
<p>题解一（暴力）：</p>
<h3 id="6-Z字形变换"><a href="#6-Z字形变换" class="headerlink" title="6.Z字形变换"></a>6.Z字形变换</h3><pre><code>链接：https://leetcode-cn.com/problems/zigzag-conversion/

将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。

比如输入字符串为 &quot;LEETCODEISHIRING&quot; 行数为 3 时，排列如下：

L   C   I   R
E T O E S I I G
E   D   H   N
之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&quot;LCIRETOESIIGEDHN&quot;。

请你实现这个将字符串进行指定行数变换的函数：

string convert(string s, int numRows);
示例 1:

输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 3
输出: &quot;LCIRETOESIIGEDHN&quot;
示例 2:

输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 4
输出: &quot;LDREOEIIECIHNTSG&quot;
解释:

L     D     R
E   O E   I I
E C   I H   N
T     S     G</code></pre>
<p>题解一：<br><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/z-word.png"><br><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/z-word1.png"></p>
<pre><code>class Solution:
    def convert(self, s: str, numRows: int) -&gt; str:
        if numRows&lt;2:
            return s
        ans=[&#39;&#39; for _ in range(numRows)]
        i,flag=0,-1
        for c in s:
            ans[i] += c
            if i==0 or i==numRows-1:
                flag=-flag
            i+=flag
        return &#39;&#39;.join(ans)
</code></pre>
<h3 id="7-整数反转"><a href="#7-整数反转" class="headerlink" title="7.整数反转"></a>7.整数反转</h3><pre><code>链接：https://leetcode-cn.com/problems/reverse-integer/

给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。

示例 1:

输入: 123
输出: 321
示例 2:

输入: -123
输出: -321
示例 3:

输入: 120
输出: 21
注意:

假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31,  2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</code></pre>
<p>题解一：<br>int型的数值范围是 -2147483648～2147483647， 那么如果我们要翻转 1000000009 这个在范围内的数得到 9000000001，而翻转后的数就超过了范围。</p>
<pre><code>class Solution:
    def reverse(self, x: int) -&gt; int:
        x=int(str(x)[::-1]) if x&gt;=0 else -int(str((-x)[::-1])) # python3没有数字范围，如果其他语言之间int会造成精度缺失。
        # return x if x&lt;2**31-1 and x&gt;-2**31 else 0
        return x if x&lt;pow(2,31)-1 and x&gt;-pow(2,31) else 0</code></pre>
<p>题解二：<br>    # /:除法<br>    # //:整除<br>    # %：取模</p>
<pre><code>class Solution:
    def reverse(self, x):
        flag = 1 if x &gt;= 0 else -1
        new_x, x = 0, abs(x)
        while x:
            new_x = 10 * new_x + x % 10
            x //= 10
        new_x = flag * new_x
        return new_x if new_x &lt; 2147483648 and new_x &gt;= -2147483648 else 0</code></pre>
<h3 id="8-字符串转换整数-atoi"><a href="#8-字符串转换整数-atoi" class="headerlink" title="8.字符串转换整数(atoi)"></a>8.字符串转换整数(atoi)</h3><pre><code>链接：https://leetcode-cn.com/problems/string-to-integer-atoi/

请你来实现一个 atoi 函数，使其能将字符串转换成整数。

首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。

当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。

该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。

注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。

在任何情况下，若函数不能进行有效的转换时，请返回 0。

说明：

假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。

示例 1:

输入: &quot;42&quot;
输出: 42
示例 2:

输入: &quot;   -42&quot;
输出: -42
解释: 第一个非空白字符为 &#39;-&#39;, 它是一个负号。
     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。
示例 3:

输入: &quot;4193 with words&quot;
输出: 4193
解释: 转换截止于数字 &#39;3&#39; ，因为它的下一个字符不为数字。
示例 4:

输入: &quot;words and 987&quot;
输出: 0
解释: 第一个非空字符是 &#39;w&#39;, 但它不是数字或正、负号。
     因此无法执行有效的转换。
示例 5:

输入: &quot;-91283472332&quot;
输出: -2147483648
解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 </code></pre>
<p>          因此返回 INT_MIN (−231) 。<br>题解一|正则表达式：</p>
<pre><code>^：匹配字符串开头
[\+\-]：代表一个+字符或-字符
?：前面一个字符可有可无
\d：一个数字
+：前面一个字符的一个或多个
\D：一个非数字字符
*：前面一个字符的0个或多个</code></pre>
<pre><code>class Solution:
    def myAtoi(self, str: str) -&gt; int:
        return max(min(int(*re.findall(&#39;^[\+\-]?\d+&#39;,str.lstrip())),2**31-1),-2**31)
        #由于返回的是个列表，解包并且转换成整数</code></pre>
<pre><code>class Solution:
    def myAtoi(self, str: str) -&gt; int:
        # return max(min(int(*re.findall(&#39;^[\+\-]?\d+&#39;,str.lstrip())),2**31-1),-2**31)
        # print(re.findall(&#39;\d&#39;,str.lstrip())) # [&#39;4&#39;, &#39;2&#39;, &#39;4&#39;, &#39;4&#39;]
        # print(re.findall(&#39;\d*&#39;,str.lstrip())) # [&#39;4244&#39;, &#39;&#39;]
        # print(re.findall(&#39;\d+&#39;,str.lstrip())) # [&#39;4244&#39;]
        # print(re.findall(&#39;^[+-]\d+&#39;,str.lstrip())) # [&#39;-4244&#39;]
        # print(re.findall(&#39;^[+-]?\d+&#39;,str.lstrip())) # ?代表前面的+-可有可无。
        # #  re.findall返回的是一个字符串列表，int()数据类型转换不支持列表，用*对列表解包得到字符串。比如[7,8,8]→7,8,8
        # print(int(*re.findall(&#39;^[+-]\d+&#39;,str.lstrip()))) # -4244

        x=int(*re.findall(&#39;^[-+]?\d+&#39;,str.lstrip()))
        if x &gt; pow(2,31)-1:
            return pow(2,31)-1
        elif x &lt; pow(-2,31):
            return pow(-2,31)
        else:
            return x</code></pre>
<p>题解二|逐个强行转int：</p>
<pre><code>class Solution:
    def myAtoi(self, str: str) -&gt; int:
        str=str.lstrip()

        if len(str)==0:
            return 0
        last=0
        i=1 if str[0]==&#39;+&#39; or str[0]==&#39;-&#39; else 0
        #循环，直到无法强转成int，跳出循环
        while i&lt;=len(str):
            try:
                last=int(str[:i+1]) # int[&#39;aa&#39;]会报错，所以走break
                i+=1
            except:
                break
        # 判断数字是否超出范围
        if last&lt;-2**31:
            return -2**31
        if last&gt;2**31-1:
            return 2**31-1
        return last
</code></pre>
<h3 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9.回文数"></a>9.回文数</h3><pre><code>链接：https://leetcode-cn.com/problems/palindrome-number/

判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

示例 1:

输入: 121
输出: true
示例 2:

输入: -121
输出: false
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
示例 3:

输入: 10
输出: false
解释: 从右向左读, 为 01 。因此它不是一个回文数。</code></pre>
<p>题解一|整数转换为字符串:</p>
<pre><code>class Solution:
    def isPalindrome(self, x: int) -&gt; bool:
        x=str(x)
        if x == x[::-1]:
            return True
        else:
            return False

class Solution:
    def isPalindrome(self, x) :
        x=str(x)
        return x==x[::-1]

# 整数转字符串，通过下标对比确定该整数是否为回文数
class Solution:
    def isPalindrome(self, x) :
        x=str(x)
        for i in range(0,int(len(x)/2)):
            if x[i] != x[-i-1]:
                return False
        return True</code></pre>
<p>题解二（数字反转）:</p>
<pre><code>class Solution:
    def isPalindrome(self, x) :
        if x&lt;0:
            return False
        m,n=x,0

        while m:
            n=n*10+m%10
            m=m//10
        if x==n:
            return True
        else:
            return False</code></pre>
<h3 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11.盛最多水的容器"></a>11.盛最多水的容器</h3><pre><code>链接：https://leetcode-cn.com/problems/container-with-most-water/

给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

说明：你不能倾斜容器，且 n 的值至少为 2。</code></pre>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/youdao/water3.jpg"></p>
<pre><code>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。

示例:

输入: [1,8,6,2,5,4,8,3,7]
输出: 49</code></pre>
<p>思路：<br>    矩阵的面积=矩阵长度 * 矩阵宽度<br>    矩阵长度：两条垂直线的距离<br>    矩阵宽度：两条垂直线中较短一条的长度<br>    面积最大化：两条垂直线的距离越远越好，两条垂直线的最短长度也要越长越好。</p>
<p>解法一|暴力|超时：<br>    在这种情况下，我们将简单地考虑每对可能出现的线段组合并找出这些情况之下的最大面积。<br>    时间复杂度O(n^2)，计算n(n-1)/2种高度组合的面积，空间复杂度O(1)。</p>
<pre><code>不能通过case:[1,1],结果应该为1.
class Solution:
    def maxArea(self, height: List[int]) -&gt; int:
        area=0
        for i in range(len(height)):
            for j in range(i+1,len(height)):
                # print(&#39;i&#39;,i,height[i])
                # print(&#39;j&#39;,j,height[j])
                area=max(area,min(height[i],height[j])*(j-1)) # j-1为矩阵的长度</code></pre>
<pre><code>class Solution:
    def maxArea(self, height: List[int]) -&gt; int:
        area=0
        for i in range(len(height)-1):
            for j in range(i+1,len(height)):
                # print(&#39;i&#39;,i,height[i])
                # print(&#39;j&#39;,j,height[j])
                area=max(area,min(height[i],height[j])*(j-i)) # j-i为矩阵的长度
        return area</code></pre>
<p>解法二|双指针：</p>
<pre><code>设置两个指针 left 和 right，分别指向数组的最左端和最右端。此时，两条垂直线的距离是最远的，若要下一个矩阵面积比当前面积来得大，必须要把 height[left] 和 height[right] 中较短的垂直线往中间移动，看看是否可以找到更长的垂直线。
时间复杂度O(n)，空间复杂度O(1)。</code></pre>
<pre><code>class Solution:
    def maxArea(self, height: List[int]) -&gt; int:
        left=0
        right=len(height)-1
        area=0

        while left &lt; right:
            cur=min(height[left],height[right]) * (right-left)
            area=max(area,cur)

            if height[left]&lt;height[right]:
                left+=1
            else:
                right-=1
        return area</code></pre>
<h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h3><pre><code>链接：https://leetcode-cn.com/problems/3sum/

给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。

注意：答案中不可以包含重复的三元组。

例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]</code></pre>
<p>题解一|暴力：<br>    使用三重循环进行暴力破解，时间复杂度为O(n^3)，空间复杂度O(n)</p>
<p>题解二|排序+双指针：</p>
<pre><code>继续思考如何优化，可以通过双指针动态消去无效解来优化效率。
铺垫：先将给定 nums 排序，复杂度为 O(nlogn)
思路：固定 3 个指针中最左（最小）数字的指针 k，双指针 i，j 分设在数组索引 (k, len(nums))两端，通过双指针交替向中间移动，记录对于每个固定指针 k 的所有满足 nums[k] + nums[i] + nums[j] == 0 的 i,j 组合。
时间复杂度O(n^2)，空间复杂度O(n)。</code></pre>
<pre><code>class Solution:
    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:
        nums.sort()
        lens=len(nums)
        res=[]

        for k in range(lens):
            if k&gt;0 and nums[k]==nums[k-1]:
                continue

            i,j=k+1,lens-1
            while i&lt;j:
                sum=nums[k]+nums[i]+nums[j]
                if sum==0:
                    tmp=[nums[k],nums[i],nums[j]]
                    res.append(tmp)

                    while i&lt;j and nums[i]==nums[i+1]:
                        i+=1
                    while i&lt;j and nums[j]==nums[j-1]:
                        j-=1

                    i+=1
                    j-=1

                elif sum&lt;0:
                    i+=1
                else:
                    j-=1

        return res</code></pre>
<h3 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16.最接近的三数之和"></a>16.最接近的三数之和</h3><pre><code>链接：https://leetcode-cn.com/problems/3sum-closest/

给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。

例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.

与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).</code></pre>
<p>题解一|排序+双指针：</p>
<p>思路类似于三数之和，首先将数组进行排序，同时在左右指针运动过程中，记录与 target 绝对值差值最小的三数之和。</p>
<p>时间复杂度：O(nlogn) + O(n^2) = O(n^2)，空间复杂度O(1)</p>
<pre><code>class Solution:
    def threeSumClosest(self, nums: List[int], target: int) -&gt; int:
        nums.sort()
        length=len(nums)
        res=float(&#39;inf&#39;)

        for k in range(length):
            # if k&gt;0 and nums[k]==nums[k-1]:
            #    continue

            i,j=k+1,length-1
            while i&lt;j:
                sum=nums[k]+nums[i]+nums[j]
                if sum==target:
                    return target

                if abs(res-target)&gt;abs(sum-target):
                    res=sum

                if sum&lt;target:
                    i+=1
                else:
                    j-=1
        return res</code></pre>
<h3 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18.四数之和"></a>18.四数之和</h3><pre><code>链接：https://leetcode-cn.com/problems/4sum/

给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。

注意：

答案中不可以包含重复的四元组。

示例：

给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。

满足要求的四元组集合为：
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]</code></pre>
<p>题解一|排序+双指针：</p>
<p>和三数之和解法类似，先将数组排序固定两个元素，再用两个指针，一个指向头，一个指向尾，看四数之和为多少，太大了右指针左移，太小了左指针右移，因为有可能存在重复的数组，先将结果保存在set中，最后在转为list输出。</p>
<p>时间复杂度：O(n^3)，空间复杂度O(n)</p>
<pre><code>class Solution:
    def fourSum(self, nums: List[int], target: int) -&gt; List[List[int]]:
        nums.sort()
        length=len(nums)
        res=[]
        sets=set()

        for i in range(length-3):
            for j in range(i+1,length-2):
                left,right=j+1,length-1

                while left&lt;right:
                    sum=nums[i]+nums[j]+nums[left]+nums[right]
                    if sum==target:
                        tmp=(nums[i],nums[j],nums[left],nums[right])
                        sets.add(tmp) # 去重
                        left+=1
                        right-=1
                    elif sum&lt;target:
                        left+=1
                    else:
                        right-=1

        for each in sets:
            res.append(list(each))
        return res </code></pre>
<h3 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26.删除排序数组中的重复项"></a>26.删除排序数组中的重复项</h3><pre><code>链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/

给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

示例 1:

给定数组 nums = [1,1,2], 

函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 

你不需要考虑数组中超出新长度后面的元素。
示例 2:

给定 nums = [0,0,1,1,1,2,2,3,3,4],

函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。

你不需要考虑数组中超出新长度后面的元素。</code></pre>
<p>题解一|双指针：</p>
<p>思路：</p>
<p>采用两指针，一个指针i指向原数组需要判断的元素，一个指针j指向新数组新加入的元素。<br>由于是有序数组，因此只要判断原数组中的元素不同于新数组新加入的元素，就将原数组的元素和新数组后一元素交换位置即可，没有重复元素就是和自身交换位置。</p>
<p>第一个指针 i ：由于数组已完成排序，因为遍历数组，每遇到 nums[i] != nums[j<br>] ,就说明遇到了新的不同数字，记录之；</p>
<p>第二个指针 j ：每遇到新的不同数字时，执行 j += 1 ， j 指针有两个作用：</p>
<pre><code>记录数组中不同数字的数量；
作为修改数组元素的索引index。</code></pre>
<p>最终，返回 k+1 即可。<br>时间复杂度O(n),空间复杂福O(1)。</p>
<pre><code>class Solution:
    def removeDuplicates(self, nums: List[int]) -&gt; int:
        if not nums:
            return 0
        j=0
        for i in range(1,len(nums)):
            if nums[i]!=nums[j]:
                nums[j+1]=nums[i]
                j+=1
        return j+1
</code></pre>
<pre><code>class Solution:
    def removeDuplicates(self, nums: List[int]) -&gt; int:
        index=0
        for i in range(1,len(nums)):
            if nums[i] != nums[index]:
                index+=1
                nums[index]=nums[i]
        return index+1
</code></pre>
<pre><code>class Solution:
    def removeDuplicates(self, nums: List[int]) -&gt; int:
        if not nums:
            return 0
        slow=0
        for fast in range(len(nums)):
            if nums[slow] != nums[fast]:
                slow+=1
            nums[slow]=nums[fast]
        return slow+1</code></pre>
<pre><code>class Solution:
    def removeDuplicates(self, nums: List[int]) -&gt; int:
        if not nums:
            return 0
        slow=0
        for fast in range(len(nums)):
            if nums[fast] == nums[slow]:
                fast+=1
            else:
                slow+=1
                nums[slow]=nums[fast]
        return slow+1</code></pre>
<pre><code>class Solution:
    def removeDuplicates(self, nums: List[int]) -&gt; int:
        pre,cur=0,1
        while cur&lt;len(nums):
            if nums[pre]==nums[cur]:
                nums.pop(cur)
            else:
                pre,cur=pre+1,cur+1</code></pre>
<h3 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27.移除元素"></a>27.移除元素</h3><pre><code>链接：https://leetcode-cn.com/problems/remove-element/

给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

示例 1:

给定 nums = [3,2,2,3], val = 3,

函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。

你不需要考虑数组中超出新长度后面的元素。
示例 2:

给定 nums = [0,1,2,2,3,0,4,2], val = 2,

函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。

注意这五个元素可为任意顺序。

你不需要考虑数组中超出新长度后面的元素。</code></pre>
<p>题解一|双指针：</p>
<p>可以保留两个指针 i 和 j，其中 i 是慢指针，j 是快指针。当 nums[j]与val相等时，递增 j以跳过该元素。只要 nums[j] 不等于 val，我们就复制 nums[j]到 nums[i] 并同时递增两个索引。重复这一过程，直到 j 到达数组的末尾，该数组的新长度为 i。<br>时间复杂度O(n),空间复杂度O(1).</p>
<pre><code>class Solution:
    def removeElement(self, nums: List[int], val: int) -&gt; int:
        i=0
        for j in range(0,len(nums)):
            if nums[j] != val:
                nums[i]=nums[j]
                i+=1
        return i</code></pre>
<h3 id="29-两数相除"><a href="#29-两数相除" class="headerlink" title="29.两数相除"></a>29.两数相除</h3><pre><code>链接：https://leetcode-cn.com/problems/divide-two-integers/submissions/

给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。

返回被除数 dividend 除以除数 divisor 得到的商。

示例 1:

输入: dividend = 10, divisor = 3
输出: 3
示例 2:

输入: dividend = 7, divisor = -3
输出: -2
说明:

被除数和除数均为 32 位有符号整数。
除数不为 0。
假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。</code></pre>
<p>题解一|减法|超时:</p>
<p>超时：当被除数为2147483648，除数为 1，必然超时。</p>
<pre><code>class Solution:
    def divide(self, dividend: int, divisor: int) -&gt; int:
        res=0
        flag=1 if dividend ^ divisor &gt;=0 else -1
        dividend=abs(dividend)
        divisor=abs(divisor)
        while dividend &gt;= divisor:
            res+=1
            dividend-=divisor
        res=res*flag
        return min(max(res,-2**31),2**31-1)</code></pre>
<p>题解二|增倍除数:</p>
<pre><code>&lt;&lt; 是左移，末位补0，类比十进制数在末尾添0相当于原数乘以10，x&lt;&lt;1是将x的二进制表示左移一位，相当于原数x乘2。比如整数4在二进制下是100，4&lt;&lt;1左移1位变成1000(二进制)，结果是8。

&gt;&gt;是右移，右移1位相当于除以2。</code></pre>
<pre><code>class Solution:
    def divide(self, dividend: int, divisor: int) -&gt; int:
        res=0
        flag=1 if dividend ^ divisor &gt;=0 else -1
        dividend=abs(dividend)
        divisor=abs(divisor)
        while dividend &gt;= divisor:
            tmp,i=divisor,1
            while dividend&gt;=tmp:
                dividend-=tmp
                res+=i
                i &lt;&lt;=1
                tmp &lt;&lt;=1
        res=res*flag
        return min(max(res,-2**31),2**31-1)</code></pre>
<p>题解三（位移）：<br>算法是把除法化归成移位和减法两种运算方法。对于 10 进制数，移位运算就是乘（左移）除（右移）10，而我们都知道计算机中的移位运算是乘（左移）除（右移）2，因为计算机是通过二进制的方法存储数的。这样，类比十进制，二进制的除法（仍以 45/2 为例）可以写作（注意，这里我们并没有用到乘除法）</p>
<pre><code>class Solution:
    def divide(self, dividend: int, divisor: int) -&gt; int:
        res=0
        flag=1 if dividend ^ divisor &gt;=0 else -1
        dividend=abs(dividend)
        divisor=abs(divisor)
        count=0

        # 不断左移，直到大于被除数
        while dividend &gt;= divisor:
            count+=1
            divisor &lt;&lt;=1

        while count &gt; 0:
            count -=1
            divisor &gt;&gt;=1
            res &lt;&lt;=1
            if divisor &lt;= dividend:
                res+=1
                dividend -= divisor

        res=res*flag
        return min(max(res,-2**31),2**31-1)</code></pre>
<h3 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a>31. 下一个排列</h3><pre><code>链接：https://leetcode-cn.com/problems/next-permutation/

实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须原地修改，只允许使用额外常数空间。

以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1</code></pre>
<p>题解一：</p>
<p>1.从右至左遍历nums，发现第一个小于右边的数nums[i]，将该nums[i]之后的数排升序；</p>
<p>2.第二层遍历nums[(i+1):]，发现第一个大于nums[i]的数nums[j]，交换两数，退出遍历break；</p>
<p>3.交换了也排好序了，退出第一次层遍历return nums</p>
<p>这里有个细节：nums本来就是降序，第一次遍历找不到nums[i],那么直接sort()</p>
<pre><code>class Solution:
    def nextPermutation(self, nums: List[int]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums in-place instead.
        &quot;&quot;&quot;
        for i in range(len(nums)-2,-1,-1):
            if nums[i] &lt; nums[i+1]:
                nums[i+1:]=sorted(nums[i+1:])
                for j in range(i+1,len(nums)):
                    if nums[i] &lt; nums[j]:
                        nums[i],nums[j]=nums[j],nums[i]
                        # break
                        return

        nums.sort()</code></pre>
<h3 id="36-有效的数独"><a href="#36-有效的数独" class="headerlink" title="36. 有效的数独"></a>36. 有效的数独</h3><pre><code>链接：https://leetcode-cn.com/problems/valid-sudoku/

判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。

数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。


上图是一个部分填充的有效的数独。

数独部分空格内已填入了数字，空白格用 &#39;.&#39; 表示。

示例 1:

输入:
[
  [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],
  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],
  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],
  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],
  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],
  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],
  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],
  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],
  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]
]
输出: true
示例 2:

输入:
[
  [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],
  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],
  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],
  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],
  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],
  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],
  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],
  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],
  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]
]
输出: false
解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。
     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
说明:

一个有效的数独（部分已被填充）不一定是可解的。
只需要根据以上规则，验证已经填入的数字是否有效即可。
给定数独序列只包含数字 1-9 和字符 &#39;.&#39; 。
给定数独永远是 9x9 形式的。</code></pre>
<p>题解一：</p>
<pre><code>class Solution:
    def isValidSudoku(self, board: List[List[str]]) -&gt; bool:
        rows=[&#123;&#125; for i in range(9)]
        columns=[&#123;&#125; for i in range(9)]
        boxes=[&#123;&#125; for i in range(9)]
        for i in range(9):
            for j in range(9):
                char=board[i][j]
                if char != &#39;.&#39;:
                    index=(i//3)*3+j//3
                    rows[i][char]=rows[i].get(char,0)+1
                    columns[j][char]=columns[j].get(char,0)+1
                    boxes[index][char]=boxes[index].get(char,0)+1

                    if rows[i][char]&gt;1 or columns[j][char]&gt;1 or boxes[index][char]&gt;1:
                        return False
        return True</code></pre>
<h3 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a>45. 跳跃游戏 II</h3><pre><code>链接：https://leetcode-cn.com/problems/jump-game-ii/

给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

你的目标是使用最少的跳跃次数到达数组的最后一个位置。

示例:

输入: [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</code></pre>
<p>题解一：<br>思路：</p>
<pre><code>1、如果某一个作为 起跳点 的格子可以跳跃的距离是 3，那么表示后面 3 个格子都可以作为 起跳点。
    11. 可以对每一个能作为 起跳点 的格子都尝试跳一次，把 能跳到最远的距离 不断更新。

2、如果从这个 起跳点 起跳叫做第 1 次 跳跃，那么从后面 3 个格子起跳 都 可以叫做第 2 次 跳跃。

3、所以，当一次 跳跃 结束时，从下一个格子开始，到现在 能跳到最远的距离，都 是下一次 跳跃 的 起跳点。
    31. 对每一次 跳跃 用 for 循环来模拟。
    32. 跳完一次之后，更新下一次 起跳点 的范围。
    33. 在新的范围内跳，更新 能跳到最远的距离。

4、记录 跳跃 次数，如果跳到了终点，就得到了结果。</code></pre>
<pre><code>class Solution:
    def jump(self, nums: List[int]) -&gt; int:
        ans=0
        start=0
        end=1
        while end&lt;len(nums):
            maxPos=0
            for i in range(start,end):
                maxPos=max(maxPos,nums[i]+i)
            start=end
            end=maxPos+1
            ans+=1
        return ans</code></pre>
<p>优化：</p>
<pre><code>class Solution:
    def jump(self, nums: List[int]) -&gt; int:
        ans=0
        end=0
        maxPos=0
        for i in range(0,len(nums)-1):
            maxPos=max(maxPos,nums[i]+i)
            if i==end:
                end=maxPos
                ans+=1
        return ans</code></pre>
<h3 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48.旋转图像"></a>48.旋转图像</h3><pre><code>链接：https://leetcode-cn.com/problems/rotate-image/

给定一个 n × n 的二维矩阵表示一个图像。

将图像顺时针旋转 90 度。

说明：

你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。

示例 1:

给定 matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

原地旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
示例 2:

给定 matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

原地旋转输入矩阵，使其变为:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]</code></pre>
<p>题解一|转置+翻转：</p>
<p>分析：先转置矩阵，然后翻转每一行。这个简单的方法已经能达到最优的时间复杂度O(N^2)。</p>
<p>时间复杂度：O(N^2)<br>空间复杂度：O(1) 由于旋转操作是 就地 完成的。</p>
<pre><code>class Solution:
    def rotate(self, matrix: List[List[int]]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify matrix in-place instead.
        &quot;&quot;&quot;
        n=len(matrix[0]) # 矩阵第一行matrix[0]
        # 矩阵转置
        for i in range(n):
            for j in range(i,n):
                matrix[j][i],matrix[i][j]=matrix[i][j],matrix[j][i]
        # 翻转每行
        for i in range(n):
            matrix[i].reverse()
        return matrix</code></pre>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rotate-image/solution/xuan-zhuan-tu-xiang-by-leetcode/">https://leetcode-cn.com/problems/rotate-image/solution/xuan-zhuan-tu-xiang-by-leetcode/</a></p>
<h3 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a>49. 字母异位词分组</h3><pre><code>链接：https://leetcode-cn.com/problems/group-anagrams/

给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。

示例:

输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],
输出:
[
  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],
  [&quot;nat&quot;,&quot;tan&quot;],
  [&quot;bat&quot;]
]
说明：

所有输入均为小写字母。
不考虑答案输出的顺序。</code></pre>
<p>题解一（hash）：</p>
<pre><code>class Solution:
    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:
        hash=&#123;&#125;
        for i in strs:
            tmp=tuple(sorted(i))
            if tmp not in hash:
                hash[tmp]=[i]
            else:
                hash[tmp].append(i)
        # print(hash)
        res=[i for i in hash.values()]
        return res</code></pre>
<p>输出：</p>
<pre><code>&#123;(&#39;a&#39;, &#39;e&#39;, &#39;t&#39;): [&#39;eat&#39;, &#39;tea&#39;, &#39;ate&#39;], (&#39;a&#39;, &#39;n&#39;, &#39;t&#39;): [&#39;tan&#39;, &#39;nat&#39;], (&#39;a&#39;, &#39;b&#39;, &#39;t&#39;): [&#39;bat&#39;]&#125;</code></pre>
<h3 id="66-加一"><a href="#66-加一" class="headerlink" title="66. 加一"></a>66. 加一</h3><p>链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/plus-one/">https://leetcode-cn.com/problems/plus-one/</a></p>
<pre><code>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。

示例 1:

输入: [1,2,3]
输出: [1,2,4]
解释: 输入数组表示数字 123。
示例 2:

输入: [4,3,2,1]
输出: [4,3,2,2]
解释: 输入数组表示数字 4321。</code></pre>
<p>题解一：</p>
<p>思路：转换为int进行加1</p>
<p>题解二：</p>
<pre><code>class Solution:
    def plusOne(self, digits: List[int]) -&gt; List[int]:
        for i in range(len(digits)-1,-1,-1):
            digits[i]+=1
            digits[i] %= 10
            if digits[i] != 0:
                return digits

        digits=[0]*(len(digits)+1) # 解决case[9],输出[1,0]
        digits[0]=1 # 解决case[9],输出[1,0]
        return digits    </code></pre>
<p>题解三：</p>
<pre><code>class Solution:
    def plusOne(self, digits: List[int]) -&gt; List[int]:
        new=[]
        while digits and digits[-1] == 9:
            digits.pop()
            new.append(0)
        if not digits:
            return [1]+new
        else:
            digits[-1]+=1
            return digits+new</code></pre>
<p>题解四：</p>
<pre><code>class Solution:
    def plusOne(self, digits):
        length=len(digits)
        i=length-1
        while(i&gt;=0):
            if i==0:
                if (digits[i]+1)&gt;9:
                    digits[i]=0
                    result=[1]
                    result.extend(digits)
                    return result
            if (digits[i]+1)&lt;=9:
                digits[i]+=1
                return digits
            else:
                digits[i]=0
                i-=1
        return digits</code></pre>
<h3 id="69-x的平方根"><a href="#69-x的平方根" class="headerlink" title="69.x的平方根"></a>69.x的平方根</h3><pre><code>链接：https://leetcode-cn.com/problems/sqrtx/

实现 int sqrt(int x) 函数。

计算并返回 x 的平方根，其中 x 是非负整数。

由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

示例 1:

输入: 4
输出: 2
示例 2:

输入: 8
输出: 2
说明: 8 的平方根是 2.82842..., 
     由于返回类型是整数，小数部分将被舍去。</code></pre>
<p>题解一(二分法):</p>
<p>思路分析：使用二分法搜索平方根的思想很简单，就类似于小时候我们看的电视节目中的“猜价格”游戏，高了就往低了猜，低了就往高了猜，范围越来越小。因此，使用二分法猜算术平方根就很自然。</p>
<p>一个数的平方根肯定不会超过它自己，不过直觉还告诉我们，一个数的平方根最多不会超过它的一半，例如 8的平方根，8 的一半是 4，4^2=16&gt;8，如果这个数越大越是如此，因此我们要计算一下，这个边界是多少。为此，解如下不等式：(a/2)^2 &gt;= a</p>
<p>时间复杂度：O(logn)<br>空间复杂度：O(1)</p>
<pre><code>class Solution:
    def mySqrt(self, x: int) -&gt; int:
        left=0
        right=x//2+1
        while left &lt; right:
            # mid = left + (right - left + 1) // 2
            # mid=(left+right+1)&gt;&gt;1
            mid=(left+right+1)//2 # 使用除法的耗时比移位多
            square=mid*mid

            if square&gt;x:
                right=mid-1
            else:
                left=mid

        return left</code></pre>
<pre><code># 单独照顾0这个特例

class Solution:
    def mySqrt(self, x: int) -&gt; int:
        if x==0:
            return 0
        left=1
        right=x//2
        while left &lt; right:
            # mid=(left+right+1)&gt;&gt;1
            mid=(left+right+1)//2 # 使用除法的耗时比移位多
            # 一定取右中位数，如果取左中位数(left+right)//2，代码可能会进入死循环
            square=mid*mid

            if square&gt;x:
                right=mid-1
            else:
                left=mid

        return left</code></pre>
<pre><code>class Solution:

    def mySqrt(self, x):
        left = 0
        right = 999999
        while left &lt; right:
            # 这种取中位数的方法又快又好，是我刚学会的，原因在下面这篇文章的评论区
            # https://www.liwei.party/2019/06/17/leetcode-solution-new/search-insert-position/
            mid = (left + right + 1) &gt;&gt; 1
            square = mid * mid
            if square &gt; x:
                right = mid - 1
            else:
                left = mid

        return left</code></pre>
<p>?题解二（牛顿法）:</p>
<p>牛顿法的应用：一个是求方程的根，另一个是求解最优化问题</p>
<p>使用牛顿法可以得到一个正实数的算术平方根，因为题目中说“结果只保留整数部分”，因此，我们把使用牛顿法得到的浮点数转换为整数即可。</p>
<p>在迭代过程中，以直线代替曲线，用一阶泰勒展式（即在当前点的切线）代替原曲线，求直线与 xx 轴的交点，重复这个过程直到收敛。<br><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/newton.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/newton.png"></p>
<pre><code>class Solution:
    def mySqrt(self, x: int) -&gt; int:
        if x&lt;0:
            # raise Exception(&#39;不能输入负数)
            return -1
        if x==0:
            return 0

        cur=1
        while True:
            pre=cur
            cur=(cur+x/cur)/2
            if abs(cur-pre)&lt; 1e-6:
                return int(cur)</code></pre>
<h3 id="73-矩阵置零"><a href="#73-矩阵置零" class="headerlink" title="73. 矩阵置零"></a>73. 矩阵置零</h3><pre><code>链接：https://leetcode-cn.com/problems/set-matrix-zeroes/

给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。

示例 1:

输入: 
[
  [1,1,1],
  [1,0,1],
  [1,1,1]
]
输出: 
[
  [1,0,1],
  [0,0,0],
  [1,0,1]
]
示例 2:

输入: 
[
  [0,1,2,0],
  [3,4,5,2],
  [1,3,1,5]
]
输出: 
[
  [0,0,0,0],
  [0,4,5,0],
  [0,3,1,0]
]
进阶:

一个直接的解决方案是使用  O(mn) 的额外空间，但这并不是一个好的解决方案。
一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。
你能想出一个常数空间的解决方案吗？</code></pre>
<p>题解一：</p>
<p>分析：</p>
<pre><code>用 O(m+n)额外空间
两遍扫matrix,第一遍用集合记录哪些行,哪些列有0;第二遍置0</code></pre>
<p>时间复杂度：O(M*N)<br>空间复杂度：O(M+N)</p>
<pre><code>class Solution:
    def setZeroes(self, matrix: List[List[int]]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify matrix in-place instead.
        &quot;&quot;&quot;
        m=len(matrix)       # 行
        n=len(matrix[0])    # 列
        m_zero=set()
        n_zero=set()
        for i in range(m):
            for j in range(n):
                if matrix[i][j]== 0:
                    m_zero.add(i)
                    n_zero.add(j)
        for i in range(m):
            for j in range(n):
                if i in m_zero or j in n_zero: # 不是if 0 in m_zero or 0 in n_zero
                    matrix[i][j]=0
        return matrix</code></pre>
<p>题解二：</p>
<p>分析:</p>
<pre><code>用matrix第一行和第一列记录该行该列是否有0,作为标志位
但是对于第一行,和第一列要设置一个标志位,为了防止自己这一行(一列)也有0的情况.


参考：https://leetcode-cn.com/problems/set-matrix-zeroes/solution/li-yong-di-yi-xing-he-di-yi-lie-ji-lu-o1kong-jian-/

定义flag_line=False，判断第一行是否需要置0。
定义flag_row=False，判断第一列是否需要置0。
遍历第一列，若第一列中存在0，将flag_row=True，表示需要将第一列置0。
遍历第一行，若第一行中存在0，将flag_line=True，表示需要将第一行置0。
遍历矩阵，遍历区间，行区间[1,m)，列区间[1,m)，若matrix[i][j]==0，则将对应的行和列记录下来，即将第一行和第一列中对应的位置置为0。matrix[i][0]=matrix[0][j]=0
再遍历一次矩阵，若当前位置的行或列索引对应的第一行或者第一列处为0，即matrix[i][0]==0 or matrix[0][j]==0，将此位置置为0。
根据flag_line，判断是否需要将第一行置为0。
根据flag_row，判断第一列是否需要置0。


时间复杂度：O(M*N)
空间复杂度：O(1)</code></pre>
<pre><code>class Solution:
    def setZeroes(self, matrix: List[List[int]]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify matrix in-place instead.
        &quot;&quot;&quot;
        # 输入：[[1,1,1,1],[1,0,1,1],[1,1,1,1]]
        m=len(matrix)       # 行的个数
        n=len(matrix[0])    # 列的个数
        m0_flag=False
        n0_flag=False

        # 找第一行是否有0
        for j in range(n):
            if matrix[0][j] == 0:
                m0_flag=True
                break
        # 找第一列是否有0
        for i in range(m):
            if matrix[i][0]==0:
                n0_flag=True
                break
        # 把第一行或者第一列作为 标志位
        for i in range(1,m):
            for j in range(1,n):
                if matrix[i][j]==0:
                    matrix[i][0]=matrix[0][j]=0
        # print(matrix)
        # [[1, 0, 1, 1], [0, 0, 1, 1], [1, 1, 1, 1]]

        # 置0
        for i in range(1,m):
            for j in range(1,n):
                if(matrix[i][0]==0 or matrix[0][j]==0):
                    matrix[i][j]=0    
        # print(matrix)  
        # [[1, 0, 1, 1], [0, 0, 0, 0], [1, 0, 1, 1]]

        if m0_flag:
            for j in range(n):
                matrix[0][j]=0
        if n0_flag:
            for i in range(m):
                matrix[i][0]=0</code></pre>
<p>???</p>
<pre><code>class Solution:
    def setZeroes(self, matrix: List[List[int]]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify matrix in-place instead.
        &quot;&quot;&quot;
        flag_col = False
        row = len(matrix)
        col = len(matrix[0])
        for i in range(row):
            if matrix[i][0] == 0: flag_col = True
            for j in range(1,col):
                if matrix[i][j] == 0:
                    matrix[i][0] = matrix[0][j] = 0

        for i in range(row - 1, -1, -1):
            for j in range(col - 1, 0, -1):
                if matrix[i][0] == 0 or matrix[0][j] == 0:
                    matrix[i][j] = 0

            if flag_col == True: matrix[i][0] = 0
</code></pre>
<h3 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a>88. 合并两个有序数组</h3><pre><code>链接：https://leetcode-cn.com/problems/merge-sorted-array/

给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 num1 成为一个有序数组。

说明:

初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。
你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。
 

示例:

输入:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

输出: [1,2,2,3,5,6]</code></pre>
<p>题解一（合并后再排序）：</p>
<p>时间复杂度 : O((n + m)\log(n + m))<br>空间复杂度 : O(1)</p>
<pre><code>class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums1 in-place instead.
        &quot;&quot;&quot;
        nums1[:]=sorted(nums1[:m]+nums2)</code></pre>
<p>题解二（双指针 / 从前往后）：</p>
<p>时间复杂度 : O(n + m)<br>空间复杂度 : O(m)</p>
<pre><code>class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums1 in-place instead.
        &quot;&quot;&quot;
        copy=nums1[:m]
        nums1[:]=[]
        p1,p2=0,0
        while p1&lt;m and p2&lt;n:
            if copy[p1]&lt;nums2[p2]:
                nums1.append(copy[p1])
                p1+=1
            else:
                nums1.append(nums2[p2])
                p2+=1
        if p1&lt;m:
            nums1[p1+p2:]=copy[p1:]
        if p2&lt;n:
            nums1[p1+p2:]=nums2[p2:]</code></pre>
<p>题解三(双指针 / 从后往前)：</p>
<p>时间复杂度 : O(n + m)<br>空间复杂度 : O(1)</p>
<pre><code>class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums1 in-place instead.
        &quot;&quot;&quot;
        p1=m-1
        p2=n-1
        p=m+n-1
        while p1&gt;=0 and p2&gt;=0:
            if nums1[p1] &lt; nums2[p2]:
                nums1[p]=nums2[p2]
                p2-=1
            else:
                nums1[p]=nums1[p1]
                p1-=1
            p-=1
        nums1[:p2+1]=nums2[:p2+1] # 解决case:[0]，0，[1]，1</code></pre>
<h3 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a>167. 两数之和 II - 输入有序数组</h3><pre><code>链接：https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/

给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。

函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。

说明:

返回的下标值（index1 和 index2）不是从零开始的。
你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。
示例:

输入: numbers = [2, 7, 11, 15], target = 9
输出: [1,2]
解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</code></pre>
<p>题解一|暴力|超时：</p>
<pre><code>class Solution:
    def twoSum(self, numbers: List[int], target: int) -&gt; List[int]:
        n=len(numbers)
        for i in range(n):
            for j in range(i+1,n):
                if numbers[i]+numbers[j]==target:
                    return [i+1,j+1]</code></pre>
<p>题解二|双指针:</p>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<pre><code>class Solution:
    def twoSum(self, numbers: List[int], target: int) -&gt; List[int]:
        left=0
        right=len(numbers)-1
        while left &lt; right:
            if numbers[left]+numbers[right]==target:
                return [left+1,right+1]
            elif numbers[left]+numbers[right] &gt; target:
                right-=1
            else:
                left+=1
        return False</code></pre>
<h3 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189. 旋转数组"></a>189. 旋转数组</h3><pre><code>链接：https://leetcode-cn.com/problems/rotate-array/

给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。

示例 1:

输入: [1,2,3,4,5,6,7] 和 k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]
示例 2:

输入: [-1,-100,3,99] 和 k = 2
输出: [3,99,-1,-100]
解释: 
向右旋转 1 步: [99,-1,-100,3]
向右旋转 2 步: [3,99,-1,-100]
说明:

尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
要求使用空间复杂度为 O(1) 的 原地 算法。</code></pre>
<p>题解一|暴力|超时：</p>
<p>时间复杂度：O(n^2)<br>空间复杂度：O(1)</p>
<pre><code>class Solution:
    def rotate(self, nums: List[int], k: int) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums in-place instead.
        &quot;&quot;&quot;
        if not nums:
            return &#39;&#39;
        n=len(nums)
        k=k%n
        while k!=0:
            tmp=nums[n-1]
            i=n-1
            while i&gt;0:
                nums[i]=nums[i-1]
                i-=1
            nums[0]=tmp
            k-=1
        return nums</code></pre>
<p>题解二|切片：</p>
<pre><code>class Solution:
    def rotate(self, nums: List[int], k: int) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums in-place instead.
        &quot;&quot;&quot;
        n=len(nums)
        if n &lt; 2:
            pass
        else:
            while k&gt;0:
                tmp=nums[-1]
                nums[1:n]=nums[0:n-1]
                nums[0]=tmp
                k-=1</code></pre>
<h3 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a>283. 移动零</h3><pre><code>链接：https://leetcode-cn.com/problems/move-zeroes/

给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

示例:

输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
说明:

必须在原数组上操作，不能拷贝额外的数组。
尽量减少操作次数。</code></pre>
<p>思路：<br>    循环，统计0的个数，非0元素前移，0放在最后；</p>
<pre><code>新开一个数组，碰到0后放，非0放在前面；

index记录非0的位置；</code></pre>
<p>题解一：</p>
<pre><code>class Solution:
    def moveZeroes(self, nums: List[int]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums in-place instead.
        &quot;&quot;&quot;
        index=0
        for i in range(len(nums)):
            if nums[i] != 0:
                nums[index]=nums[i]
                index+=1
        for i in range(index,len(nums)):
            nums[i]=0
        return nums</code></pre>
<pre><code>class Solution:
    def moveZeroes(self, nums: List[int]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums in-place instead.
        &quot;&quot;&quot;
        index=0
        for i in range(len(nums)):
            if nums[i] != 0:
                nums[index]=nums[i]
                if i != index:
                    nums[i]=0
                index+=1
        return nums</code></pre>
<h3 id="442-数组中重复的数据"><a href="#442-数组中重复的数据" class="headerlink" title="442. 数组中重复的数据"></a>442. 数组中重复的数据</h3><pre><code>链接：https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/

给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。

找到所有出现两次的元素。

你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗？

示例：

输入:
[4,3,2,7,8,2,3,1]

输出:
[2,3]</code></pre>
<p>题解一|原地变负：</p>
<p>注意：1 ≤ a[i] ≤ n，所以变负时才不会越界。</p>
<pre><code>class Solution:
    def findDuplicates(self, nums: List[int]) -&gt; List[int]:
        ans=[]
        for num in nums:
            if nums[abs(num)-1] &lt; 0:
                ans.append(abs(num))
            nums[abs(num)-1]*=-1
        return ans</code></pre>
<h3 id="498-对角线遍历"><a href="#498-对角线遍历" class="headerlink" title="498. 对角线遍历"></a>498. 对角线遍历</h3><pre><code>给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。

示例:

输入:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]

输出:  [1,2,4,7,5,3,6,8,9]

解释:

说明:

给定矩阵中的元素总数不会超过 100000 。</code></pre>
<p>题解一：</p>
<p>规律：</p>
<pre><code>对于矩形来说，矩形对角线是最长的，也是遍历结果最长的一条，从这条线，到两边对称递减

遍历顺序：从左下角到右上角交错进行</code></pre>
<p>根据以上两个特点，我们可以想到是否同一条线上的坐标有数上的关系，而且，交替遍历是否可以看成奇数和偶数的替换呢？带着这种思考我们解析这个矩阵(以图中矩阵为例子)：</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/duijiaoxian.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/duijiaoxian.png"></p>
<pre><code>1、我们现在将每一条对角线作出从0 开始的编号，可以发现最后一个的编号是 M + N - 1；并且如果编号为奇数自上而下遍历，偶数则是自下而上遍历

2、关注每一条对角线上的坐标和：对于每一条对角线上的坐标(m,n)，m + n = 编号 是我们发现的规律

3、最后一步就是确定边界：

    多少次遍历：矩阵有多少个元素就遍历多少次；
    到什么时候结束：对于最长对角线以上来说，到 m 或者 n 中的某一个到 0 为止；对于最长对角线下面来说，到 m 或者 n 中的某一个到达边界为止。</code></pre>
<pre><code>class Solution:
    def findDiagonalOrder(self, matrix: List[List[int]]) -&gt; List[int]:
        if not matrix:
            return []
        size=len(matrix)*len(matrix[0])
        index=0
        result=[0]*size
        maxK=len(matrix)+len(matrix[0])


        for k in range(maxK):
            m,n=0,0
            if k%2==0: # 偶数部分
                if k&lt;len(matrix):
                    m=k
                    n=0
                else:
                    m=len(matrix)-1
                    n=k-m
                while m&gt;=0 and n&lt;len(matrix[0]): # n到达边界为止
                    result[index]=matrix[m][n]
                    index+=1
                    m-=1
                    n+=1
            else: # 奇数部分
                if k&lt;len(matrix[0]):
                    m=0
                    n=k
                else:
                    n=len(matrix[0])-1
                    m=k-n
                while m&lt;len(matrix) and n&gt;=0: # m到达边界为止
                    result[index]=matrix[m][n]
                    index+=1
                    m+=1
                    n-=1
        return result</code></pre>
<h3 id="1424-对角线遍历-II"><a href="#1424-对角线遍历-II" class="headerlink" title="1424. 对角线遍历 II"></a>1424. 对角线遍历 II</h3><pre><code>链接：https://leetcode-cn.com/problems/diagonal-traverse-ii/solution/mei-ge-shu-zu-yuan-su-de-wei-zhi-jue-ding-liao-ta-/

给你一个列表 nums ，里面每一个元素都是一个整数列表。请你依照下面各图的规则，按顺序返回 nums 中对角线上的整数。

示例 1：

输入：nums = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,4,2,7,5,3,8,6,9]
示例 2：

输入：nums = [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]]
输出：[1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16]
示例 3：

输入：nums = [[1,2,3],[4],[5,6,7],[8],[9,10,11]]
输出：[1,4,2,5,3,8,6,9,7,10,11]
示例 4：

输入：nums = [[1,2,3,4,5,6]]
输出：[1,2,3,4,5,6]

提示：

1 &lt;= nums.length &lt;= 10^5
1 &lt;= nums[i].length &lt;= 10^5
1 &lt;= nums[i][j] &lt;= 10^9
nums 中最多有 10^5 个数字。</code></pre>
<pre><code>class Solution:
    def findDiagonalOrder(self, nums: List[List[int]]) -&gt; List[int]:
        sub=[]
        for i in range(len(nums)):
            for j in range(len(nums[i])):
                if i+j &gt;= len(sub):
                    sub.append([])
                sub[i+j].append(nums[i][j])
        result=[]
        for i in sub:
            result+=i[::-1]
        return result</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92-%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92-%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">线性回归--从0开始实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-09-17 19:19:43" itemprop="dateCreated datePublished" datetime="2018-09-17T19:19:43+08:00">2018-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-18 17:10:52" itemprop="dateModified" datetime="2020-09-18T17:10:52+08:00">2020-09-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习和深度学习</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/gluon/" itemprop="url" rel="index"><span itemprop="name">gluon</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>代码：<a target="_blank" rel="noopener" href="https://github.com/Gladysgong/gluon_learning/blob/master/chap3_basic/">https://github.com/Gladysgong/gluon_learning/blob/master/chap3_basic/</a></p>
<h2 id="一-线性回归"><a href="#一-线性回归" class="headerlink" title="一.线性回归"></a>一.线性回归</h2><pre><code>线性回归输出是连续值，因此不适用于回归问题；
Softmax回归输出是是离散值，因为适用于分类问题。</code></pre>
<h3 id="1-线性回归要素"><a href="#1-线性回归要素" class="headerlink" title="1.线性回归要素"></a>1.线性回归要素</h3><pre><code>模型: 
    表达式：</code></pre>
<p>$$\hat{y} = x_1 w_1 + x_2 w_2 + b,$$</p>
<pre><code>    模型训练:
        训练数据
        损失函数
        优化算法:
            解析解：误差最小化问题的解可以直接用公式表达出来
            数值解：大多数深度学习模型并没有解析解，只能通过优化算法有限次迭代模型参数来尽可能降低损失函数的值
                   小批量随机梯度下降：批量大小和学习率是认为设定的，叫做超参数

    模型预测</code></pre>
<h3 id="2-线性回归表示方法"><a href="#2-线性回归表示方法" class="headerlink" title="2.线性回归表示方法"></a>2.线性回归表示方法</h3><pre><code>神经网络图
矢量计算表达式</code></pre>
<h2 id="二-线性回归–从0开始实现"><a href="#二-线性回归–从0开始实现" class="headerlink" title="二.线性回归–从0开始实现"></a>二.线性回归–从0开始实现</h2><pre class=" language-python"><code class="language-python"><span class="token operator">%</span>matplotlib inline
<span class="token keyword">from</span> IPython <span class="token keyword">import</span> display
<span class="token keyword">from</span> matplotlib <span class="token keyword">import</span> pyplot <span class="token keyword">as</span> plt
<span class="token keyword">from</span> mxnet <span class="token keyword">import</span> autograd<span class="token punctuation">,</span> nd
<span class="token keyword">import</span> random</code></pre>
<h3 id="1-生成数据集"><a href="#1-生成数据集" class="headerlink" title="1.生成数据集"></a>1.生成数据集</h3><pre><code>numpy.random.normal(loc=0.0, scale=1.0, size=None)11
loc：float
    此概率分布的均值（对应着整个分布的中心centre）
scale：float
    此概率分布的标准差（对应于分布的宽度，scale越大越矮胖，scale越小，越瘦高）
size：int or tuple of ints
    输出的shape，默认为None</code></pre>
<pre class=" language-python"><code class="language-python">num_inputs<span class="token operator">=</span><span class="token number">2</span>
num_examples<span class="token operator">=</span><span class="token number">1000</span>
true_w<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">3.4</span><span class="token punctuation">]</span>
true_b<span class="token operator">=</span><span class="token number">4.2</span>
features<span class="token operator">=</span>nd<span class="token punctuation">.</span>random<span class="token punctuation">.</span>normal<span class="token punctuation">(</span>scale<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>shape<span class="token operator">=</span><span class="token punctuation">(</span>num_examples<span class="token punctuation">,</span>num_inputs<span class="token punctuation">)</span><span class="token punctuation">)</span>
labels<span class="token operator">=</span>true_w<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span>features<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span>true_w<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">*</span>features<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>true_b
labels<span class="token operator">+=</span>nd<span class="token punctuation">.</span>random<span class="token punctuation">.</span>normal<span class="token punctuation">(</span>scale<span class="token operator">=</span><span class="token number">0.01</span><span class="token punctuation">,</span>shape<span class="token operator">=</span>labels<span class="token punctuation">.</span>shape<span class="token punctuation">)</span></code></pre>
<pre class=" language-python"><code class="language-python">features<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>labels<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span></code></pre>
<pre><code>(
 [ 1.16307867  0.48380461]
 &lt;NDArray 2 @cpu(0)&gt;, 
 [ 4.87962484]
 &lt;NDArray 1 @cpu(0)&gt;)</code></pre>
<pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">use_svg_display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment" spellcheck="true"># 用矢量图表示</span>
    display<span class="token punctuation">.</span>set_matplotlib_formats<span class="token punctuation">(</span><span class="token string">'svg'</span><span class="token punctuation">)</span>

<span class="token keyword">def</span> <span class="token function">set_figsize</span><span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">3.5</span><span class="token punctuation">,</span><span class="token number">2.5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment" spellcheck="true">#set_matplotlib_formats('svg')</span>
    use_svg_display<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment" spellcheck="true"># 设置图的尺寸</span>
    plt<span class="token punctuation">.</span>rcParams<span class="token punctuation">[</span><span class="token string">'figure.figsize'</span><span class="token punctuation">]</span><span class="token operator">=</span>figsize

set_figsize<span class="token punctuation">(</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>features<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>asnumpy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>labels<span class="token punctuation">.</span>asnumpy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># plt.show()</span></code></pre>
<pre><code>&lt;matplotlib.collections.PathCollection at 0x117cadda0&gt;</code></pre>
<p><img src="/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92-%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0/linear_regression_6_1.svg" alt="svg"></p>
<h3 id="2-读取数据"><a href="#2-读取数据" class="headerlink" title="2.读取数据"></a>2.读取数据</h3><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 每次返回batch_size(批量大小)个随机样本的特征和标签</span>
<span class="token comment" spellcheck="true"># 此函数已保存在gluonbook包中方便以后使用</span>
<span class="token keyword">def</span> <span class="token function">data_iter</span><span class="token punctuation">(</span>batch_size<span class="token punctuation">,</span>features<span class="token punctuation">,</span>labels<span class="token punctuation">)</span><span class="token punctuation">:</span>
    num_examples<span class="token operator">=</span>len<span class="token punctuation">(</span>features<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"长度："</span><span class="token punctuation">,</span>num_examples<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 1000,行数</span>
    indices<span class="token operator">=</span>list<span class="token punctuation">(</span>range<span class="token punctuation">(</span>num_examples<span class="token punctuation">)</span><span class="token punctuation">)</span> 
<span class="token comment" spellcheck="true">#     print("indices：",indices)  # 0-999</span>
    random<span class="token punctuation">.</span>shuffle<span class="token punctuation">(</span>indices<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 样本的读取顺序是随机的。</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>num_examples<span class="token punctuation">,</span>batch_size<span class="token punctuation">)</span><span class="token punctuation">:</span>
        j<span class="token operator">=</span>nd<span class="token punctuation">.</span>array<span class="token punctuation">(</span>indices<span class="token punctuation">[</span>i<span class="token punctuation">:</span>min<span class="token punctuation">(</span>i<span class="token operator">+</span>batch_size<span class="token punctuation">,</span>num_examples<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">yield</span> features<span class="token punctuation">.</span>take<span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">,</span>labels<span class="token punctuation">.</span>take<span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># take 函数根据索引返回对应元素。</span></code></pre>
<pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 每个批量的特征形状为（10， 2），分别对应批量大小和输入个数；标签形状为批量大小。</span>
batch_size <span class="token operator">=</span> <span class="token number">10</span>

<span class="token keyword">for</span> X<span class="token punctuation">,</span> y <span class="token keyword">in</span> data_iter<span class="token punctuation">(</span>batch_size<span class="token punctuation">,</span> features<span class="token punctuation">,</span> labels<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> y<span class="token punctuation">)</span>
    <span class="token keyword">break</span></code></pre>
<pre><code>长度： 1000

[[-1.4370029  -2.39830184]
 [ 0.86399084 -0.95994246]
 [-1.49929214  1.21278656]
 [ 2.52268934 -0.37837121]
 [ 1.39448225  0.56141484]
 [ 0.50767344  0.07797763]
 [ 0.37963197 -0.65589839]
 [-0.47827247 -1.17394924]
 [-0.11860342  1.41482413]
 [ 1.18384051  0.65427899]]
&lt;NDArray 10x2 @cpu(0)&gt; 
[  9.47776413   9.20563984  -2.91862679  10.52518559   5.09047413
   4.9430213    7.19049788   7.2272377   -0.82722223   4.32375574]
&lt;NDArray 10 @cpu(0)&gt;</code></pre>
<h3 id="3-初始化模型参数"><a href="#3-初始化模型参数" class="headerlink" title="3.初始化模型参数"></a>3.初始化模型参数</h3><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 将权重初始化成均值为 0 标准差为 0.01 的正态随机数，偏差则初始化成 0。</span>
w<span class="token operator">=</span>nd<span class="token punctuation">.</span>random<span class="token punctuation">.</span>normal<span class="token punctuation">(</span>scale<span class="token operator">=</span><span class="token number">0.01</span><span class="token punctuation">,</span>shape<span class="token operator">=</span><span class="token punctuation">(</span>num_inputs<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
b<span class="token operator">=</span>nd<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>shape<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<pre class=" language-python"><code class="language-python">w<span class="token punctuation">,</span>b</code></pre>
<pre><code>(
 [[ 0.01464221]
  [-0.01305814]]
 &lt;NDArray 2x1 @cpu(0)&gt;, 
 [ 0.]
 &lt;NDArray 1 @cpu(0)&gt;)</code></pre>
<pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 创建梯度，yinw需要对这些参数求梯度来迭代参数的值</span>
w<span class="token punctuation">.</span>attach_grad<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 申请存储梯度所需要的内存</span>
b<span class="token punctuation">.</span>attach_grad<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<h3 id="4-定义模型"><a href="#4-定义模型" class="headerlink" title="4.定义模型"></a>4.定义模型</h3><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 线性回归的矢量计算表达式的实现</span>
<span class="token comment" spellcheck="true"># 本函数已保存在 gluonbook 包中方便以后使用。</span>
<span class="token keyword">def</span> <span class="token function">linreg</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span>w<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> nd<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>X<span class="token punctuation">,</span>w<span class="token punctuation">)</span><span class="token operator">+</span>b <span class="token comment" spellcheck="true"># dot做矩阵乘法</span></code></pre>
<h3 id="5-定义损失函数"><a href="#5-定义损失函数" class="headerlink" title="5.定义损失函数"></a>5.定义损失函数</h3><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 使用平方损失来定义线性回归的损失函数</span>
<span class="token comment" spellcheck="true"># 本函数已保存在 gluonbook 包中方便以后使用。</span>
<span class="token keyword">def</span> <span class="token function">squared_loss</span><span class="token punctuation">(</span>y_hat<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span><span class="token punctuation">(</span>y_hat<span class="token operator">-</span>y<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>y_hat<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">2</span><span class="token operator">/</span><span class="token number">2</span> <span class="token comment" spellcheck="true"># y_hat是线性回归对真实价格 y 的预测或估计</span></code></pre>
<h3 id="6-定义优化算法"><a href="#6-定义优化算法" class="headerlink" title="6.定义优化算法"></a>6.定义优化算法</h3><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 使用sgd函数实现小批量随机梯度下降算法</span>
<span class="token comment" spellcheck="true"># 通过不断迭代模型参数来优化损失函数，这里自动求导模块计算得来的梯度是一个批量样本的梯度和，将它除以批量大小来得到平均值。</span>
<span class="token comment" spellcheck="true"># 本函数已保存在 gluonbook 包中方便以后使用。</span>
<span class="token keyword">def</span> <span class="token function">sgd</span><span class="token punctuation">(</span>params<span class="token punctuation">,</span>lr<span class="token punctuation">,</span>batch_size<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> param <span class="token keyword">in</span> params<span class="token punctuation">:</span>
        param<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">=</span>param<span class="token operator">-</span>lr<span class="token operator">*</span>param<span class="token punctuation">.</span>grad<span class="token operator">/</span>batch_size</code></pre>
<h3 id="7-训练模型"><a href="#7-训练模型" class="headerlink" title="7.训练模型"></a>7.训练模型</h3><pre class=" language-python"><code class="language-python">lr <span class="token operator">=</span> <span class="token number">0.03</span>
num_epochs <span class="token operator">=</span> <span class="token number">3</span>
net <span class="token operator">=</span> linreg
loss <span class="token operator">=</span> squared_loss

<span class="token keyword">for</span> epoch <span class="token keyword">in</span> range<span class="token punctuation">(</span>num_epochs<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 训练模型一共需要 num_epochs 个迭代周期。</span>
    <span class="token comment" spellcheck="true"># 在一个迭代周期中，使用训练数据集中所有样本一次（假设样本数能够被批量大小整除）。</span>
    <span class="token comment" spellcheck="true"># X 和 y 分别是小批量样本的特征和标签。</span>
    <span class="token keyword">for</span> X<span class="token punctuation">,</span> y <span class="token keyword">in</span> data_iter<span class="token punctuation">(</span>batch_size<span class="token punctuation">,</span> features<span class="token punctuation">,</span> labels<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">with</span> autograd<span class="token punctuation">.</span>record<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            l <span class="token operator">=</span> loss<span class="token punctuation">(</span>net<span class="token punctuation">(</span>X<span class="token punctuation">,</span> w<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># l 是有关小批量 X 和 y 的损失。</span>
        l<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 小批量的损失对模型参数求梯度。</span>
        sgd<span class="token punctuation">(</span><span class="token punctuation">[</span>w<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">,</span> lr<span class="token punctuation">,</span> batch_size<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 使用小批量随机梯度下降迭代模型参数。</span>
    train_l <span class="token operator">=</span> loss<span class="token punctuation">(</span>net<span class="token punctuation">(</span>features<span class="token punctuation">,</span> w<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">,</span> labels<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'epoch %d, loss %f'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>epoch <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> train_l<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>asnumpy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<pre><code>长度： 1000
epoch 1, loss 0.000048
长度： 1000
epoch 2, loss 0.000048
长度： 1000
epoch 3, loss 0.000048</code></pre>
<pre class=" language-python"><code class="language-python">true_w<span class="token punctuation">,</span>w</code></pre>
<pre><code>([2, -3.4], 
 [[ 2.00003362]
  [-3.40025949]]
 &lt;NDArray 2x1 @cpu(0)&gt;)</code></pre>
<pre class=" language-python"><code class="language-python">true_b<span class="token punctuation">,</span>b</code></pre>
<pre><code>(4.2, 
 [ 4.20015049]
 &lt;NDArray 1 @cpu(0)&gt;)</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/KNN/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/KNN/" class="post-title-link" itemprop="url">KNN</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-09-10 14:26:36" itemprop="dateCreated datePublished" datetime="2018-09-10T14:26:36+08:00">2018-09-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-18 16:59:41" itemprop="dateModified" datetime="2020-09-18T16:59:41+08:00">2020-09-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习和深度学习</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98%E3%80%8B/" itemprop="url" rel="index"><span itemprop="name">《机器学习实战》</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#coding:utf-8</span>

<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np
<span class="token keyword">import</span> operator</code></pre>
<pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">createDataSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    group<span class="token operator">=</span>np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1.0</span><span class="token punctuation">,</span><span class="token number">1.1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1.0</span><span class="token punctuation">,</span><span class="token number">1.0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0.1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    labels<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'A'</span><span class="token punctuation">,</span><span class="token string">'A'</span><span class="token punctuation">,</span><span class="token string">'B'</span><span class="token punctuation">,</span><span class="token string">'B'</span><span class="token punctuation">]</span>
    <span class="token keyword">return</span> group<span class="token punctuation">,</span>labels</code></pre>
<pre class=" language-python"><code class="language-python">group<span class="token punctuation">,</span>labels<span class="token operator">=</span>createDataSet<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<pre class=" language-python"><code class="language-python">group<span class="token punctuation">,</span>labels</code></pre>
<pre><code>(array([[1. , 1.1],
        [1. , 1. ],
        [0. , 0. ],
        [0. , 0.1]]), [&#39;A&#39;, &#39;A&#39;, &#39;B&#39;, &#39;B&#39;])</code></pre>
<pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">classify0</span><span class="token punctuation">(</span>inX<span class="token punctuation">,</span>dataSet<span class="token punctuation">,</span>labels<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span>
    dataSetSize<span class="token operator">=</span>dataSet<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># dataSet的行数</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"dataSetSize:"</span><span class="token punctuation">,</span>dataSetSize<span class="token punctuation">)</span>
    diffMat<span class="token operator">=</span>np<span class="token punctuation">.</span>tile<span class="token punctuation">(</span>inX<span class="token punctuation">,</span><span class="token punctuation">(</span>dataSetSize<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-</span>dataSet <span class="token comment" spellcheck="true"># 构造一个和dataSet一样的矩阵，再和dataSet相减</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"diffMat:"</span><span class="token punctuation">,</span>diffMat<span class="token punctuation">)</span>
    sqDiffMat<span class="token operator">=</span>diffMat<span class="token operator">**</span><span class="token number">2</span> <span class="token comment" spellcheck="true"># 矩阵的平方</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"sqDiffMat:"</span><span class="token punctuation">,</span>sqDiffMat<span class="token punctuation">)</span>
    sqDistances<span class="token operator">=</span>sqDiffMat<span class="token punctuation">.</span>sum<span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 按行相加</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"sqDistances:"</span><span class="token punctuation">,</span>sqDistances<span class="token punctuation">)</span>
    distances<span class="token operator">=</span>sqDistances<span class="token operator">**</span><span class="token number">0.5</span> <span class="token comment" spellcheck="true"># 开方，求距离</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"distances:"</span><span class="token punctuation">,</span>distances<span class="token punctuation">)</span>
    sortedDistIndicies<span class="token operator">=</span>distances<span class="token punctuation">.</span>argsort<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 对距离排序</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"sortedDistIndicies:"</span><span class="token punctuation">,</span>sortedDistIndicies<span class="token punctuation">)</span>
    classCount<span class="token operator">=</span><span class="token operator">&amp;</span><span class="token comment" spellcheck="true">#123;&amp;#125;</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span>
        voteIlabel<span class="token operator">=</span>labels<span class="token punctuation">[</span>sortedDistIndicies<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"voteIlable:"</span><span class="token punctuation">,</span>voteIlabel<span class="token punctuation">)</span>
        classCount<span class="token punctuation">[</span>voteIlabel<span class="token punctuation">]</span><span class="token operator">=</span>classCount<span class="token punctuation">.</span>get<span class="token punctuation">(</span>voteIlabel<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"classCount:"</span><span class="token punctuation">,</span>classCount<span class="token punctuation">)</span>
    sortedClassCount<span class="token operator">=</span>sorted<span class="token punctuation">(</span>classCount<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>key<span class="token operator">=</span>operator<span class="token punctuation">.</span>itemgetter<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>reverse<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>sortedClassCount<span class="token punctuation">)</span>
    <span class="token keyword">return</span> sortedClassCount<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
classify0<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1.0</span><span class="token punctuation">,</span><span class="token number">1.2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>group<span class="token punctuation">,</span>labels<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span></code></pre>
<pre><code>dataSetSize: 4
diffMat: [[0.  0.1]
 [0.  0.2]
 [1.  1.2]
 [1.  1.1]]
sqDiffMat: [[0.   0.01]
 [0.   0.04]
 [1.   1.44]
 [1.   1.21]]
sqDistances: [0.01 0.04 2.44 2.21]
distances: [0.1        0.2        1.56204994 1.48660687]
sortedDistIndicies: [0 1 3 2]
voteIlable: A
classCount: &#123;&#39;A&#39;: 1&#125;
voteIlable: A
classCount: &#123;&#39;A&#39;: 2&#125;
voteIlable: B
classCount: &#123;&#39;A&#39;: 2, &#39;B&#39;: 1&#125;
[(&#39;A&#39;, 2), (&#39;B&#39;, 1)]





&#39;A&#39;</code></pre>
<pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 将文本记录转换为numpy矩阵</span>
<span class="token keyword">def</span> <span class="token function">file2matrix</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token punctuation">:</span>
    fr<span class="token operator">=</span>open<span class="token punctuation">(</span>filename<span class="token punctuation">)</span>

    numberOfLines<span class="token operator">=</span>len<span class="token punctuation">(</span>fr<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    returnMat<span class="token operator">=</span>np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span>numberOfLines<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 创建一个和文本一样形式的0矩阵</span>
    classLabelVector<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
    fr<span class="token operator">=</span>open<span class="token punctuation">(</span>filename<span class="token punctuation">)</span>

    index<span class="token operator">=</span><span class="token number">0</span>
    <span class="token keyword">for</span> line <span class="token keyword">in</span> fr<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        line<span class="token operator">=</span>line<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span>
        listFromLine<span class="token operator">=</span>line<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">'\t'</span><span class="token punctuation">)</span>
        returnMat<span class="token punctuation">[</span>index<span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">=</span>listFromLine<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span>
        classLabelVector<span class="token punctuation">.</span>append<span class="token punctuation">(</span>int<span class="token punctuation">(</span>listFromLine<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        index<span class="token operator">+=</span><span class="token number">1</span>
    <span class="token keyword">return</span> returnMat<span class="token punctuation">,</span>classLabelVector</code></pre>
<pre class=" language-python"><code class="language-python">datingDataMat<span class="token punctuation">,</span>datingLabels<span class="token operator">=</span>file2matrix<span class="token punctuation">(</span><span class="token string">'datingTestSet2.txt'</span><span class="token punctuation">)</span>
datingDataMat<span class="token punctuation">,</span>datingLabels<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">20</span><span class="token punctuation">]</span></code></pre>
<pre><code>(array([[4.0920000e+04, 8.3269760e+00, 9.5395200e-01],
        [1.4488000e+04, 7.1534690e+00, 1.6739040e+00],
        [2.6052000e+04, 1.4418710e+00, 8.0512400e-01],
        ...,
        [2.6575000e+04, 1.0650102e+01, 8.6662700e-01],
        [4.8111000e+04, 9.1345280e+00, 7.2804500e-01],
        [4.3757000e+04, 7.8826010e+00, 1.3324460e+00]]),
 [3, 2, 1, 1, 1, 1, 3, 3, 1, 3, 1, 1, 2, 1, 1, 1, 1, 1, 2, 3])</code></pre>
<pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 分析数据，使用Matplotlib创建散点图</span>
<span class="token keyword">import</span> matplotlib
<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt
<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np
<span class="token comment" spellcheck="true"># mpl.rcParams['font.sans-serif'] = ['SimHei']  </span>
<span class="token comment" spellcheck="true"># mpl.rcParams['axes.unicode_minus'] = False  </span>
fig<span class="token operator">=</span>plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span><span class="token punctuation">)</span>
ax<span class="token operator">=</span>fig<span class="token punctuation">.</span>add_subplot<span class="token punctuation">(</span><span class="token number">111</span><span class="token punctuation">)</span>

datingLabels <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>datingLabels<span class="token punctuation">)</span>

idx_1<span class="token operator">=</span>np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>datingLabels<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span>
p1<span class="token operator">=</span>ax<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>datingDataMat<span class="token punctuation">[</span>idx_1<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>datingDataMat<span class="token punctuation">[</span>idx_1<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>color<span class="token operator">=</span><span class="token string">'y'</span><span class="token punctuation">,</span>label<span class="token operator">=</span><span class="token string">'1'</span><span class="token punctuation">,</span>s<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span>
idx_2<span class="token operator">=</span>np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>datingLabels<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span>
p2<span class="token operator">=</span>ax<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>datingDataMat<span class="token punctuation">[</span>idx_2<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>datingDataMat<span class="token punctuation">[</span>idx_2<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>color<span class="token operator">=</span><span class="token string">'g'</span><span class="token punctuation">,</span>label<span class="token operator">=</span><span class="token string">'1'</span><span class="token punctuation">,</span>s<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">)</span>
idx_3<span class="token operator">=</span>np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>datingLabels<span class="token operator">==</span><span class="token number">3</span><span class="token punctuation">)</span>
p3<span class="token operator">=</span>ax<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>datingDataMat<span class="token punctuation">[</span>idx_3<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>datingDataMat<span class="token punctuation">[</span>idx_3<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>color<span class="token operator">=</span><span class="token string">'b'</span><span class="token punctuation">,</span>label<span class="token operator">=</span><span class="token string">'1'</span><span class="token punctuation">,</span>s<span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true"># ax.scatter(datingDataMat[:,1],datingDataMat[:,2],15.0*np.array(datingLabels),15.0*np.array(datingLabels),c='yellow')</span>

plt<span class="token punctuation">.</span>xlabel<span class="token punctuation">(</span>u<span class="token string">'每年获取的飞行常客里程数'</span><span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>ylabel<span class="token punctuation">(</span>u<span class="token string">'玩视频游戏所耗时间百分比'</span><span class="token punctuation">)</span>
ax<span class="token punctuation">.</span>legend<span class="token punctuation">(</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span>p2<span class="token punctuation">,</span>p3<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>u<span class="token string">'不喜欢'</span><span class="token punctuation">,</span> u<span class="token string">'魅力一般'</span><span class="token punctuation">,</span> u<span class="token string">'极具魅力'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> loc<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true"># ax.rc('font',family=['SeiHei'])</span>
<span class="token comment" spellcheck="true">#ax.legend((p1,p2,p3), (u'不喜欢', u'魅力一般', u'极具魅力'), loc=2, prop=zhfont)</span>
plt<span class="token punctuation">.</span>rcParams<span class="token punctuation">[</span><span class="token string">'font.sans-serif'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'SimHei'</span><span class="token punctuation">]</span>
plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<p><img src="/KNN/Untitled_7_0.png" alt="png"></p>
<pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 归一化特征值</span>
<span class="token keyword">def</span> <span class="token function">autoNorm</span><span class="token punctuation">(</span>dataSet<span class="token punctuation">)</span><span class="token punctuation">:</span>
    minVals<span class="token operator">=</span>dataSet<span class="token punctuation">.</span>min<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 3列数据中的3个最小值</span>
    maxVals<span class="token operator">=</span>dataSet<span class="token punctuation">.</span>max<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 3列数据中的3个最大值</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>minVals<span class="token punctuation">)</span>

    ranges<span class="token operator">=</span>maxVals<span class="token operator">-</span>minVals
    normDateSet<span class="token operator">=</span>np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>np<span class="token punctuation">.</span>shape<span class="token punctuation">(</span>dataSet<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>normDateSet<span class="token punctuation">)</span>
    m<span class="token operator">=</span>dataSet<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 行数1000</span>
    normDateSet<span class="token operator">=</span>dataSet<span class="token operator">-</span>np<span class="token punctuation">.</span>tile<span class="token punctuation">(</span>minVals<span class="token punctuation">,</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#dataSet减去同样格式的最小值组成的矩阵</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>normDateSet<span class="token punctuation">)</span>
    normDateSet<span class="token operator">=</span>normDateSet<span class="token operator">/</span>np<span class="token punctuation">.</span>tile<span class="token punctuation">(</span>ranges<span class="token punctuation">,</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> normDateSet<span class="token punctuation">,</span>ranges<span class="token punctuation">,</span>minVals</code></pre>
<p>normMat,ranges,minVals=autoNorm(datingDataMat)</p>
<pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 分类器针对约会网站的测试代码</span>
<span class="token keyword">def</span> <span class="token function">datingClassTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    hoRatio<span class="token operator">=</span><span class="token number">0.5</span>
    datingDataMat<span class="token punctuation">,</span>datingLabels<span class="token operator">=</span>file2matrix<span class="token punctuation">(</span><span class="token string">'datingTestSet2.txt'</span><span class="token punctuation">)</span>
    normMat<span class="token punctuation">,</span>ranges<span class="token punctuation">,</span>minVals<span class="token operator">=</span>autoNorm<span class="token punctuation">(</span>datingDataMat<span class="token punctuation">)</span>
    m<span class="token operator">=</span>normMat<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    numTestVecs<span class="token operator">=</span>int<span class="token punctuation">(</span>m<span class="token operator">*</span>hoRatio<span class="token punctuation">)</span>
    errorCount<span class="token operator">=</span><span class="token number">0.0</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>numTestVecs<span class="token punctuation">)</span><span class="token punctuation">:</span>
        classifierResult<span class="token operator">=</span>classify0<span class="token punctuation">(</span>normDateSet<span class="token punctuation">)</span></code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/%E5%A6%82%E4%BD%95%E5%B0%86ipynb%E6%96%87%E4%BB%B6%E8%BD%AC%E6%8D%A2%E4%B8%BAhtml%EF%BC%8Cmarkdown%EF%BC%8Cpdf%E7%AD%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E5%A6%82%E4%BD%95%E5%B0%86ipynb%E6%96%87%E4%BB%B6%E8%BD%AC%E6%8D%A2%E4%B8%BAhtml%EF%BC%8Cmarkdown%EF%BC%8Cpdf%E7%AD%89/" class="post-title-link" itemprop="url">如何将ipynb文件转换为html，markdown，pdf等</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-09-09 22:25:54" itemprop="dateCreated datePublished" datetime="2018-09-09T22:25:54+08:00">2018-09-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-18 21:26:53" itemprop="dateModified" datetime="2020-09-18T21:26:53+08:00">2020-09-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E7%AF%87/" itemprop="url" rel="index"><span itemprop="name">工具篇</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E7%AF%87/Jupyter/" itemprop="url" rel="index"><span itemprop="name">Jupyter</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><pre><code>本文讲将jupyter notebook中的文件（xxx.ipynb）转换成html，md，pdf等格式呢。
如果使用下列命令有误的话，建议安装jupyter相关插件：
$ pip install jupyter_contrib_nbextensions</code></pre>
<h2 id="一-ipynb转为html格式"><a href="#一-ipynb转为html格式" class="headerlink" title="一.ipynb转为html格式"></a>一.ipynb转为html格式</h2><pre><code>$ jupyter nbconvert --to html notebook.ipynb

jupyter中提供了一些命令，可以对生成的html格式进行配置：
$ jupyter nbconvert --to html --template full notebook.ipynb

默认配置，提供完整的静态html格式，交互性更强。
$ jupyter nbconvert --to html --template basic notebook.ipynb
简化的html，用于嵌入网页、博客等，这不包括html标题。</code></pre>
<h2 id="二-ipynb转换为md格式"><a href="#二-ipynb转换为md格式" class="headerlink" title="二.ipynb转换为md格式"></a>二.ipynb转换为md格式</h2><pre><code>$ jupyter nbconvert --to markdown notebook.ipynb
简单的Markdown格式输出，cell单元不受影响，代码cell缩进4个空格。</code></pre>
<h2 id="三-ipynb转换为tex格式"><a href="#三-ipynb转换为tex格式" class="headerlink" title="三.ipynb转换为tex格式"></a>三.ipynb转换为tex格式</h2><pre><code>$ jupyter nbconvert --to letex notebook.ipynb

Letex导出格式，生成后缀名为NOTEBOOK_NAME.tex的文件。jupyter提供的额外模板配置为：
$ jupyter nbconvert --to letex -template article notebook.ipynb

默认配置，Latex文章。
$ jupyter nbconvert --to letex -template report notebook.ipynb

Latex报告，提供目录和章节。
$ jupyter nbconvert --to letex -template basic notebook.ipynb
最基本的Latex输出，经常用来自定义配置。</code></pre>
<h2 id="四-jupyter转换为pdf格式"><a href="#四-jupyter转换为pdf格式" class="headerlink" title="四.jupyter转换为pdf格式"></a>四.jupyter转换为pdf格式</h2><pre><code>$ jupyter nbconvert --to pdf notebook.ipynb

转换为pdf格式分模板配置与latex配置是一样的。但是直接转换为pdf格式经常会出现xelatex错误：
该错误提示没有安装xelatex。所以，我们需要提前安装xelatex，方法是安装texLive套装：

$ sudo apt-get install texlive-full
texlive-full的安装包有点大，约1G多。</code></pre>
<h2 id="五-简单的转换方法"><a href="#五-简单的转换方法" class="headerlink" title="五.简单的转换方法"></a>五.简单的转换方法</h2><pre><code>ipynb转换为html、md、pdf等格式，还有另一种更简单的方法：在jupyter notebook中，选择File-&gt;Download as，直接选择需要转换的格式就可以了。需要注意的是，转换为pdf格式之前，同样要保证已经安装了xelatex。</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/Mac-Matplotlib%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E7%9A%84%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Mac-Matplotlib%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E4%B8%AD%E6%96%87%E7%9A%84%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">matplotlib-1-问题记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-09-02 13:29:05" itemprop="dateCreated datePublished" datetime="2018-09-02T13:29:05+08:00">2018-09-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-18 17:07:42" itemprop="dateModified" datetime="2020-09-18T17:07:42+08:00">2020-09-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%92%8C%E6%8A%93%E5%8F%96/" itemprop="url" rel="index"><span itemprop="name">数据分析和抓取</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%92%8C%E6%8A%93%E5%8F%96/Matplotlib/" itemprop="url" rel="index"><span itemprop="name">Matplotlib</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、问题：matplotlib无法显示中文的问题"><a href="#一、问题：matplotlib无法显示中文的问题" class="headerlink" title="一、问题：matplotlib无法显示中文的问题"></a>一、问题：matplotlib无法显示中文的问题</h2><pre><code>网上找了好多种方法，显示中文的时候还是小框框，在我的Mac上就是不行。这是在我的Mac上可行的办法，希望对你也有用。</code></pre>
<h3 id="1、下载SimHei-ttf字体"><a href="#1、下载SimHei-ttf字体" class="headerlink" title="1、下载SimHei.ttf字体"></a>1、下载SimHei.ttf字体</h3><pre><code>http://www.fontpalace.com/font-details/SimHei/</code></pre>
<h3 id="2、解决办法"><a href="#2、解决办法" class="headerlink" title="2、解决办法"></a>2、解决办法</h3><pre><code>1.找到Matplotlib路径
$ python
&gt; import matplotlib
&gt; print(matplotlib.matplotlib_fname()) # 获得matplotlib包所在文件夹路径
/anaconda3/envs/tensorflow/lib/python3.6/site-packages/matplotlib/mpl-data/matplotlibrc

2.将下载的ttf文件拷贝到此目录下
$ cd /anaconda3/envs/tensorflow/lib/python3.6/site-packages/matplotlib/mpl-data/
$ cd fonts/ttf
$ cp ttf文件 . # 拷贝下载的ttf文件到此目录

3. 删除字体缓存文件
$ rm -rf ~/.matplotlib/*.cache

4. 字体参数设置
$ cd /anaconda3/envs/tensorflow/lib/python3.6/site-packages/matplotlib/mpl-data
$ vi matplotlibrc
font.family         : sans-serif 
font.sans-serif     : SimHei
axes.unicode_minus  : False # use unicode for the minus symbol
# 意思是知道字库族为 sans-serif，同时添加“SimHei”即宋体到字库族列表中，同时将找到axes.unicode_minus，将True改为False，作用就是解决负号’-‘显示为方块的问题

5. 字体显示
有中文出现的情况，需要 u&#39;内容&#39;，比如 plt.xlabel(u&#39;横坐标&#39;)
同时还需在开头添加代码行：#coding:utf-8

注意：
但是我走到这一步后运行，字体显示仍未小框框。提示：
【UserWarning: findfont: Font family [‘sans-serifs’] not found. Falling back to Bitstream Vera Sans】
说明还是没有找到字体，所以我进一步进行配置。

6.配置fontList.json
# 在ttflist文件添加&quot;SimHei&quot;字体集

$ cd /Users/apple/.matplotlib
$ vi fontList.json</code></pre>
<p><img src="http://p2lakvkq0.bkt.clouddn.com/matplotlib_fonts.png"><br>    图片红框中的ttf文件是我后加的，说明之前这个ttf文件不在其中，所以自然找不到这个字体。<br>    根据自己的位置在文件中添加自己的ttf文件<br>    添加如下配置（参考文件中的配置）：</p>
<pre><code>&#123;
  &quot;fname&quot;: &quot;/anaconda3/envs/tensorflow/lib/python3.6/site-packages/matplotlib/mpl-data/fonts/ttf/SimHei.ttf&quot;,
  &quot;name&quot;: &quot;SimHei&quot;,
  &quot;style&quot;: &quot;normal&quot;,
  &quot;variant&quot;: &quot;normal&quot;,
  &quot;weight&quot;: 400,
  &quot;stretch&quot;: &quot;normal&quot;,
  &quot;size&quot;: &quot;scalable&quot;,
  &quot;_class&quot;: &quot;FontEntry&quot;
&#125;,

之后重启项目，matplotlib即可显示中文字体了。</code></pre>
<h2 id="二、查看matplotlib支持的字体集"><a href="#二、查看matplotlib支持的字体集" class="headerlink" title="二、查看matplotlib支持的字体集"></a>二、查看matplotlib支持的字体集</h2><pre><code>$ python 
&gt; import matplotlib
&gt; xxx=sorted(f.name for f in matplotlib.font_manager.fontManager.ttflist)
&gt; for i in xxx:
          print(i)</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/Django-2-ModelForm%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Django-2-ModelForm%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">Django-2-ModelForm详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-08-31 12:41:10" itemprop="dateCreated datePublished" datetime="2018-08-31T12:41:10+08:00">2018-08-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-18 13:42:46" itemprop="dateModified" datetime="2020-09-18T13:42:46+08:00">2020-09-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/Django/" itemprop="url" rel="index"><span itemprop="name">Django</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h2><pre><code>ModelForm：功能是将Model和Form组合起来</code></pre>
<h2 id="二-ModelForm"><a href="#二-ModelForm" class="headerlink" title="二.ModelForm"></a>二.ModelForm</h2><pre><code>from django.forms import ModelForm # 导入ModelForm
from django.forms import fields
from .models import Book

class BookModelForm(forms.ModelForm):
class Meta:
     # 可以在这里单独定义字段的具体类型和属性，同Form;
     # 如果定义的字段在model中存在，则会覆盖；
     name=fields.CharField(required=True)

    model = Book

    # fields控制在前端显示的字段
    fields = [&#39;name&#39;, &#39;authors&#39;, &#39;publish_date&#39;]
    fields=&#39;__all__&#39;

    # labels控制在前端是否显示标题
     labels=&#123;
             &#39;name&#39;: &#39;用户名&#39;,   # &#39;name&#39;:&#39;&#39; 
         &#39;authors&#39;: &#39;作者&#39;,
         &#39;publish_date&#39;: &#39;日期&#39;,
     &#125;

    widgets = &#123;
        &#39;name&#39;: forms.TextInput(attrs=&#123;&#39;class&#39;: &quot;form-control&quot;&#125;),
        &#39;authors&#39;: forms.Select(attrs=&#123;&#39;class&#39;: &quot;form-control&quot;&#125;),
        &#39;publish_date&#39;: forms.DateInput(attrs=&#123;&#39;class&#39;: &quot;form-control&quot;,
                                               &#39;placeholder&#39;: &quot;YYYY-MM-DD&quot;&#125;)
    &#125;




 说明：

    model: 对应的数据库model

    fields: 选择字段列表；’all’是选择所有字段

    exclude: 排除字段列表

    widgets: 插件字典

    labels: 前端显示字段名

    help_texts：帮助提示信息

    error_messages: 自定义错误提示

    localized_fields: 本地化，如：根据不同时区显示数据</code></pre>
<h2 id="三-View"><a href="#三-View" class="headerlink" title="三.View"></a>三.View</h2><pre><code>class Index(TemplateView):
  template_name = &quot;index.html&quot;

  def get(self, request, *args, **kwargs):
      form = BookModelForm()    
      return self.render_to_response(context=&#123;&quot;form&quot;: form&#125;)

  def post(self,request):

      form = BookModelForm()

      # obj=model.Book.objects.get(id=1)
      #form=BookModelForm(request.POST,instance=obj)

     if form.is_valid():
         form.save()
         return redirect(&quot;home&quot;)

            # obj = form.save(commit=False)
            # obj.save()      # 保存单表信息
            # obj.save_m2m()  # 保存关联多对多信息
     return self.render_to_response(context=&#123;&quot;form&quot;: form&#125;)</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/iTerm2-sshpass-Mac%E4%B8%8B%E4%BD%BF%E7%94%A8iTerm2%E5%85%8D%E5%AF%86%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/iTerm2-sshpass-Mac%E4%B8%8B%E4%BD%BF%E7%94%A8iTerm2%E5%85%8D%E5%AF%86%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA/" class="post-title-link" itemprop="url">iTerm2+sshpass:Mac下使用iTerm2免密连接远程主机</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-08-31 11:37:49" itemprop="dateCreated datePublished" datetime="2018-08-31T11:37:49+08:00">2018-08-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-18 16:29:24" itemprop="dateModified" datetime="2020-09-18T16:29:24+08:00">2020-09-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E7%AF%87/" itemprop="url" rel="index"><span itemprop="name">工具篇</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E7%AF%87/ssh/" itemprop="url" rel="index"><span itemprop="name">ssh</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一-安装iTerm2"><a href="#一-安装iTerm2" class="headerlink" title="一.安装iTerm2"></a>一.安装iTerm2</h2><pre><code>不再介绍</code></pre>
<h2 id="二-安装sshpass"><a href="#二-安装sshpass" class="headerlink" title="二.安装sshpass"></a>二.安装sshpass</h2><pre><code>使用brew进行安装
$ brew install https://raw.githubusercontent.com/kadwanev/bigboybrew/master/Library/Formula/sshpass.rb
$ sshpass -h # 验证是否安装成功</code></pre>
<h2 id="三-设置免密"><a href="#三-设置免密" class="headerlink" title="三.设置免密"></a>三.设置免密</h2><pre><code>关键是Command模式格式：
/usr/local/bin/sshpass -p (密码) ssh -p (端口) (登录)@(服务器IP或者域名)</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/Mac%E4%B8%8B%E4%BD%BF%E7%94%A8iTerm2%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Mac%E4%B8%8B%E4%BD%BF%E7%94%A8iTerm2%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA/" class="post-title-link" itemprop="url">Mac下使用iTerm2连接远程主机</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-08-31 11:33:11" itemprop="dateCreated datePublished" datetime="2018-08-31T11:33:11+08:00">2018-08-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-18 16:34:21" itemprop="dateModified" datetime="2020-09-18T16:34:21+08:00">2020-09-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E7%AF%87/" itemprop="url" rel="index"><span itemprop="name">工具篇</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E7%AF%87/ssh/" itemprop="url" rel="index"><span itemprop="name">ssh</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h2><pre><code>1. 打开一个 iTerm2 窗口，选择菜单 profiles 中的 Open Profiles，然后选择 Edit Profiles 中创建一个新的 Profile，自己命名
2. 选择 command，输入 ssh -A -p xxx root@输入远程计算机的 IP 地址（xxx 表示端口）。
3. 然后选择这个新的 profile，New 一个 window 就可以连接远程服务器了。</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Lilly</p>
  <div class="site-description" itemprop="description">Up in the wind!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">128</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lilly</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
