<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"gongyanli.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="五、链表2.两数相加链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;add-two-numbers&#x2F;  给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。  如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。  您可以假设除了数字 0 之外，这两个数都不会以 0 开头。  示">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode-5-链表">
<meta property="og:url" content="http://gongyanli.com/LeetCode-5-%E9%93%BE%E8%A1%A8/index.html">
<meta property="og:site_name" content="茉莉Python">
<meta property="og:description" content="五、链表2.两数相加链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;add-two-numbers&#x2F;  给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。  如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。  您可以假设除了数字 0 之外，这两个数都不会以 0 开头。  示">
<meta property="og:locale">
<meta property="og:image" content="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode1.jpg">
<meta property="og:image" content="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode2.jpg">
<meta property="og:image" content="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode3.jpg">
<meta property="og:image" content="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode4.png">
<meta property="og:image" content="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/link.png">
<meta property="og:image" content="http://p2lakvkq0.bkt.clouddn.com/linkedlist.jpg">
<meta property="og:image" content="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode5.JPG">
<meta property="og:image" content="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/link10.png">
<meta property="og:image" content="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode6.png">
<meta property="article:published_time" content="2020-01-15T14:01:02.000Z">
<meta property="article:modified_time" content="2020-09-16T07:40:06.984Z">
<meta property="article:author" content="Lilly">
<meta property="article:tag" content="LeetCode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode1.jpg">

<link rel="canonical" href="http://gongyanli.com/LeetCode-5-%E9%93%BE%E8%A1%A8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>LeetCode-5-链表 | 茉莉Python</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">茉莉Python</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">voidqueens@hotmail.com</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://gongyanli.com/LeetCode-5-%E9%93%BE%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lilly">
      <meta itemprop="description" content="Up in the wind!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="茉莉Python">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          LeetCode-5-链表
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-15 22:01:02" itemprop="dateCreated datePublished" datetime="2020-01-15T22:01:02+08:00">2020-01-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-16 15:40:06" itemprop="dateModified" datetime="2020-09-16T15:40:06+08:00">2020-09-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="五、链表"><a href="#五、链表" class="headerlink" title="五、链表"></a>五、链表</h2><h3 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h3><pre><code>链接：https://leetcode-cn.com/problems/add-two-numbers/

给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。

如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

您可以假设除了数字 0 之外，这两个数都不会以 0 开头。

示例：

输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
输出：7 -&gt; 0 -&gt; 8
原因：342 + 465 = 807</code></pre>
<p>题解一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:</span><br><span class="line">        if not l1:</span><br><span class="line">            return l2</span><br><span class="line">        if not l2:</span><br><span class="line">            return l1</span><br><span class="line">        dummy&#x3D;res&#x3D;ListNode(0)</span><br><span class="line">        flag&#x3D;0</span><br><span class="line"></span><br><span class="line">        while l1 or l2:</span><br><span class="line">            sum&#x3D;0</span><br><span class="line">            if l1:</span><br><span class="line">                sum&#x3D;l1.val</span><br><span class="line">                l1&#x3D;l1.next</span><br><span class="line">            if l2:</span><br><span class="line">                sum+&#x3D;l2.val</span><br><span class="line">                l2&#x3D;l2.next</span><br><span class="line">            tmp&#x3D;(sum+flag)%10 # 余数</span><br><span class="line">            flag&#x3D;(sum+flag)&#x2F;&#x2F;10 # 进位</span><br><span class="line"></span><br><span class="line">            res.next&#x3D;ListNode(tmp)</span><br><span class="line">            res&#x3D;res.next</span><br><span class="line"></span><br><span class="line">            if flag: # 这里虽然创建了一个节点，但是并没有res&#x3D;res.next,并没有右移。所以插入8时没有问题。同时case输入为[5]和[5]时，可以得到结果[0,1]，而非[0]</span><br><span class="line">                res.next&#x3D;ListNode(1)</span><br><span class="line">        return dummy.next</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:</span><br><span class="line">        res&#x3D;dummy&#x3D;ListNode(-1)</span><br><span class="line">        flag&#x3D;0</span><br><span class="line">        while l1 and l2:</span><br><span class="line">            res.next&#x3D;ListNode(l1.val+l2.val+flag)</span><br><span class="line">            flag&#x3D;res.next.val &#x2F;&#x2F; 10</span><br><span class="line">            res.next.val %&#x3D; 10</span><br><span class="line">            res&#x3D;res.next</span><br><span class="line">            l1&#x3D;l1.next</span><br><span class="line">            l2&#x3D;l2.next</span><br><span class="line">        </span><br><span class="line">        p&#x3D; l1 or l2</span><br><span class="line">        while p:</span><br><span class="line">            res.next&#x3D;ListNode(p.val+flag)</span><br><span class="line">            flag&#x3D;res.next.val &#x2F;&#x2F; 10</span><br><span class="line">            res.next.val %&#x3D; 10</span><br><span class="line">            p&#x3D;p.next</span><br><span class="line">            res&#x3D;res.next</span><br><span class="line">        if flag:</span><br><span class="line">            res.next&#x3D;ListNode(1)</span><br><span class="line">        return dummy.next</span><br></pre></td></tr></table></figure>

<h3 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19. 删除链表的倒数第N个节点"></a>19. 删除链表的倒数第N个节点</h3><pre><code>链接：https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/

给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。

示例：

给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.
说明：

给定的 n 保证是有效的。

进阶：你能尝试使用一趟扫描实现吗？</code></pre>
<p>题解一|两次遍历：</p>
<p>分析：<br>    删除从列表开头数起的第 (L−n+1) 个结点，其中 L 是列表的长度。只要我们找到列表的长度 L，这个问题就很容易解决。</p>
<pre><code>在第一次遍历中，我们找出列表的长度 L。
设置一个指向哑结点的指针，并移动它遍历列表，直至它到达第 (L−n) 个结点那里。我们把第 (L−n) 个结点的 next 指针重新链接至第 (L−n+2) 个结点，完成这个算法。</code></pre>
<p>时间复杂度：O(L)，该算法对列表进行了两次遍历，首先计算了列表的长度 L 其次找到第 (L−n) 个结点。 操作执行了 2L-n 步，时间复杂度为 O(L)。</p>
<p>空间复杂度：O(1)，我们只用了常量级的额外空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode:</span><br><span class="line">        dummy&#x3D;ListNode(-1)</span><br><span class="line">        dummy.next&#x3D;head # 注意case:[1]和1</span><br><span class="line">        p&#x3D;dummy</span><br><span class="line">        length&#x3D;0</span><br><span class="line">        while p:</span><br><span class="line">            p&#x3D;p.next</span><br><span class="line">            length+&#x3D;1 # 注意：这里length&#x3D;6，而不是5，因为有一个头节点。</span><br><span class="line">        length-&#x3D;(n+1)</span><br><span class="line">        p&#x3D;dummy</span><br><span class="line">        while length&gt;0:</span><br><span class="line">            p&#x3D;p.next</span><br><span class="line">            length-&#x3D;1</span><br><span class="line">        p.next&#x3D;p.next.next</span><br><span class="line">        return dummy.next</span><br></pre></td></tr></table></figure>
<p>题解二|一次遍历：</p>
<p>分析：<br>    第一个指针从列表的开头向前移动 n+1 步，而第二个指针将从列表的开头出发。</p>
<pre><code>通过同时移动两个指针向前来保持这个恒定的间隔，直到第一个指针到达最后一个结点。

此时第二个指针将指向从最后一个结点数起的第 n 个结点。我们重新链接第二个指针所引用的结点的 next 指针指向该结点的下下个结点。</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode:</span><br><span class="line">        dummy&#x3D;ListNode(-1)</span><br><span class="line">        dummy.next&#x3D;head # 如果dummy&#x3D;head,case为[1],1不能通过。</span><br><span class="line">        fast&#x3D;slow&#x3D;dummy</span><br><span class="line">        while fast and n:</span><br><span class="line">            fast&#x3D;fast.next</span><br><span class="line">            n-&#x3D;1</span><br><span class="line">        while fast.next and slow.next: # 注意不是while fast and slow：</span><br><span class="line">            fast&#x3D;fast.next</span><br><span class="line">            slow&#x3D;slow.next</span><br><span class="line"></span><br><span class="line">        # print( fast.val,slow.val)</span><br><span class="line">        slow.next&#x3D;slow.next.next</span><br><span class="line">        return dummy.next</span><br></pre></td></tr></table></figure>

<h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a>21. 合并两个有序链表</h3><pre><code>链接：https://leetcode-cn.com/problems/merge-two-sorted-lists/

将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

示例：

输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4
输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</code></pre>
<p>题解一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode:</span><br><span class="line">        # if not l1:</span><br><span class="line">        #     return l2</span><br><span class="line">        # if not l2:</span><br><span class="line">        #     return l1</span><br><span class="line">        head&#x3D;dummy&#x3D;ListNode(-1)</span><br><span class="line">        while l1 and l2:</span><br><span class="line">            if l1.val &lt; l2.val:</span><br><span class="line">                head.next&#x3D;l1</span><br><span class="line">                l1&#x3D;l1.next</span><br><span class="line">            else:</span><br><span class="line">                head.next&#x3D;l2</span><br><span class="line">                l2&#x3D;l2.next</span><br><span class="line">            head&#x3D;head.next</span><br><span class="line">        if l1:</span><br><span class="line">            head.next&#x3D;l1</span><br><span class="line">        if l2:</span><br><span class="line">            head.next&#x3D;l2</span><br><span class="line">        return dummy.next</span><br></pre></td></tr></table></figure>

<h3 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h3><pre><code>链接：https://leetcode-cn.com/problems/swap-nodes-in-pairs/

给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

示例:

给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</code></pre>
<p>参考：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/dong-hua-yan-shi-24-liang-liang-jiao-huan-lian-bia/">https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/dong-hua-yan-shi-24-liang-liang-jiao-huan-lian-bia/</a></p>
<p>题解一|递归：<br>分析：</p>
<pre><code>从链表的头节点 head 开始递归。
每次递归都负责交换一对节点。由 firstNode 和 secondNode 表示要交换的两个节点。
下一次递归则是传递的是下一对需要交换的节点。若链表中还有节点，则继续递归。
交换了两个节点以后，返回 secondNode，因为它是交换后的新头。
在所有节点交换完成以后，我们返回交换后的头，实际上是原始链表的第二个节点。</code></pre>
<p>时间复杂度：O(N)，其中 N 指的是链表的节点数量。<br>空间复杂度：O(N)，递归过程使用的堆栈空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def swapPairs(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        if not head or not head.next:</span><br><span class="line">            return head</span><br><span class="line"></span><br><span class="line">        first&#x3D;head</span><br><span class="line">        second&#x3D;head.next</span><br><span class="line"></span><br><span class="line">        # swap</span><br><span class="line">        first.next&#x3D;self.swapPairs(second.next)</span><br><span class="line">        second.next&#x3D;first</span><br><span class="line"></span><br><span class="line">        return second</span><br></pre></td></tr></table></figure>
<p>题解二|迭代：</p>
<p>我们把链表分为两部分，即奇数节点为一部分，偶数节点为一部分，A 指的是交换节点中的前面的节点，B 指的是要交换节点中的后面的节点。在完成它们的交换，我们还得用 prevNode 记录 A 的前驱节点。</p>
<p>思路：</p>
<pre><code>1、firstNode（即 A） 和 secondNode（即 B） 分别遍历偶数节点和奇数节点，即两步看作一步。

2、交换两个节点：
    firstNode.next = secondNode.next
    secondNode.next = firstNode

3、还需要更新 prevNode.next 指向交换后的头。
    prevNode.next = secondNode

4、迭代完成后得到最终的交换结果。</code></pre>
<p>时间复杂度：O(N)，其中 N 指的是链表的节点数量。<br>空间复杂度：O(1)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def swapPairs(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        dummy&#x3D;ListNode(-1)</span><br><span class="line">        dummy.next&#x3D;head</span><br><span class="line">        pre&#x3D;dummy</span><br><span class="line"></span><br><span class="line">        while head and head.next:</span><br><span class="line">            first&#x3D;head</span><br><span class="line">            second&#x3D;head.next</span><br><span class="line"></span><br><span class="line">            # swap</span><br><span class="line">            pre.next&#x3D;second</span><br><span class="line">            first.next&#x3D;second.next</span><br><span class="line">            second.next&#x3D;first</span><br><span class="line"></span><br><span class="line">            # Reinitializing the head and prev_node for next swap</span><br><span class="line">            pre&#x3D;first # 通过pre来构成新的链表</span><br><span class="line">            # print(pre.val)</span><br><span class="line">            head&#x3D;first.next</span><br><span class="line"></span><br><span class="line">        return dummy.next</span><br></pre></td></tr></table></figure>

<h3 id="61-旋转链表"><a href="#61-旋转链表" class="headerlink" title="61. 旋转链表"></a>61. 旋转链表</h3><pre><code>链接：https://leetcode-cn.com/problems/rotate-list/

给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。

示例 1:

输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2
输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL
解释:
向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL
向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL
示例 2:

输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4
输出: 2-&gt;0-&gt;1-&gt;NULL
解释:
向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL
向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL
向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL
向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL</code></pre>
<p>题解一|暴力法：</p>
<p>分析：</p>
<pre><code>首先遍历获得链表的长度以及链表尾部的指针（引用）；
之后头尾拼接起来；
随后我们只要从头遍历k - k % length步就能够找到旋转后链表的头指针，断开尾指针和头指针，返回头指针。</code></pre>
<p>关键点就是k，如果移动一次就相当于将倒数第一个元素1移到链表开头，如果移动两次就相当于将倒数第二和倒数第一个元素2和1移动到链表开头。</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode1.jpg" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode1.jpg"></p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode2.jpg" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode2.jpg"></p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode3.jpg" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode3.jpg"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def rotateRight(self, head: ListNode, k: int) -&gt; ListNode:</span><br><span class="line">        if not head:</span><br><span class="line">            return None</span><br><span class="line">        cur&#x3D;head</span><br><span class="line">        length&#x3D;1</span><br><span class="line">        while cur.next:</span><br><span class="line">            cur&#x3D;cur.next</span><br><span class="line">            length+&#x3D;1</span><br><span class="line">        cur.next&#x3D;head # 头尾拼接</span><br><span class="line">        k&#x3D;length-k%length                                          </span><br><span class="line">        while k:</span><br><span class="line">            k-&#x3D;1</span><br><span class="line">            cur&#x3D;cur.next</span><br><span class="line">        head&#x3D;cur.next # 找到头指针</span><br><span class="line">        cur.next&#x3D;None  # 断开尾节点             </span><br><span class="line">        return head</span><br></pre></td></tr></table></figure>

<h3 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="??82.删除排序链表中的重复元素 II"></a>??82.删除排序链表中的重复元素 II</h3><pre><code>链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/

给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。

示例 1:

输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5
输出: 1-&gt;2-&gt;5
示例 2:

输入: 1-&gt;1-&gt;1-&gt;2-&gt;3
输出: 2-&gt;3</code></pre>
<p>题解一：</p>
<p>建立哑结点dummy，当前处理节点为curr，它的值为anchor，它的前序节点为prev。</p>
<p>思路：</p>
<p>如果curr的后序节点的值等于anchor，那么标注flag为True，curr一直后移下去，总之，curr移到连续的最后一个值为anchor的节点，停下来。如果经历了上述步骤，那么prev和curr.next相连，prev按兵不动，curr后移一位；如果没有经历，curr的值是独一无二的，那么prev和curr同时右移一位。继续循环直到curr移到最后一位。</p>
<p>时间复杂度: O(n), 空间复杂度: O(1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        dummy&#x3D;ListNode(-1)</span><br><span class="line">        dummy.next&#x3D;head</span><br><span class="line">        pre,curr&#x3D;dummy,head</span><br><span class="line"></span><br><span class="line">        while curr:</span><br><span class="line">            anchor&#x3D;curr.val</span><br><span class="line">            flag&#x3D;False</span><br><span class="line">            while curr.next:</span><br><span class="line">                if curr.next.val &#x3D;&#x3D; anchor:</span><br><span class="line">                    curr&#x3D;curr.next</span><br><span class="line">                    flag&#x3D;True</span><br><span class="line">                else:</span><br><span class="line">                    break</span><br><span class="line">            if flag:</span><br><span class="line">                pre.next&#x3D;curr.next # pre并未向前移动</span><br><span class="line">            else:</span><br><span class="line">                pre&#x3D;curr</span><br><span class="line">            curr&#x3D;curr.next</span><br><span class="line">        return dummy.next</span><br></pre></td></tr></table></figure>

<p>题解二（快慢指针）：</p>
<pre><code>// 3.1 fast 遍历链表,让fast 去嗅探不相等元素
// 3.2 slow.next == fast --&gt; slow 与 fast 之间没有重复元素，slow 动。
// 3.3 slow.next != fast --&gt; slow 与 fast 之间存在重复元素，让slow指向的元素跳过这些重复元素，slow 不动。</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        dummy&#x3D;ListNode(-1)</span><br><span class="line">        dummy.next&#x3D;head</span><br><span class="line">        slow&#x3D;dummy</span><br><span class="line">        fast&#x3D;head</span><br><span class="line"></span><br><span class="line">        while fast and fast.next:</span><br><span class="line">            if fast.val !&#x3D; fast.next.val:</span><br><span class="line">                if slow.next &#x3D;&#x3D; fast: # 注意此处判断的是内存地址，而非节点的值</span><br><span class="line">                    slow&#x3D;fast</span><br><span class="line">                    # print(&#39;111&#39;,slow)</span><br><span class="line">                else:</span><br><span class="line">                    # print(&#39;222&#39;,fast.next)</span><br><span class="line">                    slow.next&#x3D;fast.next # slow并未向前移动</span><br><span class="line">            fast&#x3D;fast.next</span><br><span class="line">        if slow.next !&#x3D; fast: # 解决case:[1,1]</span><br><span class="line">            slow.next&#x3D;fast.next</span><br><span class="line">        return dummy.next</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        if head &#x3D;&#x3D; None or head.next &#x3D;&#x3D; None:</span><br><span class="line">            return head</span><br><span class="line">        dummy &#x3D; ListNode(-1000)</span><br><span class="line">        dummy.next &#x3D; head</span><br><span class="line">        slow &#x3D; dummy</span><br><span class="line">        fast &#x3D; dummy.next</span><br><span class="line">        while fast:</span><br><span class="line">            if  fast.next and fast.next.val &#x3D;&#x3D; fast.val:</span><br><span class="line">                tmp &#x3D; fast.val</span><br><span class="line">                while fast and tmp &#x3D;&#x3D; fast.val:</span><br><span class="line">                    fast &#x3D; fast.next</span><br><span class="line">            else:</span><br><span class="line">                slow.next &#x3D; fast</span><br><span class="line">                slow &#x3D; fast</span><br><span class="line">                fast &#x3D; fast.next</span><br><span class="line">        slow.next &#x3D; fast</span><br><span class="line">        return dummy.next</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        if head &#x3D;&#x3D; None or head.next &#x3D;&#x3D; None:</span><br><span class="line">            return head</span><br><span class="line">        dummy &#x3D; ListNode(-1)</span><br><span class="line">        dummy.next &#x3D; head</span><br><span class="line">        slow &#x3D; dummy</span><br><span class="line">        fast &#x3D; dummy.next</span><br><span class="line">        while fast:</span><br><span class="line">            while fast.next and slow.next.val &#x3D;&#x3D; fast.next.val:</span><br><span class="line">                fast &#x3D; fast.next</span><br><span class="line">            if slow.next &#x3D;&#x3D; fast:</span><br><span class="line">                slow &#x3D; fast</span><br><span class="line">            else:</span><br><span class="line">                slow.next &#x3D; fast.next</span><br><span class="line">            fast &#x3D; fast.next</span><br><span class="line">        return dummy.next</span><br></pre></td></tr></table></figure>

<p>题解三（递归）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        if not head:</span><br><span class="line">            return head</span><br><span class="line">        if head.next and head.val &#x3D;&#x3D; head.next.val:</span><br><span class="line">            while head.next and head.val &#x3D;&#x3D; head.next.val:</span><br><span class="line">                head&#x3D;head.next</span><br><span class="line">            return self.deleteDuplicates(head.next)</span><br><span class="line">        else:</span><br><span class="line">            head.next&#x3D;self.deleteDuplicates(head.next)</span><br><span class="line">        return head</span><br></pre></td></tr></table></figure>

<h3 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a>83. 删除排序链表中的重复元素</h3><pre><code>链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/

给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。

示例 1:

输入: 1-&gt;1-&gt;2
输出: 1-&gt;2
示例 2:

输入: 1-&gt;1-&gt;2-&gt;3-&gt;3
输出: 1-&gt;2-&gt;3</code></pre>
<p>思路：因为是排序列表，通过将结点的值与它之后的结点进行比较来确定它是否为重复结点。如果它是重复的，我们更改当前结点的 next 指针，以便它跳过下一个结点并直接指向下一个结点之后的结点。</p>
<p>时间复杂度：O(n)，因为列表中的每个结点都检查一次以确定它是否重复，所以总运行时间为 O(n)，其中 n 是列表中的结点数。<br>空间复杂度：O(1)，没有使用额外的空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        dummy&#x3D;ListNode(-1)</span><br><span class="line">        dummy.next&#x3D;head</span><br><span class="line">        while head and head.next:</span><br><span class="line">            if head.val &#x3D;&#x3D; head.next.val:</span><br><span class="line">                head.next&#x3D;head.next.next</span><br><span class="line">            else:</span><br><span class="line">                head&#x3D;head.next</span><br><span class="line">        return dummy.next</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        dummy&#x3D;head</span><br><span class="line">        while head and head.next:</span><br><span class="line">            if head.val &#x3D;&#x3D; head.next.val:</span><br><span class="line">                head.next&#x3D;head.next.next</span><br><span class="line">            else:</span><br><span class="line">                head&#x3D;head.next</span><br><span class="line">        return dummy</span><br></pre></td></tr></table></figure>

<h3 id="86-分隔链表"><a href="#86-分隔链表" class="headerlink" title="86. 分隔链表"></a>86. 分隔链表</h3><pre><code>链接：https://leetcode-cn.com/problems/partition-list/

给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。

你应当保留两个分区中每个节点的初始相对位置。

示例:

输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3
输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</code></pre>
<p>分析：</p>
<pre><code>哈哈，差点没看懂题。</code></pre>
<p>这道题要求我们划分链表，把所有小于给定值的节点都移到前面，大于该值的节点顺序不变，相当于一个局部排序的问题。那么可以想到的一种解法是首先找到第一个大于或等于给定值的节点，用题目中给的例子来说就是先找到4，然后再找小于3的值，每找到一个就将其取出置于4之前即可</p>
<p>题解一（双指针法）：</p>
<p>用两个指针before 和 after 来追踪上述的两个链表。两个指针可以用于分别创建两个链表，然后将这两个链表连接即可获得所需的链表。</p>
<p>时间复杂度: O(N)，其中N是原链表的长度，我们对该链表进行了遍历。<br>空间复杂度: O(1)，我们没有申请任何新空间。值得注意的是，我们只移动了原有的结点，因此没有使用任何额外空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def partition(self, head: ListNode, x: int) -&gt; ListNode:</span><br><span class="line">        before&#x3D;bf&#x3D;ListNode(-1)</span><br><span class="line">        after&#x3D;af&#x3D;ListNode(-1)</span><br><span class="line"></span><br><span class="line">        while head:</span><br><span class="line">            if head.val &lt; x:</span><br><span class="line">                before.next&#x3D;head</span><br><span class="line">                before&#x3D;before.next</span><br><span class="line">            else:</span><br><span class="line">                after.next&#x3D;head</span><br><span class="line">                after&#x3D;after.next</span><br><span class="line">            head&#x3D;head.next</span><br><span class="line">        </span><br><span class="line">        after.next&#x3D;None</span><br><span class="line">        before.next&#x3D;af.next</span><br><span class="line">        return bf.next</span><br></pre></td></tr></table></figure>

<h3 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a>92. 反转链表 II</h3><pre><code>链接：https://leetcode-cn.com/problems/reverse-linked-list-ii/

反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。

说明:
1 ≤ m ≤ n ≤ 链表长度。

示例:

输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4
输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</code></pre>
<p>题解一（迭代）：</p>
<p>时间复杂度: O(N)。考虑包含 N 个结点的链表。对每个节点最多会处理<br>（第 n 个结点之后的结点不处理）。</p>
<p>空间复杂度: O(1)。我们仅仅在原有链表的基础上调整了一些指针，只使用了 O(1)的额外存储空间来获得结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def reverseBetween(self, head: ListNode, m: int, n: int) -&gt; ListNode:</span><br><span class="line">        if not head:</span><br><span class="line">            return None</span><br><span class="line">        prev,cur&#x3D;None,head</span><br><span class="line">        while m&gt;1:</span><br><span class="line">            prev&#x3D;cur</span><br><span class="line">            cur&#x3D;cur.next</span><br><span class="line">            m,n&#x3D;m-1,n-1</span><br><span class="line">        # print(cur.val,prev.val)</span><br><span class="line">        # tail 指针指向从链表头起的第m个结点，此结点是反转后链表的尾部，故称为 tail。</span><br><span class="line">        # con 指针指向第 m 个结点的前一个结点，此结点是新链表的头部。</span><br><span class="line">        con,tail&#x3D;prev,cur</span><br><span class="line">        while n:</span><br><span class="line">            next&#x3D;cur.next</span><br><span class="line">            cur.next&#x3D;prev</span><br><span class="line">            prev&#x3D;cur</span><br><span class="line">            cur&#x3D;next</span><br><span class="line">            n-&#x3D;1</span><br><span class="line">        if con:</span><br><span class="line">            con.next&#x3D;prev # 头节点链接反转后链表的头节点</span><br><span class="line">        else:</span><br><span class="line">            # head.next&#x3D;prev</span><br><span class="line">            head&#x3D;prev</span><br><span class="line">        tail.next&#x3D;cur # 反转后的链表链接尾节点</span><br><span class="line">        return head</span><br></pre></td></tr></table></figure>

<h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141.环形链表"></a>141.环形链表</h3><pre><code>链表：https://leetcode-cn.com/problems/linked-list-cycle

给定一个链表，判断链表中是否有环。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。

示例 1：

输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。


示例 2：

输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。


示例 3：

输入：head = [1], pos = -1
输出：false
解释：链表中没有环。

进阶：你能用 O(1)（即，常量）内存解决此问题吗？</code></pre>
<p>题解一|hash:</p>
<pre><code>时间复杂度：O(n)，对于含有 n个元素的链表，我们访问每个元素最多一次。添加一个结点到哈希表中只需要花费 O(1) 的时间。

空间复杂度：O(n)，空间取决于添加到哈希表中的元素数目，最多可以添加 n 个元素。</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class ListNode:</span><br><span class="line">    def __init__(self, x):</span><br><span class="line">        self.val &#x3D; x</span><br><span class="line">        self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def hasCycle(self, head: ListNode) -&gt; bool:</span><br><span class="line">        hash&#x3D;&#123;&#125;</span><br><span class="line">        while head :</span><br><span class="line">            if head not in hash:</span><br><span class="line">                hash[head]&#x3D;0</span><br><span class="line">                head&#x3D;head.next</span><br><span class="line">            else:</span><br><span class="line">                return True</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure>
<p>题解二|快慢指针:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def hasCycle(self, head: ListNode) -&gt; bool:</span><br><span class="line">        if not head or not head.next: </span><br><span class="line">            return False</span><br><span class="line">        i,j&#x3D;head,head.next</span><br><span class="line">        while j and j.next: # 如果没有j.next，无法通过case ([1,2] -1).</span><br><span class="line">            if i&#x3D;&#x3D;j:</span><br><span class="line">                return True</span><br><span class="line">            i,j&#x3D;i.next,j.next.next</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def hasCycle(self, head: ListNode) -&gt; bool:</span><br><span class="line">        slow&#x3D;fast&#x3D;head</span><br><span class="line">        while fast and fast.next: # 如果没有fast.next，无法通过case ([1] -1).</span><br><span class="line">            fast&#x3D;fast.next.next</span><br><span class="line">            slow&#x3D;slow.next</span><br><span class="line">            # print(fast.val,slow.val)</span><br><span class="line">            if fast &#x3D;&#x3D; slow:</span><br><span class="line">                # print(fast.val)</span><br><span class="line">                return True # 返回True的节点并不一定就是环的入口节点。</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure>
<h3 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142.环形链表 II"></a>142.环形链表 II</h3><pre><code>链接：https://leetcode-cn.com/problems/linked-list-cycle-ii/

给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。

说明：不允许修改给定的链表。

示例 1：

输入：head = [3,2,0,-4], pos = 1
输出：tail connects to node index 1
解释：链表中有一个环，其尾部连接到第二个节点。


示例 2：

输入：head = [1,2], pos = 0
输出：tail connects to node index 0
解释：链表中有一个环，其尾部连接到第一个节点。


示例 3：

输入：head = [1], pos = -1
输出：no cycle
解释：链表中没有环。

进阶：你是否可以不用额外空间解决此题？</code></pre>
<p>题解一(hash)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def detectCycle(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        hash&#x3D;&#123;&#125;</span><br><span class="line">        while head:</span><br><span class="line">            if head not in hash:</span><br><span class="line">                hash[head]&#x3D;0</span><br><span class="line">                head&#x3D;head.next</span><br><span class="line">            else:</span><br><span class="line">                return head</span><br><span class="line">        return None</span><br></pre></td></tr></table></figure>
<p>题解二(快慢指针):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def detectCycle(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        if not head or not head.next:</span><br><span class="line">            return None</span><br><span class="line">        slow,fast&#x3D;head,head</span><br><span class="line">        while fast and fast.next:</span><br><span class="line">            slow&#x3D;slow.next</span><br><span class="line">            fast&#x3D;fast.next.next</span><br><span class="line">            if slow &#x3D;&#x3D; fast:</span><br><span class="line">                slow&#x3D;head</span><br><span class="line">                while slow !&#x3D; fast:</span><br><span class="line">                    slow&#x3D;slow.next</span><br><span class="line">                    fast&#x3D;fast.next</span><br><span class="line">                return slow</span><br><span class="line">        return None</span><br></pre></td></tr></table></figure>

<h3 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143. 重排链表"></a>143. 重排链表</h3><pre><code>链接：https://leetcode-cn.com/problems/reorder-list

给定一个单链表 L：L0→L1→…→Ln-1→Ln ，
将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

示例 1:

给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.
示例 2:

给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3.</code></pre>
<p>题解一（反转链表）:</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode4.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode4.png"></p>
<p>分析：</p>
<pre><code>找中点
翻转中点之后的链表
依次拼接</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def reorderList(self, head: ListNode) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Do not return anything, modify head in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 1、找中点, 偶数个时找上界</span><br><span class="line">        if not head or not head.next:</span><br><span class="line">            return head</span><br><span class="line">        slow,fast&#x3D;head,head</span><br><span class="line">        while fast and fast.next:</span><br><span class="line">            slow&#x3D;slow.next</span><br><span class="line">            fast&#x3D;fast.next.next</span><br><span class="line">        mid&#x3D;slow        </span><br><span class="line">        # 2、翻转中点之后的链表,采用是pre, slow双指针方法</span><br><span class="line">        pre&#x3D;None</span><br><span class="line">        while slow:</span><br><span class="line">            next&#x3D;slow.next</span><br><span class="line">            slow.next&#x3D;pre</span><br><span class="line">            pre&#x3D;slow</span><br><span class="line">            slow&#x3D;next</span><br><span class="line">        # 3、翻转链表和前面链表拼接</span><br><span class="line">        p1&#x3D;head # 链表头</span><br><span class="line">        p2&#x3D;pre # 翻转头</span><br><span class="line"></span><br><span class="line">        # print(mid.val,p2.val)</span><br><span class="line">        while p2 !&#x3D; mid:</span><br><span class="line">            next1,next2&#x3D;p1.next,p2.next</span><br><span class="line">            p1.next&#x3D;p2               </span><br><span class="line">            p2.next&#x3D;next1</span><br><span class="line">            p1,p2&#x3D;next1,next2</span><br><span class="line">        return head</span><br></pre></td></tr></table></figure>

<p>题解二（栈）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def reorderList(self, head: ListNode) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Do not return anything, modify head in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not head:</span><br><span class="line">            return head</span><br><span class="line">        dummy&#x3D;head</span><br><span class="line">        stack&#x3D;[]</span><br><span class="line">        while dummy:</span><br><span class="line">            stack.append(dummy)</span><br><span class="line">            dummy&#x3D;dummy.next</span><br><span class="line">        n&#x3D;len(stack)</span><br><span class="line">        mid&#x3D;(n-1)&#x2F;&#x2F;2</span><br><span class="line">        </span><br><span class="line">        dummy&#x3D;head</span><br><span class="line">        while mid:</span><br><span class="line">            tmp&#x3D;stack.pop() # 弹出链表最后一个节点</span><br><span class="line">            tmp.next&#x3D;dummy.next</span><br><span class="line">            dummy.next&#x3D;tmp</span><br><span class="line">            dummy&#x3D;tmp.next # 移动2个位置，使用dummy&#x3D;dummy.next.next也可以。</span><br><span class="line">            mid-&#x3D;1</span><br><span class="line">        stack.pop().next&#x3D;None</span><br><span class="line">        return head</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def reorderList(self, head: ListNode) -&gt; None:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        Do not return anything, modify head in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if not head:</span><br><span class="line">            return head</span><br><span class="line">        fast,slow&#x3D;head,head</span><br><span class="line">        stack&#x3D;[]</span><br><span class="line">        while fast.next and fast.next.next:</span><br><span class="line">            fast&#x3D;fast.next.next</span><br><span class="line">            slow&#x3D;slow.next</span><br><span class="line">        while slow.next:</span><br><span class="line">            stack.append(slow.next)</span><br><span class="line">            slow.next&#x3D;slow.next.next</span><br><span class="line">        dummy&#x3D;head</span><br><span class="line">        while stack:</span><br><span class="line">            tmp&#x3D;stack.pop()</span><br><span class="line">            tmp.next&#x3D;dummy.next</span><br><span class="line">            dummy.next&#x3D;tmp</span><br><span class="line">            dummy&#x3D;dummy.next.next</span><br><span class="line">        return head</span><br></pre></td></tr></table></figure>

<h3 id="147-对链表进行插入排序"><a href="#147-对链表进行插入排序" class="headerlink" title="???147. 对链表进行插入排序"></a>???147. 对链表进行插入排序</h3><pre><code>链接：https://leetcode-cn.com/problems/insertion-sort-list

对链表进行插入排序。


插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。
每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。


插入排序算法：

插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。
每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。
重复直到所有输入数据插入完为止。
 

示例 1：

输入: 4-&gt;2-&gt;1-&gt;3
输出: 1-&gt;2-&gt;3-&gt;4
示例 2：

输入: -1-&gt;5-&gt;3-&gt;4-&gt;0
输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</code></pre>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_17550379/article/details/80708238">https://blog.csdn.net/qq_17550379/article/details/80708238</a></p>
<p>插入排序（数组）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def insertSort(lists):</span><br><span class="line">    count&#x3D;len(lists)</span><br><span class="line">    for i in range(1,count):</span><br><span class="line">        key&#x3D;lists[i]</span><br><span class="line">        j&#x3D;i-1</span><br><span class="line">        while j&gt;&#x3D;0:</span><br><span class="line">            if lists[j]&gt;key:</span><br><span class="line">                lists[j+1]&#x3D;lists[j]</span><br><span class="line">                lists[j]&#x3D;key</span><br><span class="line">            j-&#x3D;1</span><br><span class="line">    return lists</span><br></pre></td></tr></table></figure>

<p>题解一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def insertionSortList(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        if head &#x3D;&#x3D; None or head.next &#x3D;&#x3D; None:</span><br><span class="line">            return head</span><br><span class="line"></span><br><span class="line">        dummy &#x3D; ListNode(-1)</span><br><span class="line">        dummy.next &#x3D; head</span><br><span class="line">        pre &#x3D; dummy</span><br><span class="line">        cur &#x3D; head</span><br><span class="line">        while cur:</span><br><span class="line">            lat &#x3D; cur.next</span><br><span class="line">            if lat and lat.val &lt; cur.val:  # 只有cur.next比cur小的时候我们才寻找插入点</span><br><span class="line">                while pre.next and pre.next.val &lt; lat.val:</span><br><span class="line">                    pre &#x3D; pre.next</span><br><span class="line">                tmp &#x3D; pre.next</span><br><span class="line">                pre.next &#x3D; lat</span><br><span class="line">                cur.next &#x3D; lat.next</span><br><span class="line">                lat.next &#x3D; tmp</span><br><span class="line">                pre &#x3D; dummy</span><br><span class="line">            else:</span><br><span class="line">                cur &#x3D; lat</span><br><span class="line"></span><br><span class="line">        return dummy.next</span><br></pre></td></tr></table></figure>

<p>？？题解二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def insertionSortList(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        p&#x3D;dummy&#x3D;ListNode(-1)</span><br><span class="line">        curr&#x3D;dummy.next&#x3D;head</span><br><span class="line">        while curr and curr.next:</span><br><span class="line">            val &#x3D; curr.next.val</span><br><span class="line">            if curr.val &lt; val:</span><br><span class="line">                curr&#x3D;curr.next</span><br><span class="line">                continue</span><br><span class="line">            if p.next.val &gt; val:</span><br><span class="line">                p&#x3D;dummy</span><br><span class="line">            while p.next.val &lt; val:</span><br><span class="line">                p&#x3D;p.next</span><br><span class="line">            new&#x3D;curr.next</span><br><span class="line">            curr.next&#x3D;new.next</span><br><span class="line">            new.next&#x3D;p.next</span><br><span class="line">            p.next&#x3D;new</span><br><span class="line">        return dummy.next</span><br></pre></td></tr></table></figure>

<h3 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a>160. 相交链表</h3><pre><code>链接：https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</code></pre>
<p>题解一|暴力:</p>
<p>对链表A中的每一个结点 ai，遍历整个链表 B 并检查链表 B 中是否存在结点和 a<br>i相同。</p>
<p>时间复杂度 : (mn)<br>空间复杂度 : O(1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode:</span><br><span class="line">        p,q&#x3D;headA,headB</span><br><span class="line">        while p:</span><br><span class="line">            while q:</span><br><span class="line">                if p &#x3D;&#x3D; q:</span><br><span class="line">                    return q</span><br><span class="line">            q&#x3D;q.next</span><br><span class="line">        p&#x3D;p.next</span><br><span class="line">        return None</span><br></pre></td></tr></table></figure>

<p>题解二|hash：</p>
<p>分析：</p>
<pre><code>遍历链表 A 并将每个结点的地址/引用存储在哈希表中。然后检查链表 B 中的每一个结点 bi 是否在哈希表中。若在，则 bi为相交结点。</code></pre>
<p>时间复杂度 : O(m+n)。<br>空间复杂度 : O(m) 或 O(n)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode:</span><br><span class="line">        p,q&#x3D;headA,headB</span><br><span class="line">        hash&#x3D;&#123;&#125;</span><br><span class="line">        while p:</span><br><span class="line">            if p not in hash:</span><br><span class="line">                hash[p]&#x3D;1</span><br><span class="line">            p&#x3D;p.next</span><br><span class="line">        while q:</span><br><span class="line">            if q in hash:</span><br><span class="line">                return q</span><br><span class="line">            q&#x3D;q.next</span><br></pre></td></tr></table></figure>

<p>题解三|双指针：</p>
<p>分析：<br>    两个指针分别从链表头开始扫描，每次分别走一步<br>    若指针走到null，则从另一个链表头部开始走<br>    两指针相同时:<br>        (利用此时两个指针移动步数一致)<br>        指针不为null：指针位置为相遇点<br>        指针为null：两个链表不相交</p>
<pre><code>创建两个指针 pA 和 pB，分别初始化为链表 A 和 B 的头结点。然后让它们向后逐结点遍历。

当 pA 到达链表的尾部时，将它重定位到链表 B 的头结点 (你没看错，就是链表 B); 类似的，当 pB 到达链表的尾部时，将它重定位到链表 A 的头结点。

若在某一时刻 pA 和 pB 相遇，则 pA/pB 为相交结点。

想弄清楚为什么这样可行, 可以考虑以下两个链表: A=&#123;1,3,5,7,9,11&#125; 和 B=&#123;2,4,9,11&#125;，相交于结点 9。 由于 B.length (=4) &lt; A.length (=6)，pB 比 pA少经过 2 个结点，会先到达尾部。将 pB 重定向到 A 的头结点，pA 重定向到 B 的头结点后，pB 要比 pA 多走 2 个结点。因此，它们会同时到达交点。

如果两个链表存在相交，它们末尾的结点必然相同。因此当 pA/pB 到达链表结尾时，记录下链表 A/B 对应的元素。若最后元素不相同，则两个链表不相交。</code></pre>
<p>时间复杂度 : O(m+n)<br>空间复杂度 : O(1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode:</span><br><span class="line">        p,q&#x3D;headA,headB</span><br><span class="line">        while p !&#x3D; q:</span><br><span class="line">            if p:</span><br><span class="line">                p&#x3D;p.next</span><br><span class="line">            else:</span><br><span class="line">                p&#x3D;headB</span><br><span class="line">            if q:</span><br><span class="line">                q&#x3D;q.next</span><br><span class="line">            else:</span><br><span class="line">                q&#x3D;headA</span><br><span class="line">        return p</span><br></pre></td></tr></table></figure>

<p>扩展：链表有环，如何判断相交？</p>
<p>分析：如果有环且两个链表相交，则两个链表都有共同一个环，即环上的任意一个节点都存在于两个链表上。因此，就可以判断一链表上俩指针相遇的那个节点，在不在另一条链表上。</p>
<pre><code>无环链表和有环链表是不可能相交的;

两个有环链表若相交，其“整个环上”的所有node一定都重合;

有环链表的相交，情况只有2种：相交于”环上”或相交于”不是环的部分”,即下图所示;</code></pre>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/link.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/link.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;cloud.tencent.com&#x2F;developer&#x2F;article&#x2F;1045468</span><br></pre></td></tr></table></figure>

<h3 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a>203. 移除链表元素</h3><pre><code>链接：https://leetcode-cn.com/problems/remove-linked-list-elements/

删除链表中等于给定值 val 的所有节点。

示例:

输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6
输出: 1-&gt;2-&gt;3-&gt;4-&gt;5</code></pre>
<p>题解一|删除头结点时另做考虑：</p>
<p>思路：删除头结点时另做考虑（由于头结点没有前一个结点）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def removeElements(self, head: ListNode, val: int) -&gt; ListNode:</span><br><span class="line">        if not head:</span><br><span class="line">            return head</span><br><span class="line">        # 如果不对头结点单独考虑，无法解决case：[1]和1</span><br><span class="line">        while head and head.val &#x3D;&#x3D; val:</span><br><span class="line">            head&#x3D;head.next</span><br><span class="line">        dummy&#x3D;head</span><br><span class="line">        while head and head.next:</span><br><span class="line">            if head.next.val &#x3D;&#x3D; val:</span><br><span class="line">                # print(val)</span><br><span class="line">                # head&#x3D;head.next.next</span><br><span class="line">                head.next&#x3D;head.next.next</span><br><span class="line">            else:</span><br><span class="line">                head&#x3D;head.next</span><br><span class="line">        return dummy</span><br></pre></td></tr></table></figure>

<p>题解二：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">时间复杂度：O(N)，只遍历了一次</span><br><span class="line">空间复杂度：O(1)</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def removeElements(self, head: ListNode, val: int) -&gt; ListNode:</span><br><span class="line">        dummy&#x3D;ListNode(0)</span><br><span class="line">        dummy.next&#x3D;head</span><br><span class="line"></span><br><span class="line">        pre,curr&#x3D;dummy,head</span><br><span class="line">        # print(pre.val,curr.val) 0和1</span><br><span class="line">        while curr:</span><br><span class="line">            if curr.val &#x3D;&#x3D; val:</span><br><span class="line">                pre.next&#x3D;curr.next</span><br><span class="line">            else:</span><br><span class="line">                pre&#x3D;curr</span><br><span class="line">            curr&#x3D;curr.next</span><br><span class="line">            </span><br><span class="line">        return dummy.next</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def removeElements(self, head: ListNode, val: int) -&gt; ListNode:</span><br><span class="line">        dummy&#x3D;ListNode(0)</span><br><span class="line">        dummy.next&#x3D;head</span><br><span class="line">        pre&#x3D;dummy</span><br><span class="line">        while pre.next:</span><br><span class="line">            if pre.next.val &#x3D;&#x3D; val:</span><br><span class="line">                pre.next&#x3D;pre.next.next</span><br><span class="line">            else:</span><br><span class="line">                pre&#x3D;pre.next</span><br><span class="line">            </span><br><span class="line">        return dummy.next</span><br></pre></td></tr></table></figure>

<p>???题解三（递归）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def removeElements(self, head: ListNode, val: int) -&gt; ListNode:</span><br><span class="line">        if not head:</span><br><span class="line">            return head</span><br><span class="line">        head.next&#x3D;self.removeElements(head.next,val)        </span><br><span class="line">        if head.val&#x3D;&#x3D;val:</span><br><span class="line">            return head.next</span><br><span class="line">        else:</span><br><span class="line">            return head</span><br></pre></td></tr></table></figure>

<h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h3><pre><code>链接：https://leetcode-cn.com/problems/reverse-linked-list/

反转一个单链表。

示例:

输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL
进阶:
你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</code></pre>
<p>题解一：</p>
<p>参考：<br>    <a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-linked-list/solution/">https://leetcode.com/problems/reverse-linked-list/solution/</a><br>     <a target="_blank" rel="noopener" href="http://baijiahao.baidu.com/s?id=1574261186522385&wfr=spider&for=pc">http://baijiahao.baidu.com/s?id=1574261186522385&amp;wfr=spider&amp;for=pc</a><br>     <a target="_blank" rel="noopener" href="https://blog.csdn.net/autumn20080101/article/details/7607148">https://blog.csdn.net/autumn20080101/article/details/7607148</a><br>     <a target="_blank" rel="noopener" href="https://www.cnblogs.com/scud001/p/4423324.html">https://www.cnblogs.com/scud001/p/4423324.html</a></p>
<pre><code>初始状态，prev是NULL，head指向当前的头节点A，next指向A节点的下一个节点B。
首先从A节点开始逆序，将A节点的next指针指向prev，因为prev的当前值是NULL，所以A节点就从链表中脱离出来了，然后移动
head和next指针，使它们分别指向B节点和B的下一个节点C（因为当前的next已经指向B节点了，因此修改A节点的next指针不会
导致链表丢失）。逆向节点A之后，链表的状态如图（2）所示：

 从图（1）的初始状态到图（2）状态共做了四个操作，这四个操作的伪代码如下：

head-&gt;next = prev;

prev = head;

head = next;

next = head-&gt;next;

这四行伪代码就是循环算法的迭代体了，现在用这个迭代体对图（2）的状态再进行一轮迭代，就得到了图（3）的状态：

那么循环终止条件呢？现在对图（3）的状态再迭代一次得到图（4）的状态：

此时可以看出，在图（4）的基础上再进行一次迭代就可以完成链表的逆序，因此循环迭代的终止条件就是当前的head指针是NULL。

现在来总结一下，循环的初始条件是：

prev = NULL;

循环迭代体是：

//在头节点改变之前，先获取下一个节点的指针
next = head-&gt;Next;
//头节点的下一个节点要改成它的上一个节点，是一个逆转的过程
head-&gt;Next = prev;
//上一个节点前移指向头节点
prev = head;
//头节点前移指向下一个节点
head = next;

循环终止条件是：

head == NULL</code></pre>
<p><img src="http://p2lakvkq0.bkt.clouddn.com/linkedlist.jpg"></p>
<p>题解一(指针迭代)：</p>
<p>反转一个节点的时候，把一个节点的后驱改为指向它前驱就可以了。这里需要注意的点就是，当你把当前节点的后驱指向前驱的时候，这个时候链表会被截断，也就是说后面的节点和当前节点分开了，所以我们需要一个变量来保存当前节点的后驱，以访丢失。</p>
<p>第一个指针叫 pre，最初是指向 null 的。<br>第二个指针 cur 指向 head，然后不断遍历 cur。<br>每次迭代到 cur，都将 cur 的 next 指向 pre，然后 pre 和 cur 前进一位。<br>都迭代完了(cur 变成 null 了)，pre 就是最后一个节点了。</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode5.JPG" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode5.JPG"></p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/baidu_31657889/article/details/91552141">https://blog.csdn.net/baidu_31657889/article/details/91552141</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def reverseList(self, head):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type head: ListNode</span><br><span class="line">        :rtype: ListNode</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        prve &#x3D; None</span><br><span class="line">        while head:</span><br><span class="line">            next &#x3D; head.next # 记录当前节点的下一个节点</span><br><span class="line">            head.next &#x3D; prve # 将当前节点指向pre</span><br><span class="line">            prve &#x3D; head # pre节点和head节点前进一位</span><br><span class="line">            head &#x3D; next</span><br><span class="line">        return prve</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reverseList(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        pre&#x3D;None</span><br><span class="line">        while head:</span><br><span class="line">            pre, pre.next, head &#x3D; head, pre, head.next</span><br><span class="line">        return pre</span><br></pre></td></tr></table></figure>

<p>???题解二(递归):</p>
<p>递归的两个条件：</p>
<pre><code>终止条件是当前节点或者下一个节点==null
在函数内部，改变节点的指向，也就是 head 的下一个节点指向 head 递归函数那句

很不好理解，其实就是 head 的下一个节点指向head。</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def reverseList(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        if head is None or head.next is None:  </span><br><span class="line">            return head  # 递归终止条件是当前为空，或者下一个节点为空</span><br><span class="line">        cur&#x3D;self.reverseList(head.next) # cur是最后一个节点5</span><br><span class="line">        head.next.next&#x3D;head </span><br><span class="line">        head.next&#x3D;None</span><br><span class="line">        return cur</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def reverseList(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        def helper(head):</span><br><span class="line">            if head is None or head.next is None:</span><br><span class="line">                return head,head</span><br><span class="line">            pre,last&#x3D;helper(head.next)</span><br><span class="line">            last.next&#x3D;head</span><br><span class="line">            head.next&#x3D;None</span><br><span class="line">            return pre,head</span><br><span class="line">        res,_&#x3D;helper(head)</span><br><span class="line">        return res,_</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>问题扩展：部分节点进行反转</p>
<h3 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234.回文链表"></a>234.回文链表</h3><pre><code>链接：https://leetcode-cn.com/problems/palindrome-linked-list/

请判断一个链表是否为回文链表。

示例 1:

输入: 1-&gt;2
输出: false
示例 2:

输入: 1-&gt;2-&gt;2-&gt;1
输出: true
进阶：
你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</code></pre>
<p>数组列表底层是使用数组存储值，我们可以通过索引在 O(1)的时间访问列表任何位置的值，这是由于内存寻址的方式。</p>
<p>链表存储的是称为节点的对象，每个节点保存一个值和指向下一个节点的指针。访问某个特定索引的节点需要 O(n) 的时间，因为要通过指针获取到下一个位置的节点。</p>
<p>题解一|数组：</p>
<p>分析：</p>
<p>确定数组列表是否为回文很简单，我们可以使用双指针法来比较两端的元素，并向中间移动。一个指针从起点向中间移动，另一个指针从终点向中间移动。这需要 O(n)的时间，因为访问每个元素的时间是 O(1)，而有 n 个元素要访问。</p>
<p>然后，直接在链表上操作并不简单，因为不论是正向访问还是反向访问都不是 O(1)。而将链表的值复制到数组列表中是 O(n)，因此最简单的方法就是将链表的值复制到数组列表中，再使用双指针法判断。</p>
<p>算法：</p>
<pre><code>复制链表值到数组列表中。
使用双指针法判断是否为回文。</code></pre>
<p>第一步，我们需要遍历链表将值复制到数组列表中。我们用 currentNode 指向当前节点。每次迭代向数组添加 currentNode.val，并更新 currentNode = currentNode.next，当 currentNode = null 则停止循环。</p>
<p>执行第二部的最佳方法取决于你使用的编程语言。在 Python 中，很容易构造一个列表的反向副本，也很容易比较两个列表。在其他语言中，就没有那么简单。因此最好使用双指针法来检查是否为回文。我们在起点放置一个指针，在结尾放置一个指针，每一次迭代判断两个指针指向的元素是否相同，若不同，返回 false；相同则将两个指针向内移动，并继续判断，直到相遇。</p>
<p>在编码的过程中，注意我们比较的是节点值的大小，而不是节点本身。正确的比较方式是：node_1.val==node_2.val，node_1==node_2 是错误的。</p>
<p>复杂度：</p>
<p>时间复杂度：O(n)，其中 n 指的是链表的元素个数。</p>
<pre><code>第一步： 遍历链表并将值复制到数组中，O(n)。
第二步：双指针判断是否为回文，执行了 O(n/2) 次的判断，即 O(n)。
总的时间复杂度：O(2n) = O(n)</code></pre>
<p>空间复杂度：O(n)，其中 n 指的是链表的元素个数，我们使用了一个数组列表存放链表的元素值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def isPalindrome(self, head: ListNode) -&gt; bool:</span><br><span class="line">        arr&#x3D;[]</span><br><span class="line">        while head:</span><br><span class="line">            arr.append(head.val)</span><br><span class="line">            head&#x3D;head.next</span><br><span class="line">        return arr&#x3D;&#x3D;arr[::-1]</span><br></pre></td></tr></table></figure>

<p>快慢指针：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">l &#x3D; 0</span><br><span class="line">r &#x3D; len(tmp)-1</span><br><span class="line">while l&lt;r:</span><br><span class="line">    if tmp[l] !&#x3D; tmp[r]:</span><br><span class="line">        return False</span><br><span class="line">    l +&#x3D; 1</span><br><span class="line">    r -&#x3D; 1</span><br><span class="line">return True</span><br></pre></td></tr></table></figure>

<p>题解二|快慢指针+反转链表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def isPalindrome(self, head: ListNode) -&gt; bool:</span><br><span class="line">        def reverseList(head):</span><br><span class="line">            pre&#x3D;None</span><br><span class="line">            while head:</span><br><span class="line">                next&#x3D;head.next</span><br><span class="line">                head.next&#x3D;pre</span><br><span class="line">                pre&#x3D;head</span><br><span class="line">                head&#x3D;next</span><br><span class="line">            return pre</span><br><span class="line"></span><br><span class="line">        # 快慢指针，快指针到达尾部，慢指针到达中间</span><br><span class="line">        slow&#x3D;fast&#x3D;head</span><br><span class="line">        while fast and fast.next:</span><br><span class="line">            slow&#x3D;slow.next</span><br><span class="line">            fast&#x3D;fast.next.next</span><br><span class="line">        </span><br><span class="line">        newHead&#x3D;reverseList(slow)</span><br><span class="line">        p1&#x3D;head</span><br><span class="line">        p2&#x3D;newHead</span><br><span class="line">        while p1 and p2:</span><br><span class="line">            if p1.val !&#x3D; p2.val:</span><br><span class="line">                return False</span><br><span class="line">            p1&#x3D;p1.next</span><br><span class="line">            p2&#x3D;p2.next</span><br><span class="line">        return True</span><br></pre></td></tr></table></figure>
<h3 id="237-删除链表中的节点"><a href="#237-删除链表中的节点" class="headerlink" title="237.删除链表中的节点"></a>237.删除链表中的节点</h3><pre><code>链接：https://leetcode-cn.com/problems/delete-node-in-a-linked-list/

请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。

现有一个链表 -- head = [4,5,1,9]，它可以表示为:

示例 1:

输入: head = [4,5,1,9], node = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.
示例 2:

输入: head = [4,5,1,9], node = 1
输出: [4,5,9]
解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.
 

说明:

链表至少包含两个节点。
链表中所有节点的值都是唯一的。
给定的节点为非末尾节点并且一定是链表中的一个有效节点。
不要从你的函数中返回任何结果。</code></pre>
<p>时间复杂度 O(1)<br>空间复杂度 O(1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def deleteNode(self, node):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type node: ListNode</span><br><span class="line">        :rtype: void Do not return anything, modify node in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        node.val&#x3D;node.next.val</span><br><span class="line">        node.next&#x3D;node.next.next</span><br></pre></td></tr></table></figure>
<h3 id="876-链表的中间节点"><a href="#876-链表的中间节点" class="headerlink" title="876.链表的中间节点"></a>876.链表的中间节点</h3><pre><code>链接：https://leetcode-cn.com/problems/middle-of-the-linked-list/

给定一个带有头结点 head 的非空单链表，返回链表的中间结点。

如果有两个中间结点，则返回第二个中间结点。

示例 1：

输入：[1,2,3,4,5]
输出：此列表中的结点 3 (序列化形式：[3,4,5])
返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。
注意，我们返回了一个 ListNode 类型的对象 ans，这样：
ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.
示例 2：

输入：[1,2,3,4,5,6]
输出：此列表中的结点 4 (序列化形式：[4,5,6])
由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。
 

提示：给定链表的结点数介于 1 和 100 之间。</code></pre>
<p>题解一|数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def middleNode(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        arr&#x3D;[]</span><br><span class="line">        dummy&#x3D;head</span><br><span class="line">        while head:</span><br><span class="line">            arr.append(head.val)</span><br><span class="line">            head&#x3D;head.next</span><br><span class="line">        mid&#x3D;len(arr)&#x2F;&#x2F;2</span><br><span class="line">        i&#x3D;0</span><br><span class="line">        while dummy:</span><br><span class="line">            if i&#x3D;&#x3D;mid:</span><br><span class="line">                return dummy</span><br><span class="line">            dummy&#x3D;dummy.next</span><br><span class="line">            i+&#x3D;1</span><br></pre></td></tr></table></figure>

<p>题解二|快慢指针：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def middleNode(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        slow&#x3D;fast&#x3D;head</span><br><span class="line">        while fast and fast.next:</span><br><span class="line">            slow&#x3D;slow.next</span><br><span class="line">            fast&#x3D;fast.next.next</span><br><span class="line">        return slow</span><br></pre></td></tr></table></figure>

<h3 id="剑指-Offer-06-从尾到头打印链表"><a href="#剑指-Offer-06-从尾到头打印链表" class="headerlink" title="剑指 Offer 06. 从尾到头打印链表"></a>剑指 Offer 06. 从尾到头打印链表</h3><pre><code>链接：https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/

输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。

示例 1：

输入：head = [1,3,2]
输出：[2,3,1]

限制：

0 &lt;= 链表长度 &lt;= 10000</code></pre>
<p>题解一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def reversePrint(self, head: ListNode) -&gt; List[int]:</span><br><span class="line">        arr&#x3D;[]</span><br><span class="line">        while head:</span><br><span class="line">            arr.append(head.val)</span><br><span class="line">            head&#x3D;head.next</span><br><span class="line">        return arr[::-1]</span><br></pre></td></tr></table></figure>

<h3 id="面试题-02-01-移除重复节点"><a href="#面试题-02-01-移除重复节点" class="headerlink" title="面试题 02.01. 移除重复节点"></a>面试题 02.01. 移除重复节点</h3><pre><code>链接：https://leetcode-cn.com/problems/remove-duplicate-node-lcci/

编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。

示例1:

 输入：[1, 2, 3, 3, 2, 1]
 输出：[1, 2, 3]
示例2:

 输入：[1, 1, 1, 1, 2]
 输出：[1, 2]
提示：

链表长度在[0, 20000]范围内。
链表元素在[0, 20000]范围内。
进阶：

如果不得使用临时缓冲区，该怎么解决？</code></pre>
<p>题解一（hash）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def removeDuplicateNodes(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        dummy&#x3D;res&#x3D;ListNode(-1)</span><br><span class="line">        dummy.next&#x3D;head</span><br><span class="line">        hash&#x3D;&#123;&#125;</span><br><span class="line">        while head:</span><br><span class="line">            if head.val not in hash:</span><br><span class="line">                hash[head.val]&#x3D;1</span><br><span class="line">                res&#x3D;head</span><br><span class="line">            else:</span><br><span class="line">                res.next&#x3D;head.next</span><br><span class="line">            head&#x3D;head.next</span><br><span class="line">        return dummy.next</span><br></pre></td></tr></table></figure>
<p>???题解二（快慢指针)：</p>
<p>思路：</p>
<pre><code>1.快慢双指针，第一层大循环为slow非空的循环，
2.第二层循环为fast循环，prev的下一个始终指向fast，保证出现fast.val==slow.val时，可以有效的删除相同结点，只需要fast和prev即可完美做到
3.slow和fast双层循环依次进行，slow和fast以及以后的依次比较，直到结束</code></pre>
<p>运行超时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def removeDuplicateNodes(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        fast&#x3D;slow&#x3D;head</span><br><span class="line">        while slow:</span><br><span class="line">            fast&#x3D;slow.next</span><br><span class="line">            pre&#x3D;slow</span><br><span class="line">            while fast:</span><br><span class="line">                if fast.val &#x3D;&#x3D; slow.val:</span><br><span class="line">                    pre.next&#x3D;fast.next</span><br><span class="line">                else:</span><br><span class="line">                    pre&#x3D;pre.next</span><br><span class="line">                fast&#x3D;fast.next</span><br><span class="line">            slow&#x3D;slow.next</span><br><span class="line">        return head</span><br></pre></td></tr></table></figure>

<h3 id="面试题-02-02-返回倒数第-k-个节点"><a href="#面试题-02-02-返回倒数第-k-个节点" class="headerlink" title="面试题 02.02. 返回倒数第 k 个节点"></a>面试题 02.02. 返回倒数第 k 个节点</h3><pre><code>链接：https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/

实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。

注意：本题相对原题稍作改动

示例：

输入： 1-&gt;2-&gt;3-&gt;4-&gt;5 和 k = 2
输出： 4
说明：

给定的 k 保证是有效的。</code></pre>
<p>题解一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def kthToLast(self, head: ListNode, k: int) -&gt; int:</span><br><span class="line">        res&#x3D;head</span><br><span class="line">        n&#x3D;1</span><br><span class="line">        while head.next:</span><br><span class="line">            n+&#x3D;1</span><br><span class="line">            head&#x3D;head.next</span><br><span class="line">        k&#x3D;n-k</span><br><span class="line">        while k&gt;0:</span><br><span class="line">            k-&#x3D;1</span><br><span class="line">            res&#x3D;res.next</span><br><span class="line">        return res.val</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def kthToLast(self, head: ListNode, k: int) -&gt; int:</span><br><span class="line">        tmp&#x3D;head</span><br><span class="line">        n&#x3D;0</span><br><span class="line">        while head:</span><br><span class="line">            head&#x3D;head.next</span><br><span class="line">            n+&#x3D;1</span><br><span class="line">        k&#x3D;n-k</span><br><span class="line">        while k&gt;0:</span><br><span class="line">            k-&#x3D;1</span><br><span class="line">            tmp&#x3D;tmp.next</span><br><span class="line">        return tmp.val</span><br></pre></td></tr></table></figure>
<p>题解二（快慢指针）:</p>
<pre><code>定义两个指针，快指针 fast， 慢指针 low .
让 fast 先向前移动 k 个位置，然后 low 和 fast 再一起向前移动 .
当 fast 到达链表尾部，返回 low .</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def kthToLast(self, head: ListNode, k: int) -&gt; int:</span><br><span class="line">        fast&#x3D;slow&#x3D;head</span><br><span class="line">        while fast:</span><br><span class="line">            fast&#x3D;fast.next</span><br><span class="line">            if k&#x3D;&#x3D;0:</span><br><span class="line">                slow&#x3D;slow.next</span><br><span class="line">            else:</span><br><span class="line">                k-&#x3D;1</span><br><span class="line">        return slow.val</span><br><span class="line">                  </span><br></pre></td></tr></table></figure>

<h3 id="面试题-02-03-删除中间节点"><a href="#面试题-02-03-删除中间节点" class="headerlink" title="面试题 02.03. 删除中间节点"></a>面试题 02.03. 删除中间节点</h3><pre><code>链接：https://leetcode-cn.com/problems/delete-middle-node-lcci/

实现一种算法，删除单向链表中间的某个节点（除了第一个和最后一个节点，不一定是中间节点），假定你只能访问该节点。

示例：

输入：单向链表a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f中的节点c
结果：不返回任何数据，但该链表变为a-&gt;b-&gt;d-&gt;e-&gt;f</code></pre>
<p>题解一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def deleteNode(self, node):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type node: ListNode</span><br><span class="line">        :rtype: void Do not return anything, modify node in-place instead.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        node.val&#x3D;node.next.val</span><br><span class="line">        node.next&#x3D;node.next.next</span><br></pre></td></tr></table></figure>

<h3 id="面试题-02-04-分割链表"><a href="#面试题-02-04-分割链表" class="headerlink" title="面试题 02.04. 分割链表"></a>面试题 02.04. 分割链表</h3><pre><code>链接：https://leetcode-cn.com/problems/partition-list-lcci/

编写程序以 x 为基准分割链表，使得所有小于 x 的节点排在大于或等于 x 的节点之前。如果链表中包含 x，x 只需出现在小于 x 的元素之后(如下所示)。分割元素 x 只需处于“右半部分”即可，其不需要被置于左右两部分之间。

示例:

输入: head = 3-&gt;5-&gt;8-&gt;5-&gt;10-&gt;2-&gt;1, x = 5
输出: 3-&gt;1-&gt;2-&gt;10-&gt;5-&gt;5-&gt;8</code></pre>
<p>题解一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def partition(self, head: ListNode, x: int) -&gt; ListNode:</span><br><span class="line">        before&#x3D;bf&#x3D;ListNode(-1)</span><br><span class="line">        after&#x3D;af&#x3D;ListNode(-1)</span><br><span class="line">        while head:</span><br><span class="line">            if head.val&lt;x:</span><br><span class="line">                before.next&#x3D;head</span><br><span class="line">                before&#x3D;before.next</span><br><span class="line">            else:</span><br><span class="line">                after.next&#x3D;head</span><br><span class="line">                after&#x3D;after.next</span><br><span class="line">            head&#x3D;head.next</span><br><span class="line">        after.next&#x3D;None</span><br><span class="line">        before.next&#x3D;af.next</span><br><span class="line">        return bf.next</span><br></pre></td></tr></table></figure>

<h3 id="面试题-02-05-链表求和"><a href="#面试题-02-05-链表求和" class="headerlink" title="面试题 02.05. 链表求和"></a>面试题 02.05. 链表求和</h3><pre><code>链接：https://leetcode-cn.com/problems/sum-lists-lcci/

给定两个用链表表示的整数，每个节点包含一个数位。

这些数位是反向存放的，也就是个位排在链表首部。

编写函数对这两个整数求和，并用链表形式返回结果。

 

示例：

输入：(7 -&gt; 1 -&gt; 6) + (5 -&gt; 9 -&gt; 2)，即617 + 295
输出：2 -&gt; 1 -&gt; 9，即912
进阶：假设这些数位是正向存放的，请再做一遍。

示例：

输入：(6 -&gt; 1 -&gt; 7) + (2 -&gt; 9 -&gt; 5)，即617 + 295
输出：9 -&gt; 1 -&gt; 2，即912</code></pre>
<p>题解一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:</span><br><span class="line">        if not l1:</span><br><span class="line">            return l2</span><br><span class="line">        if not l2:</span><br><span class="line">            return l1</span><br><span class="line">        dummy&#x3D;res&#x3D;ListNode(0)</span><br><span class="line">        flag&#x3D;0</span><br><span class="line">        while l1 or l2:</span><br><span class="line">            sum&#x3D;0</span><br><span class="line">            if l1:</span><br><span class="line">                sum+&#x3D;l1.val</span><br><span class="line">                l1&#x3D;l1.next</span><br><span class="line">            if l2:</span><br><span class="line">                sum+&#x3D;l2.val</span><br><span class="line">                l2&#x3D;l2.next</span><br><span class="line">            tmp&#x3D;(sum+flag)%10</span><br><span class="line">            flag&#x3D;(sum+flag)&#x2F;&#x2F;10</span><br><span class="line">            res.next&#x3D;ListNode(tmp)</span><br><span class="line">            res&#x3D;res.next</span><br><span class="line">        if flag:</span><br><span class="line">            res.next&#x3D;ListNode(flag)</span><br><span class="line">            # res.next&#x3D;ListNode(1)</span><br><span class="line">        return dummy.next</span><br></pre></td></tr></table></figure>

<h3 id="面试题-02-06-回文链表"><a href="#面试题-02-06-回文链表" class="headerlink" title="面试题 02.06. 回文链表"></a>面试题 02.06. 回文链表</h3><pre><code>链接：https://leetcode-cn.com/problems/palindrome-linked-list-lcci/

编写一个函数，检查输入的链表是否是回文的。

示例 1：

输入： 1-&gt;2
输出： false 
示例 2：

输入： 1-&gt;2-&gt;2-&gt;1
输出： true 


进阶：
你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</code></pre>
<p>题解一（数组）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isPalindrome(self, head: ListNode) -&gt; bool:</span><br><span class="line">        arr&#x3D;[]</span><br><span class="line">        while head:</span><br><span class="line">            arr.append(head.val)</span><br><span class="line">            head&#x3D;head.next</span><br><span class="line">        return arr&#x3D;&#x3D;arr[::-1]</span><br></pre></td></tr></table></figure>
<p>题解二（快慢指针）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val &#x3D; x</span><br><span class="line">#         self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def isPalindrome(self, head: ListNode) -&gt; bool:</span><br><span class="line">        if not head:</span><br><span class="line">            return True</span><br><span class="line">        slow&#x3D;fast&#x3D;head</span><br><span class="line">        while fast and fast.next:</span><br><span class="line">            slow&#x3D;slow.next</span><br><span class="line">            fast&#x3D;fast.next.next</span><br><span class="line">        pre&#x3D;slow</span><br><span class="line">        while slow and slow.next:</span><br><span class="line">            next&#x3D;slow.next.next</span><br><span class="line">            slow.next.next&#x3D;pre</span><br><span class="line">            pre&#x3D;slow.next</span><br><span class="line">            slow.next&#x3D;next</span><br><span class="line">        while head and pre:</span><br><span class="line">            if head.val !&#x3D; pre.val:</span><br><span class="line">                return False</span><br><span class="line">            head&#x3D;head.next</span><br><span class="line">            pre&#x3D;pre.next</span><br><span class="line">        return True</span><br></pre></td></tr></table></figure>

<h3 id="面试题-02-07-链表相交"><a href="#面试题-02-07-链表相交" class="headerlink" title="面试题 02.07. 链表相交"></a>面试题 02.07. 链表相交</h3><pre><code>链接：https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/

给定两个（单向）链表，判定它们是否相交并返回交点。请注意相交的定义基于节点的引用，而不是基于节点的值。换句话说，如果一个链表的第k个节点与另一个链表的第j个节点是同一节点（引用完全相同），则这两个链表相交。


示例 1：

输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。

示例 2：

输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Reference of the node with value = 2
输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。

示例 3：

输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
解释：这两个链表不相交，因此返回 null。

注意：

如果两个链表没有交点，返回 null 。
在返回结果后，两个链表仍须保持原有的结构。
可假定整个链表结构中没有循环。
程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</code></pre>
<p>题解一（循环）：<br>超时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode:</span><br><span class="line">        p,q&#x3D;headA.next,headB.next</span><br><span class="line">        while p:</span><br><span class="line">            while q:</span><br><span class="line">                if p&#x3D;&#x3D;q:</span><br><span class="line">                    return q</span><br><span class="line">            q&#x3D;q.next</span><br><span class="line">        p&#x3D;p.next</span><br><span class="line">        return None</span><br></pre></td></tr></table></figure>
<p>题解二（双指针）：</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/link10.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/link10.png"></p>
<p>算法让两个指针分别从A和B点往C点走，两个指针分别走到C后，又各自从另外一个指针的起点，也就是A指针第二次走从B点开始走，B指针同理，这样，A指针走的路径长度 AO + OC + BO 必定等于B指针走的路径长度 BO + OC + AO，这也就意味着这两个指针第二轮走必定会在O点相遇，相遇后也即到达了退出循环的条件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode:</span><br><span class="line">        p,q&#x3D;headA,headB</span><br><span class="line">        while p !&#x3D; q:</span><br><span class="line">            if p:</span><br><span class="line">                p&#x3D;p.next</span><br><span class="line">            else:</span><br><span class="line">                p&#x3D;headB</span><br><span class="line">            if q:</span><br><span class="line">                q&#x3D;q.next</span><br><span class="line">            else:</span><br><span class="line">                q&#x3D;headA</span><br><span class="line">        return p</span><br></pre></td></tr></table></figure>

<h3 id="面试题-02-08-环路检测"><a href="#面试题-02-08-环路检测" class="headerlink" title="面试题 02.08. 环路检测"></a>面试题 02.08. 环路检测</h3><pre><code>链接：https://leetcode-cn.com/problems/linked-list-cycle-lcci/

给定一个有环链表，实现一个算法返回环路的开头节点。
有环链表的定义：在链表中某个节点的next元素指向在它前面出现过的节点，则表明该链表存在环路。

示例 1：

输入：head = [3,2,0,-4], pos = 1
输出：tail connects to node index 1
解释：链表中有一个环，其尾部连接到第二个节点。

示例 2：

输入：head = [1,2], pos = 0
输出：tail connects to node index 0
解释：链表中有一个环，其尾部连接到第一个节点。

示例 3：

输入：head = [1], pos = -1
输出：no cycle
解释：链表中没有环。

进阶：你是否可以不用额外空间解决此题？</code></pre>
<p>题解一（双指针）：</p>
<p><img src="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode6.png" alt="https://gypsy-1255824480.cos.ap-beijing.myqcloud.com/blog/linknode6.png"></p>
<p>z=n*环的大小+z</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def detectCycle(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        if not head:</span><br><span class="line">            return None</span><br><span class="line">        slow&#x3D;fast&#x3D;head</span><br><span class="line">        while  fast and fast.next:</span><br><span class="line">            slow&#x3D;slow.next</span><br><span class="line">            fast&#x3D;fast.next.next</span><br><span class="line">            if slow&#x3D;&#x3D;fast:</span><br><span class="line">                slow&#x3D;head</span><br><span class="line">                while slow!&#x3D;fast:</span><br><span class="line">                    slow&#x3D;slow.next</span><br><span class="line">                    fast&#x3D;fast.next</span><br><span class="line">                return slow</span><br><span class="line">        return None</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def detectCycle(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        if not head:</span><br><span class="line">            return None</span><br><span class="line">        slow&#x3D;fast&#x3D;head</span><br><span class="line">        while True:</span><br><span class="line">            if not (fast and fast.next):</span><br><span class="line">                return</span><br><span class="line">            slow&#x3D;slow.next</span><br><span class="line">            fast&#x3D;fast.next.next</span><br><span class="line">            if slow &#x3D;&#x3D; fast:</span><br><span class="line">                break</span><br><span class="line">        slow&#x3D;head</span><br><span class="line">        while slow !&#x3D; fast:</span><br><span class="line">            slow&#x3D;slow.next</span><br><span class="line">            fast&#x3D;fast.next</span><br><span class="line">        return slow  </span><br></pre></td></tr></table></figure>

<h3 id="面试题18-删除链表的节点"><a href="#面试题18-删除链表的节点" class="headerlink" title="面试题18. 删除链表的节点"></a>面试题18. 删除链表的节点</h3><pre><code>链接：https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/

给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。

返回删除后的链表的头节点。

注意：此题对比原题有改动

示例 1:

输入: head = [4,5,1,9], val = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.
示例 2:

输入: head = [4,5,1,9], val = 1
输出: [4,5,9]
解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.


说明：

题目保证链表中节点的值互不相同
若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点</code></pre>
<p>题解一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def deleteNode(self, head: ListNode, val: int) -&gt; ListNode:</span><br><span class="line">        dummy&#x3D;ListNode(-1)</span><br><span class="line">        dummy.next&#x3D;head</span><br><span class="line">        res&#x3D;dummy</span><br><span class="line">        while res.next:</span><br><span class="line">            if res.next.val&#x3D;&#x3D;val:</span><br><span class="line">                res.next&#x3D;res.next.next</span><br><span class="line">            else:</span><br><span class="line">                res&#x3D;res.next</span><br><span class="line">        return dummy.next</span><br></pre></td></tr></table></figure>

<h3 id="面试题22-链表中倒数第k个节点"><a href="#面试题22-链表中倒数第k个节点" class="headerlink" title="面试题22. 链表中倒数第k个节点"></a>面试题22. 链表中倒数第k个节点</h3><pre><code>链接：https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/

个链表的倒数第3个节点是值为4的节点。

示例：

给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k = 2.

返回链表 4-&gt;5.</code></pre>
<p>题解一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def getKthFromEnd(self, head: ListNode, k: int) -&gt; ListNode:</span><br><span class="line">        fast&#x3D;slow&#x3D;head</span><br><span class="line">        while fast:</span><br><span class="line">            fast&#x3D;fast.next</span><br><span class="line">            if k&#x3D;&#x3D;0:</span><br><span class="line">                slow&#x3D;slow.next</span><br><span class="line">            else:</span><br><span class="line">                k-&#x3D;1</span><br><span class="line">        return slow</span><br></pre></td></tr></table></figure>

<h3 id="面试题24-反转链表"><a href="#面试题24-反转链表" class="headerlink" title="面试题24. 反转链表"></a>面试题24. 反转链表</h3><pre><code>链接：https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/

定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

示例:

输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL


限制：

0 &lt;= 节点个数 &lt;= 5000</code></pre>
<p>题解一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reverseList(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        pre&#x3D;None</span><br><span class="line">        while head:</span><br><span class="line">            next&#x3D;head.next</span><br><span class="line">            head.next&#x3D;pre</span><br><span class="line">            pre&#x3D;head</span><br><span class="line">            head&#x3D;next</span><br><span class="line">        return pre</span><br></pre></td></tr></table></figure>

<h3 id><a href="#" class="headerlink" title></a></h3><p>题解一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def copyRandomList(self, head: &#39;Node&#39;) -&gt; &#39;Node&#39;:</span><br><span class="line">        return copy.deepcopy(head)</span><br></pre></td></tr></table></figure>

<p>题解二（深度优先遍历）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line"># Definition for a Node.</span><br><span class="line">class Node:</span><br><span class="line">    def __init__(self, x: int, next: &#39;Node&#39; &#x3D; None, random: &#39;Node&#39; &#x3D; None):</span><br><span class="line">        self.val &#x3D; int(x)</span><br><span class="line">        self.next &#x3D; next</span><br><span class="line">        self.random &#x3D; random</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">class Solution:</span><br><span class="line">    def copyRandomList(self, head: &#39;Node&#39;) -&gt; &#39;Node&#39;:</span><br><span class="line">        def dfs(head):</span><br><span class="line">            if not head:</span><br><span class="line">                return None</span><br><span class="line">            if head in visited:</span><br><span class="line">                return visited[head]</span><br><span class="line">            copy&#x3D;Node(head.val,None,None)</span><br><span class="line">            visited[head]&#x3D;copy</span><br><span class="line">            copy.next&#x3D;dfs(head.next)</span><br><span class="line">            copy.random&#x3D;dfs(head.random)</span><br><span class="line">            return copy</span><br><span class="line">        visited&#x3D;&#123;&#125;</span><br><span class="line">        return dfs(head)</span><br></pre></td></tr></table></figure>

<p>题解三（bfs）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line"># Definition for a Node.</span><br><span class="line">class Node:</span><br><span class="line">    def __init__(self, x: int, next: &#39;Node&#39; &#x3D; None, random: &#39;Node&#39; &#x3D; None):</span><br><span class="line">        self.val &#x3D; int(x)</span><br><span class="line">        self.next &#x3D; next</span><br><span class="line">        self.random &#x3D; random</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">import collections</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def copyRandomList(self, head: &#39;Node&#39;) -&gt; &#39;Node&#39;:</span><br><span class="line">        visited&#x3D;&#123;&#125;</span><br><span class="line">        def bfs(head):</span><br><span class="line">            if not head:</span><br><span class="line">                return None</span><br><span class="line">            clone&#x3D;Node(head.val,None,None)</span><br><span class="line">            queue&#x3D;collections.deque()</span><br><span class="line">            queue.append(head)</span><br><span class="line">            visited[head]&#x3D;clone</span><br><span class="line">            while queue:</span><br><span class="line">                tmp&#x3D;queue.pop()</span><br><span class="line">                if tmp.next and tmp.next not in visited:</span><br><span class="line">                    visited[tmp.next]&#x3D;None(tmp.next.val,[],[])</span><br><span class="line">                    queue.append(tmp.next)</span><br><span class="line">                if tmp.random and tmp.random not in visited:</span><br><span class="line">                    visited[tmp.random] &#x3D; Node(tmp.random.val, [], [])</span><br><span class="line">                    queue.append(tmp.random)</span><br><span class="line">                visited[tmp].next&#x3D;visited.get(tmp.next)</span><br><span class="line">                visited[tmp].random&#x3D;visited.get(tmp.random)</span><br><span class="line">            return clone</span><br><span class="line">        return bfs(head)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="面试题52-两个链表的第一个公共节点"><a href="#面试题52-两个链表的第一个公共节点" class="headerlink" title="面试题52. 两个链表的第一个公共节点"></a>面试题52. 两个链表的第一个公共节点</h3><pre><code>链接：https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/

输入两个链表，找出它们的第一个公共节点。

如下面的两个链表：

在节点 c1 开始相交。

示例 1：

输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。

示例 2：

输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Reference of the node with value = 2
输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。

示例 3：

输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
解释：这两个链表不相交，因此返回 null。

注意：

如果两个链表没有交点，返回 null.
在返回结果后，两个链表仍须保持原有的结构。
可假定整个链表结构中没有循环。
程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</code></pre>
<p>题解一（hash）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode:</span><br><span class="line">        p&#x3D;headA</span><br><span class="line">        q&#x3D;headB</span><br><span class="line">        hash&#x3D;&#123;&#125;</span><br><span class="line">        while headA:</span><br><span class="line">            if headA not in hash:</span><br><span class="line">                hash[headA]&#x3D;1</span><br><span class="line">                headA&#x3D;headA.next</span><br><span class="line">        while headB:</span><br><span class="line">            if headB in hash:</span><br><span class="line">                return headB</span><br><span class="line">            else:</span><br><span class="line">                headB&#x3D;headB.next</span><br><span class="line">        return None</span><br></pre></td></tr></table></figure>

<p>题解二（双指针）：</p>
<p>时间复杂度：O(M+N)<br>空间复杂度：O(1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -&gt; ListNode:</span><br><span class="line">        node1, node2 &#x3D; headA, headB</span><br><span class="line">        </span><br><span class="line">        while node1 !&#x3D; node2:</span><br><span class="line">            node1 &#x3D; node1.next if node1 else headB</span><br><span class="line">            node2 &#x3D; node2.next if node2 else headA</span><br><span class="line"></span><br><span class="line">        return node1</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/LeetCode/" rel="tag"># LeetCode</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/LeetCode-3-%E6%A0%91-%E4%B8%80/" rel="prev" title="LeetCode-3.树-一">
      <i class="fa fa-chevron-left"></i> LeetCode-3.树-一
    </a></div>
      <div class="post-nav-item">
    <a href="/LeetCode-7-%E9%80%92%E5%BD%92/" rel="next" title="LeetCode-7-递归">
      LeetCode-7-递归 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E9%93%BE%E8%A1%A8"><span class="nav-number">1.</span> <span class="nav-text">五、链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0"><span class="nav-number">1.1.</span> <span class="nav-text">2.两数相加</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="nav-number">1.2.</span> <span class="nav-text">19. 删除链表的倒数第N个节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-number">1.3.</span> <span class="nav-text">21. 合并两个有序链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">1.4.</span> <span class="nav-text">24. 两两交换链表中的节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#61-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">1.5.</span> <span class="nav-text">61. 旋转链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#82-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-II"><span class="nav-number">1.6.</span> <span class="nav-text">??82.删除排序链表中的重复元素 II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="nav-number">1.7.</span> <span class="nav-text">83. 删除排序链表中的重复元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#86-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8"><span class="nav-number">1.8.</span> <span class="nav-text">86. 分隔链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-II"><span class="nav-number">1.9.</span> <span class="nav-text">92. 反转链表 II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="nav-number">1.10.</span> <span class="nav-text">141.环形链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II"><span class="nav-number">1.11.</span> <span class="nav-text">142.环形链表 II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8"><span class="nav-number">1.12.</span> <span class="nav-text">143. 重排链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">1.13.</span> <span class="nav-text">???147. 对链表进行插入排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8"><span class="nav-number">1.14.</span> <span class="nav-text">160. 相交链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0"><span class="nav-number">1.15.</span> <span class="nav-text">203. 移除链表元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">1.16.</span> <span class="nav-text">206.反转链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="nav-number">1.17.</span> <span class="nav-text">234.回文链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#237-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">1.18.</span> <span class="nav-text">237.删除链表中的节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#876-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9"><span class="nav-number">1.19.</span> <span class="nav-text">876.链表的中间节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-06-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8"><span class="nav-number">1.20.</span> <span class="nav-text">剑指 Offer 06. 从尾到头打印链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-02-01-%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9"><span class="nav-number">1.21.</span> <span class="nav-text">面试题 02.01. 移除重复节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-02-02-%E8%BF%94%E5%9B%9E%E5%80%92%E6%95%B0%E7%AC%AC-k-%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="nav-number">1.22.</span> <span class="nav-text">面试题 02.02. 返回倒数第 k 个节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-02-03-%E5%88%A0%E9%99%A4%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9"><span class="nav-number">1.23.</span> <span class="nav-text">面试题 02.03. 删除中间节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-02-04-%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8"><span class="nav-number">1.24.</span> <span class="nav-text">面试题 02.04. 分割链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-02-05-%E9%93%BE%E8%A1%A8%E6%B1%82%E5%92%8C"><span class="nav-number">1.25.</span> <span class="nav-text">面试题 02.05. 链表求和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-02-06-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="nav-number">1.26.</span> <span class="nav-text">面试题 02.06. 回文链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-02-07-%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4"><span class="nav-number">1.27.</span> <span class="nav-text">面试题 02.07. 链表相交</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-02-08-%E7%8E%AF%E8%B7%AF%E6%A3%80%E6%B5%8B"><span class="nav-number">1.28.</span> <span class="nav-text">面试题 02.08. 环路检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%9818-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">1.29.</span> <span class="nav-text">面试题18. 删除链表的节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%9822-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="nav-number">1.30.</span> <span class="nav-text">面试题22. 链表中倒数第k个节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%9824-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">1.31.</span> <span class="nav-text">面试题24. 反转链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">1.32.</span> <span class="nav-text"></span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%9852-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9"><span class="nav-number">1.33.</span> <span class="nav-text">面试题52. 两个链表的第一个公共节点</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Lilly</p>
  <div class="site-description" itemprop="description">Up in the wind!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">130</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">52</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">46</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lilly</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
